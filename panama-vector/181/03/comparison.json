{"files":[{"patch":"@@ -522,0 +522,11 @@\n+    case VECTOR_OP_REVERSE_BYTES: {\n+     switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:   return Op_ReverseBytesI;\n+        case T_LONG:  return Op_ReverseBytesL;\n+        default: fatal(\"REVERSE_BYTES: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+    VECTOR_OP_REVERSE_BYTES = 32,\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+    public static final int VECTOR_OP_REVERSE_BYTES = 32;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -666,0 +666,2 @@\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> a);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -666,0 +666,2 @@\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.reverseBytes(a));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,0 +624,2 @@\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.reverseBytes(a));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -666,0 +666,2 @@\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Short.reverseBytes(a));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -461,0 +461,2 @@\n+    \/** Produce {@code reverseBytes(a)} *\/\n+    public static final Unary REVERSE_BYTES = unary(\"REVERSE_BYTES\", \"reverseBytes\", VectorSupport.VECTOR_OP_REVERSE_BYTES, VO_NOFP);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -704,0 +704,9 @@\n+#if[BITWISE]\n+#if[byte]\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> a);\n+#else[byte]\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverseBytes(a));\n+#end[byte]\n+#end[BITWISE]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5457,0 +5457,49 @@\n+\n+\n+\n+\n+\n+\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5457,0 +5457,49 @@\n+\n+\n+\n+\n+\n+\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5457,0 +5457,49 @@\n+\n+\n+\n+\n+\n+\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5457,0 +5457,49 @@\n+\n+\n+\n+\n+\n+\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5462,0 +5462,49 @@\n+\n+\n+\n+\n+\n+\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -4672,0 +4672,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4672,0 +4672,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4672,0 +4672,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4672,0 +4672,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4677,0 +4677,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4640,0 +4640,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4640,0 +4640,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4640,0 +4640,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4640,0 +4640,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4645,0 +4645,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5419,0 +5419,49 @@\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5419,0 +5419,49 @@\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5419,0 +5419,49 @@\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5419,0 +5419,49 @@\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5424,0 +5424,49 @@\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5369,0 +5369,49 @@\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5369,0 +5369,49 @@\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5369,0 +5369,49 @@\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5369,0 +5369,49 @@\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5374,0 +5374,49 @@\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5448,0 +5448,49 @@\n+\n+\n+\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5448,0 +5448,49 @@\n+\n+\n+\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5448,0 +5448,49 @@\n+\n+\n+\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5448,0 +5448,49 @@\n+\n+\n+\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -5453,0 +5453,49 @@\n+\n+\n+\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -558,0 +558,3 @@\n+gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"intOrLong\"\n+gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"short\"\n+gen_unary_alu_op \"REVERSE_BYTES\" \"a\" \"byte\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1824,0 +1824,40 @@\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(a) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1623,0 +1623,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1623,0 +1623,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1623,0 +1623,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1623,0 +1623,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1623,0 +1623,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1267,0 +1267,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1623,0 +1623,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1623,0 +1623,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1623,0 +1623,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1623,0 +1623,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1623,0 +1623,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1267,0 +1267,6 @@\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1821,0 +1821,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(Integer.reverseBytes(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(Integer.reverseBytes(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1821,0 +1821,40 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(Long.reverseBytes(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(Long.reverseBytes(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2201,0 +2201,40 @@\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1825,0 +1825,40 @@\n+\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Short.reverseBytes(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Short.reverseBytes(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}