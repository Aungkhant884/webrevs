{"files":[{"patch":"@@ -231,4 +231,0 @@\n-      case Op_LoadVectorGather:\n-      case Op_StoreVectorScatter:\n-        \/\/ Partial size of gather\/scatter are not supported for now.\n-        return length_in_bytes == MaxVectorSize;\n@@ -4114,0 +4110,1 @@\n+            n->as_LoadVectorGather()->memory_size() == MaxVectorSize &&\n@@ -4127,0 +4124,1 @@\n+            n->as_LoadVectorGather()->memory_size() == MaxVectorSize &&\n@@ -4144,0 +4142,1 @@\n+            n->as_StoreVectorScatter()->memory_size() == MaxVectorSize &&\n@@ -4157,0 +4156,1 @@\n+            n->as_StoreVectorScatter()->memory_size() == MaxVectorSize &&\n@@ -4170,0 +4170,88 @@\n+\/\/ ------------------------------ Vector Load Gather Partial-------------------------------\n+instruct gatherI_partial(vReg dst, indirect mem, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() >= 16 &&\n+            n->as_LoadVectorGather()->memory_size() < MaxVectorSize &&\n+           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST + INSN_COST);\n+  format %{ \"mov rscratch1, vector_length\\n\\t\"\n+            \"sve_whilelo $pTmp, zr, rscratch1\\n\\t\"\n+            \"load_vector_gather $dst, $pTmp, $mem, $idx\\t# vector load gather partial (I\/F)\" %}\n+  ins_encode %{\n+    __ mov(rscratch1, vector_length(this));\n+    __ sve_whilelo(as_PRegister($pTmp$$reg), __ S, zr, rscratch1);\n+    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), as_PRegister($pTmp$$reg), as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gatherL_partial(vReg dst, indirect mem, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() >= 16 &&\n+            n->as_LoadVectorGather()->memory_size() < MaxVectorSize &&\n+           (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(3 * SVE_COST + INSN_COST);\n+  format %{ \"mov rscratch1, vector_length\\n\\t\"\n+            \"sve_whilelo $pTmp, zr, rscratch1\\n\\t\"\n+            \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"load_vector_gather $dst, $pTmp, $mem, $idx\\t# vector load gather partial (L\/D)\" %}\n+  ins_encode %{\n+    __ mov(rscratch1, vector_length(this));\n+    __ sve_whilelo(as_PRegister($pTmp$$reg), __ D, zr, rscratch1);\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), as_PRegister($pTmp$$reg), as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Store Scatter Partial-------------------------------\n+\n+instruct scatterI_partial(indirect mem, vReg src, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() >= 16 &&\n+            n->as_StoreVectorScatter()->memory_size() < MaxVectorSize &&\n+           (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+            n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST + INSN_COST);\n+  format %{ \"mov rscratch1, vector_length\\n\\t\"\n+            \"sve_whilelo $pTmp, zr, rscratch1\\n\\t\"\n+            \"store_vector_scatter $mem, $pTmp, $idx, $src\\t# vector store scatter partial (I\/F)\" %}\n+  ins_encode %{\n+    __ mov(rscratch1, vector_length(this, $src));\n+    __ sve_whilelo(as_PRegister($pTmp$$reg), __ S, zr, rscratch1);\n+    __ sve_st1w_scatter(as_FloatRegister($src$$reg), as_PRegister($pTmp$$reg), as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatterL_partial(indirect mem, vReg src, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() >= 16 &&\n+            n->as_StoreVectorScatter()->memory_size() < MaxVectorSize &&\n+           (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+            n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(3 * SVE_COST + INSN_COST);\n+  format %{ \"mov rscratch1, vector_length\\n\\t\"\n+            \"sve_whilelo $pTmp, zr, rscratch1\\n\\t\"\n+            \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"store_vector_scatter $mem, $pTmp, $idx, $src\\t# vector store scatter partial (L\/D)\" %}\n+  ins_encode %{\n+    __ mov(rscratch1, vector_length(this, $src));\n+    __ sve_whilelo(as_PRegister($pTmp$$reg), __ D, zr, rscratch1);\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_st1d_scatter(as_FloatRegister($src$$reg), as_PRegister($pTmp$$reg), as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":92,"deletions":4,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -226,4 +226,0 @@\n-      case Op_LoadVectorGather:\n-      case Op_StoreVectorScatter:\n-        \/\/ Partial size of gather\/scatter are not supported for now.\n-        return length_in_bytes == MaxVectorSize;\n@@ -2430,0 +2426,1 @@\n+            n->as_LoadVectorGather()->memory_size() == MaxVectorSize &&\n@@ -2443,0 +2440,1 @@\n+            n->as_LoadVectorGather()->memory_size() == MaxVectorSize &&\n@@ -2460,0 +2458,1 @@\n+            n->as_StoreVectorScatter()->memory_size() == MaxVectorSize &&\n@@ -2473,0 +2472,1 @@\n+            n->as_StoreVectorScatter()->memory_size() == MaxVectorSize &&\n@@ -2486,0 +2486,88 @@\n+\/\/ ------------------------------ Vector Load Gather Partial-------------------------------\n+instruct gatherI_partial(vReg dst, indirect mem, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() >= 16 &&\n+            n->as_LoadVectorGather()->memory_size() < MaxVectorSize &&\n+           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST + INSN_COST);\n+  format %{ \"mov rscratch1, vector_length\\n\\t\"\n+            \"sve_whilelo $pTmp, zr, rscratch1\\n\\t\"\n+            \"load_vector_gather $dst, $pTmp, $mem, $idx\\t# vector load gather partial (I\/F)\" %}\n+  ins_encode %{\n+    __ mov(rscratch1, vector_length(this));\n+    __ sve_whilelo(as_PRegister($pTmp$$reg), __ S, zr, rscratch1);\n+    __ sve_ld1w_gather(as_FloatRegister($dst$$reg), as_PRegister($pTmp$$reg), as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct gatherL_partial(vReg dst, indirect mem, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_LoadVectorGather()->memory_size() >= 16 &&\n+            n->as_LoadVectorGather()->memory_size() < MaxVectorSize &&\n+           (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (LoadVectorGather mem idx));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(3 * SVE_COST + INSN_COST);\n+  format %{ \"mov rscratch1, vector_length\\n\\t\"\n+            \"sve_whilelo $pTmp, zr, rscratch1\\n\\t\"\n+            \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"load_vector_gather $dst, $pTmp, $mem, $idx\\t# vector load gather partial (L\/D)\" %}\n+  ins_encode %{\n+    __ mov(rscratch1, vector_length(this));\n+    __ sve_whilelo(as_PRegister($pTmp$$reg), __ D, zr, rscratch1);\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), as_PRegister($pTmp$$reg), as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ Vector Store Scatter Partial-------------------------------\n+\n+instruct scatterI_partial(indirect mem, vReg src, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() >= 16 &&\n+            n->as_StoreVectorScatter()->memory_size() < MaxVectorSize &&\n+           (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+            n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(2 * SVE_COST + INSN_COST);\n+  format %{ \"mov rscratch1, vector_length\\n\\t\"\n+            \"sve_whilelo $pTmp, zr, rscratch1\\n\\t\"\n+            \"store_vector_scatter $mem, $pTmp, $idx, $src\\t# vector store scatter partial (I\/F)\" %}\n+  ins_encode %{\n+    __ mov(rscratch1, vector_length(this, $src));\n+    __ sve_whilelo(as_PRegister($pTmp$$reg), __ S, zr, rscratch1);\n+    __ sve_st1w_scatter(as_FloatRegister($src$$reg), as_PRegister($pTmp$$reg), as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct scatterL_partial(indirect mem, vReg src, vReg idx, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->as_StoreVectorScatter()->memory_size() >= 16 &&\n+            n->as_StoreVectorScatter()->memory_size() < MaxVectorSize &&\n+           (n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+            n->in(3)->in(1)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set mem (StoreVectorScatter mem (Binary src idx)));\n+  effect(TEMP pTmp, KILL cr);\n+  ins_cost(3 * SVE_COST + INSN_COST);\n+  format %{ \"mov rscratch1, vector_length\\n\\t\"\n+            \"sve_whilelo $pTmp, zr, rscratch1\\n\\t\"\n+            \"sve_uunpklo $idx, $idx\\n\\t\"\n+            \"store_vector_scatter $mem, $pTmp, $idx, $src\\t# vector store scatter partial (L\/D)\" %}\n+  ins_encode %{\n+    __ mov(rscratch1, vector_length(this, $src));\n+    __ sve_whilelo(as_PRegister($pTmp$$reg), __ D, zr, rscratch1);\n+    __ sve_uunpklo(as_FloatRegister($idx$$reg), __ D, as_FloatRegister($idx$$reg));\n+    __ sve_st1d_scatter(as_FloatRegister($src$$reg), as_PRegister($pTmp$$reg), as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":92,"deletions":4,"binary":false,"changes":96,"status":"modified"}]}