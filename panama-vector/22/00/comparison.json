{"files":[{"patch":"@@ -808,0 +808,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -840,0 +840,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -904,0 +904,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -792,0 +792,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -778,0 +778,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2825,0 +2825,1 @@\n+\n@@ -2951,1 +2952,1 @@\n-     * Stores this vector into an array of {@code byte}\n+     * Stores this vector into an array of type {@code byte[]}\n@@ -3067,0 +3068,1 @@\n+\n@@ -3173,0 +3175,1 @@\n+\n@@ -3303,0 +3306,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -776,0 +776,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -780,0 +780,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -788,0 +788,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -774,0 +774,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -773,0 +773,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2738,0 +2738,1 @@\n+\n@@ -2870,1 +2871,1 @@\n-     * Stores this vector into an array of {@code double}\n+     * Stores this vector into an array of type {@code double[]}\n@@ -3027,0 +3028,1 @@\n+\n@@ -3133,0 +3135,1 @@\n+\n@@ -3268,0 +3271,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -780,0 +780,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -788,0 +788,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -804,0 +804,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -776,0 +776,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -773,0 +773,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2744,0 +2744,1 @@\n+\n@@ -2876,1 +2877,1 @@\n-     * Stores this vector into an array of {@code float}\n+     * Stores this vector into an array of type {@code float[]}\n@@ -3014,0 +3015,1 @@\n+\n@@ -3120,0 +3122,1 @@\n+\n@@ -3255,0 +3258,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -784,0 +784,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -792,0 +792,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -808,0 +808,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -780,0 +780,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -789,0 +789,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2841,0 +2841,1 @@\n+\n@@ -2973,1 +2974,1 @@\n-     * Stores this vector into an array of {@code int}\n+     * Stores this vector into an array of type {@code int[]}\n@@ -3111,0 +3112,1 @@\n+\n@@ -3217,0 +3219,1 @@\n+\n@@ -3352,0 +3355,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -770,0 +770,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -774,0 +774,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -782,0 +782,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -768,0 +768,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -768,0 +768,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2725,0 +2725,1 @@\n+\n@@ -2857,1 +2858,1 @@\n-     * Stores this vector into an array of {@code long}\n+     * Stores this vector into an array of type {@code long[]}\n@@ -3014,0 +3015,1 @@\n+\n@@ -3120,0 +3122,1 @@\n+\n@@ -3255,0 +3258,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -792,0 +792,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -808,0 +808,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -840,0 +840,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -784,0 +784,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -778,0 +778,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    ShortVector fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2825,0 +2825,150 @@\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<Short> m) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            ShortVector zero = vsp.zero();\n+            return zero.blend(zero.fromCharArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (short) a[offset + i]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<Short> m) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n@@ -2957,1 +3107,1 @@\n-     * Stores this vector into an array of {@code short}\n+     * Stores this vector into an array of type {@code short[]}\n@@ -3073,0 +3223,152 @@\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        ShortSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<Short> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            ShortSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<Short> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n@@ -3179,0 +3481,15 @@\n+    \/*package-private*\/\n+    abstract\n+    ShortVector fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    ShortVector fromCharArray0Template(char[] a, int offset) {\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n@@ -3314,0 +3631,10 @@\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":328,"deletions":1,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -3363,0 +3363,152 @@\n+#if[short]\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            $abstractvectortype$ zero = vsp.zero();\n+            return zero.blend(zero.fromCharArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (short) a[offset + i]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+#end[short]\n+\n@@ -3501,1 +3653,1 @@\n-     * Stores this vector into an array of {@code $type$}\n+     * Stores this vector into an array of type {@code $type$[]}\n@@ -3692,0 +3844,154 @@\n+#if[short]\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        $Type$Species vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<$Boxtype$> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+#end[short]\n+\n@@ -3798,0 +4104,17 @@\n+#if[short]\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromCharArray0Template(char[] a, int offset) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+#end[short]\n+\n@@ -3935,0 +4258,12 @@\n+#if[short]\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+#end[short]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":336,"deletions":1,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -1066,0 +1066,9 @@\n+#if[short]\n+    @ForceInline\n+    @Override\n+    final\n+    $abstractvectortype$ fromCharArray0(char[] a, int offset) {\n+        return super.fromCharArray0Template(a, offset);  \/\/ specialize\n+    }\n+#end[short]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -536,16 +536,0 @@\n-    @Test(dataProvider = \"byteMaskProvider\")\n-    static void loadStoreMask(IntFunction<byte[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -973,0 +957,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -536,16 +536,0 @@\n-    @Test(dataProvider = \"byteMaskProvider\")\n-    static void loadStoreMask(IntFunction<byte[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -973,0 +957,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -536,16 +536,0 @@\n-    @Test(dataProvider = \"byteMaskProvider\")\n-    static void loadStoreMask(IntFunction<byte[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -973,0 +957,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -536,16 +536,0 @@\n-    @Test(dataProvider = \"byteMaskProvider\")\n-    static void loadStoreMask(IntFunction<byte[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -973,0 +957,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -545,16 +545,0 @@\n-    @Test(dataProvider = \"byteMaskProvider\")\n-    static void loadStoreMask(IntFunction<byte[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -982,0 +966,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"doubleMaskProvider\")\n-    static void loadStoreMask(IntFunction<double[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"doubleMaskProvider\")\n-    static void loadStoreMask(IntFunction<double[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"doubleMaskProvider\")\n-    static void loadStoreMask(IntFunction<double[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"doubleMaskProvider\")\n-    static void loadStoreMask(IntFunction<double[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -556,16 +556,0 @@\n-    @Test(dataProvider = \"doubleMaskProvider\")\n-    static void loadStoreMask(IntFunction<double[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -993,0 +977,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"floatMaskProvider\")\n-    static void loadStoreMask(IntFunction<float[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"floatMaskProvider\")\n-    static void loadStoreMask(IntFunction<float[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"floatMaskProvider\")\n-    static void loadStoreMask(IntFunction<float[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"floatMaskProvider\")\n-    static void loadStoreMask(IntFunction<float[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -556,16 +556,0 @@\n-    @Test(dataProvider = \"floatMaskProvider\")\n-    static void loadStoreMask(IntFunction<float[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -993,0 +977,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"intMaskProvider\")\n-    static void loadStoreMask(IntFunction<int[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"intMaskProvider\")\n-    static void loadStoreMask(IntFunction<int[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"intMaskProvider\")\n-    static void loadStoreMask(IntFunction<int[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"intMaskProvider\")\n-    static void loadStoreMask(IntFunction<int[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -556,16 +556,0 @@\n-    @Test(dataProvider = \"intMaskProvider\")\n-    static void loadStoreMask(IntFunction<int[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -993,0 +977,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void loadStoreMask(IntFunction<long[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void loadStoreMask(IntFunction<long[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void loadStoreMask(IntFunction<long[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void loadStoreMask(IntFunction<long[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -556,16 +556,0 @@\n-    @Test(dataProvider = \"longMaskProvider\")\n-    static void loadStoreMask(IntFunction<long[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -993,0 +977,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"shortMaskProvider\")\n-    static void loadStoreMask(IntFunction<short[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,246 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":246,"deletions":16,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"shortMaskProvider\")\n-    static void loadStoreMask(IntFunction<short[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,246 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":246,"deletions":16,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"shortMaskProvider\")\n-    static void loadStoreMask(IntFunction<short[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,246 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":246,"deletions":16,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -547,16 +547,0 @@\n-    @Test(dataProvider = \"shortMaskProvider\")\n-    static void loadStoreMask(IntFunction<short[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -984,0 +968,246 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":246,"deletions":16,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -556,16 +556,0 @@\n-    @Test(dataProvider = \"shortMaskProvider\")\n-    static void loadStoreMask(IntFunction<short[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -993,0 +977,246 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":246,"deletions":16,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -579,16 +579,0 @@\n-    @Test(dataProvider = \"$type$MaskProvider\")\n-    static void loadStoreMask(IntFunction<$type$[]> fa,\n-                              IntFunction<boolean[]> fm) {\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        boolean[] r = new boolean[mask.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n-                VectorMask<$Boxtype$> vmask = VectorMask.fromArray(SPECIES, mask, i);\n-                vmask.intoArray(r, i);\n-            }\n-        }\n-        Assert.assertEquals(mask, r);\n-    }\n-\n-\n@@ -1016,0 +1000,248 @@\n+\n+\n+#if[short]\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static $abstractvectortype$ fromCharArray(char[] a, int i) {\n+        return $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static $abstractvectortype$ fromCharArray(char[] a, int i, VectorMask<$Boxtype$> m) {\n+        return $abstractvectortype$.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray($abstractvectortype$ v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray($abstractvectortype$ v, char[] a, int i, VectorMask<$Boxtype$> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+#end[short]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":248,"deletions":16,"binary":false,"changes":264,"status":"modified"}]}