{"files":[{"patch":"@@ -648,1 +648,2 @@\n-        assert(s.laneType == laneType) : s + \"!=\" + laneType;\n+        \/\/ FIXME: Let the assert condition true for Halffloat as laneType is short for Halffloat.\n+        assert(s.laneType == laneType) || laneType.switchKey == LaneType.SK_HALFFLOAT : s + \"!=\" + laneType;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,734 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat128VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat128VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 128);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return SHORT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n+    }\n+\n+\n+    interface ToShortF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToShortF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToShortF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        return HalffloatVector.fromArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(r, a);\n+       }\n+    }\n+\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorLoadStoreTests.java","additions":734,"deletions":0,"binary":false,"changes":734,"status":"added"},{"patch":"@@ -0,0 +1,1813 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat128VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat128VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 128);\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n+        try {\n+            for (; i < end; i += 1) {\n+                if(i%SPECIES.length() == index) {\n+                    Assert.assertEquals(r[i], element);\n+                } else {\n+                    Assert.assertEquals(r[i], a[i]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (i%SPECIES.length() == index) {\n+                Assert.assertEquals(r[i], element, \"at index #\" + i);\n+            } else {\n+                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n+            }\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    \/\/ TODO: Fix and Enable isWithin1Ulp\n+\n+    interface FBinArrayOp {\n+        short apply(short[] a, int b);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Halffloat.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SHORT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return SHORT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> SHORT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return SHORT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_TEST_GENERATOR_ARGS =\n+        SHORT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return SHORT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_COMPARE_GENERATOR_PAIRS =\n+        SHORT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> SHORT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return SHORT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToShortF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToShortF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToShortF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        switch(i % 7) {\n+            case 0:\n+                return Halffloat.MAX_VALUE;\n+            case 1:\n+                return Halffloat.MIN_VALUE;\n+            case 2:\n+                return Halffloat.NEGATIVE_INFINITY;\n+            case 3:\n+                return Halffloat.POSITIVE_INFINITY;\n+            case 4:\n+                return Halffloat.NaN;\n+            case 5:\n+                return (short)0.0;\n+            default:\n+                return Short.MIN_VALUE;\n+        }\n+    }\n+\n+    static short get(short[] a, int i) {\n+        return (short) a[i];\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MUL);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat128VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat128VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat128VectorTests::FMA);\n+    }\n+\n+    \/\/ TODO: Fix and Enable ltHalffloat128VectorTestsBroadcastSmokeTest\n+    \/\/ TODO: Fix and Enable eqHalffloat128VectorTestsBroadcastMaskedSmokeTest\n+    \/\/ TODO: Fix and Enable toLongArrayHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable toDoubleArrayHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable toStringHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable hashCodeHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat128VectorTests\n+    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat128VectorTestsMasked\n+    \/\/ TODO: Fix and Enable BroadcastLongHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable blendHalffloat128VectorTestsBroadcastLongSmokeTest\n+\n+\n+    \/\/ TODO: Fix and Enable SelectFromHalffloat128VectorTests\n+    \/\/ TODO: Fix and Enable SelectFromHalffloat128VectorTestsMaskedSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleMiscellaneousHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleToStringHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleEqualsHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskEqualsHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskEqHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskHashCodeHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskTrueCountHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskLastTrueHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskFirstTrueHalffloat128VectorTestsSmokeTest\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat128VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    \/\/ TODO: Fix and Enable indexInRangeHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable indexInRangeLongHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable loopBoundHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable loopBoundLongHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ElementSizeHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable VectorShapeHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ShapeWithLanesHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ElementTypeHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable SpeciesElementSizeHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable VectorTypeHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable WithLanesHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable WithShapeHalffloat128VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable MaskAllTrueHalffloat128VectorTestsSmokeTest\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorTests.java","additions":1813,"deletions":0,"binary":false,"changes":1813,"status":"added"},{"patch":"@@ -0,0 +1,734 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat256VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat256VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 256);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return SHORT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n+    }\n+\n+\n+    interface ToShortF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToShortF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToShortF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        return HalffloatVector.fromArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(r, a);\n+       }\n+    }\n+\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorLoadStoreTests.java","additions":734,"deletions":0,"binary":false,"changes":734,"status":"added"},{"patch":"@@ -0,0 +1,1813 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat256VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat256VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 256);\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n+        try {\n+            for (; i < end; i += 1) {\n+                if(i%SPECIES.length() == index) {\n+                    Assert.assertEquals(r[i], element);\n+                } else {\n+                    Assert.assertEquals(r[i], a[i]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (i%SPECIES.length() == index) {\n+                Assert.assertEquals(r[i], element, \"at index #\" + i);\n+            } else {\n+                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n+            }\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    \/\/ TODO: Fix and Enable isWithin1Ulp\n+\n+    interface FBinArrayOp {\n+        short apply(short[] a, int b);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Halffloat.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SHORT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return SHORT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> SHORT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return SHORT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_TEST_GENERATOR_ARGS =\n+        SHORT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return SHORT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_COMPARE_GENERATOR_PAIRS =\n+        SHORT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> SHORT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return SHORT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToShortF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToShortF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToShortF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        switch(i % 7) {\n+            case 0:\n+                return Halffloat.MAX_VALUE;\n+            case 1:\n+                return Halffloat.MIN_VALUE;\n+            case 2:\n+                return Halffloat.NEGATIVE_INFINITY;\n+            case 3:\n+                return Halffloat.POSITIVE_INFINITY;\n+            case 4:\n+                return Halffloat.NaN;\n+            case 5:\n+                return (short)0.0;\n+            default:\n+                return Short.MIN_VALUE;\n+        }\n+    }\n+\n+    static short get(short[] a, int i) {\n+        return (short) a[i];\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MUL);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat256VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat256VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat256VectorTests::FMA);\n+    }\n+\n+    \/\/ TODO: Fix and Enable ltHalffloat256VectorTestsBroadcastSmokeTest\n+    \/\/ TODO: Fix and Enable eqHalffloat256VectorTestsBroadcastMaskedSmokeTest\n+    \/\/ TODO: Fix and Enable toLongArrayHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable toDoubleArrayHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable toStringHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable hashCodeHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat256VectorTests\n+    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat256VectorTestsMasked\n+    \/\/ TODO: Fix and Enable BroadcastLongHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable blendHalffloat256VectorTestsBroadcastLongSmokeTest\n+\n+\n+    \/\/ TODO: Fix and Enable SelectFromHalffloat256VectorTests\n+    \/\/ TODO: Fix and Enable SelectFromHalffloat256VectorTestsMaskedSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleMiscellaneousHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleToStringHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleEqualsHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskEqualsHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskEqHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskHashCodeHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskTrueCountHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskLastTrueHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskFirstTrueHalffloat256VectorTestsSmokeTest\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat256VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    \/\/ TODO: Fix and Enable indexInRangeHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable indexInRangeLongHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable loopBoundHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable loopBoundLongHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ElementSizeHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable VectorShapeHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ShapeWithLanesHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ElementTypeHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable SpeciesElementSizeHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable VectorTypeHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable WithLanesHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable WithShapeHalffloat256VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable MaskAllTrueHalffloat256VectorTestsSmokeTest\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorTests.java","additions":1813,"deletions":0,"binary":false,"changes":1813,"status":"added"},{"patch":"@@ -0,0 +1,734 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat512VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat512VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 512);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return SHORT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n+    }\n+\n+\n+    interface ToShortF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToShortF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToShortF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        return HalffloatVector.fromArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(r, a);\n+       }\n+    }\n+\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorLoadStoreTests.java","additions":734,"deletions":0,"binary":false,"changes":734,"status":"added"},{"patch":"@@ -0,0 +1,1813 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat512VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat512VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 512);\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n+        try {\n+            for (; i < end; i += 1) {\n+                if(i%SPECIES.length() == index) {\n+                    Assert.assertEquals(r[i], element);\n+                } else {\n+                    Assert.assertEquals(r[i], a[i]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (i%SPECIES.length() == index) {\n+                Assert.assertEquals(r[i], element, \"at index #\" + i);\n+            } else {\n+                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n+            }\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    \/\/ TODO: Fix and Enable isWithin1Ulp\n+\n+    interface FBinArrayOp {\n+        short apply(short[] a, int b);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Halffloat.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SHORT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return SHORT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> SHORT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return SHORT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_TEST_GENERATOR_ARGS =\n+        SHORT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return SHORT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_COMPARE_GENERATOR_PAIRS =\n+        SHORT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> SHORT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return SHORT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToShortF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToShortF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToShortF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        switch(i % 7) {\n+            case 0:\n+                return Halffloat.MAX_VALUE;\n+            case 1:\n+                return Halffloat.MIN_VALUE;\n+            case 2:\n+                return Halffloat.NEGATIVE_INFINITY;\n+            case 3:\n+                return Halffloat.POSITIVE_INFINITY;\n+            case 4:\n+                return Halffloat.NaN;\n+            case 5:\n+                return (short)0.0;\n+            default:\n+                return Short.MIN_VALUE;\n+        }\n+    }\n+\n+    static short get(short[] a, int i) {\n+        return (short) a[i];\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MUL);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat512VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat512VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat512VectorTests::FMA);\n+    }\n+\n+    \/\/ TODO: Fix and Enable ltHalffloat512VectorTestsBroadcastSmokeTest\n+    \/\/ TODO: Fix and Enable eqHalffloat512VectorTestsBroadcastMaskedSmokeTest\n+    \/\/ TODO: Fix and Enable toLongArrayHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable toDoubleArrayHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable toStringHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable hashCodeHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat512VectorTests\n+    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat512VectorTestsMasked\n+    \/\/ TODO: Fix and Enable BroadcastLongHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable blendHalffloat512VectorTestsBroadcastLongSmokeTest\n+\n+\n+    \/\/ TODO: Fix and Enable SelectFromHalffloat512VectorTests\n+    \/\/ TODO: Fix and Enable SelectFromHalffloat512VectorTestsMaskedSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleMiscellaneousHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleToStringHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleEqualsHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskEqualsHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskEqHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskHashCodeHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskTrueCountHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskLastTrueHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskFirstTrueHalffloat512VectorTestsSmokeTest\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat512VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    \/\/ TODO: Fix and Enable indexInRangeHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable indexInRangeLongHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable loopBoundHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable loopBoundLongHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ElementSizeHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable VectorShapeHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ShapeWithLanesHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ElementTypeHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable SpeciesElementSizeHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable VectorTypeHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable WithLanesHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable WithShapeHalffloat512VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable MaskAllTrueHalffloat512VectorTestsSmokeTest\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorTests.java","additions":1813,"deletions":0,"binary":false,"changes":1813,"status":"added"},{"patch":"@@ -0,0 +1,734 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:-TieredCompilation Halffloat64VectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class Halffloat64VectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 64);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return SHORT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n+    }\n+\n+\n+    interface ToShortF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToShortF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToShortF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        return HalffloatVector.fromArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(r, a);\n+       }\n+    }\n+\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorLoadStoreTests.java","additions":734,"deletions":0,"binary":false,"changes":734,"status":"added"},{"patch":"@@ -0,0 +1,1813 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Halffloat64VectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class Halffloat64VectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ 64);\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n+        try {\n+            for (; i < end; i += 1) {\n+                if(i%SPECIES.length() == index) {\n+                    Assert.assertEquals(r[i], element);\n+                } else {\n+                    Assert.assertEquals(r[i], a[i]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (i%SPECIES.length() == index) {\n+                Assert.assertEquals(r[i], element, \"at index #\" + i);\n+            } else {\n+                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n+            }\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    \/\/ TODO: Fix and Enable isWithin1Ulp\n+\n+    interface FBinArrayOp {\n+        short apply(short[] a, int b);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Halffloat.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SHORT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return SHORT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> SHORT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return SHORT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_TEST_GENERATOR_ARGS =\n+        SHORT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return SHORT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_COMPARE_GENERATOR_PAIRS =\n+        SHORT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> SHORT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return SHORT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToShortF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToShortF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToShortF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        switch(i % 7) {\n+            case 0:\n+                return Halffloat.MAX_VALUE;\n+            case 1:\n+                return Halffloat.MIN_VALUE;\n+            case 2:\n+                return Halffloat.NEGATIVE_INFINITY;\n+            case 3:\n+                return Halffloat.POSITIVE_INFINITY;\n+            case 4:\n+                return Halffloat.NaN;\n+            case 5:\n+                return (short)0.0;\n+            default:\n+                return Short.MIN_VALUE;\n+        }\n+    }\n+\n+    static short get(short[] a, int i) {\n+        return (short) a[i];\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MUL);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat64VectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, Halffloat64VectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, Halffloat64VectorTests::FMA);\n+    }\n+\n+    \/\/ TODO: Fix and Enable ltHalffloat64VectorTestsBroadcastSmokeTest\n+    \/\/ TODO: Fix and Enable eqHalffloat64VectorTestsBroadcastMaskedSmokeTest\n+    \/\/ TODO: Fix and Enable toLongArrayHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable toDoubleArrayHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable toStringHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable hashCodeHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat64VectorTests\n+    \/\/ TODO: Fix and Enable ADDReduceLongHalffloat64VectorTestsMasked\n+    \/\/ TODO: Fix and Enable BroadcastLongHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable blendHalffloat64VectorTestsBroadcastLongSmokeTest\n+\n+\n+    \/\/ TODO: Fix and Enable SelectFromHalffloat64VectorTests\n+    \/\/ TODO: Fix and Enable SelectFromHalffloat64VectorTestsMaskedSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleMiscellaneousHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleToStringHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleEqualsHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskEqualsHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskEqHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskHashCodeHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskTrueCountHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskLastTrueHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskFirstTrueHalffloat64VectorTestsSmokeTest\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLongHalffloat64VectorTestsSmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    \/\/ TODO: Fix and Enable indexInRangeHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable indexInRangeLongHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable loopBoundHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable loopBoundLongHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ElementSizeHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable VectorShapeHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ShapeWithLanesHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ElementTypeHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable SpeciesElementSizeHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable VectorTypeHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable WithLanesHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable WithShapeHalffloat64VectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable MaskAllTrueHalffloat64VectorTestsSmokeTest\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorTests.java","additions":1813,"deletions":0,"binary":false,"changes":1813,"status":"added"},{"patch":"@@ -0,0 +1,741 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign jdk.incubator.vector java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm --add-opens jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED\n+ *      -XX:-TieredCompilation HalffloatMaxVectorLoadStoreTests\n+ *\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.internal.vm.annotation.DontInline;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.function.*;\n+\n+@Test\n+public class HalffloatMaxVectorLoadStoreTests extends AbstractVectorLoadStoreTest {\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static VectorShape getMaxBit() {\n+        return VectorShape.S_Max_BIT;\n+    }\n+\n+    private static final int Max = 256;  \/\/ juts so we can do N\/Max\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ Max);\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? a[i] : (short) 0, \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            })\n+    );\n+\n+    \/\/ Relative to array.length\n+    static final List<IntFunction<Integer>> INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl + 1\", (int l) -> {\n+                return l - SPECIES.length() + 1;\n+            }),\n+            withToString(\"l + speciesl - 1\", (int l) -> {\n+                return l + SPECIES.length() - 1;\n+            }),\n+            withToString(\"l + speciesl\", (int l) -> {\n+                return l + SPECIES.length();\n+            }),\n+            withToString(\"l + speciesl + 1\", (int l) -> {\n+                return l + SPECIES.length() + 1;\n+            })\n+    );\n+\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n+    static final List<IntFunction<Integer>> BYTE_INDEX_GENERATORS = List.of(\n+            withToString(\"-1\", (int l) -> {\n+                return -1;\n+            }),\n+            withToString(\"l\", (int l) -> {\n+                return l;\n+            }),\n+            withToString(\"l - 1\", (int l) -> {\n+                return l - 1;\n+            }),\n+            withToString(\"l + 1\", (int l) -> {\n+                return l + 1;\n+            }),\n+            withToString(\"l - speciesl*ebsize + 1\", (int l) -> {\n+                return l - SPECIES.vectorByteSize() + 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize - 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() - 1;\n+            }),\n+            withToString(\"l + speciesl*ebsize\", (int l) -> {\n+                return l + SPECIES.vectorByteSize();\n+            }),\n+            withToString(\"l + speciesl*ebsize + 1\", (int l) -> {\n+                return l + SPECIES.vectorByteSize() + 1;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortProvider() {\n+        return SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMaskProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentProvider() {\n+        return SHORT_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, bo};\n+                        }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortMemorySegmentMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n+                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n+                            return new Object[]{fa, fb, fm, bo};\n+                        })))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortByteMaskProviderForIOOBE() {\n+        var f = SHORT_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n+        }\n+        return ms;\n+    }\n+\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n+    }\n+\n+\n+    interface ToShortF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToShortF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToShortF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i) {\n+        return HalffloatVector.fromArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromArray(short[] a, int i, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i) {\n+        v.intoArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoArray(HalffloatVector v, short[] a, int i, VectorMask<Halffloat> m) {\n+        v.intoArray(a, i, m);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+    }\n+\n+    @DontInline\n+    static HalffloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        return HalffloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n+    }\n+\n+    @DontInline\n+    static void intoMemorySegment(HalffloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Halffloat> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n+    }\n+\n+    @Test(dataProvider = \"shortProvider\")\n+    static void loadStoreArray(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void loadArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortProviderForIOOBE\")\n+    static void storeArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMaskArray(IntFunction<short[]> fa,\n+                                   IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+\n+\n+        r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask);\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void loadArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = fromArray(a, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMaskProviderForIOOBE\")\n+    static void storeArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                intoArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, 0);\n+            intoArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"shortMaskProvider\")\n+    static void loadStoreMask(IntFunction<short[]> fa,\n+                              IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[mask.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, mask);\n+    }\n+\n+\n+    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int l = (int) a.byteSize();\n+        int s = SPECIES.vectorByteSize();\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < l; i += s) {\n+                HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n+            }\n+        }\n+\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n+        try {\n+            HalffloatVector av = HalffloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n+\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n+\n+        VectorMask<Halffloat> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n+    }\n+\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void loadStoreMask(IntFunction<boolean[]> fm) {\n+        boolean[] a = fm.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                VectorMask<Halffloat> vmask = SPECIES.loadMask(a, i);\n+                vmask.intoArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(r, a);\n+    }\n+\n+\n+    @Test\n+    static void loadStoreShuffle() {\n+        IntUnaryOperator fn = a -> a + 5;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            var shuffle = VectorShuffle.fromOp(SPECIES, fn);\n+            int [] r = shuffle.toArray();\n+\n+            int [] a = expectedShuffle(SPECIES.length(), fn);\n+            Assert.assertEquals(r, a);\n+       }\n+    }\n+\n+\n+\n+\n+\n+    \/\/ Gather\/Scatter load\/store tests\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], a[i + indexMap[j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i + indexMap[j]], \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertGatherArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                j = i;\n+                for (; j < i + SPECIES.length(); j++) {\n+                    Assert.assertEquals(r[j], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[j % SPECIES.length()] ? a[i + indexMap[j]]: (short) 0, \"at index #\" + j);\n+        }\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap, boolean[] mask) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                if (mask[j % SPECIES.length()]) {\n+                    expected[i + indexMap[j]] = a[j];\n+                }\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    static void assertScatterArraysEquals(short[] r, short[] a, int[] indexMap) {\n+        short[] expected = new short[r.length];\n+\n+        \/\/ Store before checking, since the same location may be stored to more than once\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int j = i; j < i + SPECIES.length(); j++) {\n+                expected[i + indexMap[j]] = a[j];\n+            }\n+        }\n+\n+        Assert.assertEquals(r, expected);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterProvider() {\n+        return INT_INDEX_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] gatherScatterMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+          flatMap(fs -> INT_INDEX_GENERATORS.stream().flatMap(fm ->\n+            SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm, fs};\n+            }))).\n+            toArray(Object[][]::new);\n+    }\n+\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void gather(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void gatherMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i, b, i, vmask);\n+                av.intoArray(r, i);\n+            }\n+        }\n+\n+        assertGatherArraysEquals(r, a, b, mask);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterProvider\")\n+    static void scatter(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b);\n+    }\n+\n+    @Test(dataProvider = \"gatherScatterMaskProvider\")\n+    static void scatterMask(IntFunction<short[]> fa, BiFunction<Integer,Integer,int[]> fs, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] b = fs.apply(a.length, SPECIES.length());\n+        short[] r = new short[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.intoArray(r, i, b, i, vmask);\n+            }\n+        }\n+\n+        assertScatterArraysEquals(r, a, b, mask);\n+    }\n+\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorLoadStoreTests.java","additions":741,"deletions":0,"binary":false,"changes":741,"status":"added"},{"patch":"@@ -0,0 +1,1802 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation HalffloatMaxVectorTests\n+ *\/\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class HalffloatMaxVectorTests extends AbstractVectorTest {\n+\n+    static final VectorSpecies<Halffloat> SPECIES =\n+                HalffloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+    static VectorShape getMaxBit() {\n+        return VectorShape.S_Max_BIT;\n+    }\n+\n+    private static final int Max = 256;  \/\/ juts so we can do N\/Max\n+\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ Max);\n+\n+    interface FUnOp {\n+        short apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        short[] apply(short a);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a[i]);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        short apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        short apply(short[] a);\n+    }\n+\n+    static void assertReductionArraysEquals(short[] r, short rc, short[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        short apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        short apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked(short[] r, short rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionOpLong {\n+        long apply(short[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply(short[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, short[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply(short[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply(short[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, short[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n+        try {\n+            for (; i < end; i += 1) {\n+                if(i%SPECIES.length() == index) {\n+                    Assert.assertEquals(r[i], element);\n+                } else {\n+                    Assert.assertEquals(r[i], a[i]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (i%SPECIES.length() == index) {\n+                Assert.assertEquals(r[i], element, \"at index #\" + i);\n+            } else {\n+                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n+            }\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals(short[] r, short[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals(short[] r, short[] a, short[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], (short)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        short apply(short a, short b);\n+    }\n+\n+    interface FBinMaskOp {\n+        short apply(short a, short b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], (short)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals(short[] r, short[] a, short[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FBinConstOp {\n+        short apply(short a);\n+    }\n+\n+    interface FBinConstMaskOp {\n+        short apply(short a, boolean m);\n+\n+        static FBinConstMaskOp lift(FBinConstOp f) {\n+            return (a, m) -> m ? f.apply(a) : a;\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, FBinConstOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstOp f) {\n+        assertShiftConstEquals(r, a, mask, FBinConstMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftConstEquals(short[] r, short[] a, boolean[] mask, FBinConstMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        short apply(short a, short b, short c);\n+    }\n+\n+    interface FTernMaskOp {\n+        short apply(short a, short b, short c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals(short[] r, short[] a, short[] b, short[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+    \/\/ TODO: Fix and Enable isWithin1Ulp\n+\n+    interface FBinArrayOp {\n+        short apply(short[] a, int b);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        short[] apply(short[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        short[] apply(short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        short[] apply(short[] r, short[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(r, a, i, mask, b, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        short[] apply(short[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        short[] apply(short[] a, short[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        short[] apply(short[] a, short[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals(short[] r, short[] a, short[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            short[] ref = f.apply(a, b, origin, part, mask, i);\n+            short[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> INT_SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)intCornerCaseValue(i));\n+            })\n+    );\n+\n+    static void assertArraysEquals(int[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<short[]>> LONG_SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)longCornerCaseValue(i));\n+            })\n+    );\n+\n+\n+    static void assertArraysEquals(long[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static void assertArraysEquals(double[] r, short[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+    static short bits(short e) {\n+        return  Halffloat.shortToShortBits(e);\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_GENERATORS = List.of(\n+            withToString(\"short[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-i * 5));\n+            }),\n+            withToString(\"short[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i * 5));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (((short)(i + 1) == 0) ? 1 : (short)(i + 1)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_PAIRS =\n+        Stream.of(SHORT_GENERATORS.get(0)).\n+                flatMap(fa -> SHORT_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_GENERATOR_TRIPLES =\n+        SHORT_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> SHORT_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpProvider() {\n+        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortIndexedOpProvider() {\n+        return SHORT_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortBinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpProvider() {\n+        return SHORT_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpProvider() {\n+        return SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoIntUnaryOpProvider() {\n+        return INT_SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shorttoLongUnaryOpProvider() {\n+        return LONG_SHORT_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<BiFunction<Integer,Integer,short[]>> SHORT_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                short[] a = new short[l];\n+                int upper = m;\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = (short)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromProvider() {\n+        return SHORT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortUnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> SHORT_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<IntFunction<short[]>> SHORT_COMPARE_GENERATORS = List.of(\n+            withToString(\"short[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)i);\n+            }),\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"short[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i + 1));\n+            }),\n+            withToString(\"short[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - 2));\n+            }),\n+            withToString(\"short[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? (short)i : (i%3 == 1 ? (short)(i + 1) : (short)(i - 2)));\n+            }),\n+            withToString(\"short[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_TEST_GENERATOR_ARGS =\n+        SHORT_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortTestOpProvider() {\n+        return SHORT_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortTestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<short[]>>> SHORT_COMPARE_GENERATOR_PAIRS =\n+        SHORT_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> SHORT_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpProvider() {\n+        return SHORT_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortCompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToShortF {\n+        short apply(int i);\n+    }\n+\n+    static short[] fill(int s , ToShortF f) {\n+        return fill(new short[s], f);\n+    }\n+\n+    static short[] fill(short[] a, ToShortF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static short cornerCaseValue(int i) {\n+        switch(i % 7) {\n+            case 0:\n+                return Halffloat.MAX_VALUE;\n+            case 1:\n+                return Halffloat.MIN_VALUE;\n+            case 2:\n+                return Halffloat.NEGATIVE_INFINITY;\n+            case 3:\n+                return Halffloat.POSITIVE_INFINITY;\n+            case 4:\n+                return Halffloat.NaN;\n+            case 5:\n+                return (short)0.0;\n+            default:\n+                return Short.MIN_VALUE;\n+        }\n+    }\n+\n+    static short get(short[] a, int i) {\n+        return (short) a[i];\n+    }\n+\n+    static final IntFunction<short[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new short[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+\n+    static short ADD(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ADDHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::ADD);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void ADDHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::ADD);\n+    }\n+\n+    static short SUB(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void SUBHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::SUB);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void SUBHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::SUB);\n+    }\n+\n+    static short MUL(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() * Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MULHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MUL);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MULHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MUL);\n+    }\n+\n+    static short MAX(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MAXHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MAX);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MAXHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MAX);\n+    }\n+\n+    static short MIN(short a, short b) {\n+        return (short)(Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void MINHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::MIN);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void MINHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::MIN);\n+    }\n+\n+    static short ABS(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    static short abs(short a) {\n+        return (short)(Math.abs(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ABSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::ABS);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void absHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::abs);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void ABSMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::ABS);\n+    }\n+\n+    static short NEG(short a) {\n+        return (short)(-a);\n+    }\n+\n+    static short neg(short a) {\n+        return (short)(-a);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void NEGHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::NEG);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void negHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::neg);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void NEGMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::NEG);\n+    }\n+\n+    static short FMA(short a, short b, short c) {\n+        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+    }\n+\n+    static short fma(short a, short b, short c) {\n+        return (short)(Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void FMAHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpProvider\")\n+    static void fmaHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+            HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, HalffloatMaxVectorTests::fma);\n+    }\n+\n+    @Test(dataProvider = \"shortTernaryOpMaskProvider\")\n+    static void FMAHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                HalffloatVector cv = HalffloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, HalffloatMaxVectorTests::FMA);\n+    }\n+\n+    \/\/ TODO: Fix and Enable ltHalffloatMaxVectorTestsBroadcastSmokeTest\n+    \/\/ TODO: Fix and Enable eqHalffloatMaxVectorTestsBroadcastMaskedSmokeTest\n+    \/\/ TODO: Fix and Enable toLongArrayHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable toDoubleArrayHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable toStringHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable hashCodeHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ADDReduceLongHalffloatMaxVectorTests\n+    \/\/ TODO: Fix and Enable ADDReduceLongHalffloatMaxVectorTestsMasked\n+    \/\/ TODO: Fix and Enable BroadcastLongHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable blendHalffloatMaxVectorTestsBroadcastLongSmokeTest\n+\n+\n+    \/\/ TODO: Fix and Enable SelectFromHalffloatMaxVectorTests\n+    \/\/ TODO: Fix and Enable SelectFromHalffloatMaxVectorTestsMaskedSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleMiscellaneousHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleToStringHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleEqualsHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskEqualsHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskEqHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskHashCodeHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskTrueCountHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskLastTrueHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable maskFirstTrueHalffloatMaxVectorTestsSmokeTest\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressHalffloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    \/\/ TODO: Fix and Enable indexInRangeHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable indexInRangeLongHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable loopBoundHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable loopBoundLongHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ElementSizeHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable VectorShapeHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ShapeWithLanesHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable ElementTypeHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable SpeciesElementSizeHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable VectorTypeHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable WithLanesHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable WithShapeHalffloatMaxVectorTestsSmokeTest\n+    \/\/ TODO: Fix and Enable MaskAllTrueHalffloatMaxVectorTestsSmokeTest\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorTests.java","additions":1802,"deletions":0,"binary":false,"changes":1802,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-generate_perf_tests=$1\n+generate_perf_tests=$2\n@@ -400,180 +400,192 @@\n-# ALU binary ops.\n-# Here \"ADD+add+withMask\" says VectorOperator name is \"ADD\", and we have a dedicate method too named 'add', and add() is also available with mask variant.\n-gen_binary_alu_op \"ADD+add+withMask\" \"a + b\"\n-gen_binary_alu_op \"SUB+sub+withMask\" \"a - b\"\n-gen_binary_alu_op \"MUL+mul+withMask\" \"a \\* b\"\n-gen_binary_alu_op \"DIV+div+withMask\" \"a \\\/ b\" \"FP\"\n-gen_op_tmpl \"Binary-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_op_tmpl \"Binary-Masked-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_binary_alu_op \"FIRST_NONZERO\" \"{#if[FP]?Double.doubleToLongBits}(a)!=0?a:b\"\n-gen_binary_alu_op \"AND+and\"   \"a \\& b\"  \"BITWISE\"\n-gen_binary_alu_op \"AND_NOT\" \"a \\& ~b\" \"BITWISE\"\n-gen_binary_alu_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n-# Missing:        \"OR_UNCHECKED\"\n-gen_binary_alu_op \"XOR\"   \"a ^ b\"   \"BITWISE\"\n-gen_binary_alu_op \"COMPRESS_BITS\" \"\\$Boxtype\\$.compress(a, b)\" \"intOrLong\"\n-gen_binary_alu_op \"EXPAND_BITS\" \"\\$Boxtype\\$.expand(a, b)\" \"intOrLong\"\n-# Generate the broadcast versions\n-gen_binary_alu_bcst_op \"add+withMask\" \"a + b\"\n-gen_binary_alu_bcst_op \"sub+withMask\" \"a - b\"\n-gen_binary_alu_bcst_op \"mul+withMask\" \"a \\* b\"\n-gen_binary_alu_bcst_op \"div+withMask\" \"a \\\/ b\" \"FP\"\n-gen_op_tmpl \"Binary-Broadcast-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_op_tmpl \"Binary-Broadcast-Masked-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n-gen_binary_alu_bcst_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n-gen_binary_alu_bcst_op \"AND+and\"    \"a \\& b\"   \"BITWISE\"\n-gen_binary_alu_bcst_long_op \"OR\"     \"a | b\"   \"BITWISE\"\n-gen_binary_alu_bcst_long_op \"ADD\"    \"a + b\"\n-\n-# Shifts\n-gen_binary_alu_op \"LSHL\" \"(a << b)\" \"intOrLong\"\n-gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0x7))\" \"byte\"\n-gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0xF))\" \"short\"\n-gen_binary_alu_op \"ASHR\" \"(a >> b)\" \"intOrLong\"\n-gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0x7))\" \"byte\"\n-gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0xF))\" \"short\"\n-gen_binary_alu_op \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n-gen_binary_alu_op \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 0x7))\" \"byte\"\n-gen_binary_alu_op \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 0xF))\" \"short\"\n-gen_shift_op  \"LSHL\" \"(a << b)\" \"intOrLong\"\n-gen_shift_op  \"LSHL\" \"(a << (b \\& 7))\" \"byte\"\n-gen_shift_op  \"LSHL\" \"(a << (b \\& 15))\" \"short\"\n-gen_shift_op  \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n-gen_shift_op  \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 7))\" \"byte\"\n-gen_shift_op  \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 15))\" \"short\"\n-gen_shift_op  \"ASHR\" \"(a >> b)\" \"intOrLong\"\n-gen_shift_op  \"ASHR\" \"(a >> (b \\& 7))\" \"byte\"\n-gen_shift_op  \"ASHR\" \"(a >> (b \\& 15))\" \"short\"\n-gen_binary_alu_op \"ROR\" \"ROR_scalar(a,b)\" \"BITWISE\"\n-gen_binary_alu_op \"ROL\" \"ROL_scalar(a,b)\" \"BITWISE\"\n-gen_shift_op  \"ROR\" \"ROR_scalar(a, b)\" \"BITWISE\"\n-gen_shift_op  \"ROL\" \"ROL_scalar(a, b)\" \"BITWISE\"\n-\n-# Constant Shifts\n-gen_shift_cst_op  \"LSHR\" \"(a >>> CONST_SHIFT)\" \"intOrLong\"\n-gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFF) >>> CONST_SHIFT)\" \"byte\"\n-gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFFFF) >>> CONST_SHIFT)\" \"short\"\n-gen_shift_cst_op  \"LSHL\" \"(a << CONST_SHIFT)\" \"BITWISE\"\n-gen_shift_cst_op  \"ASHR\" \"(a >> CONST_SHIFT)\" \"BITWISE\"\n-gen_shift_cst_op  \"ROR\" \"ROR_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n-gen_shift_cst_op  \"ROL\" \"ROL_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n-\n-# Masked reductions.\n-gen_binary_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n-gen_binary_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n-gen_binary_bcst_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n-gen_binary_bcst_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n-\n-# Reductions.\n-gen_reduction_op \"AND\" \"\\&\" \"BITWISE\" \"-1\"\n-gen_reduction_op \"OR\" \"|\" \"BITWISE\" \"0\"\n-gen_reduction_op \"XOR\" \"^\" \"BITWISE\" \"0\"\n-gen_reduction_op \"ADD\" \"+\" \"\" \"0\"\n-gen_reduction_op \"MUL\" \"*\" \"\" \"1\"\n-gen_reduction_op_func \"MIN\" \"(\\$type\\$) Math.min\" \"\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n-gen_reduction_op_func \"MAX\" \"(\\$type\\$) Math.max\" \"\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n-gen_reduction_op_func \"FIRST_NONZERO\" \"firstNonZero\" \"\" \"(\\$type\\$) 0\"\n-\n-# Boolean reductions.\n-gen_bool_reduction_op \"anyTrue\" \"|\" \"BITWISE\" \"false\"\n-gen_bool_reduction_op \"allTrue\" \"\\&\" \"BITWISE\" \"true\"\n-\n-#Insert\n-gen_with_op \"withLane\" \"\" \"\" \"\"\n-\n-# Tests\n-gen_op_tmpl $test_template \"IS_DEFAULT\" \"bits(a)==0\"\n-gen_op_tmpl $test_template \"IS_NEGATIVE\" \"bits(a)<0\"\n-gen_op_tmpl $test_template \"IS_FINITE\" \"\\$Boxtype\\$.isFinite(a)\" \"FP\"\n-gen_op_tmpl $test_template \"IS_NAN\" \"\\$Boxtype\\$.isNaN(a)\" \"FP\"\n-gen_op_tmpl $test_template \"IS_INFINITE\" \"\\$Boxtype\\$.isInfinite(a)\" \"FP\"\n-\n-# Compares\n-gen_compare_op \"LT+lt\" \"lt\"\n-gen_compare_op \"GT\" \"gt\"\n-gen_compare_op \"EQ+eq\" \"eq\"\n-gen_compare_op \"NE\" \"neq\"\n-gen_compare_op \"LE\" \"le\"\n-gen_compare_op \"GE\" \"ge\"\n-\n-gen_compare_op \"UNSIGNED_LT\" \"ult\" \"BITWISE\"\n-gen_compare_op \"UNSIGNED_GT\" \"ugt\" \"BITWISE\"\n-gen_compare_op \"UNSIGNED_LE\" \"ule\" \"BITWISE\"\n-gen_compare_op \"UNSIGNED_GE\" \"uge\" \"BITWISE\"\n-\n-\n-gen_compare_bcst_op \"LT\" \"<\"\n-gen_compare_bcst_op \"EQ\" \"==\"\n-\n-# Blend.\n-gen_op_tmpl $blend \"blend\" \"\"\n-\n-# Rearrange\n-gen_op_tmpl $rearrange_template \"rearrange\" \"\"\n-\n-# Compress\/Expand\n-gen_op_tmpl $compressexpand_template \"compress_expand\" \"\"\n-\n-# Get\n-gen_get_op \"lane\" \"\"\n-\n-# Broadcast\n-gen_op_tmpl $broadcast_template \"broadcast\" \"\"\n-\n-# Zero\n-gen_op_tmpl $zero_template \"zero\" \"\"\n-\n-# Slice\n-gen_op_tmpl $slice_template \"sliceUnary\" \"\"\n-gen_op_tmpl $slice1_template \"sliceBinary\" \"\"\n-gen_op_tmpl $slice1_masked_template \"slice\" \"\"\n-\n-# Unslice\n-gen_op_tmpl $unslice_template \"unsliceUnary\" \"\"\n-gen_op_tmpl $unslice1_template \"unsliceBinary\" \"\"\n-gen_op_tmpl $unslice1_masked_template \"unslice\" \"\"\n-\n-# Math\n-gen_op_tmpl $unary_math_template \"SIN\" \"Math.sin((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"EXP\" \"Math.exp((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG1P\" \"Math.log1p((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG\" \"Math.log((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"LOG10\" \"Math.log10((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"EXPM1\" \"Math.expm1((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"COS\" \"Math.cos((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"TAN\" \"Math.tan((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"SINH\" \"Math.sinh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"COSH\" \"Math.cosh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"TANH\" \"Math.tanh((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ASIN\" \"Math.asin((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ACOS\" \"Math.acos((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"ATAN\" \"Math.atan((double)a)\" \"FP\"\n-gen_op_tmpl $unary_math_template \"CBRT\" \"Math.cbrt((double)a)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"HYPOT\" \"Math.hypot((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_template \"ATAN2\" \"Math.atan2((double)a, (double)b)\" \"FP\"\n-gen_op_tmpl $binary_math_broadcast_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n-\n-# Ternary operations.\n-gen_ternary_alu_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n-gen_ternary_alu_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n-gen_ternary_alu_bcst_op \"FMA\" \"Math.fma(a, b, c)\" \"FP\"\n-gen_ternary_alu_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n-gen_ternary_alu_double_bcst_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n-gen_ternary_alu_double_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n-\n-# Unary operations.\n-gen_unary_alu_op \"NEG+neg\" \"-((\\$type\\$)a)\"\n-gen_unary_alu_op \"ABS+abs\" \"Math.abs((\\$type\\$)a)\"\n-gen_unary_alu_op \"NOT+not\" \"~((\\$type\\$)a)\" \"BITWISE\"\n-gen_unary_alu_op \"ZOMO\" \"(a==0?0:-1)\" \"BITWISE\"\n-gen_unary_alu_op \"SQRT+sqrt\" \"Math.sqrt((double)a)\" \"FP\"\n-gen_unary_alu_op \"BIT_COUNT\" \"\\$Boxtype\\$.bitCount(a)\" \"intOrLong\"\n-gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFF)\" \"byte\"\n-gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFFFF)\" \"short\"\n-gen_unary_alu_op \"TRAILING_ZEROS_COUNT\" \"TRAILING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n-gen_unary_alu_op \"LEADING_ZEROS_COUNT\" \"LEADING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n-gen_unary_alu_op \"REVERSE\" \"REVERSE_scalar(a)\" \"BITWISE\"\n-gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"intOrLong\"\n-gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"short\"\n-gen_unary_alu_op \"REVERSE_BYTES\" \"a\" \"byte\"\n+if [ \"$1\" == \"ALL_PRIM_TYPES\" ]; then\n+  # ALU binary ops.\n+  # Here \"ADD+add+withMask\" says VectorOperator name is \"ADD\", and we have a dedicate method too named 'add', and add() is also available with mask variant.\n+  gen_binary_alu_op \"ADD+add+withMask\" \"a + b\"\n+  gen_binary_alu_op \"SUB+sub+withMask\" \"a - b\"\n+  gen_binary_alu_op \"MUL+mul+withMask\" \"a \\* b\"\n+  gen_binary_alu_op \"DIV+div+withMask\" \"a \\\/ b\" \"FP\"\n+  gen_op_tmpl \"Binary-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_op_tmpl \"Binary-Masked-op_bitwise-div\" \"DIV+div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_binary_alu_op \"FIRST_NONZERO\" \"{#if[FP]?Double.doubleToLongBits}(a)!=0?a:b\"\n+  gen_binary_alu_op \"AND+and\"   \"a \\& b\"  \"BITWISE\"\n+  gen_binary_alu_op \"AND_NOT\" \"a \\& ~b\" \"BITWISE\"\n+  gen_binary_alu_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n+  # Missing:        \"OR_UNCHECKED\"\n+  gen_binary_alu_op \"XOR\"   \"a ^ b\"   \"BITWISE\"\n+  gen_binary_alu_op \"COMPRESS_BITS\" \"\\$Boxtype\\$.compress(a, b)\" \"intOrLong\"\n+  gen_binary_alu_op \"EXPAND_BITS\" \"\\$Boxtype\\$.expand(a, b)\" \"intOrLong\"\n+  # Generate the broadcast versions\n+  gen_binary_alu_bcst_op \"add+withMask\" \"a + b\"\n+  gen_binary_alu_bcst_op \"sub+withMask\" \"a - b\"\n+  gen_binary_alu_bcst_op \"mul+withMask\" \"a \\* b\"\n+  gen_binary_alu_bcst_op \"div+withMask\" \"a \\\/ b\" \"FP\"\n+  gen_op_tmpl \"Binary-Broadcast-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_op_tmpl \"Binary-Broadcast-Masked-op_bitwise-div\" \"div+withMask\" \"a \\\/ b\" \"BITWISE\"\n+  gen_binary_alu_bcst_op \"OR+or\"    \"a | b\"   \"BITWISE\"\n+  gen_binary_alu_bcst_op \"AND+and\"    \"a \\& b\"   \"BITWISE\"\n+  gen_binary_alu_bcst_long_op \"OR\"     \"a | b\"   \"BITWISE\"\n+  gen_binary_alu_bcst_long_op \"ADD\"    \"a + b\"\n+\n+  # Shifts\n+  gen_binary_alu_op \"LSHL\" \"(a << b)\" \"intOrLong\"\n+  gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0x7))\" \"byte\"\n+  gen_binary_alu_op \"LSHL\" \"(a << (b \\& 0xF))\" \"short\"\n+  gen_binary_alu_op \"ASHR\" \"(a >> b)\" \"intOrLong\"\n+  gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0x7))\" \"byte\"\n+  gen_binary_alu_op \"ASHR\" \"(a >> (b \\& 0xF))\" \"short\"\n+  gen_binary_alu_op \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n+  gen_binary_alu_op \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 0x7))\" \"byte\"\n+  gen_binary_alu_op \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 0xF))\" \"short\"\n+  gen_shift_op  \"LSHL\" \"(a << b)\" \"intOrLong\"\n+  gen_shift_op  \"LSHL\" \"(a << (b \\& 7))\" \"byte\"\n+  gen_shift_op  \"LSHL\" \"(a << (b \\& 15))\" \"short\"\n+  gen_shift_op  \"LSHR\" \"(a >>> b)\" \"intOrLong\"\n+  gen_shift_op  \"LSHR\" \"((a \\& 0xFF) >>> (b \\& 7))\" \"byte\"\n+  gen_shift_op  \"LSHR\" \"((a \\& 0xFFFF) >>> (b \\& 15))\" \"short\"\n+  gen_shift_op  \"ASHR\" \"(a >> b)\" \"intOrLong\"\n+  gen_shift_op  \"ASHR\" \"(a >> (b \\& 7))\" \"byte\"\n+  gen_shift_op  \"ASHR\" \"(a >> (b \\& 15))\" \"short\"\n+  gen_binary_alu_op \"ROR\" \"ROR_scalar(a,b)\" \"BITWISE\"\n+  gen_binary_alu_op \"ROL\" \"ROL_scalar(a,b)\" \"BITWISE\"\n+  gen_shift_op  \"ROR\" \"ROR_scalar(a, b)\" \"BITWISE\"\n+  gen_shift_op  \"ROL\" \"ROL_scalar(a, b)\" \"BITWISE\"\n+\n+  # Constant Shifts\n+  gen_shift_cst_op  \"LSHR\" \"(a >>> CONST_SHIFT)\" \"intOrLong\"\n+  gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFF) >>> CONST_SHIFT)\" \"byte\"\n+  gen_shift_cst_op  \"LSHR\" \"((a \\& 0xFFFF) >>> CONST_SHIFT)\" \"short\"\n+  gen_shift_cst_op  \"LSHL\" \"(a << CONST_SHIFT)\" \"BITWISE\"\n+  gen_shift_cst_op  \"ASHR\" \"(a >> CONST_SHIFT)\" \"BITWISE\"\n+  gen_shift_cst_op  \"ROR\" \"ROR_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n+  gen_shift_cst_op  \"ROL\" \"ROL_scalar(a, CONST_SHIFT)\" \"BITWISE\"\n+\n+  # Masked reductions.\n+  gen_binary_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n+  gen_binary_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n+  gen_binary_bcst_op_no_masked \"MIN+min\" \"Math.min(a, b)\"\n+  gen_binary_bcst_op_no_masked \"MAX+max\" \"Math.max(a, b)\"\n+\n+  # Reductions.\n+  gen_reduction_op \"AND\" \"\\&\" \"BITWISE\" \"-1\"\n+  gen_reduction_op \"OR\" \"|\" \"BITWISE\" \"0\"\n+  gen_reduction_op \"XOR\" \"^\" \"BITWISE\" \"0\"\n+  gen_reduction_op \"ADD\" \"+\" \"\" \"0\"\n+  gen_reduction_op \"MUL\" \"*\" \"\" \"1\"\n+  gen_reduction_op_func \"MIN\" \"(\\$type\\$) Math.min\" \"\" \"\\$Wideboxtype\\$.\\$MaxValue\\$\"\n+  gen_reduction_op_func \"MAX\" \"(\\$type\\$) Math.max\" \"\" \"\\$Wideboxtype\\$.\\$MinValue\\$\"\n+  gen_reduction_op_func \"FIRST_NONZERO\" \"firstNonZero\" \"\" \"(\\$type\\$) 0\"\n+\n+  # Boolean reductions.\n+  gen_bool_reduction_op \"anyTrue\" \"|\" \"BITWISE\" \"false\"\n+  gen_bool_reduction_op \"allTrue\" \"\\&\" \"BITWISE\" \"true\"\n+\n+  #Insert\n+  gen_with_op \"withLane\" \"\" \"\" \"\"\n+\n+  # Tests\n+  gen_op_tmpl $test_template \"IS_DEFAULT\" \"bits(a)==0\"\n+  gen_op_tmpl $test_template \"IS_NEGATIVE\" \"bits(a)<0\"\n+  gen_op_tmpl $test_template \"IS_FINITE\" \"\\$Boxtype\\$.isFinite(a)\" \"FP\"\n+  gen_op_tmpl $test_template \"IS_NAN\" \"\\$Boxtype\\$.isNaN(a)\" \"FP\"\n+  gen_op_tmpl $test_template \"IS_INFINITE\" \"\\$Boxtype\\$.isInfinite(a)\" \"FP\"\n+\n+  # Compares\n+  gen_compare_op \"LT+lt\" \"lt\"\n+  gen_compare_op \"GT\" \"gt\"\n+  gen_compare_op \"EQ+eq\" \"eq\"\n+  gen_compare_op \"NE\" \"neq\"\n+  gen_compare_op \"LE\" \"le\"\n+  gen_compare_op \"GE\" \"ge\"\n+\n+  gen_compare_op \"UNSIGNED_LT\" \"ult\" \"BITWISE\"\n+  gen_compare_op \"UNSIGNED_GT\" \"ugt\" \"BITWISE\"\n+  gen_compare_op \"UNSIGNED_LE\" \"ule\" \"BITWISE\"\n+  gen_compare_op \"UNSIGNED_GE\" \"uge\" \"BITWISE\"\n+\n+\n+  gen_compare_bcst_op \"LT\" \"<\"\n+  gen_compare_bcst_op \"EQ\" \"==\"\n+\n+  # Blend.\n+  gen_op_tmpl $blend \"blend\" \"\"\n+\n+  # Rearrange\n+  gen_op_tmpl $rearrange_template \"rearrange\" \"\"\n+\n+  # Compress\/Expand\n+  gen_op_tmpl $compressexpand_template \"compress_expand\" \"\"\n+\n+  # Get\n+  gen_get_op \"lane\" \"\"\n+\n+  # Broadcast\n+  gen_op_tmpl $broadcast_template \"broadcast\" \"\"\n+\n+  # Zero\n+  gen_op_tmpl $zero_template \"zero\" \"\"\n+\n+  # Slice\n+  gen_op_tmpl $slice_template \"sliceUnary\" \"\"\n+  gen_op_tmpl $slice1_template \"sliceBinary\" \"\"\n+  gen_op_tmpl $slice1_masked_template \"slice\" \"\"\n+\n+  # Unslice\n+  gen_op_tmpl $unslice_template \"unsliceUnary\" \"\"\n+  gen_op_tmpl $unslice1_template \"unsliceBinary\" \"\"\n+  gen_op_tmpl $unslice1_masked_template \"unslice\" \"\"\n+\n+  # Math\n+  gen_op_tmpl $unary_math_template \"SIN\" \"Math.sin((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"EXP\" \"Math.exp((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"LOG1P\" \"Math.log1p((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"LOG\" \"Math.log((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"LOG10\" \"Math.log10((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"EXPM1\" \"Math.expm1((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"COS\" \"Math.cos((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"TAN\" \"Math.tan((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"SINH\" \"Math.sinh((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"COSH\" \"Math.cosh((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"TANH\" \"Math.tanh((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"ASIN\" \"Math.asin((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"ACOS\" \"Math.acos((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"ATAN\" \"Math.atan((double)a)\" \"FP\"\n+  gen_op_tmpl $unary_math_template \"CBRT\" \"Math.cbrt((double)a)\" \"FP\"\n+  gen_op_tmpl $binary_math_template \"HYPOT\" \"Math.hypot((double)a, (double)b)\" \"FP\"\n+  gen_op_tmpl $binary_math_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n+  gen_op_tmpl $binary_math_template \"ATAN2\" \"Math.atan2((double)a, (double)b)\" \"FP\"\n+  gen_op_tmpl $binary_math_broadcast_template \"POW+pow\" \"Math.pow((double)a, (double)b)\" \"FP\"\n+\n+  # Ternary operations.\n+  gen_ternary_alu_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n+  gen_ternary_alu_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n+  gen_ternary_alu_bcst_op \"FMA\" \"Math.fma(a, b, c)\" \"FP\"\n+  gen_ternary_alu_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n+  gen_ternary_alu_double_bcst_op \"FMA+fma\" \"Math.fma(a, b, c)\" \"FP\"\n+  gen_ternary_alu_double_bcst_op \"BITWISE_BLEND+bitwiseBlend\" \"(a\\&~(c))|(b\\&c)\" \"BITWISE\"\n+\n+  # Unary operations.\n+  gen_unary_alu_op \"NEG+neg\" \"-((\\$type\\$)a)\"\n+  gen_unary_alu_op \"ABS+abs\" \"Math.abs((\\$type\\$)a)\"\n+  gen_unary_alu_op \"NOT+not\" \"~((\\$type\\$)a)\" \"BITWISE\"\n+  gen_unary_alu_op \"ZOMO\" \"(a==0?0:-1)\" \"BITWISE\"\n+  gen_unary_alu_op \"SQRT+sqrt\" \"Math.sqrt((double)a)\" \"FP\"\n+  gen_unary_alu_op \"BIT_COUNT\" \"\\$Boxtype\\$.bitCount(a)\" \"intOrLong\"\n+  gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFF)\" \"byte\"\n+  gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFFFF)\" \"short\"\n+  gen_unary_alu_op \"TRAILING_ZEROS_COUNT\" \"TRAILING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n+  gen_unary_alu_op \"LEADING_ZEROS_COUNT\" \"LEADING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n+  gen_unary_alu_op \"REVERSE\" \"REVERSE_scalar(a)\" \"BITWISE\"\n+  gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"intOrLong\"\n+  gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"short\"\n+  gen_unary_alu_op \"REVERSE_BYTES\" \"a\" \"byte\"\n+\n+elif [ \"$1\" == \"HALF_FLOAT_TYPE\" ]; then\n+  gen_binary_alu_op \"ADD\" \"Halffloat.valueOf((Halffloat.valueOf(a).floatValue() + Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n+  gen_binary_alu_op \"SUB\" \"Halffloat.valueOf((Halffloat.valueOf(a).floatValue() - Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n+  gen_binary_alu_op \"MUL\" \"Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \\* Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n+  gen_binary_alu_op \"MAX\" \"Halffloat.valueOf(Math.max(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n+  gen_binary_alu_op \"MIN\" \"Halffloat.valueOf(Math.min(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n+  gen_unary_alu_op \"ABS+abs\" \"Math.abs(a)\" \"Halffloat\"\n+  gen_unary_alu_op \"NEG+neg\" \"-a\" \"Halffloat\"\n+  gen_ternary_alu_op \"FMA+fma\" \"Halffloat.valueOf(Math.fma(Halffloat.valueOf(a).floatValue(), Halffloat.valueOf(b).floatValue(), Halffloat.valueOf(c).floatValue()))\" \"Halffloat\"\n+fi\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":193,"deletions":181,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -31,5 +31,2 @@\n-case $* in\n-'')             CLASS_FILTER='*';;\n---generate*)    CLASS_FILTER=${2-'*'};;\n---help|*)       echo \"Usage: $0 [--generate [file]]\"; exit 1;;\n-esac\n+generate_test_case() {\n+  Log false \"Generating Vector API tests, $(date)\\n\"\n@@ -37,1 +34,5 @@\n-. config.sh\n+  # Compile SPP\n+  Log true \"Compiling SPP... \"\n+  compilation=$(${JAVAC} -d . \"${JDK_SRC_HOME}\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\")\n+  Log false \"$compilation\\n\"\n+  Log true \"done\\n\"\n@@ -39,5 +40,6 @@\n-# Detect whether to generate the performance tests\n-generate_perf_tests=false\n-if [ -d \"$PERF_DEST\" ]; then\n-  generate_perf_tests=true\n-fi\n+  array=()\n+  if [ $1 == \"ALL_PRIM_TYPES\" ]; then\n+    array=(\"byte\" \"short\" \"int\" \"long\" \"float\" \"double\")\n+  elif [ $1 == \"HALF_FLOAT_TYPE\" ]; then\n+    array=(\"halffloat\")\n+  fi\n@@ -45,92 +47,2 @@\n-# First, generate the template file.\n-bash .\/gen-template.sh $generate_perf_tests\n-\n-Log false \"Generating Vector API tests, $(date)\\n\"\n-\n-# Compile SPP\n-Log true \"Compiling SPP... \"\n-compilation=$(${JAVAC} -d . \"${JDK_SRC_HOME}\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\")\n-Log false \"$compilation\\n\"\n-Log true \"done\\n\"\n-\n-# For each type\n-for type in byte short int long float double\n-do\n-  Type=\"$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})${type:1}\"\n-  TYPE=\"$(tr '[:lower:]' '[:upper:]' <<< ${type})\"\n-  args=\"-K$type -Dtype=$type -DType=$Type -DTYPE=$TYPE\"\n-\n-  Boxtype=$Type\n-  Wideboxtype=$Boxtype\n-  MaxValue=MAX_VALUE\n-  MinValue=MIN_VALUE\n-\n-  kind=BITWISE\n-\n-  bitstype=$type\n-  Bitstype=$Type\n-  Boxbitstype=$Boxtype\n-\n-  fptype=$type\n-  Fptype=$Type\n-  Boxfptype=$Boxtype\n-\n-  case $type in\n-    byte)\n-      Wideboxtype=Byte\n-      args=\"$args -KbyteOrShort\"\n-      ;;\n-    short)\n-      Wideboxtype=Short\n-      args=\"$args -KbyteOrShort\"\n-      ;;\n-    int)\n-      Boxtype=Integer\n-      Wideboxtype=Integer\n-      fptype=float\n-      Fptype=Float\n-      Boxfptype=Float\n-      args=\"$args -KintOrLong\"\n-      ;;\n-    long)\n-      Wideboxtype=Long\n-      fptype=double\n-      Fptype=Double\n-      Boxfptype=Double\n-      args=\"$args -KintOrLong\"\n-      ;;\n-    float)\n-      kind=FP\n-      bitstype=int\n-      Bitstype=Int\n-      Boxbitstype=Integer\n-      Wideboxtype=Float\n-      MaxValue=POSITIVE_INFINITY\n-      MinValue=NEGATIVE_INFINITY\n-      ;;\n-    double)\n-      kind=FP\n-      bitstype=long\n-      Bitstype=Long\n-      Boxbitstype=Long\n-      Wideboxtype=Double\n-      MaxValue=POSITIVE_INFINITY\n-      MinValue=NEGATIVE_INFINITY\n-      ;;\n-  esac\n-\n-  args=\"$args -K$kind -K$Type -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype -DMaxValue=$MaxValue -DMinValue=$MinValue\"\n-  args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype\"\n-  args=\"$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype\"\n-\n-  abstractvectortype=${typeprefix}${Type}Vector\n-  abstractvectorteststype=${typeprefix}${Type}VectorTests\n-  abstractbitsvectortype=${typeprefix}${Bitstype}Vector\n-  abstractfpvectortype=${typeprefix}${Fptype}Vector\n-  args=\"$args -Dabstractvectortype=$abstractvectortype -Dabstractvectorteststype=$abstractvectorteststype -Dabstractbitsvectortype=$abstractbitsvectortype -Dabstractfpvectortype=$abstractfpvectortype\"\n-\n-  # Generate tests for operations\n-  # For each size\n-  Log true \"${Type}:\"\n-\n-  for bits in 64 128 256 512 Max\n+  # For each type\n+  for type in ${array[@]}\n@@ -138,15 +50,3 @@\n-    vectortype=${typeprefix}${Type}${bits}Vector\n-    vectorteststype=${typeprefix}${Type}${bits}VectorTests\n-    vectorbenchtype=${typeprefix}${Type}${bits}Vector\n-    masktype=${typeprefix}${Type}${bits}Mask\n-    bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n-    fpvectortype=${typeprefix}${Fptype}${bits}Vector\n-    shape=S${bits}Bit\n-    Shape=S_${bits}_BIT\n-    if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n-      args=\"$args -KByteMax\"\n-    fi\n-    bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n-    if [ $bits == 'Max' ]; then\n-      bitargs=\"$bitargs -KMaxBit\"\n-    fi\n+    Type=\"$(tr '[:lower:]' '[:upper:]' <<< ${type:0:1})${type:1}\"\n+    TYPE=\"$(tr '[:lower:]' '[:upper:]' <<< ${type})\"\n+    args=\"-K$type -Dtype=$type -DType=$Type -DTYPE=$TYPE\"\n@@ -154,13 +54,99 @@\n-    # Generate jtreg tests\n-    case $vectorteststype in\n-    $CLASS_FILTER)\n-      Log true \" ${bits}_jtreg $vectorteststype.java\"\n-      Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${TEMPLATE_FILE} -o$vectorteststype.java \"\n-      TEST_DEST_FILE=\"${vectorteststype}.java\"\n-      rm -f ${TEST_DEST_FILE}\n-      ${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs \\\n-        -i${TEMPLATE_FILE} \\\n-        -o${TEST_DEST_FILE}\n-      if [ VAR_OS_ENV==windows.cygwin ]; then\n-        tr -d  '\\r' < ${TEST_DEST_FILE} > temp\n-        mv temp ${TEST_DEST_FILE}\n+    Boxtype=$Type\n+    Wideboxtype=$Boxtype\n+    MaxValue=MAX_VALUE\n+    MinValue=MIN_VALUE\n+    ElementType=$Type\n+    kind=BITWISE\n+    VecEleType=$Type\n+    bitstype=$type\n+    Bitstype=$Type\n+    Boxbitstype=$Boxtype\n+    fptype=$type\n+    Fptype=$Type\n+    Boxfptype=$Boxtype\n+\n+    case $type in\n+      byte)\n+        Wideboxtype=Byte\n+        args=\"$args -KbyteOrShort\"\n+        ;;\n+      short)\n+        Wideboxtype=Short\n+        args=\"$args -KbyteOrShort\"\n+        ;;\n+      int)\n+        ElementType=Int\n+        VecEleType=Integer\n+        Boxtype=Integer\n+        Wideboxtype=Integer\n+        fptype=float\n+        Fptype=Float\n+        Boxfptype=Float\n+        args=\"$args -KintOrLong\"\n+        ;;\n+      long)\n+        Wideboxtype=Long\n+        fptype=double\n+        Fptype=Double\n+        Boxfptype=Double\n+        args=\"$args -KintOrLong\"\n+        ;;\n+      float)\n+        kind=FP\n+        bitstype=int\n+        Bitstype=Int\n+        Boxbitstype=Integer\n+        Wideboxtype=Float\n+        MaxValue=POSITIVE_INFINITY\n+        MinValue=NEGATIVE_INFINITY\n+        ;;\n+      double)\n+        kind=FP\n+        bitstype=long\n+        Bitstype=Long\n+        Boxbitstype=Long\n+        Wideboxtype=Double\n+        MaxValue=POSITIVE_INFINITY\n+        MinValue=NEGATIVE_INFINITY\n+        ;;\n+      halffloat)\n+        VecEleType=Short\n+        kind=FP\n+        bitstype=short\n+        Bitstype=Short\n+        Boxbitstype=Short\n+        Wideboxtype=Halffloat\n+        args=\"$args -Dtype=short -DType=Short -DTYPE=SHORT -DElementType=Halffloat\"\n+        ;;\n+      esac\n+\n+    args=\"$args -K$kind -K$Type -DBoxtype=$Boxtype -DWideboxtype=$Wideboxtype -DMaxValue=$MaxValue -DMinValue=$MinValue\"\n+    args=\"$args -Dbitstype=$bitstype -DBitstype=$Bitstype -DBoxbitstype=$Boxbitstype -DElementType=$Type -DVecEleType=$VecEleType\"\n+    args=\"$args -Dfptype=$fptype -DFptype=$Fptype -DBoxfptype=$Boxfptype\"\n+\n+    abstractvectortype=${typeprefix}${Type}Vector\n+    abstractvectorteststype=${typeprefix}${Type}VectorTests\n+    abstractbitsvectortype=${typeprefix}${Bitstype}Vector\n+    abstractfpvectortype=${typeprefix}${Fptype}Vector\n+    args=\"$args -Dabstractvectortype=$abstractvectortype -Dabstractvectorteststype=$abstractvectorteststype -Dabstractbitsvectortype=$abstractbitsvectortype -Dabstractfpvectortype=$abstractfpvectortype\"\n+\n+    # Generate tests for operations\n+    # For each size\n+    Log true \"${Type}:\"\n+\n+    for bits in 64 128 256 512 Max\n+    do\n+      vectortype=${typeprefix}${Type}${bits}Vector\n+      vectorteststype=${typeprefix}${Type}${bits}VectorTests\n+      vectorbenchtype=${typeprefix}${Type}${bits}Vector\n+      masktype=${typeprefix}${Type}${bits}Mask\n+      bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n+      fpvectortype=${typeprefix}${Fptype}${bits}Vector\n+      shape=S${bits}Bit\n+      Shape=S_${bits}_BIT\n+      if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n+        args=\"$args -KByteMax\"\n+      fi\n+      bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n+      if [ $bits == 'Max' ]; then\n+        bitargs=\"$bitargs -KMaxBit\"\n@@ -168,2 +154,0 @@\n-      ;;\n-    esac\n@@ -171,3 +155,2 @@\n-    if [ $generate_perf_tests == true ]; then\n-      # Generate jmh performance tests\n-      case $vectorbenchtype in\n+      # Generate jtreg tests\n+      case $vectorteststype in\n@@ -175,4 +158,4 @@\n-        Log true \" ${bits}_jmh $vectorbenchtype.java\"\n-        Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${PERF_TEMPLATE_FILE} -o${vectorteststype}Perf.java \"\n-        PERF_DEST_FILE=\"${PERF_DEST}\/${vectorbenchtype}.java\"\n-        rm -f ${PERF_DEST_FILE}\n+        Log true \" ${bits}_jtreg $vectorteststype.java\"\n+        Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${TEMPLATE_FILE} -o$vectorteststype.java \"\n+        TEST_DEST_FILE=\"${vectorteststype}.java\"\n+        rm -f ${TEST_DEST_FILE}\n@@ -180,2 +163,2 @@\n-          -i${PERF_TEMPLATE_FILE} \\\n-          -o${PERF_DEST_FILE}\n+          -i${TEMPLATE_FILE} \\\n+          -o${TEST_DEST_FILE}\n@@ -183,2 +166,2 @@\n-          tr -d  '\\r' < ${PERF_DEST_FILE} > temp\n-          mv temp ${PERF_DEST_FILE}\n+          tr -d  '\\r' < ${TEST_DEST_FILE} > temp\n+          mv temp ${TEST_DEST_FILE}\n@@ -188,2 +171,0 @@\n-    fi\n-  done\n@@ -191,17 +172,21 @@\n-  if [ $generate_perf_tests == true ]; then\n-    # Generate jmh performance tests\n-    case ${Type}Scalar in\n-    $CLASS_FILTER)\n-    Log true \" scalar ${Type}Scalar.java\"\n-    PERF_DEST_FILE=\"${PERF_DEST}\/${Type}Scalar.java\"\n-    rm -f ${PERF_DEST_FILE}\n-    ${JAVA} -cp . ${SPP_CLASSNAME} -nel $args \\\n-      -i${PERF_SCALAR_TEMPLATE_FILE} \\\n-      -o${PERF_DEST_FILE}\n-    if [ VAR_OS_ENV==windows.cygwin ]; then\n-      tr -d  '\\r' < ${PERF_DEST_FILE} > temp\n-      mv temp ${PERF_DEST_FILE}\n-    fi\n-      ;;\n-    esac\n-  fi\n+      if [ $1 == \"ALL_PRIM_TYPES\" ]; then\n+        if [ $generate_perf_tests == true ]; then\n+          # Generate jmh performance tests\n+          case $vectorbenchtype in\n+          $CLASS_FILTER)\n+          Log true \" ${bits}_jmh $vectorbenchtype.java\"\n+          Log false \"${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs -i${PERF_TEMPLATE_FILE} -o${vectorteststype}Perf.java \"\n+          PERF_DEST_FILE=\"${PERF_DEST}\/${vectorbenchtype}.java\"\n+          rm -f ${PERF_DEST_FILE}\n+          ${JAVA} -cp . ${SPP_CLASSNAME} -nel $bitargs \\\n+          -i${PERF_TEMPLATE_FILE} \\\n+          -o${PERF_DEST_FILE}\n+          if [ VAR_OS_ENV==windows.cygwin ]; then\n+            tr -d  '\\r' < ${PERF_DEST_FILE} > temp\n+            mv temp ${PERF_DEST_FILE}\n+          fi\n+            ;;\n+          esac\n+        fi\n+      fi\n+    done\n@@ -209,18 +194,18 @@\n-  # Generate tests for loads and stores\n-  # For each size\n-  for bits in 64 128 256 512 Max\n-  do\n-    vectortype=${typeprefix}${Type}${bits}Vector\n-    vectorteststype=${typeprefix}${Type}${bits}VectorLoadStoreTests\n-    vectorbenchtype=${typeprefix}${Type}${bits}VectorLoadStore\n-    masktype=${typeprefix}${Type}${bits}Mask\n-    bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n-    fpvectortype=${typeprefix}${Fptype}${bits}Vector\n-    shape=S${bits}Bit\n-    Shape=S_${bits}_BIT\n-    if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n-      args=\"$args -KByteMax\"\n-    fi\n-    bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n-    if [ $bits == 'Max' ]; then\n-      bitargs=\"$bitargs -KMaxBit\"\n+    if [ $1 == \"ALL_PRIM_TYPES\" ]; then\n+      if [ $generate_perf_tests == true ]; then\n+        # Generate jmh performance tests\n+        case ${Type}Scalar in\n+        $CLASS_FILTER)\n+        Log true \" scalar ${Type}Scalar.java\"\n+        PERF_DEST_FILE=\"${PERF_DEST}\/${Type}Scalar.java\"\n+        rm -f ${PERF_DEST_FILE}\n+        ${JAVA} -cp . ${SPP_CLASSNAME} -nel $args \\\n+        -i${PERF_SCALAR_TEMPLATE_FILE} \\\n+        -o${PERF_DEST_FILE}\n+        if [ VAR_OS_ENV==windows.cygwin ]; then\n+          tr -d  '\\r' < ${PERF_DEST_FILE} > temp\n+          mv temp ${PERF_DEST_FILE}\n+        fi\n+          ;;\n+        esac\n+      fi\n@@ -228,0 +213,19 @@\n+    # Generate tests for loads and stores\n+    # For each size\n+    for bits in 64 128 256 512 Max\n+    do\n+      vectortype=${typeprefix}${Type}${bits}Vector\n+      vectorteststype=${typeprefix}${Type}${bits}VectorLoadStoreTests\n+      vectorbenchtype=${typeprefix}${Type}${bits}VectorLoadStore\n+      masktype=${typeprefix}${Type}${bits}Mask\n+      bitsvectortype=${typeprefix}${Bitstype}${bits}Vector\n+      fpvectortype=${typeprefix}${Fptype}${bits}Vector\n+      shape=S${bits}Bit\n+      Shape=S_${bits}_BIT\n+      if [[ \"${vectortype}\" == \"ByteMaxVector\" ]]; then\n+        args=\"$args -KByteMax\"\n+      fi\n+      bitargs=\"$args -Dbits=$bits -Dvectortype=$vectortype -Dvectorteststype=$vectorteststype -Dvectorbenchtype=$vectorbenchtype -Dmasktype=$masktype -Dbitsvectortype=$bitsvectortype -Dfpvectortype=$fpvectortype -Dshape=$shape -DShape=$Shape\"\n+      if [ $bits == 'Max' ]; then\n+        bitargs=\"$bitargs -KMaxBit\"\n+      fi\n@@ -229,3 +233,3 @@\n-    # Generate\n-    case $vectorteststype in\n-    $CLASS_FILTER)\n+      # Generate\n+      case $vectorteststype in\n+      $CLASS_FILTER)\n@@ -237,2 +241,2 @@\n-        -itemplates\/X-LoadStoreTest.java.template \\\n-        -o${TEST_DEST_FILE}\n+      -itemplates\/X-LoadStoreTest.java.template \\\n+      -o${TEST_DEST_FILE}\n@@ -243,2 +247,7 @@\n-      ;;\n-    esac\n+        ;;\n+      esac\n+\n+      # TODO: Generate jmh performance tests for LoadStore variants\n+    done\n+\n+    Log true \" done\\n\"\n@@ -246,1 +255,0 @@\n-    # TODO: Generate jmh performance tests for LoadStore variants\n@@ -248,0 +256,7 @@\n+}\n+\n+case $* in\n+'')             CLASS_FILTER='*';;\n+--generate*)    CLASS_FILTER=${2-'*'};;\n+--help|*)       echo \"Usage: $0 [--generate [file]]\"; exit 1;;\n+esac\n@@ -249,1 +264,1 @@\n-  Log true \" done\\n\"\n+. config.sh\n@@ -251,1 +266,5 @@\n-done\n+# Detect whether to generate the performance tests\n+generate_perf_tests=false\n+if [ -d \"$PERF_DEST\" ]; then\n+  generate_perf_tests=true\n+fi\n@@ -253,0 +272,7 @@\n+# First, generate the template files.\n+gen_type=\"ALL_PRIM_TYPES\"\n+gen_half_type=\"HALF_FLOAT_TYPE\"\n+bash gen-template.sh $gen_type $generate_perf_tests\n+generate_test_case $gen_type\n+bash gen-template.sh $gen_half_type $generate_perf_tests\n+generate_test_case $gen_half_type\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":217,"deletions":191,"binary":false,"changes":408,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+#if[!Halffloat]\n@@ -235,0 +236,12 @@\n+#else[!Halffloat]\n+    \/\/ TODO: Fix and Enable lt$vectorteststype$BroadcastSmokeTest\n+    \/\/ TODO: Fix and Enable eq$vectorteststype$BroadcastMaskedSmokeTest\n+    \/\/ TODO: Fix and Enable toLongArray$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable toDoubleArray$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable toString$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable hashCode$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable ADDReduceLong$vectorteststype$\n+    \/\/ TODO: Fix and Enable ADDReduceLong$vectorteststype$Masked\n+    \/\/ TODO: Fix and Enable BroadcastLong$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable blend$vectorteststype$BroadcastLongSmokeTest\n+#end[!Halffloat]\n@@ -280,0 +293,1 @@\n+#if[!Halffloat]\n@@ -486,0 +500,13 @@\n+#else[!Halffloat]\n+    \/\/ TODO: Fix and Enable SelectFrom$vectorteststype$\n+    \/\/ TODO: Fix and Enable SelectFrom$vectorteststype$MaskedSmokeTest\n+    \/\/ TODO: Fix and Enable shuffleMiscellaneous$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable shuffleToString$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable shuffleEquals$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable maskEquals$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable maskEq$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable maskHashCode$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable maskTrueCount$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable maskLastTrue$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable maskFirstTrue$vectorteststype$SmokeTest\n+#end[!Halffloat]\n@@ -534,0 +561,1 @@\n+#if[!Halffloat]\n@@ -651,0 +679,15 @@\n+#else[!Halffloat]\n+    \/\/ TODO: Fix and Enable indexInRange$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable indexInRangeLong$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable loopBound$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable loopBoundLong$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable ElementSize$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable VectorShape$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable ShapeWithLanes$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable ElementType$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable SpeciesElementSize$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable VectorType$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable WithLanes$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable WithShape$vectorteststype$SmokeTest\n+    \/\/ TODO: Fix and Enable MaskAllTrue$vectorteststype$SmokeTest\n+#end[!Halffloat]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+#if[Halffloat]\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+#end[Halffloat]\n@@ -76,1 +80,1 @@\n-                $Type$Vector.SPECIES_MAX;\n+                $ElementType$Vector.SPECIES_MAX;\n@@ -79,1 +83,1 @@\n-                $Type$Vector.SPECIES_$bits$;\n+                $ElementType$Vector.SPECIES_$bits$;\n@@ -737,0 +741,1 @@\n+#if[!Halffloat]\n@@ -811,0 +816,3 @@\n+#else[!Halffloat]\n+    \/\/ TODO: Fix and Enable isWithin1Ulp\n+#end[!Halffloat]\n@@ -1134,1 +1142,1 @@\n-        return {#if[FP]? $Type$.$type$To$Bitstype$Bits(e): e};\n+        return {#if[FP]? $Wideboxtype$.$type$To$Bitstype$Bits(e): e};\n@@ -1426,0 +1434,3 @@\n+#if[Halffloat]\n+                return Short.MIN_VALUE;\n+#else[Halffloat]\n@@ -1427,0 +1438,1 @@\n+#end[Halffloat]\n@@ -1549,0 +1561,38 @@\n+#if[Halffloat]\n+\n+    static boolean eq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() == bt.floatValue();\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() != bt.floatValue();\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() < bt.floatValue();\n+    }\n+\n+    static boolean le(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() <= bt.floatValue();\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() > bt.floatValue();\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        Halffloat at = Halffloat.valueOf(a);\n+        Halffloat bt = Halffloat.valueOf(b);\n+        return at.floatValue() >= bt.floatValue();\n+    }\n+#else[Halffloat]\n@@ -1573,0 +1623,1 @@\n+#end[Halffloat]\n@@ -1593,1 +1644,1 @@\n-        return $Boxtype$.compare(a, ($type$) 0) != 0 ? a : b;\n+        return $VecEleType$.compare(a, ($type$) 0) != 0 ? a : b;\n@@ -1596,0 +1647,1 @@\n+#if[!Halffloat]\n@@ -1715,0 +1767,3 @@\n+#else[!Halffloat]\n+    \/\/ TODO: Fix and Enable smokeTest1, smokeTest2, shuffleTest, viewAsIntegeralLanesTest, viewAsFloatingLanesTest\n+#end[!Halffloat]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":59,"deletions":4,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -46,0 +46,4 @@\n+#if[Halffloat]\n+import jdk.incubator.vector.Halffloat;\n+import jdk.incubator.vector.HalffloatVector;\n+#end[Halffloat]\n@@ -61,1 +65,1 @@\n-                $Type$Vector.SPECIES_MAX;\n+                $ElementType$Vector.SPECIES_MAX;\n@@ -64,1 +68,1 @@\n-                $Type$Vector.SPECIES_$bits$;\n+                $ElementType$Vector.SPECIES_$bits$;\n@@ -477,0 +481,1 @@\n+#if[!Halffloat]\n@@ -590,0 +595,3 @@\n+#else[!Halffloat]\n+    \/\/ TODO: Fix and Enable loadStoreMemorySegment, loadMemorySegmentIOOBE, storeMemorySegmentIOOBE, loadStoreMemorySegmentMask\n+#end[!Halffloat]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"}]}