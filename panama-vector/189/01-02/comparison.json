{"files":[{"patch":"@@ -7957,1 +7957,0 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_32bit);\n@@ -7970,1 +7969,0 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV,\/* input_size_in_bits *\/ EVEX_32bit);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4436,4 +4436,14 @@\n-void C2_MacroAssembler::vbroadcastd(XMMRegister dst, int imm32, Register rtmp, int vec_enc) {\n-  if (VM_Version::supports_avx512vl()) {\n-    movl(rtmp, imm32);\n-    evpbroadcastd(dst, rtmp, vec_enc);\n+void C2_MacroAssembler::vbroadcast(BasicType bt, XMMRegister dst, int imm32, Register rtmp, int vec_enc) {\n+  int lane_size = type2aelembytes(bt);\n+  bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n+  if ((is_LP64 || lane_size < 8) &&\n+      ((is_non_subword_integral_type(bt) && VM_Version::supports_avx512vl()) ||\n+       (is_subword_type(bt) && VM_Version::supports_avx512bw()))) {\n+    movptr(rtmp, imm32);\n+    switch(lane_size) {\n+      case 1 : evpbroadcastb(dst, rtmp, vec_enc); break;\n+      case 2 : evpbroadcastw(dst, rtmp, vec_enc); break;\n+      case 4 : evpbroadcastd(dst, rtmp, vec_enc); break;\n+      case 8 : evpbroadcastq(dst, rtmp, vec_enc); break;\n+      default : ShouldNotReachHere(); break;\n+    }\n@@ -4441,3 +4451,9 @@\n-    movl(rtmp, imm32);\n-    movdl(dst, rtmp);\n-    vpbroadcastd(dst, dst, vec_enc);\n+    movptr(rtmp, imm32);\n+    LP64_ONLY(movq(dst, rtmp)) NOT_LP64(movdl(dst, rtmp));\n+    switch(lane_size) {\n+      case 1 : vpbroadcastb(dst, dst, vec_enc); break;\n+      case 2 : vpbroadcastw(dst, dst, vec_enc); break;\n+      case 4 : vpbroadcastd(dst, dst, vec_enc); break;\n+      case 8 : vpbroadcastq(dst, dst, vec_enc); break;\n+      default : ShouldNotReachHere(); break;\n+    }\n@@ -4480,1 +4496,1 @@\n-  vbroadcastd(xtmp1, 0x0F0F0F0F, rtmp, vec_enc);\n+  vbroadcast(T_INT, xtmp1, 0x0F0F0F0F, rtmp, vec_enc);\n@@ -4506,1 +4522,1 @@\n-  vbroadcastd(xtmp2, 0x00FF00FF, rtmp, vec_enc);\n+  vbroadcast(T_INT, xtmp2, 0x00FF00FF, rtmp, vec_enc);\n@@ -4522,0 +4538,3 @@\n+    case T_LONG:\n+      vector_popcount_long(dst, src, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n@@ -4585,2 +4604,1 @@\n-    movl(rtmp, 0x0F0F0F0F);\n-    evpbroadcastd(xtmp2, rtmp, vec_enc);\n+    vbroadcast(T_INT, xtmp2, 0x0F0F0F0F, rtmp, vec_enc);\n@@ -4605,2 +4623,1 @@\n-    movl(rtmp, 0x0f0f0f0f);\n-    evpbroadcastd(xtmp1, rtmp, vec_enc);\n+    vbroadcast(T_INT, xtmp1, 0x0F0F0F0F, rtmp, vec_enc);\n@@ -4616,2 +4633,1 @@\n-    movl(rtmp, 0x33333333);\n-    evpbroadcastd(xtmp2, rtmp, vec_enc);\n+    vbroadcast(T_INT, xtmp2, 0x33333333, rtmp, vec_enc);\n@@ -4625,2 +4641,1 @@\n-    movl(rtmp, 0x55555555);\n-    evpbroadcastd(xtmp2, rtmp, vec_enc);\n+    vbroadcast(T_INT, xtmp2, 0x55555555, rtmp, vec_enc);\n@@ -4637,3 +4652,1 @@\n-    movl(rtmp, 0x0F0F0F0F);\n-    movdl(xtmp2, rtmp);\n-    vpbroadcastd(xtmp2, xtmp2, vec_enc);\n+    vbroadcast(T_INT, xtmp2, 0x0F0F0F0F, rtmp, vec_enc);\n@@ -4682,2 +4695,1 @@\n-      movl(rtmp, 0x00FF00FF);\n-      evpbroadcastd(dst, rtmp, vec_enc);\n+      vbroadcast(T_INT, dst, 0x00FF00FF, rtmp, vec_enc);\n@@ -4757,3 +4769,3 @@\n-      evpbroadcastd(xtmp2, rtmp, vec_enc);\n-      vpand(dst, xtmp2, src, vec_enc);\n-      vpshufb(dst, xtmp1, dst, vec_enc);\n+      evpbroadcastd(dst, rtmp, vec_enc);\n+      vpand(xtmp2, dst, src, vec_enc);\n+      vpshufb(xtmp2, xtmp1, xtmp2, vec_enc);\n@@ -4761,2 +4773,2 @@\n-      vpand(xtmp3, xtmp2, xtmp3, vec_enc);\n-      vpshufb(xtmp2, xtmp1, xtmp3, vec_enc);\n+      vpand(xtmp3, dst, xtmp3, vec_enc);\n+      vpshufb(dst, xtmp1, xtmp3, vec_enc);\n@@ -4765,2 +4777,1 @@\n-      vpaddb(dst, dst, xtmp2, vec_enc);\n-      evpblendmb(dst, ktmp, xtmp2, dst, true, vec_enc);\n+      evpaddb(dst, ktmp, dst, xtmp2, true, vec_enc);\n@@ -4772,0 +4783,1 @@\n+\n@@ -4897,0 +4909,75 @@\n+\n+void C2_MacroAssembler::vpsub(BasicType bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vec_enc) {\n+  switch(bt) {\n+    case T_BYTE:\n+      vpsubb(dst, src1, src2, vec_enc);\n+      break;\n+    case T_SHORT:\n+      vpsubw(dst, src1, src2, vec_enc);\n+      break;\n+    case T_INT:\n+      vpsubd(dst, src1, src2, vec_enc);\n+      break;\n+    case T_LONG:\n+      vpsubq(dst, src1, src2, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::vpadd(BasicType bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vec_enc) {\n+  switch(bt) {\n+    case T_BYTE:\n+      vpaddb(dst, src1, src2, vec_enc);\n+      break;\n+    case T_SHORT:\n+      vpaddw(dst, src1, src2, vec_enc);\n+      break;\n+    case T_INT:\n+      vpaddd(dst, src1, src2, vec_enc);\n+      break;\n+    case T_LONG:\n+      vpaddq(dst, src1, src2, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+\/\/ Trailing zero count computation is based on leading zero count operation as per\n+\/\/ following equation. All AVX3 targets support AVX512CD feature which offers\n+\/\/ direct vector instruction to compute leading zero count.\n+\/\/      CTZ = PRIM_TYPE_WIDHT - CLZ((x - 1) & ~x)\n+void C2_MacroAssembler::vector_count_trailing_zeros_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                         XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3,\n+                                                         XMMRegister xtmp4, KRegister ktmp, Register rtmp, int vec_enc) {\n+  assert(is_integral_type(bt), \"\");\n+  int bcast_value [] = { 0x8, 0x10, 0, 0x20, 0, 0, 0, 0x40 };\n+  \/\/ xtmp = -1\n+  vpternlogd(xtmp4, 0xff, xtmp4, xtmp4, vec_enc);\n+  \/\/ xtmp = xtmp + src\n+  vpadd(bt, xtmp4, xtmp4, src, vec_enc);\n+  \/\/ xtmp = xtmp & ~src\n+  vpternlogd(xtmp4, 0x40, xtmp4, src, vec_enc);\n+  vector_count_leading_zeros_evex(bt, dst, xtmp4, xtmp1, xtmp2, xtmp3, ktmp, rtmp, true, vec_enc);\n+  vbroadcast(bt, xtmp4, bcast_value[type2aelembytes(bt) - 1], rtmp, vec_enc);\n+  vpsub(bt, dst, xtmp4, dst, vec_enc);\n+}\n+\n+\/\/ Trailing zero count computation for AVX2 targets is based on popcount operation as per following equation\n+\/\/      CTZ = PRIM_TYPE_WIDHT - POPC(x | -x)\n+void C2_MacroAssembler::vector_count_trailing_zeros_avx(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                        XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc) {\n+  assert(is_integral_type(bt), \"\");\n+  int bcast_value [] = { 0x8, 0x10, 0, 0x20, 0, 0, 0, 0x40 };\n+  \/\/ xtmp = 0\n+  vpxor(xtmp3 , xtmp3, xtmp3, vec_enc);\n+  \/\/ xtmp = 0 - src\n+  vpsub(bt, xtmp3, xtmp3, src, vec_enc);\n+  \/\/ xtmp = xtmp | src\n+  vpor(xtmp3, xtmp3, src, vec_enc);\n+  vector_popcount_integral(bt, dst, xtmp3, xtmp1, xtmp2, rtmp, vec_enc);\n+  vbroadcast(bt, xtmp1, bcast_value[type2aelembytes(bt) - 1], rtmp, vec_enc);\n+  vpsub(bt, dst, xtmp1, dst, vec_enc);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":116,"deletions":29,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-  void vbroadcastd(XMMRegister dst, int imm32, Register rtmp, int vec_enc);\n+  void vbroadcast(BasicType bt, XMMRegister dst, int imm32, Register rtmp, int vec_enc);\n@@ -375,0 +375,11 @@\n+  void vpadd(BasicType bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vec_enc);\n+\n+  void vpsub(BasicType bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vec_enc);\n+\n+  void vector_count_trailing_zeros_evex(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                        XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, KRegister ktmp,\n+                                        Register rtmp, int vec_enc);\n+\n+  void vector_count_trailing_zeros_avx(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                       XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+      case Op_CountTrailingZerosV:\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1244,0 +1244,5 @@\n+static inline bool is_vector_popcount_predicate(BasicType bt) {\n+  return (is_subword_type(bt) && VM_Version::supports_avx512_bitalg()) ||\n+         (is_non_subword_integral_type(bt) && VM_Version::supports_avx512_vpopcntdq());\n+}\n+\n@@ -1248,1 +1253,1 @@\n-static inline bool is_clz_evex_predicate(BasicType bt, int vlen_bytes) {\n+static inline bool is_clz_non_subword_predicate_evex(BasicType bt, int vlen_bytes) {\n@@ -1261,1 +1266,0 @@\n-\n@@ -1921,0 +1925,1 @@\n+    case Op_CountTrailingZerosV:\n@@ -8646,0 +8651,1 @@\n+\n@@ -8647,4 +8653,1 @@\n-  predicate((is_subword_type(Matcher::vector_element_basic_type(n->in(1))) &&\n-              VM_Version::supports_avx512_bitalg()) ||\n-             (is_non_subword_integral_type(Matcher::vector_element_basic_type(n->in(1))) &&\n-              VM_Version::supports_avx512_vpopcntdq()));\n+  predicate(is_vector_popcount_predicate(Matcher::vector_element_basic_type(n->in(1))));\n@@ -8654,1 +8657,1 @@\n-  format %{ \"vector_popcount_integral_evex $dst, $src\" %}\n+  format %{ \"vector_popcount_integral $dst, $src\" %}\n@@ -8671,4 +8674,1 @@\n-  predicate((is_subword_type(Matcher::vector_element_basic_type(n->in(1))) &&\n-              VM_Version::supports_avx512_bitalg()) ||\n-             (is_non_subword_integral_type(Matcher::vector_element_basic_type(n->in(1))) &&\n-              VM_Version::supports_avx512_vpopcntdq()));\n+  predicate(is_vector_popcount_predicate(Matcher::vector_element_basic_type(n->in(1))));\n@@ -8677,1 +8677,1 @@\n-  format %{ \"vector_popcount_integral_evex_masked $dst, $src, $mask\" %}\n+  format %{ \"vector_popcount_integral_masked $dst, $src, $mask\" %}\n@@ -8679,1 +8679,0 @@\n-    int opcode = this->ideal_Opcode();\n@@ -8688,3 +8687,2 @@\n-instruct vpopcountI_avx_reg(vec dst, vec src, vec xtmp1, vec xtmp2, rRegP rtmp) %{\n-  predicate((!VM_Version::supports_avx512_vpopcntdq() && Matcher::vector_element_basic_type(n->in(1)) == T_INT) ||\n-            (!VM_Version::supports_avx512_bitalg() && is_subword_type(Matcher::vector_element_basic_type(n->in(1)))));\n+instruct vpopcount_evx_reg(vec dst, vec src, vec xtmp1, vec xtmp2, rRegP rtmp) %{\n+  predicate(!is_vector_popcount_predicate(Matcher::vector_element_basic_type(n->in(1))));\n@@ -8692,0 +8690,1 @@\n+  match(Set dst (PopCountVL src));\n@@ -8693,1 +8692,1 @@\n-  format %{ \"vector_popcount_int  $dst, $src\\t! using $xtmp1, $xtmp2 and $rtmp as TEMP\" %}\n+  format %{ \"vector_popcount_integral $dst, $src\\t! using $xtmp1, $xtmp2, and $rtmp as TEMP\" %}\n@@ -8695,0 +8694,2 @@\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $src);\n@@ -8696,1 +8697,0 @@\n-    int vlen_enc = vector_length_encoding(this);\n@@ -8699,0 +8699,12 @@\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n+      if (VM_Version::supports_avx512vl()) {\n+        __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+      } else {\n+        assert(VM_Version::supports_avx2(), \"\");\n+        __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n+        __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n+      }\n+    }\n@@ -8703,3 +8715,30 @@\n-instruct vpopcountL_avx_reg(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp) %{\n-  predicate(!VM_Version::supports_avx512_vpopcntdq());\n-  match(Set dst (PopCountVL src));\n+\/\/ --------------------------------- Vector Trailing Zeros Count --------------------------------------\n+\n+instruct vcount_trailing_zeros_reg_evex(vec dst, vec src, vec xtmp, rRegP rtmp) %{\n+  predicate(is_clz_non_subword_predicate_evex(Matcher::vector_element_basic_type(n->in(1)),\n+                                              Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (CountTrailingZerosV src));\n+  effect(TEMP dst, TEMP xtmp, TEMP rtmp);\n+  ins_cost(400);\n+  format %{ \"vector_count_trailing_zeros $dst, $src!\\t using $xtmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType rbt = Matcher::vector_element_basic_type(this);\n+    __ vector_count_trailing_zeros_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, xnoreg,\n+                                        xnoreg, xnoreg, $xtmp$$XMMRegister, k0, $rtmp$$Register, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountTrailingZerosV\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (bt == T_LONG && rbt == T_INT) {\n+      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcount_trailing_zeros_short_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(1)) == T_SHORT &&\n+            VM_Version::supports_avx512cd() &&\n+            (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64));\n+  match(Set dst (CountTrailingZerosV src));\n@@ -8707,1 +8746,2 @@\n-  format %{ \"vector_popcount_long  $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+  ins_cost(400);\n+  format %{ \"vector_count_trailing_zeros $dst, $src!\\t using $xtmp1, $xtmp2, $xtmp3 and $rtmp as TEMP\" %}\n@@ -8710,3 +8750,34 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    __ vector_popcount_long($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n-                            $xtmp2$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_count_trailing_zeros_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                        $xtmp2$$XMMRegister, xnoreg, $xtmp3$$XMMRegister, k0, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcount_trailing_zeros_byte_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, kReg ktmp, rRegP rtmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(1)) == T_BYTE && VM_Version::supports_avx512vlbw());\n+  match(Set dst (CountTrailingZerosV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, TEMP ktmp, TEMP rtmp);\n+  ins_cost(400);\n+  format %{ \"vector_count_trailing_zeros $dst, $src!\\t using $xtmp1, $xtmp2, $xtmp3, $xtmp4, $ktmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_count_trailing_zeros_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                        $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister,\n+                                        $ktmp$$KRegister, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcount_trailing_zeros_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64);\n+  match(Set dst (CountTrailingZerosV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp);\n+  format %{ \"vector_count_trailing_zeros $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType rbt = Matcher::vector_element_basic_type(this);\n+    __ vector_count_trailing_zeros_avx(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n@@ -8716,1 +8787,1 @@\n-    if (bt == T_INT) {\n+    if (bt == T_LONG && rbt == T_INT) {\n@@ -8729,0 +8800,1 @@\n+\n@@ -9094,1 +9166,2 @@\n-  predicate(is_clz_evex_predicate(Matcher::vector_element_basic_type(n->in(1)), Matcher::vector_length_in_bytes(n)));\n+  predicate(is_clz_non_subword_predicate_evex(Matcher::vector_element_basic_type(n->in(1)),\n+                                              Matcher::vector_length_in_bytes(n->in(1))));\n@@ -9114,1 +9187,2 @@\n-  predicate(is_clz_evex_predicate(Matcher::vector_element_basic_type(n->in(1)), Matcher::vector_length_in_bytes(n)));\n+  predicate(is_clz_non_subword_predicate_evex(Matcher::vector_element_basic_type(n->in(1)),\n+                                              Matcher::vector_length_in_bytes(n->in(1))));\n@@ -9129,2 +9203,2 @@\n-             VM_Version::supports_avx512cd() &&\n-             (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64));\n+            VM_Version::supports_avx512cd() &&\n+            (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64));\n@@ -9144,2 +9218,1 @@\n-  predicate(Matcher::vector_element_basic_type(n->in(1)) == T_BYTE &&\n-             (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64));\n+  predicate(Matcher::vector_element_basic_type(n->in(1)) == T_BYTE && VM_Version::supports_avx512vlbw());\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":105,"deletions":32,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -973,0 +973,3 @@\n+      case Op_CountTrailingZerosV:\n+      case Op_CountLeadingZerosV:\n+      case Op_ReverseV:\n@@ -978,5 +981,0 @@\n-      case Op_CountLeadingZerosV:\n-      case Op_ReverseV: {\n-        const TypeVect* vt = n->bottom_type()->is_vect();\n-        body_size += Matcher::vector_op_pre_select_sz_estimate(n->Opcode(), vt->element_basic_type(), vt->length());\n-      } break;\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2567,1 +2567,2 @@\n-                 opc == Op_CountLeadingZerosI || opc == Op_CountLeadingZerosL) {\n+                 opc == Op_CountLeadingZerosI || opc == Op_CountLeadingZerosL ||\n+                 opc == Op_CountTrailingZerosI || opc == Op_CountTrailingZerosL) {\n@@ -2960,1 +2961,1 @@\n-    \/\/ PopCountL\/CountLeadingZerosL takes long and produces\n+    \/\/ PopCountL\/CountLeadingZerosL\/CountTrailingZerosL takes long and produces\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -317,0 +317,1 @@\n+    case Op_CountTrailingZerosL:\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}