{"files":[{"patch":"@@ -2446,0 +2446,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n@@ -2494,0 +2508,4 @@\n+    if (bt == T_BOOLEAN) {\n+      \/\/ To support vector api load\/store mask.\n+      return MaxVectorSize \/ 8;\n+    }\n@@ -2521,1 +2539,1 @@\n-  if (UseSVE > 0 && 16 <= len && len <= 256) {\n+  if (UseSVE > 0 && 2 <= len && len <= 256) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3210,1 +3210,1 @@\n-  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, int imm8) {\n+  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, int imm16) {\n@@ -3214,1 +3214,2 @@\n-    if (imm8 <= 127 && imm8 >= -128) {\n+    unsigned imm = imm16;\n+    if (imm16 <= 127 && imm16 >= -128) {\n@@ -3216,1 +3217,1 @@\n-    } else if (T != B && imm8 <= 32512 && imm8 >= -32768 && (imm8 & 0xff) == 0) {\n+    } else if (T != B && imm16 <= 32512 && imm16 >= -32768 && (imm16 & 0xff) == 0) {\n@@ -3218,1 +3219,1 @@\n-      imm8 = (imm8 >> 8);\n+      imm = (imm >> 8);\n@@ -3222,0 +3223,2 @@\n+    unsigned mask = (1U << 8) - 1;\n+    imm &= mask;\n@@ -3223,1 +3226,1 @@\n-    f(sh, 13), sf(imm8, 12, 5), rf(Zd, 0);\n+    f(sh, 13), f(imm, 12, 5), rf(Zd, 0);\n@@ -3232,0 +3235,220 @@\n+   \/\/ SVE cpy immediate\n+  void sve_cpy(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg, int imm16, bool isMerge) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    int sh = 0;\n+    unsigned imm = imm16;\n+    if (imm16 <= 127 && imm16 >= -128) {\n+      sh = 0;\n+    } else if (T != B && imm16 <= 32512 && imm16 >= -32768 && (imm16 & 0xff) == 0) {\n+      sh = 1;\n+      imm = (imm >> 8);\n+    } else {\n+      guarantee(false, \"invalid immediate\");\n+    }\n+    unsigned mask = (1U << 8) - 1;\n+    imm &= mask;\n+    int m = isMerge ? 1 : 0;\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b01, 21, 20);\n+    prf(Pg, 16), f(0b0, 15), f(m, 14), f(sh, 13), f(imm, 12, 5), rf(Zd, 0);\n+  }\n+\n+  \/\/ SVE vector sel\n+  void sve_sel(FloatRegister Zd,\n+               SIMD_RegVariant T,\n+               PRegister Pg,\n+               FloatRegister Zn,\n+               FloatRegister Zm) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);\n+    f(0b11, 15, 14), prf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n+\/\/ SVE compare vector\n+#define INSN(NAME, op, cond, fp)  \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, FloatRegister Zm)  { \\\n+    starti;                                                                                       \\\n+    if (fp == 0) {                                                                                \\\n+      assert(T != Q, \"invalid size\");                                                             \\\n+    } else {                                                                                      \\\n+      assert(T != B && T != Q, \"invalid size\");                                                   \\\n+    }                                                                                             \\\n+    f(op, 31, 24), f(T, 23, 22), f(0b0, 21), rf(Zm, 16), f((cond >> 1) & 0x7, 15, 13);            \\\n+    pgrf(Pg, 10), rf(Zn, 5), f(cond & 0x1, 4), prf(Pd, 0);                                        \\\n+  }\n+\n+  INSN(sve_cmpeq, 0b00100100, 0b1010, 0);\n+  INSN(sve_cmpne, 0b00100100, 0b1011, 0);\n+  INSN(sve_cmpge, 0b00100100, 0b1000, 0);\n+  INSN(sve_cmpgt, 0b00100100, 0b1001, 0);\n+  INSN(sve_fcmeq, 0b01100101, 0b0110, 1);\n+  INSN(sve_fcmne, 0b01100101, 0b0111, 1);\n+  INSN(sve_fcmgt, 0b01100101, 0b0101, 1);\n+  INSN(sve_fcmge, 0b01100101, 0b0100, 1);\n+#undef INSN\n+\n+\/\/ SVE compare vector with immediate\n+#define INSN(NAME, cond)  \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, int imm5) { \\\n+    starti;                                                                              \\\n+    assert(T != Q, \"invalid size\");                                                      \\\n+    if (imm5 > 15 || imm5 < -16) {                                                       \\\n+      guarantee(false, \"invalid immediate\");                                             \\\n+    }                                                                                    \\\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b0, 21), sf(imm5, 20, 16),                   \\\n+    f((cond >> 1) & 0x7, 15, 13), pgrf(Pg, 10), rf(Zn, 5), f(cond & 0x1, 4), prf(Pd, 0); \\\n+  }\n+\n+  INSN(sve_cmpeq, 0b1000);\n+  INSN(sve_cmpne, 0b1001);\n+  INSN(sve_cmpgt, 0b0001);\n+  INSN(sve_cmpge, 0b0000);\n+  INSN(sve_cmplt, 0b0010);\n+  INSN(sve_cmple, 0b0011);\n+#undef INSN\n+\n+\/\/ SVE unpack and extend\n+#define INSN(NAME, op) \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn) { \\\n+    starti;                                                          \\\n+    assert(T != B && T != Q, \"invalid size\");                        \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1100, 21, 18);          \\\n+    f(op, 17, 16), f(0b001110, 15, 10), rf(Zn, 5), rf(Zd, 0);        \\\n+  }\n+\n+  INSN(sve_uunpkhi, 0b11);\n+  INSN(sve_uunpklo, 0b10);\n+  INSN(sve_sunpkhi, 0b01);\n+  INSN(sve_sunpklo, 0b00);\n+#undef INSN\n+\n+\/\/ SVE vector uzp1,uzp2\n+#define INSN(NAME, op) \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) { \\\n+    starti;                                                                            \\\n+    assert(T != Q, \"invalid size\");                                                    \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);                       \\\n+    f(0b01101, 15, 11), f(op, 10), rf(Zn, 5), rf(Zd, 0);                               \\\n+  }\n+\n+  INSN(sve_uzp1, 0b0);\n+  INSN(sve_uzp2, 0b1);\n+#undef INSN\n+\n+\/\/ SVE while[cond]\n+#define INSN(NAME, decode, sf)                                            \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, Register Rn, Register Rm) {  \\\n+    starti;                                                               \\\n+    assert(T != Q, \"invalid register variant\");                           \\\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(1, 21),                        \\\n+    zrf(Rm, 16), f(0, 15, 13), f(sf, 12), f(decode >> 1, 11, 10),         \\\n+    zrf(Rn, 5), f(decode & 0b1, 4), prf(Pd, 0);                           \\\n+  }\n+\n+  INSN(sve_whilelt,  0b010, 1);\n+  INSN(sve_whileltw, 0b010, 0);\n+  INSN(sve_whilele,  0b011, 1);\n+  INSN(sve_whilelew, 0b011, 0);\n+  INSN(sve_whilelo,  0b110, 1);\n+  INSN(sve_whilelow, 0b110, 0);\n+  INSN(sve_whilels,  0b111, 1);\n+  INSN(sve_whilelsw, 0b111, 0);\n+#undef INSN\n+\n+private:\n+\n+  void encode_cvtf_T(SIMD_RegVariant T_dst, SIMD_RegVariant T_src,\n+                     unsigned& opc, unsigned& opc2) {\n+    assert(T_src != B && T_dst != B &&\n+           T_src != Q && T_dst != Q, \"invalid register variant\");\n+    if (T_dst != D) {\n+      assert(T_dst <= T_src, \"invalid register variant\");\n+    } else {\n+      assert(T_src != H, \"invalid register variant\");\n+    }\n+    \/\/ In most cases we can treat T_dst,T_src as opc,opc2\n+    \/\/ except following four cases. These cases should be converted\n+    \/\/ according to Arm's architecture reference manual:\n+    \/\/ +-----+------+---+------------------------------------+\n+    \/\/ | opc | opc2 | U |        Instruction Details         |\n+    \/\/ +-----+------+---+------------------------------------+\n+    \/\/ |  11 |   00 | 0 | SCVTF — 32-bit to double-precision |\n+    \/\/ |  11 |   00 | 1 | UCVTF — 32-bit to double-precision |\n+    \/\/ |  11 |   10 | 0 | SCVTF — 64-bit to single-precision |\n+    \/\/ |  11 |   10 | 1 | UCVTF — 64-bit to single-precision |\n+    \/\/ +-----+------+---+------------------------------------+\n+    if (T_dst == S && T_src == D) { \/\/ 64-bit to single-precision\n+      T_dst = D;\n+      T_src = S;\n+    } else if (T_dst == D && T_src == S) { \/\/ 32-bit to double-precision\n+      T_dst = D;\n+      T_src = B;\n+    }\n+    opc = T_dst;\n+    opc2 = T_src;\n+  }\n+public:\n+\n+\/\/ SVE convert integer to floating-point (predicated)\n+#define INSN(NAME, sign)                                                \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,      \\\n+            FloatRegister Zn, SIMD_RegVariant T_src) {                  \\\n+    starti;                                                             \\\n+    unsigned opc, opc2;                                                 \\\n+    encode_cvtf_T(T_dst, T_src, opc, opc2);                             \\\n+    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b010, 21, 19);            \\\n+    f(opc2, 18, 17), f(sign, 16), f(0b101, 15, 13);                     \\\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);                                 \\\n+  }\n+\n+  INSN(sve_scvtf, 0b0);\n+  INSN(sve_ucvtf, 0b1);\n+#undef INSN\n+\n+private:\n+\n+  void encode_fcvt_T(SIMD_RegVariant T_src,SIMD_RegVariant T_dst,\n+                     unsigned& opc, unsigned& opc2) {\n+    assert(T_src != B && T_dst != B &&\n+           T_src != Q && T_dst != Q, \"invalid register variant\");\n+    assert(T_src != T_dst, \"invalid register variant\");\n+    if (T_src == S) {\n+      if (T_dst == H) {\n+        opc = 0b10;\n+        opc2 = 0b00;\n+      } else if (T_dst == D) {\n+        opc = 0b11;\n+        opc2 = 0b11;\n+      }\n+    } else if (T_src == H) {\n+      if (T_dst == S) {\n+        opc = 0b10;\n+        opc2 = 0b01;\n+      } else if (T_dst == D) {\n+        opc = 0b11;\n+        opc2 = 0b01;\n+      }\n+    } else if (T_src == D) {\n+      if (T_dst == H) {\n+        opc = 0b11;\n+        opc2 = 0b00;\n+      } else if (T_dst == S) {\n+        opc = 0b11;\n+        opc2 = 0b10;\n+      }\n+    }\n+  }\n+public:\n+\n+\/\/ SVE floating-point convert precision (predicated)\n+  void sve_fcvt(FloatRegister Zd, SIMD_RegVariant T_dst, PRegister Pg,\n+            FloatRegister Zn, SIMD_RegVariant T_src) {\n+    starti;\n+    unsigned opc, opc2;\n+    encode_fcvt_T(T_src, T_dst, opc, opc2);\n+    f(0b01100101, 31, 24), f(opc, 23, 22), f(0b0010, 21, 18);\n+    f(opc2, 17, 16), f(0b101, 15, 13);\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":228,"deletions":5,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -864,0 +864,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -367,0 +367,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2167,0 +2167,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -930,0 +930,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -864,0 +864,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1035,0 +1035,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1139,0 +1139,25 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(num_bits == 64 || num_bits == 128 || num_bits == 256 || num_bits == 512,\n+         \"only certain vector sizes are supported for now\");\n+\n+  static const XMMRegister VEC_ArgReg[32] = {\n+     xmm0,  xmm1,  xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,\n+     xmm8,  xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,\n+    xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,\n+    xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31\n+  };\n+\n+  uint stk_args = 0;\n+  uint fp_args = 0;\n+\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[fp_args++]->as_VMReg();\n+    int next_val = num_bits == 64 ? 1 : (num_bits == 128 ? 3 : (num_bits  == 256 ? 7 : 15));\n+    regs[i].set_pair(vmreg->next(next_val), vmreg);\n+  }\n+\n+  return stk_args;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -57,0 +57,277 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+\/\/ Vector API SVML routines written in assembly\n+extern \"C\"\n+{\n+   float __svml_expf4_ha_ex(float a);\n+   double __svml_exp1_ha_ex(double a);\n+   double __svml_exp2_ha_ex(double a);\n+   float __svml_expf4_ha_l9(float a);\n+   float __svml_expf8_ha_l9(float a);\n+   float __svml_expf4_ha_e9(float a);\n+   float __svml_expf8_ha_e9(float a);\n+   float __svml_expf16_ha_z0(float a);\n+   double __svml_exp1_ha_l9(double a);\n+   double __svml_exp2_ha_l9(double a);\n+   double __svml_exp4_ha_l9(double a);\n+   double __svml_exp1_ha_e9(double a);\n+   double __svml_exp2_ha_e9(double a);\n+   double __svml_exp4_ha_e9(double a);\n+   double __svml_exp8_ha_z0(double a);\n+   float  __svml_expm1f4_ha_ex(float a);\n+   double __svml_expm11_ha_ex(double a);\n+   double __svml_expm12_ha_ex(double a);\n+   float  __svml_expm1f4_ha_l9(float a);\n+   float  __svml_expm1f8_ha_l9(float a);\n+   float  __svml_expm1f4_ha_e9(float a);\n+   float  __svml_expm1f8_ha_e9(float a);\n+   float __svml_expm1f16_ha_z0(float a);\n+   double __svml_expm11_ha_l9(double a);\n+   double __svml_expm12_ha_l9(double a);\n+   double __svml_expm14_ha_l9(double a);\n+   double __svml_expm11_ha_e9(double a);\n+   double __svml_expm12_ha_e9(double a);\n+   double __svml_expm14_ha_e9(double a);\n+   double __svml_expm18_ha_z0(double a);\n+   float __svml_log1pf4_ha_l9(float a);\n+   float __svml_log1pf8_ha_l9(float a);\n+   float __svml_log1pf4_ha_e9(float a);\n+   float __svml_log1pf8_ha_e9(float a);\n+   float __svml_log1pf16_ha_z0(float a);\n+   double __svml_log1p1_ha_l9(double a);\n+   double __svml_log1p2_ha_l9(double a);\n+   double __svml_log1p4_ha_l9(double a);\n+   double __svml_log1p1_ha_e9(double a);\n+   double __svml_log1p2_ha_e9(double a);\n+   double __svml_log1p4_ha_e9(double a);\n+   double __svml_log1p8_ha_z0(double a);\n+   float __svml_logf4_ha_l9(float a);\n+   float __svml_logf8_ha_l9(float a);\n+   float __svml_logf4_ha_e9(float a);\n+   float __svml_logf8_ha_e9(float a);\n+   float __svml_logf16_ha_z0(float a);\n+   double __svml_log1_ha_l9(double a);\n+   double __svml_log2_ha_l9(double a);\n+   double __svml_log4_ha_l9(double a);\n+   double __svml_log1_ha_e9(double a);\n+   double __svml_log2_ha_e9(double a);\n+   double __svml_log4_ha_e9(double a);\n+   double __svml_log8_ha_z0(double a);\n+   float __svml_log10f4_ha_l9(float a);\n+   float __svml_log10f8_ha_l9(float a);\n+   float __svml_log10f4_ha_e9(float a);\n+   float __svml_log10f8_ha_e9(float a);\n+   float __svml_log10f16_ha_z0(float a);\n+   double __svml_log101_ha_l9(double a);\n+   double __svml_log102_ha_l9(double a);\n+   double __svml_log104_ha_l9(double a);\n+   double __svml_log101_ha_e9(double a);\n+   double __svml_log102_ha_e9(double a);\n+   double __svml_log104_ha_e9(double a);\n+   double __svml_log108_ha_z0(double a);\n+   float __svml_sinf4_ha_l9(float a);\n+   float __svml_sinf8_ha_l9(float a);\n+   float __svml_sinf4_ha_e9(float a);\n+   float __svml_sinf8_ha_e9(float a);\n+   float __svml_sinf16_ha_z0(float a);\n+   double __svml_sin1_ha_l9(double a);\n+   double __svml_sin2_ha_l9(double a);\n+   double __svml_sin4_ha_l9(double a);\n+   double __svml_sin1_ha_e9(double a);\n+   double __svml_sin2_ha_e9(double a);\n+   double __svml_sin4_ha_e9(double a);\n+   double __svml_sin8_ha_z0(double a);\n+   float __svml_cosf4_ha_l9(float a);\n+   float __svml_cosf8_ha_l9(float a);\n+   float __svml_cosf4_ha_e9(float a);\n+   float __svml_cosf8_ha_e9(float a);\n+   float __svml_cosf16_ha_z0(float a);\n+   double  __svml_cos1_ha_l9(double a);\n+   double  __svml_cos2_ha_l9(double a);\n+   double __svml_cos4_ha_l9(double a);\n+   double  __svml_cos1_ha_e9(double a);\n+   double  __svml_cos2_ha_e9(double a);\n+   double __svml_cos4_ha_e9(double a);\n+   double  __svml_cos8_ha_z0(double a);\n+   float __svml_tanf4_ha_l9(float a);\n+   float __svml_tanf8_ha_l9(float a);\n+   float __svml_tanf4_ha_e9(float a);\n+   float __svml_tanf8_ha_e9(float a);\n+   float __svml_tanf16_ha_z0(float a);\n+   double __svml_tan1_ha_l9(double a);\n+   double __svml_tan2_ha_l9(double a);\n+   double __svml_tan4_ha_l9(double a);\n+   double __svml_tan1_ha_e9(double a);\n+   double __svml_tan2_ha_e9(double a);\n+   double __svml_tan4_ha_e9(double a);\n+   double __svml_tan8_ha_z0(double a);\n+   double __svml_sinh1_ha_l9(double a);\n+   double __svml_sinh2_ha_l9(double a);\n+   double __svml_sinh4_ha_l9(double a);\n+   double __svml_sinh1_ha_e9(double a);\n+   double __svml_sinh2_ha_e9(double a);\n+   double __svml_sinh4_ha_e9(double a);\n+   double __svml_sinh8_ha_z0(double a);\n+   float __svml_sinhf4_ha_l9(float a);\n+   float __svml_sinhf8_ha_l9(float a);\n+   float __svml_sinhf4_ha_e9(float a);\n+   float __svml_sinhf8_ha_e9(float a);\n+   float __svml_sinhf16_ha_z0(float a);\n+   double __svml_cosh1_ha_l9(double a);\n+   double __svml_cosh2_ha_l9(double a);\n+   double __svml_cosh4_ha_l9(double a);\n+   double __svml_cosh1_ha_e9(double a);\n+   double __svml_cosh2_ha_e9(double a);\n+   double __svml_cosh4_ha_e9(double a);\n+   double __svml_cosh8_ha_z0(double a);\n+   float __svml_coshf4_ha_l9(float a);\n+   float __svml_coshf8_ha_l9(float a);\n+   float __svml_coshf4_ha_e9(float a);\n+   float __svml_coshf8_ha_e9(float a);\n+   float __svml_coshf16_ha_z0(float a);\n+   double __svml_tanh1_ha_l9(double a);\n+   double __svml_tanh2_ha_l9(double a);\n+   double __svml_tanh4_ha_l9(double a);\n+   double __svml_tanh1_ha_e9(double a);\n+   double __svml_tanh2_ha_e9(double a);\n+   double __svml_tanh4_ha_e9(double a);\n+   double __svml_tanh8_ha_z0(double a);\n+   float __svml_tanhf4_ha_l9(float a);\n+   float __svml_tanhf8_ha_l9(float a);\n+   float __svml_tanhf4_ha_e9(float a);\n+   float __svml_tanhf8_ha_e9(float a);\n+   float __svml_tanhf16_ha_z0(float a);\n+   float __svml_acosf4_ha_ex(float a);\n+   float __svml_acosf4_ha_l9(float a);\n+   float __svml_acosf8_ha_l9(float a);\n+   float __svml_acosf4_ha_e9(float a);\n+   float __svml_acosf8_ha_e9(float a);\n+   float __svml_acosf16_ha_z0(float a);\n+   double __svml_acos1_ha_ex(double a);\n+   double __svml_acos2_ha_ex(double a);\n+   double __svml_acos1_ha_l9(double a);\n+   double __svml_acos2_ha_l9(double a);\n+   double __svml_acos4_ha_l9(double a);\n+   double __svml_acos1_ha_e9(double a);\n+   double __svml_acos2_ha_e9(double a);\n+   double __svml_acos4_ha_e9(double a);\n+   double __svml_acos8_ha_z0(double a);\n+   float __svml_asinf4_ha_ex(float a);\n+   double __svml_asin1_ha_ex(double a);\n+   double __svml_asin2_ha_ex(double a);\n+   double __svml_asin1_ha_l9(double a);\n+   double __svml_asin2_ha_l9(double a);\n+   double __svml_asin4_ha_l9(double a);\n+   double __svml_asin1_ha_e9(double a);\n+   double __svml_asin2_ha_e9(double a);\n+   double __svml_asin4_ha_e9(double a);\n+   double __svml_asin8_ha_z0(double a);\n+   float __svml_asinf4_ha_l9(float a);\n+   float __svml_asinf8_ha_l9(float a);\n+   float __svml_asinf4_ha_e9(float a);\n+   float __svml_asinf8_ha_e9(float a);\n+   float __svml_asinf16_ha_z0(float a);\n+   float __svml_atanf4_ha_ex(float a);\n+   double __svml_atan1_ha_ex(double a);\n+   double __svml_atan2_ha_ex(double a);\n+   double __svml_atan1_ha_l9(double a);\n+   double __svml_atan2_ha_l9(double a);\n+   double __svml_atan4_ha_l9(double a);\n+   double __svml_atan1_ha_e9(double a);\n+   double __svml_atan2_ha_e9(double a);\n+   double __svml_atan4_ha_e9(double a);\n+   double __svml_atan8_ha_z0(double a);\n+   float __svml_atanf4_ha_l9(float a);\n+   float __svml_atanf8_ha_l9(float a);\n+   float __svml_atanf4_ha_e9(float a);\n+   float __svml_atanf8_ha_e9(float a);\n+   float __svml_atanf16_ha_z0(float a);\n+   float __svml_powf4_ha_l9(float a, float b);\n+   float __svml_powf8_ha_l9(float a, float b);\n+   float __svml_powf4_ha_e9(float a, float b);\n+   float __svml_powf8_ha_e9(float a, float b);\n+   float __svml_powf16_ha_z0(float a, float b);\n+   double __svml_pow1_ha_l9(double a, double b);\n+   double __svml_pow2_ha_l9(double a, double b);\n+   double __svml_pow4_ha_l9(double a, double b);\n+   double __svml_pow1_ha_e9(double a, double b);\n+   double __svml_pow2_ha_e9(double a, double b);\n+   double __svml_pow4_ha_e9(double a, double b);\n+   double __svml_pow8_ha_z0(double a, double b);\n+   float __svml_hypotf4_ha_l9(float a, float b);\n+   float __svml_hypotf8_ha_l9(float a, float b);\n+   float __svml_hypotf4_ha_e9(float a, float b);\n+   float __svml_hypotf8_ha_e9(float a, float b);\n+   float __svml_hypotf16_ha_z0(float a, float b);\n+   double __svml_hypot1_ha_l9(double a, double b);\n+   double __svml_hypot2_ha_l9(double a, double b);\n+   double __svml_hypot4_ha_l9(double a, double b);\n+   double __svml_hypot1_ha_e9(double a, double b);\n+   double __svml_hypot2_ha_e9(double a, double b);\n+   double __svml_hypot4_ha_e9(double a, double b);\n+   double __svml_hypot8_ha_z0(double a, double b);\n+   float __svml_cbrtf4_ha_l9(float a);\n+   float __svml_cbrtf8_ha_l9(float a);\n+   float __svml_cbrtf4_ha_e9(float a);\n+   float __svml_cbrtf8_ha_e9(float a);\n+   float __svml_cbrtf16_ha_z0(float a);\n+   double __svml_cbrt1_ha_l9(double a);\n+   double __svml_cbrt2_ha_l9(double a);\n+   double __svml_cbrt4_ha_l9(double a);\n+   double __svml_cbrt1_ha_e9(double a);\n+   double __svml_cbrt2_ha_e9(double a);\n+   double __svml_cbrt4_ha_e9(double a);\n+   double __svml_cbrt8_ha_z0(double a);\n+   float __svml_atan2f4_ha_l9(float a, float b);\n+   float __svml_atan2f8_ha_l9(float a, float b);\n+   float __svml_atan2f4_ha_e9(float a, float b);\n+   float __svml_atan2f8_ha_e9(float a, float b);\n+   float __svml_atan2f16_ha_z0(float a, float b);\n+   double __svml_atan21_ha_l9(double a, double b);\n+   double __svml_atan22_ha_l9(double a, double b);\n+   double __svml_atan24_ha_l9(double a, double b);\n+   double __svml_atan28_ha_z0(double a, double b);\n+   double __svml_atan21_ha_e9(double a, double b);\n+   double __svml_atan22_ha_e9(double a, double b);\n+   double __svml_atan24_ha_e9(double a, double b);\n+   float __svml_sinf4_ha_ex(float a);\n+   double __svml_sin1_ha_ex(double a);\n+   double __svml_sin2_ha_ex(double a);\n+   float __svml_cosf4_ha_ex(float a);\n+   double __svml_cos1_ha_ex(double a);\n+   double __svml_cos2_ha_ex(double a);\n+   float __svml_tanf4_ha_ex(float a);\n+   double __svml_tan1_ha_ex(double a);\n+   double __svml_tan2_ha_ex(double a);\n+   float __svml_sinhf4_ha_ex(float a);\n+   double __svml_sinh1_ha_ex(double a);\n+   double __svml_sinh2_ha_ex(double a);\n+   float __svml_coshf4_ha_ex(float a);\n+   double __svml_cosh1_ha_ex(double a);\n+   double __svml_cosh2_ha_ex(double a);\n+   float __svml_tanhf4_ha_ex(float a);\n+   double __svml_tanh1_ha_ex(double a);\n+   double __svml_tanh2_ha_ex(double a);\n+   double __svml_log1_ha_ex(double a);\n+   double __svml_log2_ha_ex(double a);\n+   double __svml_log1p1_ha_ex(double a);\n+   double __svml_log1p2_ha_ex(double a);\n+   double __svml_log101_ha_ex(double a);\n+   double __svml_log102_ha_ex(double a);\n+   float __svml_logf4_ha_ex(float a);\n+   float __svml_log1pf4_ha_ex(float a);\n+   float __svml_log10f4_ha_ex(float a);\n+   double __svml_atan21_ha_ex(double a);\n+   double __svml_atan22_ha_ex(double a);\n+   float __svml_atan2f4_ha_ex(float a);\n+   float __svml_hypotf4_ha_ex(float a);\n+   double __svml_hypot1_ha_ex(double a);\n+   double __svml_hypot2_ha_ex(double a);\n+   double __svml_pow1_ha_ex(double a);\n+   double __svml_pow2_ha_ex(double a);\n+   float __svml_powf4_ha_ex(float a);\n+   double __svml_cbrt1_ha_ex(double a);\n+   double __svml_cbrt2_ha_ex(double a);\n+   float __svml_cbrtf4_ha_ex(float a);\n+}\n+#endif\n+\n@@ -6968,0 +7245,319 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+#ifdef __VECTOR_API_MATH_INTRINSICS_LINUX\n+    if (UseAVX > 2) {\n+      StubRoutines::_vector_exp_float512    = CAST_FROM_FN_PTR(address, __svml_expf16_ha_z0);\n+      StubRoutines::_vector_exp_double512   = CAST_FROM_FN_PTR(address, __svml_exp8_ha_z0);\n+      StubRoutines::_vector_expm1_float512  = CAST_FROM_FN_PTR(address, __svml_expm1f16_ha_z0);\n+      StubRoutines::_vector_expm1_double512 = CAST_FROM_FN_PTR(address, __svml_expm18_ha_z0);\n+      StubRoutines::_vector_log1p_float512  = CAST_FROM_FN_PTR(address, __svml_log1pf16_ha_z0);\n+      StubRoutines::_vector_log1p_double512 = CAST_FROM_FN_PTR(address, __svml_log1p8_ha_z0);\n+      StubRoutines::_vector_log_float512    = CAST_FROM_FN_PTR(address, __svml_logf16_ha_z0);\n+      StubRoutines::_vector_log_double512   = CAST_FROM_FN_PTR(address, __svml_log8_ha_z0);\n+      StubRoutines::_vector_log10_float512  = CAST_FROM_FN_PTR(address, __svml_log10f16_ha_z0);\n+      StubRoutines::_vector_log10_double512 = CAST_FROM_FN_PTR(address, __svml_log108_ha_z0);\n+      StubRoutines::_vector_sin_float512    = CAST_FROM_FN_PTR(address, __svml_sinf16_ha_z0);\n+      StubRoutines::_vector_sin_double512   = CAST_FROM_FN_PTR(address, __svml_sin8_ha_z0);\n+      StubRoutines::_vector_cos_float512    = CAST_FROM_FN_PTR(address, __svml_cosf16_ha_z0);\n+      StubRoutines::_vector_cos_double512   = CAST_FROM_FN_PTR(address, __svml_cos8_ha_z0);\n+      StubRoutines::_vector_tan_float512    = CAST_FROM_FN_PTR(address, __svml_tanf16_ha_z0);\n+      StubRoutines::_vector_tan_double512   = CAST_FROM_FN_PTR(address, __svml_tan8_ha_z0);\n+      StubRoutines::_vector_sinh_float512   = CAST_FROM_FN_PTR(address, __svml_sinhf16_ha_z0);\n+      StubRoutines::_vector_sinh_double512  = CAST_FROM_FN_PTR(address, __svml_sinh8_ha_z0);\n+      StubRoutines::_vector_cosh_float512   = CAST_FROM_FN_PTR(address, __svml_coshf16_ha_z0);\n+      StubRoutines::_vector_cosh_double512  = CAST_FROM_FN_PTR(address, __svml_cosh8_ha_z0);\n+      StubRoutines::_vector_tanh_float512   = CAST_FROM_FN_PTR(address, __svml_tanhf16_ha_z0);\n+      StubRoutines::_vector_tanh_double512  = CAST_FROM_FN_PTR(address, __svml_tanh8_ha_z0);\n+      StubRoutines::_vector_acos_float512   = CAST_FROM_FN_PTR(address, __svml_acosf16_ha_z0);\n+      StubRoutines::_vector_acos_double512  = CAST_FROM_FN_PTR(address, __svml_acos8_ha_z0);\n+      StubRoutines::_vector_asin_float512   = CAST_FROM_FN_PTR(address, __svml_asinf16_ha_z0);\n+      StubRoutines::_vector_asin_double512  = CAST_FROM_FN_PTR(address, __svml_asin8_ha_z0);\n+      StubRoutines::_vector_atan_float512   = CAST_FROM_FN_PTR(address, __svml_atanf16_ha_z0);\n+      StubRoutines::_vector_atan_double512  = CAST_FROM_FN_PTR(address, __svml_atan8_ha_z0);\n+      StubRoutines::_vector_pow_float512    = CAST_FROM_FN_PTR(address, __svml_powf16_ha_z0);\n+      StubRoutines::_vector_pow_double512   = CAST_FROM_FN_PTR(address, __svml_pow8_ha_z0);\n+      StubRoutines::_vector_hypot_float512  = CAST_FROM_FN_PTR(address, __svml_hypotf16_ha_z0);\n+      StubRoutines::_vector_hypot_double512 = CAST_FROM_FN_PTR(address, __svml_hypot8_ha_z0);\n+      StubRoutines::_vector_cbrt_float512   = CAST_FROM_FN_PTR(address, __svml_cbrtf16_ha_z0);\n+      StubRoutines::_vector_cbrt_double512  = CAST_FROM_FN_PTR(address, __svml_cbrt8_ha_z0);\n+      StubRoutines::_vector_atan2_float512  = CAST_FROM_FN_PTR(address, __svml_atan2f16_ha_z0);\n+      StubRoutines::_vector_atan2_double512 = CAST_FROM_FN_PTR(address, __svml_atan28_ha_z0);\n+    }\n+#endif\n+    if (UseAVX > 1) {\n+      StubRoutines::_vector_exp_float64     = CAST_FROM_FN_PTR(address, __svml_expf4_ha_l9);\n+      StubRoutines::_vector_exp_float128    = CAST_FROM_FN_PTR(address, __svml_expf4_ha_l9);\n+      StubRoutines::_vector_exp_float256    = CAST_FROM_FN_PTR(address, __svml_expf8_ha_l9);\n+      StubRoutines::_vector_exp_double64    = CAST_FROM_FN_PTR(address, __svml_exp1_ha_l9);\n+      StubRoutines::_vector_exp_double128   = CAST_FROM_FN_PTR(address, __svml_exp2_ha_l9);\n+      StubRoutines::_vector_exp_double256   = CAST_FROM_FN_PTR(address, __svml_exp4_ha_l9);\n+      StubRoutines::_vector_expm1_float64   = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_l9);\n+      StubRoutines::_vector_expm1_float128  = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_l9);\n+      StubRoutines::_vector_expm1_float256  = CAST_FROM_FN_PTR(address, __svml_expm1f8_ha_l9);\n+      StubRoutines::_vector_expm1_double64  = CAST_FROM_FN_PTR(address, __svml_expm11_ha_l9);\n+      StubRoutines::_vector_expm1_double128 = CAST_FROM_FN_PTR(address, __svml_expm12_ha_l9);\n+      StubRoutines::_vector_expm1_double256 = CAST_FROM_FN_PTR(address, __svml_expm14_ha_l9);\n+      StubRoutines::_vector_log1p_float64   = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_l9);\n+      StubRoutines::_vector_log1p_float128  = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_l9);\n+      StubRoutines::_vector_log1p_float256  = CAST_FROM_FN_PTR(address, __svml_log1pf8_ha_l9);\n+      StubRoutines::_vector_log1p_double64  = CAST_FROM_FN_PTR(address, __svml_log1p1_ha_l9);\n+      StubRoutines::_vector_log1p_double128 = CAST_FROM_FN_PTR(address, __svml_log1p2_ha_l9);\n+      StubRoutines::_vector_log1p_double256 = CAST_FROM_FN_PTR(address, __svml_log1p4_ha_l9);\n+      StubRoutines::_vector_log_float64     = CAST_FROM_FN_PTR(address, __svml_logf4_ha_l9);\n+      StubRoutines::_vector_log_float128    = CAST_FROM_FN_PTR(address, __svml_logf4_ha_l9);\n+      StubRoutines::_vector_log_float256    = CAST_FROM_FN_PTR(address, __svml_logf8_ha_l9);\n+      StubRoutines::_vector_log_double64    = CAST_FROM_FN_PTR(address, __svml_log1_ha_l9);\n+      StubRoutines::_vector_log_double128   = CAST_FROM_FN_PTR(address, __svml_log2_ha_l9);\n+      StubRoutines::_vector_log_double256   = CAST_FROM_FN_PTR(address, __svml_log4_ha_l9);\n+      StubRoutines::_vector_log10_float64   = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_l9);\n+      StubRoutines::_vector_log10_float128  = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_l9);\n+      StubRoutines::_vector_log10_float256  = CAST_FROM_FN_PTR(address, __svml_log10f8_ha_l9);\n+      StubRoutines::_vector_log10_double64  = CAST_FROM_FN_PTR(address, __svml_log101_ha_l9);\n+      StubRoutines::_vector_log10_double128 = CAST_FROM_FN_PTR(address, __svml_log102_ha_l9);\n+      StubRoutines::_vector_log10_double256 = CAST_FROM_FN_PTR(address, __svml_log104_ha_l9);\n+      StubRoutines::_vector_sin_float64     = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_l9);\n+      StubRoutines::_vector_sin_float128    = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_l9);\n+      StubRoutines::_vector_sin_float256    = CAST_FROM_FN_PTR(address, __svml_sinf8_ha_l9);\n+      StubRoutines::_vector_sin_double64    = CAST_FROM_FN_PTR(address, __svml_sin1_ha_l9);\n+      StubRoutines::_vector_sin_double128   = CAST_FROM_FN_PTR(address, __svml_sin2_ha_l9);\n+      StubRoutines::_vector_sin_double256   = CAST_FROM_FN_PTR(address, __svml_sin4_ha_l9);\n+      StubRoutines::_vector_cos_float64     = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_l9);\n+      StubRoutines::_vector_cos_float128    = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_l9);\n+      StubRoutines::_vector_cos_float256    = CAST_FROM_FN_PTR(address, __svml_cosf8_ha_l9);\n+      StubRoutines::_vector_cos_double64    = CAST_FROM_FN_PTR(address, __svml_cos1_ha_l9);\n+      StubRoutines::_vector_cos_double128   = CAST_FROM_FN_PTR(address, __svml_cos2_ha_l9);\n+      StubRoutines::_vector_cos_double256   = CAST_FROM_FN_PTR(address, __svml_cos4_ha_l9);\n+      StubRoutines::_vector_tan_float64     = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_l9);\n+      StubRoutines::_vector_tan_float128    = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_l9);\n+      StubRoutines::_vector_tan_float256    = CAST_FROM_FN_PTR(address, __svml_tanf8_ha_l9);\n+      StubRoutines::_vector_tan_double64    = CAST_FROM_FN_PTR(address, __svml_tan1_ha_l9);\n+      StubRoutines::_vector_tan_double128   = CAST_FROM_FN_PTR(address, __svml_tan2_ha_l9);\n+      StubRoutines::_vector_tan_double256   = CAST_FROM_FN_PTR(address, __svml_tan4_ha_l9);\n+      StubRoutines::_vector_sinh_float64    = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_l9);\n+      StubRoutines::_vector_sinh_float128   = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_l9);\n+      StubRoutines::_vector_sinh_float256   = CAST_FROM_FN_PTR(address, __svml_sinhf8_ha_l9);\n+      StubRoutines::_vector_sinh_double64   = CAST_FROM_FN_PTR(address, __svml_sinh1_ha_l9);\n+      StubRoutines::_vector_sinh_double128  = CAST_FROM_FN_PTR(address, __svml_sinh2_ha_l9);\n+      StubRoutines::_vector_sinh_double256  = CAST_FROM_FN_PTR(address, __svml_sinh4_ha_l9);\n+      StubRoutines::_vector_cosh_float64    = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_l9);\n+      StubRoutines::_vector_cosh_float128   = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_l9);\n+      StubRoutines::_vector_cosh_float256   = CAST_FROM_FN_PTR(address, __svml_coshf8_ha_l9);\n+      StubRoutines::_vector_cosh_double64   = CAST_FROM_FN_PTR(address, __svml_cosh1_ha_l9);\n+      StubRoutines::_vector_cosh_double128  = CAST_FROM_FN_PTR(address, __svml_cosh2_ha_l9);\n+      StubRoutines::_vector_cosh_double256  = CAST_FROM_FN_PTR(address, __svml_cosh4_ha_l9);\n+      StubRoutines::_vector_tanh_float64    = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_l9);\n+      StubRoutines::_vector_tanh_float128   = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_l9);\n+      StubRoutines::_vector_tanh_float256   = CAST_FROM_FN_PTR(address, __svml_tanhf8_ha_l9);\n+      StubRoutines::_vector_tanh_double64   = CAST_FROM_FN_PTR(address, __svml_tanh1_ha_l9);\n+      StubRoutines::_vector_tanh_double128  = CAST_FROM_FN_PTR(address, __svml_tanh2_ha_l9);\n+      StubRoutines::_vector_tanh_double256  = CAST_FROM_FN_PTR(address, __svml_tanh4_ha_l9);\n+      StubRoutines::_vector_acos_float64    = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_l9);\n+      StubRoutines::_vector_acos_float128   = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_l9);\n+      StubRoutines::_vector_acos_float256   = CAST_FROM_FN_PTR(address, __svml_acosf8_ha_l9);\n+      StubRoutines::_vector_acos_double64   = CAST_FROM_FN_PTR(address, __svml_acos1_ha_l9);\n+      StubRoutines::_vector_acos_double128  = CAST_FROM_FN_PTR(address, __svml_acos2_ha_l9);\n+      StubRoutines::_vector_acos_double256  = CAST_FROM_FN_PTR(address, __svml_acos4_ha_l9);\n+      StubRoutines::_vector_asin_float64    = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_l9);\n+      StubRoutines::_vector_asin_float128   = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_l9);\n+      StubRoutines::_vector_asin_float256   = CAST_FROM_FN_PTR(address, __svml_asinf8_ha_l9);\n+      StubRoutines::_vector_asin_double64   = CAST_FROM_FN_PTR(address, __svml_asin1_ha_l9);\n+      StubRoutines::_vector_asin_double128  = CAST_FROM_FN_PTR(address, __svml_asin2_ha_l9);\n+      StubRoutines::_vector_asin_double256  = CAST_FROM_FN_PTR(address, __svml_asin4_ha_l9);\n+      StubRoutines::_vector_atan_float64    = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_l9);\n+      StubRoutines::_vector_atan_float128   = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_l9);\n+      StubRoutines::_vector_atan_float256   = CAST_FROM_FN_PTR(address, __svml_atanf8_ha_l9);\n+      StubRoutines::_vector_atan_double64   = CAST_FROM_FN_PTR(address, __svml_atan1_ha_l9);\n+      StubRoutines::_vector_atan_double128  = CAST_FROM_FN_PTR(address, __svml_atan2_ha_l9);\n+      StubRoutines::_vector_atan_double256  = CAST_FROM_FN_PTR(address, __svml_atan4_ha_l9);\n+      StubRoutines::_vector_hypot_float64   = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_l9);\n+      StubRoutines::_vector_hypot_float128  = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_l9);\n+      StubRoutines::_vector_hypot_float256  = CAST_FROM_FN_PTR(address, __svml_hypotf8_ha_l9);\n+      StubRoutines::_vector_hypot_double64  = CAST_FROM_FN_PTR(address, __svml_hypot1_ha_l9);\n+      StubRoutines::_vector_hypot_double128 = CAST_FROM_FN_PTR(address, __svml_hypot2_ha_l9);\n+      StubRoutines::_vector_hypot_double256 = CAST_FROM_FN_PTR(address, __svml_hypot4_ha_l9);\n+      StubRoutines::_vector_cbrt_float64    = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_l9);\n+      StubRoutines::_vector_cbrt_float128   = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_l9);\n+      StubRoutines::_vector_cbrt_float256   = CAST_FROM_FN_PTR(address, __svml_cbrtf8_ha_l9);\n+      StubRoutines::_vector_cbrt_double64   = CAST_FROM_FN_PTR(address, __svml_cbrt1_ha_l9);\n+      StubRoutines::_vector_cbrt_double128  = CAST_FROM_FN_PTR(address, __svml_cbrt2_ha_l9);\n+      StubRoutines::_vector_cbrt_double256  = CAST_FROM_FN_PTR(address, __svml_cbrt4_ha_l9);\n+      StubRoutines::_vector_atan2_float64   = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_l9);\n+      StubRoutines::_vector_atan2_float128  = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_l9);\n+      StubRoutines::_vector_atan2_float256  = CAST_FROM_FN_PTR(address, __svml_atan2f8_ha_l9);\n+      StubRoutines::_vector_atan2_double64  = CAST_FROM_FN_PTR(address, __svml_atan21_ha_l9);\n+      StubRoutines::_vector_atan2_double128 = CAST_FROM_FN_PTR(address, __svml_atan22_ha_l9);\n+      StubRoutines::_vector_atan2_double256 = CAST_FROM_FN_PTR(address, __svml_atan24_ha_l9);\n+    } else if (UseAVX > 0) {\n+      StubRoutines::_vector_exp_float64     = CAST_FROM_FN_PTR(address, __svml_expf4_ha_e9);\n+      StubRoutines::_vector_exp_float128    = CAST_FROM_FN_PTR(address, __svml_expf4_ha_e9);\n+      StubRoutines::_vector_exp_float256    = CAST_FROM_FN_PTR(address, __svml_expf8_ha_e9);\n+      StubRoutines::_vector_exp_double64    = CAST_FROM_FN_PTR(address, __svml_exp1_ha_e9);\n+      StubRoutines::_vector_exp_double128   = CAST_FROM_FN_PTR(address, __svml_exp2_ha_e9);\n+      StubRoutines::_vector_exp_double256   = CAST_FROM_FN_PTR(address, __svml_exp4_ha_e9);\n+      StubRoutines::_vector_expm1_float64   = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_e9);\n+      StubRoutines::_vector_expm1_float128  = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_e9);\n+      StubRoutines::_vector_expm1_float256  = CAST_FROM_FN_PTR(address, __svml_expm1f8_ha_e9);\n+      StubRoutines::_vector_expm1_double64  = CAST_FROM_FN_PTR(address, __svml_expm11_ha_e9);\n+      StubRoutines::_vector_expm1_double128 = CAST_FROM_FN_PTR(address, __svml_expm12_ha_e9);\n+      StubRoutines::_vector_expm1_double256 = CAST_FROM_FN_PTR(address, __svml_expm14_ha_e9);\n+      StubRoutines::_vector_log1p_float64   = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_e9);\n+      StubRoutines::_vector_log1p_float128  = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_e9);\n+      StubRoutines::_vector_log1p_float256  = CAST_FROM_FN_PTR(address, __svml_log1pf8_ha_e9);\n+      StubRoutines::_vector_log1p_double64  = CAST_FROM_FN_PTR(address, __svml_log1p1_ha_e9);\n+      StubRoutines::_vector_log1p_double128 = CAST_FROM_FN_PTR(address, __svml_log1p2_ha_e9);\n+      StubRoutines::_vector_log1p_double256 = CAST_FROM_FN_PTR(address, __svml_log1p4_ha_e9);\n+      StubRoutines::_vector_log_float64     = CAST_FROM_FN_PTR(address, __svml_logf4_ha_e9);\n+      StubRoutines::_vector_log_float128    = CAST_FROM_FN_PTR(address, __svml_logf4_ha_e9);\n+      StubRoutines::_vector_log_float256    = CAST_FROM_FN_PTR(address, __svml_logf8_ha_e9);\n+      StubRoutines::_vector_log_double64    = CAST_FROM_FN_PTR(address, __svml_log1_ha_e9);\n+      StubRoutines::_vector_log_double128   = CAST_FROM_FN_PTR(address, __svml_log2_ha_e9);\n+      StubRoutines::_vector_log_double256   = CAST_FROM_FN_PTR(address, __svml_log4_ha_e9);\n+      StubRoutines::_vector_log10_float64   = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_e9);\n+      StubRoutines::_vector_log10_float128  = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_e9);\n+      StubRoutines::_vector_log10_float256  = CAST_FROM_FN_PTR(address, __svml_log10f8_ha_e9);\n+      StubRoutines::_vector_log10_double64  = CAST_FROM_FN_PTR(address, __svml_log101_ha_e9);\n+      StubRoutines::_vector_log10_double128 = CAST_FROM_FN_PTR(address, __svml_log102_ha_e9);\n+      StubRoutines::_vector_log10_double256 = CAST_FROM_FN_PTR(address, __svml_log104_ha_e9);\n+      StubRoutines::_vector_sin_float64     = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_e9);\n+      StubRoutines::_vector_sin_float128    = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_e9);\n+      StubRoutines::_vector_sin_float256    = CAST_FROM_FN_PTR(address, __svml_sinf8_ha_e9);\n+      StubRoutines::_vector_sin_double64    = CAST_FROM_FN_PTR(address, __svml_sin1_ha_e9);\n+      StubRoutines::_vector_sin_double128   = CAST_FROM_FN_PTR(address, __svml_sin2_ha_e9);\n+      StubRoutines::_vector_sin_double256   = CAST_FROM_FN_PTR(address, __svml_sin4_ha_e9);\n+      StubRoutines::_vector_cos_float64     = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_e9);\n+      StubRoutines::_vector_cos_float128    = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_e9);\n+      StubRoutines::_vector_cos_float256    = CAST_FROM_FN_PTR(address, __svml_cosf8_ha_e9);\n+      StubRoutines::_vector_cos_double64    = CAST_FROM_FN_PTR(address, __svml_cos1_ha_e9);\n+      StubRoutines::_vector_cos_double128   = CAST_FROM_FN_PTR(address, __svml_cos2_ha_e9);\n+      StubRoutines::_vector_cos_double256   = CAST_FROM_FN_PTR(address, __svml_cos4_ha_e9);\n+      StubRoutines::_vector_tan_float64     = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_e9);\n+      StubRoutines::_vector_tan_float128    = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_e9);\n+      StubRoutines::_vector_tan_float256    = CAST_FROM_FN_PTR(address, __svml_tanf8_ha_e9);\n+      StubRoutines::_vector_tan_double64    = CAST_FROM_FN_PTR(address, __svml_tan1_ha_e9);\n+      StubRoutines::_vector_tan_double128   = CAST_FROM_FN_PTR(address, __svml_tan2_ha_e9);\n+      StubRoutines::_vector_tan_double256   = CAST_FROM_FN_PTR(address, __svml_tan4_ha_e9);\n+      StubRoutines::_vector_sinh_float64    = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_e9);\n+      StubRoutines::_vector_sinh_float128   = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_e9);\n+      StubRoutines::_vector_sinh_float256   = CAST_FROM_FN_PTR(address, __svml_sinhf8_ha_e9);\n+      StubRoutines::_vector_sinh_double64   = CAST_FROM_FN_PTR(address, __svml_sinh1_ha_e9);\n+      StubRoutines::_vector_sinh_double128  = CAST_FROM_FN_PTR(address, __svml_sinh2_ha_e9);\n+      StubRoutines::_vector_sinh_double256  = CAST_FROM_FN_PTR(address, __svml_sinh4_ha_e9);\n+      StubRoutines::_vector_cosh_float64    = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_e9);\n+      StubRoutines::_vector_cosh_float128   = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_e9);\n+      StubRoutines::_vector_cosh_float256   = CAST_FROM_FN_PTR(address, __svml_coshf8_ha_e9);\n+      StubRoutines::_vector_cosh_double64   = CAST_FROM_FN_PTR(address, __svml_cosh1_ha_e9);\n+      StubRoutines::_vector_cosh_double128  = CAST_FROM_FN_PTR(address, __svml_cosh2_ha_e9);\n+      StubRoutines::_vector_cosh_double256  = CAST_FROM_FN_PTR(address, __svml_cosh4_ha_e9);\n+      StubRoutines::_vector_tanh_float64    = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_e9);\n+      StubRoutines::_vector_tanh_float128   = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_e9);\n+      StubRoutines::_vector_tanh_float256   = CAST_FROM_FN_PTR(address, __svml_tanhf8_ha_e9);\n+      StubRoutines::_vector_tanh_double64   = CAST_FROM_FN_PTR(address, __svml_tanh1_ha_e9);\n+      StubRoutines::_vector_tanh_double128  = CAST_FROM_FN_PTR(address, __svml_tanh2_ha_e9);\n+      StubRoutines::_vector_tanh_double256  = CAST_FROM_FN_PTR(address, __svml_tanh4_ha_e9);\n+      StubRoutines::_vector_acos_float64    = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_e9);\n+      StubRoutines::_vector_acos_float128   = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_e9);\n+      StubRoutines::_vector_acos_float256   = CAST_FROM_FN_PTR(address, __svml_acosf8_ha_e9);\n+      StubRoutines::_vector_acos_double64   = CAST_FROM_FN_PTR(address, __svml_acos1_ha_e9);\n+      StubRoutines::_vector_acos_double128  = CAST_FROM_FN_PTR(address, __svml_acos2_ha_e9);\n+      StubRoutines::_vector_acos_double256  = CAST_FROM_FN_PTR(address, __svml_acos4_ha_e9);\n+      StubRoutines::_vector_asin_float64    = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_e9);\n+      StubRoutines::_vector_asin_float128   = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_e9);\n+      StubRoutines::_vector_asin_float256   = CAST_FROM_FN_PTR(address, __svml_asinf8_ha_e9);\n+      StubRoutines::_vector_asin_double64   = CAST_FROM_FN_PTR(address, __svml_asin1_ha_e9);\n+      StubRoutines::_vector_asin_double128  = CAST_FROM_FN_PTR(address, __svml_asin2_ha_e9);\n+      StubRoutines::_vector_asin_double256  = CAST_FROM_FN_PTR(address, __svml_asin4_ha_e9);\n+      StubRoutines::_vector_atan_float64    = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_e9);\n+      StubRoutines::_vector_atan_float128   = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_e9);\n+      StubRoutines::_vector_atan_float256   = CAST_FROM_FN_PTR(address, __svml_atanf8_ha_e9);\n+      StubRoutines::_vector_atan_double64   = CAST_FROM_FN_PTR(address, __svml_atan1_ha_e9);\n+      StubRoutines::_vector_atan_double128  = CAST_FROM_FN_PTR(address, __svml_atan2_ha_e9);\n+      StubRoutines::_vector_atan_double256  = CAST_FROM_FN_PTR(address, __svml_atan4_ha_e9);\n+      StubRoutines::_vector_hypot_float64   = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_e9);\n+      StubRoutines::_vector_hypot_float128  = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_e9);\n+      StubRoutines::_vector_hypot_float256  = CAST_FROM_FN_PTR(address, __svml_hypotf8_ha_e9);\n+      StubRoutines::_vector_hypot_double64  = CAST_FROM_FN_PTR(address, __svml_hypot1_ha_e9);\n+      StubRoutines::_vector_hypot_double128 = CAST_FROM_FN_PTR(address, __svml_hypot2_ha_e9);\n+      StubRoutines::_vector_hypot_double256 = CAST_FROM_FN_PTR(address, __svml_hypot4_ha_e9);\n+      StubRoutines::_vector_cbrt_float64    = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_e9);\n+      StubRoutines::_vector_cbrt_float128   = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_e9);\n+      StubRoutines::_vector_cbrt_float256   = CAST_FROM_FN_PTR(address, __svml_cbrtf8_ha_e9);\n+      StubRoutines::_vector_cbrt_double64   = CAST_FROM_FN_PTR(address, __svml_cbrt1_ha_e9);\n+      StubRoutines::_vector_cbrt_double128  = CAST_FROM_FN_PTR(address, __svml_cbrt2_ha_e9);\n+      StubRoutines::_vector_cbrt_double256  = CAST_FROM_FN_PTR(address, __svml_cbrt4_ha_e9);\n+      StubRoutines::_vector_atan2_float64   = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_e9);\n+      StubRoutines::_vector_atan2_float128  = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_e9);\n+      StubRoutines::_vector_atan2_float256  = CAST_FROM_FN_PTR(address, __svml_atan2f8_ha_e9);\n+      StubRoutines::_vector_atan2_double64  = CAST_FROM_FN_PTR(address, __svml_atan21_ha_e9);\n+      StubRoutines::_vector_atan2_double128 = CAST_FROM_FN_PTR(address, __svml_atan22_ha_e9);\n+      StubRoutines::_vector_atan2_double256 = CAST_FROM_FN_PTR(address, __svml_atan24_ha_e9);\n+    } else {\n+      assert(UseAVX == 0 && UseSSE >= 2, \"\");\n+      StubRoutines::_vector_exp_float64     = CAST_FROM_FN_PTR(address, __svml_expf4_ha_ex);\n+      StubRoutines::_vector_exp_float128    = CAST_FROM_FN_PTR(address, __svml_expf4_ha_ex);\n+      StubRoutines::_vector_exp_double64    = CAST_FROM_FN_PTR(address, __svml_exp1_ha_ex);\n+      StubRoutines::_vector_exp_double128   = CAST_FROM_FN_PTR(address, __svml_exp2_ha_ex);\n+      StubRoutines::_vector_expm1_float64   = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_ex);\n+      StubRoutines::_vector_expm1_float128  = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_ex);\n+      StubRoutines::_vector_expm1_double64  = CAST_FROM_FN_PTR(address, __svml_expm11_ha_ex);\n+      StubRoutines::_vector_expm1_double128 = CAST_FROM_FN_PTR(address, __svml_expm12_ha_ex);\n+      StubRoutines::_vector_acos_float64    = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_ex);\n+      StubRoutines::_vector_acos_float128   = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_ex);\n+      StubRoutines::_vector_acos_double64   = CAST_FROM_FN_PTR(address, __svml_acos1_ha_ex);\n+      StubRoutines::_vector_acos_double128  = CAST_FROM_FN_PTR(address, __svml_acos2_ha_ex);\n+      StubRoutines::_vector_asin_float64    = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_ex);\n+      StubRoutines::_vector_asin_float128   = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_ex);\n+      StubRoutines::_vector_asin_double64   = CAST_FROM_FN_PTR(address, __svml_asin1_ha_ex);\n+      StubRoutines::_vector_asin_double128  = CAST_FROM_FN_PTR(address, __svml_asin2_ha_ex);\n+      StubRoutines::_vector_atan_float64    = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_ex);\n+      StubRoutines::_vector_atan_float128   = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_ex);\n+      StubRoutines::_vector_atan_double64   = CAST_FROM_FN_PTR(address, __svml_atan1_ha_ex);\n+      StubRoutines::_vector_atan_double128  = CAST_FROM_FN_PTR(address, __svml_atan2_ha_ex);\n+      StubRoutines::_vector_sin_float64     = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_ex);\n+      StubRoutines::_vector_sin_float128    = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_ex);\n+      StubRoutines::_vector_sin_double64    = CAST_FROM_FN_PTR(address, __svml_sin1_ha_ex);\n+      StubRoutines::_vector_sin_double128   = CAST_FROM_FN_PTR(address, __svml_sin2_ha_ex);\n+      StubRoutines::_vector_cos_float64     = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_ex);\n+      StubRoutines::_vector_cos_float128    = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_ex);\n+      StubRoutines::_vector_cos_double64    = CAST_FROM_FN_PTR(address, __svml_cos1_ha_ex);\n+      StubRoutines::_vector_cos_double128   = CAST_FROM_FN_PTR(address, __svml_cos2_ha_ex);\n+      StubRoutines::_vector_tan_float64     = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_ex);\n+      StubRoutines::_vector_tan_float128    = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_ex);\n+      StubRoutines::_vector_tan_double64    = CAST_FROM_FN_PTR(address, __svml_tan1_ha_ex);\n+      StubRoutines::_vector_tan_double128   = CAST_FROM_FN_PTR(address, __svml_tan2_ha_ex);\n+      StubRoutines::_vector_sinh_float64    = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_ex);\n+      StubRoutines::_vector_sinh_float128   = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_ex);\n+      StubRoutines::_vector_sinh_double64   = CAST_FROM_FN_PTR(address, __svml_sinh1_ha_ex);\n+      StubRoutines::_vector_sinh_double128  = CAST_FROM_FN_PTR(address, __svml_sinh2_ha_ex);\n+      StubRoutines::_vector_cosh_float64    = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_ex);\n+      StubRoutines::_vector_cosh_float128   = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_ex);\n+      StubRoutines::_vector_cosh_double64   = CAST_FROM_FN_PTR(address, __svml_cosh1_ha_ex);\n+      StubRoutines::_vector_cosh_double128  = CAST_FROM_FN_PTR(address, __svml_cosh2_ha_ex);\n+      StubRoutines::_vector_tanh_float64    = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_ex);\n+      StubRoutines::_vector_tanh_float128   = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_ex);\n+      StubRoutines::_vector_tanh_double64   = CAST_FROM_FN_PTR(address, __svml_tanh1_ha_ex);\n+      StubRoutines::_vector_tanh_double128  = CAST_FROM_FN_PTR(address, __svml_tanh2_ha_ex);\n+      StubRoutines::_vector_log_float64     = CAST_FROM_FN_PTR(address, __svml_logf4_ha_ex);\n+      StubRoutines::_vector_log_float128    = CAST_FROM_FN_PTR(address, __svml_logf4_ha_ex);\n+      StubRoutines::_vector_log_double64    = CAST_FROM_FN_PTR(address, __svml_log1_ha_ex);\n+      StubRoutines::_vector_log_double128   = CAST_FROM_FN_PTR(address, __svml_log2_ha_ex);\n+      StubRoutines::_vector_log10_float64   = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_ex);\n+      StubRoutines::_vector_log10_float128  = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_ex);\n+      StubRoutines::_vector_log10_double64  = CAST_FROM_FN_PTR(address, __svml_log101_ha_ex);\n+      StubRoutines::_vector_log10_double128 = CAST_FROM_FN_PTR(address, __svml_log102_ha_ex);\n+      StubRoutines::_vector_log1p_float64   = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_ex);\n+      StubRoutines::_vector_log1p_float128  = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_ex);\n+      StubRoutines::_vector_log1p_double64  = CAST_FROM_FN_PTR(address, __svml_log1p1_ha_ex);\n+      StubRoutines::_vector_log1p_double128 = CAST_FROM_FN_PTR(address, __svml_log1p2_ha_ex);\n+      StubRoutines::_vector_atan2_float64   = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_ex);\n+      StubRoutines::_vector_atan2_float128  = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_ex);\n+      StubRoutines::_vector_atan2_double64  = CAST_FROM_FN_PTR(address, __svml_atan21_ha_ex);\n+      StubRoutines::_vector_atan2_double128 = CAST_FROM_FN_PTR(address, __svml_atan22_ha_ex);\n+      StubRoutines::_vector_hypot_float64   = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_ex);\n+      StubRoutines::_vector_hypot_float128  = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_ex);\n+      StubRoutines::_vector_hypot_double64  = CAST_FROM_FN_PTR(address, __svml_hypot1_ha_ex);\n+      StubRoutines::_vector_hypot_double128 = CAST_FROM_FN_PTR(address, __svml_hypot2_ha_ex);\n+      StubRoutines::_vector_cbrt_float64    = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_ex);\n+      StubRoutines::_vector_cbrt_float128   = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_ex);\n+      StubRoutines::_vector_cbrt_double64   = CAST_FROM_FN_PTR(address, __svml_cbrt1_ha_ex);\n+      StubRoutines::_vector_cbrt_double128  = CAST_FROM_FN_PTR(address, __svml_cbrt2_ha_ex);\n+    }\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":596,"deletions":0,"binary":false,"changes":596,"status":"modified"},{"patch":"@@ -1638,0 +1638,5 @@\n+    case Op_CallLeafVector:\n+      if (size_in_bits == 512 && !VM_Version::supports_avx512vlbwdq()) {\n+        return false;\n+      }\n+      break;\n@@ -1897,0 +1902,4 @@\n+  \/\/ Support for calling svml double64 vectors\n+  if (bt == T_DOUBLE) {\n+    size = 1;\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+macro(CallLeafVector)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2195,1 +2195,2 @@\n-    for_igvn()->clear();\n+    Unique_Node_List* old_worklist = for_igvn();\n+    old_worklist->clear();\n@@ -2205,1 +2206,1 @@\n-    set_for_igvn(save_for_igvn);\n+    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n@@ -3018,0 +3019,1 @@\n+  case Op_CallLeafVector:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2507,0 +2507,3 @@\n+  } else  if (flags & RC_VECTOR){\n+    uint num_bits = call_type->range()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte;\n+    call = new CallLeafVectorNode(call_type, call_addr, call_name, adr_type, num_bits);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -666,0 +666,19 @@\n+const TypeFunc *OptoRuntime::Math_Vector_Vector_Type(uint num_arg, const TypeVect* in_type, const TypeVect* out_type) {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(num_arg);\n+  \/\/ Symbol* name of class to be loaded\n+  assert(num_arg > 0, \"must have at least 1 input\");\n+  for (uint i = 0; i < num_arg; i++) {\n+    fields[TypeFunc::Parms+i] = in_type;\n+  }\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+num_arg, fields);\n+\n+  \/\/ create result type (range)\n+  const uint num_ret = 1;\n+  fields = TypeTuple::fields(num_ret);\n+  fields[TypeFunc::Parms+0] = out_type;\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+num_ret, fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,24 @@\n+  if (num_elem == 1) {\n+    if (mask_use_type != VecMaskNotUsed) {\n+#ifndef PRODUCT\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** Rejected vector mask op (%s,%s,%d) because architecture does not support it\",\n+                      NodeClassNames[sopc], type2name(type), num_elem);\n+      }\n+#endif\n+      return false;\n+    }\n+\n+    if (sopc != 0) {\n+      if (sopc != Op_LoadVector && sopc != Op_StoreVector) {\n+#ifndef PRODUCT\n+        if (C->print_intrinsics()) {\n+          tty->print_cr(\"  ** Not a svml call or load\/store vector op (%s,%s,%d)\",\n+                        NodeClassNames[sopc], type2name(type), num_elem);\n+        }\n+#endif\n+        return false;\n+      }\n+    }\n+  }\n+\n@@ -234,1 +258,1 @@\n-  if (sopc == 0) {\n+  if ((opc != Op_CallLeafVector) && (sopc == 0)) {\n@@ -240,0 +264,9 @@\n+  if (num_elem == 1) {\n+    if (opc != Op_CallLeafVector || elem_bt != T_DOUBLE) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not a svml call: arity=%d opc=%d vlen=%d etype=%s\",\n+                      n, opc, num_elem, type2name(elem_bt));\n+      }\n+      return false;\n+    }\n+  }\n@@ -243,0 +276,22 @@\n+  if (opc == Op_CallLeafVector) {\n+    if (!UseVectorStubs) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** vector stubs support is disabled\");\n+      }\n+      return false;\n+    }\n+    if (!Matcher::supports_vector_calling_convention()) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** no vector calling conventions supported\");\n+      }\n+      return false;\n+    }\n+    if (!Matcher::vector_size_supported(elem_bt, num_elem)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** vector size (vlen=%d, etype=%s) is not supported\",\n+                      num_elem, type2name(elem_bt));\n+      }\n+      return false;\n+    }\n+  }\n+\n@@ -244,1 +299,2 @@\n-  if (!arch_supports_vector(sopc, num_elem, elem_bt, is_vector_mask(vbox_klass) ? VecMaskUseAll : VecMaskNotUsed)) {\n+  if ((sopc != 0) &&\n+      !arch_supports_vector(sopc, num_elem, elem_bt, is_vector_mask(vbox_klass) ? VecMaskUseAll : VecMaskNotUsed)) {\n@@ -292,10 +348,22 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n-  switch (n) {\n-    case 1:\n-    case 2: {\n-      operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, vt));\n-      break;\n-    }\n-    case 3: {\n-      operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, opd3, vt));\n-      break;\n+  if (opc == Op_CallLeafVector) {\n+    assert(UseVectorStubs, \"sanity\");\n+    operation = gen_call_to_svml(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n+    if (operation == NULL) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** svml call failed\");\n+      }\n+      return false;\n+     }\n+  } else {\n+    const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+    switch (n) {\n+      case 1:\n+      case 2: {\n+        operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, vt));\n+        break;\n+      }\n+      case 3: {\n+        operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, opd3, vt));\n+        break;\n+      }\n+      default: fatal(\"unsupported arity: %d\", n);\n@@ -303,1 +371,0 @@\n-    default: fatal(\"unsupported arity: %d\", n);\n@@ -355,0 +422,3 @@\n+  if (!arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed)) {\n+    return false;\n+  }\n@@ -386,1 +456,1 @@\n-    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(1));\n+    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ge));\n@@ -411,0 +481,1 @@\n+  \/\/ TODO shuffle is not supported on SVE\n@@ -1240,0 +1311,417 @@\n+static void get_svml_address(int op, int bits, BasicType bt, const char** name_ptr, address* addr_ptr) {\n+  assert(UseVectorStubs, \"sanity\");\n+  assert(name_ptr != NULL, \"unexpected\");\n+  assert(addr_ptr != NULL, \"unexpected\");\n+\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+  \/\/ Since the addresses are resolved at runtime, using switch instead of table - otherwise might get NULL addresses.\n+  if (bt == T_FLOAT) {\n+    switch(op) {\n+      case VectorSupport::VECTOR_OP_EXP: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_exp_float64\";  *addr_ptr = StubRoutines::vector_exp_float64();  break;\n+            case 128: *name_ptr = \"vector_exp_float128\"; *addr_ptr = StubRoutines::vector_exp_float128(); break;\n+            case 256: *name_ptr = \"vector_exp_float256\"; *addr_ptr = StubRoutines::vector_exp_float256(); break;\n+            case 512: *name_ptr = \"vector_exp_float512\"; *addr_ptr = StubRoutines::vector_exp_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG1P: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log1p_float64\";  *addr_ptr = StubRoutines::vector_log1p_float64();  break;\n+            case 128: *name_ptr = \"vector_log1p_float128\"; *addr_ptr = StubRoutines::vector_log1p_float128(); break;\n+            case 256: *name_ptr = \"vector_log1p_float256\"; *addr_ptr = StubRoutines::vector_log1p_float256(); break;\n+            case 512: *name_ptr = \"vector_log1p_float512\"; *addr_ptr = StubRoutines::vector_log1p_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log_float64\";  *addr_ptr = StubRoutines::vector_log_float64();  break;\n+            case 128: *name_ptr = \"vector_log_float128\"; *addr_ptr = StubRoutines::vector_log_float128(); break;\n+            case 256: *name_ptr = \"vector_log_float256\"; *addr_ptr = StubRoutines::vector_log_float256(); break;\n+            case 512: *name_ptr = \"vector_log_float512\"; *addr_ptr = StubRoutines::vector_log_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG10: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log10_float64\";  *addr_ptr = StubRoutines::vector_log10_float64();  break;\n+            case 128: *name_ptr = \"vector_log10_float128\"; *addr_ptr = StubRoutines::vector_log10_float128(); break;\n+            case 256: *name_ptr = \"vector_log10_float256\"; *addr_ptr = StubRoutines::vector_log10_float256(); break;\n+            case 512: *name_ptr = \"vector_log10_float512\"; *addr_ptr = StubRoutines::vector_log10_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_EXPM1: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_expm1_float64\";  *addr_ptr = StubRoutines::vector_expm1_float64();  break;\n+            case 128: *name_ptr = \"vector_expm1_float128\"; *addr_ptr = StubRoutines::vector_expm1_float128(); break;\n+            case 256: *name_ptr = \"vector_expm1_float256\"; *addr_ptr = StubRoutines::vector_expm1_float256(); break;\n+            case 512: *name_ptr = \"vector_expm1_float512\"; *addr_ptr = StubRoutines::vector_expm1_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sin_float64\";  *addr_ptr = StubRoutines::vector_sin_float64();  break;\n+            case 128: *name_ptr = \"vector_sin_float128\"; *addr_ptr = StubRoutines::vector_sin_float128(); break;\n+            case 256: *name_ptr = \"vector_sin_float256\"; *addr_ptr = StubRoutines::vector_sin_float256(); break;\n+            case 512: *name_ptr = \"vector_sin_float512\"; *addr_ptr = StubRoutines::vector_sin_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cos_float64\";  *addr_ptr = StubRoutines::vector_cos_float64();  break;\n+            case 128: *name_ptr = \"vector_cos_float128\"; *addr_ptr = StubRoutines::vector_cos_float128(); break;\n+            case 256: *name_ptr = \"vector_cos_float256\"; *addr_ptr = StubRoutines::vector_cos_float256(); break;\n+            case 512: *name_ptr = \"vector_cos_float512\"; *addr_ptr = StubRoutines::vector_cos_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tan_float64\";  *addr_ptr = StubRoutines::vector_tan_float64();  break;\n+            case 128: *name_ptr = \"vector_tan_float128\"; *addr_ptr = StubRoutines::vector_tan_float128(); break;\n+            case 256: *name_ptr = \"vector_tan_float256\"; *addr_ptr = StubRoutines::vector_tan_float256(); break;\n+            case 512: *name_ptr = \"vector_tan_float512\"; *addr_ptr = StubRoutines::vector_tan_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SINH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sinh_float64\";  *addr_ptr = StubRoutines::vector_sinh_float64();  break;\n+            case 128: *name_ptr = \"vector_sinh_float128\"; *addr_ptr = StubRoutines::vector_sinh_float128(); break;\n+            case 256: *name_ptr = \"vector_sinh_float256\"; *addr_ptr = StubRoutines::vector_sinh_float256(); break;\n+            case 512: *name_ptr = \"vector_sinh_float512\"; *addr_ptr = StubRoutines::vector_sinh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COSH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cosh_float64\";  *addr_ptr = StubRoutines::vector_cosh_float64();  break;\n+            case 128: *name_ptr = \"vector_cosh_float128\"; *addr_ptr = StubRoutines::vector_cosh_float128(); break;\n+            case 256: *name_ptr = \"vector_cosh_float256\"; *addr_ptr = StubRoutines::vector_cosh_float256(); break;\n+            case 512: *name_ptr = \"vector_cosh_float512\"; *addr_ptr = StubRoutines::vector_cosh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TANH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tanh_float64\";  *addr_ptr = StubRoutines::vector_tanh_float64();  break;\n+            case 128: *name_ptr = \"vector_tanh_float128\"; *addr_ptr = StubRoutines::vector_tanh_float128(); break;\n+            case 256: *name_ptr = \"vector_tanh_float256\"; *addr_ptr = StubRoutines::vector_tanh_float256(); break;\n+            case 512: *name_ptr = \"vector_tanh_float512\"; *addr_ptr = StubRoutines::vector_tanh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ASIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_asin_float64\";  *addr_ptr = StubRoutines::vector_asin_float64();  break;\n+            case 128: *name_ptr = \"vector_asin_float128\"; *addr_ptr = StubRoutines::vector_asin_float128(); break;\n+            case 256: *name_ptr = \"vector_asin_float256\"; *addr_ptr = StubRoutines::vector_asin_float256(); break;\n+            case 512: *name_ptr = \"vector_asin_float512\"; *addr_ptr = StubRoutines::vector_asin_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ACOS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_acos_float64\";  *addr_ptr = StubRoutines::vector_acos_float64();  break;\n+            case 128: *name_ptr = \"vector_acos_float128\"; *addr_ptr = StubRoutines::vector_acos_float128(); break;\n+            case 256: *name_ptr = \"vector_acos_float256\"; *addr_ptr = StubRoutines::vector_acos_float256(); break;\n+            case 512: *name_ptr = \"vector_acos_float512\"; *addr_ptr = StubRoutines::vector_acos_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan_float64\";  *addr_ptr = StubRoutines::vector_atan_float64();  break;\n+            case 128: *name_ptr = \"vector_atan_float128\"; *addr_ptr = StubRoutines::vector_atan_float128(); break;\n+            case 256: *name_ptr = \"vector_atan_float256\"; *addr_ptr = StubRoutines::vector_atan_float256(); break;\n+            case 512: *name_ptr = \"vector_atan_float512\"; *addr_ptr = StubRoutines::vector_atan_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_CBRT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cbrt_float64\";  *addr_ptr = StubRoutines::vector_cbrt_float64();  break;\n+            case 128: *name_ptr = \"vector_cbrt_float128\"; *addr_ptr = StubRoutines::vector_cbrt_float128(); break;\n+            case 256: *name_ptr = \"vector_cbrt_float256\"; *addr_ptr = StubRoutines::vector_cbrt_float256(); break;\n+            case 512: *name_ptr = \"vector_cbrt_float512\"; *addr_ptr = StubRoutines::vector_cbrt_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+       case VectorSupport::VECTOR_OP_HYPOT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_hypot_float64\";  *addr_ptr = StubRoutines::vector_hypot_float64();  break;\n+            case 128: *name_ptr = \"vector_hypot_float128\"; *addr_ptr = StubRoutines::vector_hypot_float128(); break;\n+            case 256: *name_ptr = \"vector_hypot_float256\"; *addr_ptr = StubRoutines::vector_hypot_float256(); break;\n+            case 512: *name_ptr = \"vector_hypot_float512\"; *addr_ptr = StubRoutines::vector_hypot_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_POW: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_pow_float64\";  *addr_ptr = StubRoutines::vector_pow_float64();  break;\n+            case 128: *name_ptr = \"vector_pow_float128\"; *addr_ptr = StubRoutines::vector_pow_float128(); break;\n+            case 256: *name_ptr = \"vector_pow_float256\"; *addr_ptr = StubRoutines::vector_pow_float256(); break;\n+            case 512: *name_ptr = \"vector_pow_float512\"; *addr_ptr = StubRoutines::vector_pow_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN2: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan2_float64\";  *addr_ptr = StubRoutines::vector_atan2_float64();  break;\n+            case 128: *name_ptr = \"vector_atan2_float128\"; *addr_ptr = StubRoutines::vector_atan2_float128(); break;\n+            case 256: *name_ptr = \"vector_atan2_float256\"; *addr_ptr = StubRoutines::vector_atan2_float256(); break;\n+            case 512: *name_ptr = \"vector_atan2_float512\"; *addr_ptr = StubRoutines::vector_atan2_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      default:\n+        *name_ptr = \"invalid\";\n+        *addr_ptr = NULL;\n+        break;\n+    }\n+  } else {\n+    assert(bt == T_DOUBLE, \"must be FP type only\");\n+    switch(op) {\n+      case VectorSupport::VECTOR_OP_EXP: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_exp_double64\";  *addr_ptr = StubRoutines::vector_exp_double64();  break;\n+            case 128: *name_ptr = \"vector_exp_double128\"; *addr_ptr = StubRoutines::vector_exp_double128(); break;\n+            case 256: *name_ptr = \"vector_exp_double256\"; *addr_ptr = StubRoutines::vector_exp_double256(); break;\n+            case 512: *name_ptr = \"vector_exp_double512\"; *addr_ptr = StubRoutines::vector_exp_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG1P: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log1p_double64\";  *addr_ptr = StubRoutines::vector_log1p_double64();  break;\n+            case 128: *name_ptr = \"vector_log1p_double128\"; *addr_ptr = StubRoutines::vector_log1p_double128(); break;\n+            case 256: *name_ptr = \"vector_log1p_double256\"; *addr_ptr = StubRoutines::vector_log1p_double256(); break;\n+            case 512: *name_ptr = \"vector_log1p_double512\"; *addr_ptr = StubRoutines::vector_log1p_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log_double64\";  *addr_ptr = StubRoutines::vector_log_double64();  break;\n+            case 128: *name_ptr = \"vector_log_double128\"; *addr_ptr = StubRoutines::vector_log_double128(); break;\n+            case 256: *name_ptr = \"vector_log_double256\"; *addr_ptr = StubRoutines::vector_log_double256(); break;\n+            case 512: *name_ptr = \"vector_log_double512\"; *addr_ptr = StubRoutines::vector_log_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG10: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log10_double64\";  *addr_ptr = StubRoutines::vector_log10_double64();  break;\n+            case 128: *name_ptr = \"vector_log10_double128\"; *addr_ptr = StubRoutines::vector_log10_double128(); break;\n+            case 256: *name_ptr = \"vector_log10_double256\"; *addr_ptr = StubRoutines::vector_log10_double256(); break;\n+            case 512: *name_ptr = \"vector_log10_double512\"; *addr_ptr = StubRoutines::vector_log10_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_EXPM1: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_expm1_double64\";  *addr_ptr = StubRoutines::vector_expm1_double64();  break;\n+            case 128: *name_ptr = \"vector_expm1_double128\"; *addr_ptr = StubRoutines::vector_expm1_double128(); break;\n+            case 256: *name_ptr = \"vector_expm1_double256\"; *addr_ptr = StubRoutines::vector_expm1_double256(); break;\n+            case 512: *name_ptr = \"vector_expm1_double512\"; *addr_ptr = StubRoutines::vector_expm1_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sin_double64\";  *addr_ptr = StubRoutines::vector_sin_double64();  break;\n+            case 128: *name_ptr = \"vector_sin_double128\"; *addr_ptr = StubRoutines::vector_sin_double128(); break;\n+            case 256: *name_ptr = \"vector_sin_double256\"; *addr_ptr = StubRoutines::vector_sin_double256(); break;\n+            case 512: *name_ptr = \"vector_sin_double512\"; *addr_ptr = StubRoutines::vector_sin_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cos_double64\";  *addr_ptr = StubRoutines::vector_cos_double64();  break;\n+            case 128: *name_ptr = \"vector_cos_double128\"; *addr_ptr = StubRoutines::vector_cos_double128(); break;\n+            case 256: *name_ptr = \"vector_cos_double256\"; *addr_ptr = StubRoutines::vector_cos_double256(); break;\n+            case 512: *name_ptr = \"vector_cos_double512\"; *addr_ptr = StubRoutines::vector_cos_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tan_double64\";  *addr_ptr = StubRoutines::vector_tan_double64();  break;\n+            case 128: *name_ptr = \"vector_tan_double128\"; *addr_ptr = StubRoutines::vector_tan_double128(); break;\n+            case 256: *name_ptr = \"vector_tan_double256\"; *addr_ptr = StubRoutines::vector_tan_double256(); break;\n+            case 512: *name_ptr = \"vector_tan_double512\"; *addr_ptr = StubRoutines::vector_tan_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SINH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sinh_double64\";  *addr_ptr = StubRoutines::vector_sinh_double64();  break;\n+            case 128: *name_ptr = \"vector_sinh_double128\"; *addr_ptr = StubRoutines::vector_sinh_double128(); break;\n+            case 256: *name_ptr = \"vector_sinh_double256\"; *addr_ptr = StubRoutines::vector_sinh_double256(); break;\n+            case 512: *name_ptr = \"vector_sinh_double512\"; *addr_ptr = StubRoutines::vector_sinh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COSH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cosh_double64\";  *addr_ptr = StubRoutines::vector_cosh_double64();  break;\n+            case 128: *name_ptr = \"vector_cosh_double128\"; *addr_ptr = StubRoutines::vector_cosh_double128(); break;\n+            case 256: *name_ptr = \"vector_cosh_double256\"; *addr_ptr = StubRoutines::vector_cosh_double256(); break;\n+            case 512: *name_ptr = \"vector_cosh_double512\"; *addr_ptr = StubRoutines::vector_cosh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TANH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tanh_double64\";  *addr_ptr = StubRoutines::vector_tanh_double64();  break;\n+            case 128: *name_ptr = \"vector_tanh_double128\"; *addr_ptr = StubRoutines::vector_tanh_double128(); break;\n+            case 256: *name_ptr = \"vector_tanh_double256\"; *addr_ptr = StubRoutines::vector_tanh_double256(); break;\n+            case 512: *name_ptr = \"vector_tanh_double512\"; *addr_ptr = StubRoutines::vector_tanh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ASIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_asin_double64\";  *addr_ptr = StubRoutines::vector_asin_double64();  break;\n+            case 128: *name_ptr = \"vector_asin_double128\"; *addr_ptr = StubRoutines::vector_asin_double128(); break;\n+            case 256: *name_ptr = \"vector_asin_double256\"; *addr_ptr = StubRoutines::vector_asin_double256(); break;\n+            case 512: *name_ptr = \"vector_asin_double512\"; *addr_ptr = StubRoutines::vector_asin_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ACOS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_acos_double64\";  *addr_ptr = StubRoutines::vector_acos_double64();  break;\n+            case 128: *name_ptr = \"vector_acos_double128\"; *addr_ptr = StubRoutines::vector_acos_double128(); break;\n+            case 256: *name_ptr = \"vector_acos_double256\"; *addr_ptr = StubRoutines::vector_acos_double256(); break;\n+            case 512: *name_ptr = \"vector_acos_double512\"; *addr_ptr = StubRoutines::vector_acos_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan_double64\";  *addr_ptr = StubRoutines::vector_atan_double64();  break;\n+            case 128: *name_ptr = \"vector_atan_double128\"; *addr_ptr = StubRoutines::vector_atan_double128(); break;\n+            case 256: *name_ptr = \"vector_atan_double256\"; *addr_ptr = StubRoutines::vector_atan_double256(); break;\n+            case 512: *name_ptr = \"vector_atan_double512\"; *addr_ptr = StubRoutines::vector_atan_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_CBRT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cbrt_double64\";  *addr_ptr = StubRoutines::vector_cbrt_double64();  break;\n+            case 128: *name_ptr = \"vector_cbrt_double128\"; *addr_ptr = StubRoutines::vector_cbrt_double128(); break;\n+            case 256: *name_ptr = \"vector_cbrt_double256\"; *addr_ptr = StubRoutines::vector_cbrt_double256(); break;\n+            case 512: *name_ptr = \"vector_cbrt_double512\"; *addr_ptr = StubRoutines::vector_cbrt_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_HYPOT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_hypot_double64\";  *addr_ptr = StubRoutines::vector_hypot_double64();  break;\n+            case 128: *name_ptr = \"vector_hypot_double128\"; *addr_ptr = StubRoutines::vector_hypot_double128(); break;\n+            case 256: *name_ptr = \"vector_hypot_double256\"; *addr_ptr = StubRoutines::vector_hypot_double256(); break;\n+            case 512: *name_ptr = \"vector_hypot_double512\"; *addr_ptr = StubRoutines::vector_hypot_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_POW: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_pow_double64\";  *addr_ptr = StubRoutines::vector_pow_double64();  break;\n+            case 128: *name_ptr = \"vector_pow_double128\"; *addr_ptr = StubRoutines::vector_pow_double128(); break;\n+            case 256: *name_ptr = \"vector_pow_double256\"; *addr_ptr = StubRoutines::vector_pow_double256(); break;\n+            case 512: *name_ptr = \"vector_pow_double512\"; *addr_ptr = StubRoutines::vector_pow_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN2: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan2_double64\";  *addr_ptr = StubRoutines::vector_atan2_double64();  break;\n+            case 128: *name_ptr = \"vector_atan2_double128\"; *addr_ptr = StubRoutines::vector_atan2_double128(); break;\n+            case 256: *name_ptr = \"vector_atan2_double256\"; *addr_ptr = StubRoutines::vector_atan2_double256(); break;\n+            case 512: *name_ptr = \"vector_atan2_double512\"; *addr_ptr = StubRoutines::vector_atan2_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+\n+      default:\n+        *name_ptr = \"invalid\";\n+        *addr_ptr = NULL;\n+        break;\n+    }\n+  }\n+#else\n+  *name_ptr = \"invalid\";\n+  *addr_ptr = NULL;\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+}\n+\n+Node* LibraryCallKit::gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n+  assert(UseVectorStubs, \"sanity\");\n+  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_SVML_START && vector_api_op_id <= VectorSupport::VECTOR_OP_SVML_END, \"need valid op id\");\n+  assert(opd1 != NULL, \"must not be null\");\n+  const TypeVect* vt = TypeVect::make(bt, num_elem);\n+  const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(opd2 != NULL ? 2 : 1, vt, vt);\n+  const char* name = NULL;\n+  address addr = NULL;\n+\n+  \/\/ Get address for svml method.\n+  get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, &name, &addr);\n+\n+  if (addr == NULL) {\n+    return NULL;\n+  }\n+\n+  assert(name != NULL, \"name must not be null\");\n+  Node* operation = make_runtime_call(RC_VECTOR,\n+                                      call_type,\n+                                      addr,\n+                                      name,\n+                                      TypePtr::BOTTOM,\n+                                      opd1,\n+                                      opd2);\n+  return gvn().transform(new ProjNode(gvn().transform(operation), TypeFunc::Parms));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":503,"deletions":15,"binary":false,"changes":518,"status":"modified"},{"patch":"@@ -354,0 +354,19 @@\n+    case VECTOR_OP_TAN:\n+    case VECTOR_OP_TANH:\n+    case VECTOR_OP_SIN:\n+    case VECTOR_OP_SINH:\n+    case VECTOR_OP_COS:\n+    case VECTOR_OP_COSH:\n+    case VECTOR_OP_ASIN:\n+    case VECTOR_OP_ACOS:\n+    case VECTOR_OP_ATAN:\n+    case VECTOR_OP_ATAN2:\n+    case VECTOR_OP_CBRT:\n+    case VECTOR_OP_LOG:\n+    case VECTOR_OP_LOG10:\n+    case VECTOR_OP_LOG1P:\n+    case VECTOR_OP_POW:\n+    case VECTOR_OP_EXP:\n+    case VECTOR_OP_EXPM1:\n+    case VECTOR_OP_HYPOT:\n+      return Op_CallLeafVector;\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -4101,0 +4101,5 @@\n+\n+    if (!FLAG_IS_DEFAULT(UseVectorStubs) && UseVectorStubs) {\n+      warning(\"Disabling UseVectorStubs since EnableVectorSupport is turned off.\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorStubs, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -391,0 +391,4 @@\n+  static int vector_calling_convention(VMRegPair *regs,\n+                                       uint num_bits,\n+                                       uint total_args_passed);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,0 +185,147 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+address StubRoutines::_vector_exp_float64                = NULL;\n+address StubRoutines::_vector_exp_float128               = NULL;\n+address StubRoutines::_vector_exp_float256               = NULL;\n+address StubRoutines::_vector_exp_float512               = NULL;\n+address StubRoutines::_vector_exp_double64               = NULL;\n+address StubRoutines::_vector_exp_double128              = NULL;\n+address StubRoutines::_vector_exp_double256              = NULL;\n+address StubRoutines::_vector_exp_double512              = NULL;\n+address StubRoutines::_vector_expm1_float64              = NULL;\n+address StubRoutines::_vector_expm1_float128             = NULL;\n+address StubRoutines::_vector_expm1_float256             = NULL;\n+address StubRoutines::_vector_expm1_float512             = NULL;\n+address StubRoutines::_vector_expm1_double64             = NULL;\n+address StubRoutines::_vector_expm1_double128            = NULL;\n+address StubRoutines::_vector_expm1_double256            = NULL;\n+address StubRoutines::_vector_expm1_double512            = NULL;\n+address StubRoutines::_vector_log1p_float64              = NULL;\n+address StubRoutines::_vector_log1p_float128             = NULL;\n+address StubRoutines::_vector_log1p_float256             = NULL;\n+address StubRoutines::_vector_log1p_float512             = NULL;\n+address StubRoutines::_vector_log1p_double64             = NULL;\n+address StubRoutines::_vector_log1p_double128            = NULL;\n+address StubRoutines::_vector_log1p_double256            = NULL;\n+address StubRoutines::_vector_log1p_double512            = NULL;\n+address StubRoutines::_vector_log_float64                = NULL;\n+address StubRoutines::_vector_log_float128               = NULL;\n+address StubRoutines::_vector_log_float256               = NULL;\n+address StubRoutines::_vector_log_float512               = NULL;\n+address StubRoutines::_vector_log_double64               = NULL;\n+address StubRoutines::_vector_log_double128              = NULL;\n+address StubRoutines::_vector_log_double256              = NULL;\n+address StubRoutines::_vector_log_double512              = NULL;\n+address StubRoutines::_vector_log10_float64              = NULL;\n+address StubRoutines::_vector_log10_float128             = NULL;\n+address StubRoutines::_vector_log10_float256             = NULL;\n+address StubRoutines::_vector_log10_float512             = NULL;\n+address StubRoutines::_vector_log10_double64             = NULL;\n+address StubRoutines::_vector_log10_double128            = NULL;\n+address StubRoutines::_vector_log10_double256            = NULL;\n+address StubRoutines::_vector_log10_double512            = NULL;\n+address StubRoutines::_vector_sin_float64                = NULL;\n+address StubRoutines::_vector_sin_float128               = NULL;\n+address StubRoutines::_vector_sin_float256               = NULL;\n+address StubRoutines::_vector_sin_float512               = NULL;\n+address StubRoutines::_vector_sin_double64               = NULL;\n+address StubRoutines::_vector_sin_double128              = NULL;\n+address StubRoutines::_vector_sin_double256              = NULL;\n+address StubRoutines::_vector_sin_double512              = NULL;\n+address StubRoutines::_vector_cos_float64                = NULL;\n+address StubRoutines::_vector_cos_float128               = NULL;\n+address StubRoutines::_vector_cos_float256               = NULL;\n+address StubRoutines::_vector_cos_float512               = NULL;\n+address StubRoutines::_vector_cos_double64               = NULL;\n+address StubRoutines::_vector_cos_double128              = NULL;\n+address StubRoutines::_vector_cos_double256              = NULL;\n+address StubRoutines::_vector_cos_double512              = NULL;\n+address StubRoutines::_vector_tan_float64                = NULL;\n+address StubRoutines::_vector_tan_float128               = NULL;\n+address StubRoutines::_vector_tan_float256               = NULL;\n+address StubRoutines::_vector_tan_float512               = NULL;\n+address StubRoutines::_vector_tan_double64               = NULL;\n+address StubRoutines::_vector_tan_double128              = NULL;\n+address StubRoutines::_vector_tan_double256              = NULL;\n+address StubRoutines::_vector_tan_double512              = NULL;\n+address StubRoutines::_vector_sinh_float64               = NULL;\n+address StubRoutines::_vector_sinh_float128               = NULL;\n+address StubRoutines::_vector_sinh_float256               = NULL;\n+address StubRoutines::_vector_sinh_float512               = NULL;\n+address StubRoutines::_vector_sinh_double64               = NULL;\n+address StubRoutines::_vector_sinh_double128              = NULL;\n+address StubRoutines::_vector_sinh_double256              = NULL;\n+address StubRoutines::_vector_sinh_double512              = NULL;\n+address StubRoutines::_vector_cosh_float64                = NULL;\n+address StubRoutines::_vector_cosh_float128               = NULL;\n+address StubRoutines::_vector_cosh_float256               = NULL;\n+address StubRoutines::_vector_cosh_float512               = NULL;\n+address StubRoutines::_vector_cosh_double64               = NULL;\n+address StubRoutines::_vector_cosh_double128              = NULL;\n+address StubRoutines::_vector_cosh_double256              = NULL;\n+address StubRoutines::_vector_cosh_double512              = NULL;\n+address StubRoutines::_vector_tanh_float64                = NULL;\n+address StubRoutines::_vector_tanh_float128               = NULL;\n+address StubRoutines::_vector_tanh_float256               = NULL;\n+address StubRoutines::_vector_tanh_float512               = NULL;\n+address StubRoutines::_vector_tanh_double64               = NULL;\n+address StubRoutines::_vector_tanh_double128              = NULL;\n+address StubRoutines::_vector_tanh_double256              = NULL;\n+address StubRoutines::_vector_tanh_double512              = NULL;\n+address StubRoutines::_vector_acos_float64                = NULL;\n+address StubRoutines::_vector_acos_float128               = NULL;\n+address StubRoutines::_vector_acos_float256               = NULL;\n+address StubRoutines::_vector_acos_float512               = NULL;\n+address StubRoutines::_vector_acos_double64               = NULL;\n+address StubRoutines::_vector_acos_double128              = NULL;\n+address StubRoutines::_vector_acos_double256              = NULL;\n+address StubRoutines::_vector_acos_double512              = NULL;\n+address StubRoutines::_vector_asin_float64                = NULL;\n+address StubRoutines::_vector_asin_float128               = NULL;\n+address StubRoutines::_vector_asin_float256               = NULL;\n+address StubRoutines::_vector_asin_float512               = NULL;\n+address StubRoutines::_vector_asin_double64               = NULL;\n+address StubRoutines::_vector_asin_double128              = NULL;\n+address StubRoutines::_vector_asin_double256              = NULL;\n+address StubRoutines::_vector_asin_double512              = NULL;\n+address StubRoutines::_vector_atan_float64                = NULL;\n+address StubRoutines::_vector_atan_float128               = NULL;\n+address StubRoutines::_vector_atan_float256               = NULL;\n+address StubRoutines::_vector_atan_float512               = NULL;\n+address StubRoutines::_vector_atan_double64               = NULL;\n+address StubRoutines::_vector_atan_double128              = NULL;\n+address StubRoutines::_vector_atan_double256              = NULL;\n+address StubRoutines::_vector_atan_double512              = NULL;\n+address StubRoutines::_vector_pow_float64                 = NULL;\n+address StubRoutines::_vector_pow_float128                = NULL;\n+address StubRoutines::_vector_pow_float256                = NULL;\n+address StubRoutines::_vector_pow_float512                = NULL;\n+address StubRoutines::_vector_pow_double64                = NULL;\n+address StubRoutines::_vector_pow_double128               = NULL;\n+address StubRoutines::_vector_pow_double256               = NULL;\n+address StubRoutines::_vector_pow_double512               = NULL;\n+address StubRoutines::_vector_hypot_float64               = NULL;\n+address StubRoutines::_vector_hypot_float128              = NULL;\n+address StubRoutines::_vector_hypot_float256              = NULL;\n+address StubRoutines::_vector_hypot_float512              = NULL;\n+address StubRoutines::_vector_hypot_double64              = NULL;\n+address StubRoutines::_vector_hypot_double128             = NULL;\n+address StubRoutines::_vector_hypot_double256             = NULL;\n+address StubRoutines::_vector_hypot_double512             = NULL;\n+address StubRoutines::_vector_cbrt_float64                = NULL;\n+address StubRoutines::_vector_cbrt_float128               = NULL;\n+address StubRoutines::_vector_cbrt_float256               = NULL;\n+address StubRoutines::_vector_cbrt_float512               = NULL;\n+address StubRoutines::_vector_cbrt_double64               = NULL;\n+address StubRoutines::_vector_cbrt_double128              = NULL;\n+address StubRoutines::_vector_cbrt_double256              = NULL;\n+address StubRoutines::_vector_cbrt_double512              = NULL;\n+address StubRoutines::_vector_atan2_float64               = NULL;\n+address StubRoutines::_vector_atan2_float128              = NULL;\n+address StubRoutines::_vector_atan2_float256              = NULL;\n+address StubRoutines::_vector_atan2_float512              = NULL;\n+address StubRoutines::_vector_atan2_double64              = NULL;\n+address StubRoutines::_vector_atan2_double128             = NULL;\n+address StubRoutines::_vector_atan2_double256             = NULL;\n+address StubRoutines::_vector_atan2_double512             = NULL;\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":147,"deletions":0,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -268,0 +268,166 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+  \/\/ Vector Math Routines\n+  static address _vector_exp_float64;\n+  static address _vector_exp_float128;\n+  static address _vector_exp_float256;\n+  static address _vector_exp_float512;\n+  static address _vector_exp_double64;\n+  static address _vector_exp_double128;\n+  static address _vector_exp_double256;\n+  static address _vector_exp_double512;\n+\n+  static address _vector_expm1_float64;\n+  static address _vector_expm1_float128;\n+  static address _vector_expm1_float256;\n+  static address _vector_expm1_float512;\n+  static address _vector_expm1_double64;\n+  static address _vector_expm1_double128;\n+  static address _vector_expm1_double256;\n+  static address _vector_expm1_double512;\n+\n+  static address _vector_log1p_float64;\n+  static address _vector_log1p_float128;\n+  static address _vector_log1p_float256;\n+  static address _vector_log1p_float512;\n+  static address _vector_log1p_double64;\n+  static address _vector_log1p_double128;\n+  static address _vector_log1p_double256;\n+  static address _vector_log1p_double512;\n+\n+  static address _vector_log_float64;\n+  static address _vector_log_float128;\n+  static address _vector_log_float256;\n+  static address _vector_log_float512;\n+  static address _vector_log_double64;\n+  static address _vector_log_double128;\n+  static address _vector_log_double256;\n+  static address _vector_log_double512;\n+\n+  static address _vector_log10_float64;\n+  static address _vector_log10_float128;\n+  static address _vector_log10_float256;\n+  static address _vector_log10_float512;\n+  static address _vector_log10_double64;\n+  static address _vector_log10_double128;\n+  static address _vector_log10_double256;\n+  static address _vector_log10_double512;\n+\n+  static address _vector_sin_float64;\n+  static address _vector_sin_float128;\n+  static address _vector_sin_float256;\n+  static address _vector_sin_float512;\n+  static address _vector_sin_double64;\n+  static address _vector_sin_double128;\n+  static address _vector_sin_double256;\n+  static address _vector_sin_double512;\n+\n+  static address _vector_cos_float64;\n+  static address _vector_cos_float128;\n+  static address _vector_cos_float256;\n+  static address _vector_cos_float512;\n+  static address _vector_cos_double64;\n+  static address _vector_cos_double128;\n+  static address _vector_cos_double256;\n+  static address _vector_cos_double512;\n+\n+  static address _vector_tan_float64;\n+  static address _vector_tan_float128;\n+  static address _vector_tan_float256;\n+  static address _vector_tan_float512;\n+  static address _vector_tan_double64;\n+  static address _vector_tan_double128;\n+  static address _vector_tan_double256;\n+  static address _vector_tan_double512;\n+\n+  static address _vector_sinh_float64;\n+  static address _vector_sinh_float128;\n+  static address _vector_sinh_float256;\n+  static address _vector_sinh_float512;\n+  static address _vector_sinh_double64;\n+  static address _vector_sinh_double128;\n+  static address _vector_sinh_double256;\n+  static address _vector_sinh_double512;\n+\n+  static address _vector_cosh_float64;\n+  static address _vector_cosh_float128;\n+  static address _vector_cosh_float256;\n+  static address _vector_cosh_float512;\n+  static address _vector_cosh_double64;\n+  static address _vector_cosh_double128;\n+  static address _vector_cosh_double256;\n+  static address _vector_cosh_double512;\n+\n+  static address _vector_tanh_float64;\n+  static address _vector_tanh_float128;\n+  static address _vector_tanh_float256;\n+  static address _vector_tanh_float512;\n+  static address _vector_tanh_double64;\n+  static address _vector_tanh_double128;\n+  static address _vector_tanh_double256;\n+  static address _vector_tanh_double512;\n+\n+  static address _vector_acos_float64;\n+  static address _vector_acos_float128;\n+  static address _vector_acos_float256;\n+  static address _vector_acos_float512;\n+  static address _vector_acos_double64;\n+  static address _vector_acos_double128;\n+  static address _vector_acos_double256;\n+  static address _vector_acos_double512;\n+\n+  static address _vector_asin_float64;\n+  static address _vector_asin_float128;\n+  static address _vector_asin_float256;\n+  static address _vector_asin_float512;\n+  static address _vector_asin_double64;\n+  static address _vector_asin_double128;\n+  static address _vector_asin_double256;\n+  static address _vector_asin_double512;\n+\n+  static address _vector_atan_float64;\n+  static address _vector_atan_float128;\n+  static address _vector_atan_float256;\n+  static address _vector_atan_float512;\n+  static address _vector_atan_double64;\n+  static address _vector_atan_double128;\n+  static address _vector_atan_double256;\n+  static address _vector_atan_double512;\n+\n+  static address _vector_pow_float64;\n+  static address _vector_pow_float128;\n+  static address _vector_pow_float256;\n+  static address _vector_pow_float512;\n+  static address _vector_pow_double64;\n+  static address _vector_pow_double128;\n+  static address _vector_pow_double256;\n+  static address _vector_pow_double512;\n+\n+  static address _vector_hypot_float64;\n+  static address _vector_hypot_float128;\n+  static address _vector_hypot_float256;\n+  static address _vector_hypot_float512;\n+  static address _vector_hypot_double64;\n+  static address _vector_hypot_double128;\n+  static address _vector_hypot_double256;\n+  static address _vector_hypot_double512;\n+\n+  static address _vector_cbrt_float64;\n+  static address _vector_cbrt_float128;\n+  static address _vector_cbrt_float256;\n+  static address _vector_cbrt_float512;\n+  static address _vector_cbrt_double64;\n+  static address _vector_cbrt_double128;\n+  static address _vector_cbrt_double256;\n+  static address _vector_cbrt_double512;\n+\n+  static address _vector_atan2_float64;\n+  static address _vector_atan2_float128;\n+  static address _vector_atan2_float256;\n+  static address _vector_atan2_float512;\n+  static address _vector_atan2_double64;\n+  static address _vector_atan2_double128;\n+  static address _vector_atan2_double256;\n+  static address _vector_atan2_double512;\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+\n+\n@@ -444,0 +610,165 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+  static address vector_exp_float64()   { return _vector_exp_float64;   }\n+  static address vector_exp_float128()  { return _vector_exp_float128;  }\n+  static address vector_exp_float256()  { return _vector_exp_float256;  }\n+  static address vector_exp_float512()  { return _vector_exp_float512;  }\n+  static address vector_exp_double64()  { return _vector_exp_double64;  }\n+  static address vector_exp_double128() { return _vector_exp_double128; }\n+  static address vector_exp_double256() { return _vector_exp_double256; }\n+  static address vector_exp_double512() { return _vector_exp_double512; }\n+\n+  static address vector_expm1_float64()   { return _vector_expm1_float64;   }\n+  static address vector_expm1_float128()  { return _vector_expm1_float128;  }\n+  static address vector_expm1_float256()  { return _vector_expm1_float256;  }\n+  static address vector_expm1_float512()  { return _vector_expm1_float512;  }\n+  static address vector_expm1_double64()  { return _vector_expm1_double64;  }\n+  static address vector_expm1_double128() { return _vector_expm1_double128; }\n+  static address vector_expm1_double256() { return _vector_expm1_double256; }\n+  static address vector_expm1_double512() { return _vector_expm1_double512; }\n+\n+  static address vector_log1p_float64()   { return _vector_log1p_float64;   }\n+  static address vector_log1p_float128()  { return _vector_log1p_float128;  }\n+  static address vector_log1p_float256()  { return _vector_log1p_float256;  }\n+  static address vector_log1p_float512()  { return _vector_log1p_float512;  }\n+  static address vector_log1p_double64()  { return _vector_log1p_double64;  }\n+  static address vector_log1p_double128() { return _vector_log1p_double128; }\n+  static address vector_log1p_double256() { return _vector_log1p_double256; }\n+  static address vector_log1p_double512() { return _vector_log1p_double512; }\n+\n+  static address vector_log_float64()   { return _vector_log_float64;   }\n+  static address vector_log_float128()  { return _vector_log_float128;  }\n+  static address vector_log_float256()  { return _vector_log_float256;  }\n+  static address vector_log_float512()  { return _vector_log_float512;  }\n+  static address vector_log_double64()  { return _vector_log_double64;  }\n+  static address vector_log_double128() { return _vector_log_double128; }\n+  static address vector_log_double256() { return _vector_log_double256; }\n+  static address vector_log_double512() { return _vector_log_double512; }\n+\n+  static address vector_log10_float64()   { return _vector_log10_float64;   }\n+  static address vector_log10_float128()  { return _vector_log10_float128;  }\n+  static address vector_log10_float256()  { return _vector_log10_float256;  }\n+  static address vector_log10_float512()  { return _vector_log10_float512;  }\n+  static address vector_log10_double64()  { return _vector_log10_double64;  }\n+  static address vector_log10_double128() { return _vector_log10_double128; }\n+  static address vector_log10_double256() { return _vector_log10_double256; }\n+  static address vector_log10_double512() { return _vector_log10_double512; }\n+\n+  static address vector_sin_float64()   { return _vector_sin_float64;   }\n+  static address vector_sin_float128()  { return _vector_sin_float128;  }\n+  static address vector_sin_float256()  { return _vector_sin_float256;  }\n+  static address vector_sin_float512()  { return _vector_sin_float512;  }\n+  static address vector_sin_double64()  { return _vector_sin_double64;  }\n+  static address vector_sin_double128() { return _vector_sin_double128; }\n+  static address vector_sin_double256() { return _vector_sin_double256; }\n+  static address vector_sin_double512() { return _vector_sin_double512; }\n+\n+  static address vector_cos_float64()    { return _vector_cos_float64;   }\n+  static address vector_cos_float128()   { return _vector_cos_float128;  }\n+  static address vector_cos_float256()   { return _vector_cos_float256;  }\n+  static address vector_cos_float512()   { return _vector_cos_float512;  }\n+  static address vector_cos_double64()   { return _vector_cos_double64;  }\n+  static address vector_cos_double128()  { return _vector_cos_double128; }\n+  static address vector_cos_double256()  { return _vector_cos_double256; }\n+  static address vector_cos_double512()  { return _vector_cos_double512; }\n+\n+  static address vector_tan_float64()   { return _vector_tan_float64;   }\n+  static address vector_tan_float128()  { return _vector_tan_float128;  }\n+  static address vector_tan_float256()  { return _vector_tan_float256;  }\n+  static address vector_tan_float512()  { return _vector_tan_float512;  }\n+  static address vector_tan_double64()  { return _vector_tan_double64;  }\n+  static address vector_tan_double128() { return _vector_tan_double128; }\n+  static address vector_tan_double256() { return _vector_tan_double256; }\n+  static address vector_tan_double512() { return _vector_tan_double512; }\n+\n+  static address vector_sinh_float64()   { return _vector_sinh_float64;   }\n+  static address vector_sinh_float128()  { return _vector_sinh_float128;  }\n+  static address vector_sinh_float256()  { return _vector_sinh_float256;  }\n+  static address vector_sinh_float512()  { return _vector_sinh_float512;  }\n+  static address vector_sinh_double64()  { return _vector_sinh_double64;  }\n+  static address vector_sinh_double128() { return _vector_sinh_double128; }\n+  static address vector_sinh_double256() { return _vector_sinh_double256; }\n+  static address vector_sinh_double512() { return _vector_sinh_double512; }\n+\n+  static address vector_cosh_float64()   { return _vector_cosh_float64;   }\n+  static address vector_cosh_float128()  { return _vector_cosh_float128;  }\n+  static address vector_cosh_float256()  { return _vector_cosh_float256;  }\n+  static address vector_cosh_float512()  { return _vector_cosh_float512;  }\n+  static address vector_cosh_double64()  { return _vector_cosh_double64;  }\n+  static address vector_cosh_double128() { return _vector_cosh_double128; }\n+  static address vector_cosh_double256() { return _vector_cosh_double256; }\n+  static address vector_cosh_double512() { return _vector_cosh_double512; }\n+\n+  static address vector_tanh_float64()   { return _vector_tanh_float64;   }\n+  static address vector_tanh_float128()  { return _vector_tanh_float128;  }\n+  static address vector_tanh_float256()  { return _vector_tanh_float256;  }\n+  static address vector_tanh_float512()  { return _vector_tanh_float512;  }\n+  static address vector_tanh_double64()  { return _vector_tanh_double64;  }\n+  static address vector_tanh_double128() { return _vector_tanh_double128; }\n+  static address vector_tanh_double256() { return _vector_tanh_double256; }\n+  static address vector_tanh_double512() { return _vector_tanh_double512; }\n+\n+  static address vector_asin_float64()   { return _vector_asin_float64;   }\n+  static address vector_asin_float128()  { return _vector_asin_float128;  }\n+  static address vector_asin_float256()  { return _vector_asin_float256;  }\n+  static address vector_asin_float512()  { return _vector_asin_float512;  }\n+  static address vector_asin_double64()  { return _vector_asin_double64;  }\n+  static address vector_asin_double128() { return _vector_asin_double128; }\n+  static address vector_asin_double256() { return _vector_asin_double256; }\n+  static address vector_asin_double512() { return _vector_asin_double512; }\n+\n+  static address vector_acos_float64()   { return _vector_acos_float64;   }\n+  static address vector_acos_float128()  { return _vector_acos_float128;  }\n+  static address vector_acos_float256()  { return _vector_acos_float256;  }\n+  static address vector_acos_float512()  { return _vector_acos_float512;  }\n+  static address vector_acos_double64()  { return _vector_acos_double64;  }\n+  static address vector_acos_double128() { return _vector_acos_double128; }\n+  static address vector_acos_double256() { return _vector_acos_double256; }\n+  static address vector_acos_double512() { return _vector_acos_double512; }\n+\n+  static address vector_atan_float64()   { return _vector_atan_float64;   }\n+  static address vector_atan_float128()  { return _vector_atan_float128;  }\n+  static address vector_atan_float256()  { return _vector_atan_float256;  }\n+  static address vector_atan_float512()  { return _vector_atan_float512;  }\n+  static address vector_atan_double64()  { return _vector_atan_double64;  }\n+  static address vector_atan_double128() { return _vector_atan_double128; }\n+  static address vector_atan_double256() { return _vector_atan_double256; }\n+  static address vector_atan_double512() { return _vector_atan_double512; }\n+\n+  static address vector_pow_float64()   { return _vector_pow_float64;   }\n+  static address vector_pow_float128()  { return _vector_pow_float128;  }\n+  static address vector_pow_float256()  { return _vector_pow_float256;  }\n+  static address vector_pow_float512()  { return _vector_pow_float512;  }\n+  static address vector_pow_double64()  { return _vector_pow_double64;  }\n+  static address vector_pow_double128() { return _vector_pow_double128; }\n+  static address vector_pow_double256() { return _vector_pow_double256; }\n+  static address vector_pow_double512() { return _vector_pow_double512; }\n+\n+  static address vector_hypot_float64()   { return _vector_hypot_float64;   }\n+  static address vector_hypot_float128()  { return _vector_hypot_float128;  }\n+  static address vector_hypot_float256()  { return _vector_hypot_float256;  }\n+  static address vector_hypot_float512()  { return _vector_hypot_float512;  }\n+  static address vector_hypot_double64()  { return _vector_hypot_double64;  }\n+  static address vector_hypot_double128() { return _vector_hypot_double128; }\n+  static address vector_hypot_double256() { return _vector_hypot_double256; }\n+  static address vector_hypot_double512() { return _vector_hypot_double512; }\n+\n+  static address vector_cbrt_float64()   { return _vector_cbrt_float64;   }\n+  static address vector_cbrt_float128()  { return _vector_cbrt_float128;  }\n+  static address vector_cbrt_float256()  { return _vector_cbrt_float256;  }\n+  static address vector_cbrt_float512()  { return _vector_cbrt_float512;  }\n+  static address vector_cbrt_double64()  { return _vector_cbrt_double64;  }\n+  static address vector_cbrt_double128() { return _vector_cbrt_double128; }\n+  static address vector_cbrt_double256() { return _vector_cbrt_double256; }\n+  static address vector_cbrt_double512() { return _vector_cbrt_double512; }\n+\n+  static address vector_atan2_float64()   { return _vector_atan2_float64;   }\n+  static address vector_atan2_float128()  { return _vector_atan2_float128;  }\n+  static address vector_atan2_float256()  { return _vector_atan2_float256;  }\n+  static address vector_atan2_float512()  { return _vector_atan2_float512;  }\n+  static address vector_atan2_double64()  { return _vector_atan2_double64;  }\n+  static address vector_atan2_double128() { return _vector_atan2_double128; }\n+  static address vector_atan2_double256() { return _vector_atan2_double256; }\n+  static address vector_atan2_double512() { return _vector_atan2_double512; }\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":331,"deletions":0,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -1534,0 +1534,1 @@\n+  declare_c2_type(CallLeafVectorNode, CallLeafNode)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,20 @@\n+    \/\/ Math routines\n+    public static final int VECTOR_OP_TAN = 101;\n+    public static final int VECTOR_OP_TANH = 102;\n+    public static final int VECTOR_OP_SIN = 103;\n+    public static final int VECTOR_OP_SINH = 104;\n+    public static final int VECTOR_OP_COS = 105;\n+    public static final int VECTOR_OP_COSH = 106;\n+    public static final int VECTOR_OP_ASIN = 107;\n+    public static final int VECTOR_OP_ACOS = 108;\n+    public static final int VECTOR_OP_ATAN = 109;\n+    public static final int VECTOR_OP_ATAN2 = 110;\n+    public static final int VECTOR_OP_CBRT = 111;\n+    public static final int VECTOR_OP_LOG = 112;\n+    public static final int VECTOR_OP_LOG10 = 113;\n+    public static final int VECTOR_OP_LOG1P = 114;\n+    public static final int VECTOR_OP_POW = 115;\n+    public static final int VECTOR_OP_EXP = 116;\n+    public static final int VECTOR_OP_EXPM1 = 117;\n+    public static final int VECTOR_OP_HYPOT = 118;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2826,0 +2826,1 @@\n+\n@@ -2952,1 +2953,1 @@\n-     * Stores this vector into an array of {@code byte}\n+     * Stores this vector into an array of type {@code byte[]}\n@@ -3068,0 +3069,1 @@\n+\n@@ -3174,0 +3176,1 @@\n+\n@@ -3304,0 +3307,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -552,31 +552,0 @@\n-            if (op == SIN) {\n-                return uOp((i, a) -> (double) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> (double) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> (double) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> (double) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> (double) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> (double) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> (double) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> (double) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> (double) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> (double) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> (double) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> (double) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> (double) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> (double) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> (double) Math.log1p(a));\n-            }\n@@ -594,0 +563,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log10(a));\n@@ -596,0 +583,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log1p(a));\n@@ -642,7 +641,0 @@\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> (double) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> (double) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> (double) Math.hypot(a, b));\n-            }\n@@ -668,0 +660,8 @@\n+                case VECTOR_OP_OR: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.hypot(a, b));\n@@ -2733,0 +2733,1 @@\n+\n@@ -2865,1 +2866,1 @@\n-     * Stores this vector into an array of {@code double}\n+     * Stores this vector into an array of type {@code double[]}\n@@ -3022,0 +3023,1 @@\n+\n@@ -3128,0 +3130,1 @@\n+\n@@ -3263,0 +3266,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":43,"deletions":39,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -552,31 +552,0 @@\n-            if (op == SIN) {\n-                return uOp((i, a) -> (float) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> (float) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> (float) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> (float) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> (float) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> (float) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> (float) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> (float) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> (float) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> (float) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> (float) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> (float) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> (float) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> (float) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> (float) Math.log1p(a));\n-            }\n@@ -594,0 +563,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log10(a));\n@@ -596,0 +583,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log1p(a));\n@@ -642,7 +641,0 @@\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> (float) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> (float) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> (float) Math.hypot(a, b));\n-            }\n@@ -668,0 +660,8 @@\n+                case VECTOR_OP_OR: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.hypot(a, b));\n@@ -2739,0 +2739,1 @@\n+\n@@ -2871,1 +2872,1 @@\n-     * Stores this vector into an array of {@code float}\n+     * Stores this vector into an array of type {@code float[]}\n@@ -3009,0 +3010,1 @@\n+\n@@ -3115,0 +3117,1 @@\n+\n@@ -3250,0 +3253,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":43,"deletions":39,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2842,0 +2842,1 @@\n+\n@@ -2974,1 +2975,1 @@\n-     * Stores this vector into an array of {@code int}\n+     * Stores this vector into an array of type {@code int[]}\n@@ -3112,0 +3113,1 @@\n+\n@@ -3218,0 +3220,1 @@\n+\n@@ -3353,0 +3356,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2726,0 +2726,1 @@\n+\n@@ -2858,1 +2859,1 @@\n-     * Stores this vector into an array of {@code long}\n+     * Stores this vector into an array of type {@code long[]}\n@@ -3015,0 +3016,1 @@\n+\n@@ -3121,0 +3123,1 @@\n+\n@@ -3256,0 +3259,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2826,0 +2826,150 @@\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<Short> m) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            ShortVector zero = vsp.zero();\n+            return zero.blend(zero.fromCharArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (short) a[offset + i]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromCharArray(VectorSpecies<Short> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<Short> m) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n@@ -2958,1 +3108,1 @@\n-     * Stores this vector into an array of {@code short}\n+     * Stores this vector into an array of type {@code short[]}\n@@ -3074,0 +3224,152 @@\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        ShortSpecies vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<Short> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            ShortSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see ShortVector#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<Short> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n@@ -3180,0 +3482,15 @@\n+    \/*package-private*\/\n+    abstract\n+    ShortVector fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    ShortVector fromCharArray0Template(char[] a, int offset) {\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+\n@@ -3315,0 +3632,10 @@\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":328,"deletions":1,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -572,33 +572,0 @@\n-#if[FP]\n-            if (op == SIN) {\n-                return uOp((i, a) -> ($type$) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> ($type$) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> ($type$) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> ($type$) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> ($type$) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> ($type$) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> ($type$) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> ($type$) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> ($type$) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> ($type$) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> ($type$) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> ($type$) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> ($type$) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> ($type$) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> ($type$) Math.log1p(a));\n-            }\n-#end[FP]\n@@ -617,0 +584,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log10(a));\n@@ -619,0 +604,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log1p(a));\n@@ -692,9 +689,0 @@\n-#if[FP]\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.hypot(a, b));\n-            }\n-#end[FP]\n@@ -734,0 +722,10 @@\n+#if[FP]\n+                case VECTOR_OP_OR: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.hypot(a, b));\n+#end[FP]\n@@ -3366,0 +3364,152 @@\n+#if[short]\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            $abstractvectortype$ zero = vsp.zero();\n+            return zero.blend(zero.fromCharArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (short) a[offset + i]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+#end[short]\n+\n@@ -3504,1 +3654,1 @@\n-     * Stores this vector into an array of {@code $type$}\n+     * Stores this vector into an array of type {@code $type$[]}\n@@ -3695,0 +3845,154 @@\n+#if[short]\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        $Type$Species vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<$Boxtype$> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+#end[short]\n+\n@@ -3801,0 +4105,17 @@\n+#if[short]\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromCharArray0Template(char[] a, int offset) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+#end[short]\n+\n@@ -3938,0 +4259,12 @@\n+#if[short]\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+#end[short]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":376,"deletions":43,"binary":false,"changes":419,"status":"modified"},{"patch":"@@ -1511,33 +1511,82 @@\n-                        [\"cpy\",    \"__ sve_cpy(z0, __ S, p0, v1);\",                      \"mov\\tz0.s, p0\/m, s1\"],\n-                        [\"inc\",    \"__ sve_inc(r0, __ S);\",                              \"incw\\tx0\"],\n-                        [\"dec\",    \"__ sve_dec(r1, __ H);\",                              \"dech\\tx1\"],\n-                        [\"lsl\",    \"__ sve_lsl(z0, __ B, z1, 7);\",                       \"lsl\\tz0.b, z1.b, #7\"],\n-                        [\"lsl\",    \"__ sve_lsl(z21, __ H, z1, 15);\",                     \"lsl\\tz21.h, z1.h, #15\"],\n-                        [\"lsl\",    \"__ sve_lsl(z0, __ S, z1, 31);\",                      \"lsl\\tz0.s, z1.s, #31\"],\n-                        [\"lsl\",    \"__ sve_lsl(z0, __ D, z1, 63);\",                      \"lsl\\tz0.d, z1.d, #63\"],\n-                        [\"lsr\",    \"__ sve_lsr(z0, __ B, z1, 7);\",                       \"lsr\\tz0.b, z1.b, #7\"],\n-                        [\"asr\",    \"__ sve_asr(z0, __ H, z11, 15);\",                     \"asr\\tz0.h, z11.h, #15\"],\n-                        [\"lsr\",    \"__ sve_lsr(z30, __ S, z1, 31);\",                     \"lsr\\tz30.s, z1.s, #31\"],\n-                        [\"asr\",    \"__ sve_asr(z0, __ D, z1, 63);\",                      \"asr\\tz0.d, z1.d, #63\"],\n-                        [\"addvl\",  \"__ sve_addvl(sp, r0, 31);\",                          \"addvl\\tsp, x0, #31\"],\n-                        [\"addpl\",  \"__ sve_addpl(r1, sp, -32);\",                         \"addpl\\tx1, sp, -32\"],\n-                        [\"cntp\",   \"__ sve_cntp(r8, __ B, p0, p1);\",                     \"cntp\\tx8, p0, p1.b\"],\n-                        [\"dup\",    \"__ sve_dup(z0, __ B, 127);\",                         \"dup\\tz0.b, 127\"],\n-                        [\"dup\",    \"__ sve_dup(z1, __ H, -128);\",                        \"dup\\tz1.h, -128\"],\n-                        [\"dup\",    \"__ sve_dup(z2, __ S, 32512);\",                       \"dup\\tz2.s, 32512\"],\n-                        [\"dup\",    \"__ sve_dup(z7, __ D, -32768);\",                      \"dup\\tz7.d, -32768\"],\n-                        [\"ld1b\",   \"__ sve_ld1b(z0, __ B, p0, Address(sp));\",            \"ld1b\\t{z0.b}, p0\/z, [sp]\"],\n-                        [\"ld1h\",   \"__ sve_ld1h(z10, __ H, p1, Address(sp, -8));\",       \"ld1h\\t{z10.h}, p1\/z, [sp, #-8, MUL VL]\"],\n-                        [\"ld1w\",   \"__ sve_ld1w(z20, __ S, p2, Address(r0, 7));\",        \"ld1w\\t{z20.s}, p2\/z, [x0, #7, MUL VL]\"],\n-                        [\"ld1b\",   \"__ sve_ld1b(z30, __ B, p3, Address(sp, r8));\",       \"ld1b\\t{z30.b}, p3\/z, [sp, x8]\"],\n-                        [\"ld1w\",   \"__ sve_ld1w(z0, __ S, p4, Address(sp, r28));\",       \"ld1w\\t{z0.s}, p4\/z, [sp, x28, LSL #2]\"],\n-                        [\"ld1d\",   \"__ sve_ld1d(z11, __ D, p5, Address(r0, r1));\",       \"ld1d\\t{z11.d}, p5\/z, [x0, x1, LSL #3]\"],\n-                        [\"st1b\",   \"__ sve_st1b(z22, __ B, p6, Address(sp));\",           \"st1b\\t{z22.b}, p6, [sp]\"],\n-                        [\"st1b\",   \"__ sve_st1b(z31, __ B, p7, Address(sp, -8));\",       \"st1b\\t{z31.b}, p7, [sp, #-8, MUL VL]\"],\n-                        [\"st1w\",   \"__ sve_st1w(z0, __ S, p1, Address(r0, 7));\",         \"st1w\\t{z0.s}, p1, [x0, #7, MUL VL]\"],\n-                        [\"st1b\",   \"__ sve_st1b(z0, __ B, p2, Address(sp, r1));\",        \"st1b\\t{z0.b}, p2, [sp, x1]\"],\n-                        [\"st1h\",   \"__ sve_st1h(z0, __ H, p3, Address(sp, r8));\",        \"st1h\\t{z0.h}, p3, [sp, x8, LSL #1]\"],\n-                        [\"st1d\",   \"__ sve_st1d(z0, __ D, p4, Address(r0, r17));\",       \"st1d\\t{z0.d}, p4, [x0, x17, LSL #3]\"],\n-                        [\"ldr\",    \"__ sve_ldr(z0, Address(sp));\",                       \"ldr\\tz0, [sp]\"],\n-                        [\"ldr\",    \"__ sve_ldr(z31, Address(sp, -256));\",                \"ldr\\tz31, [sp, #-256, MUL VL]\"],\n-                        [\"str\",    \"__ sve_str(z8, Address(r8, 255));\",                  \"str\\tz8, [x8, #255, MUL VL]\"],\n+                        [\"cpy\",     \"__ sve_cpy(z0, __ S, p0, v1);\",                      \"mov\\tz0.s, p0\/m, s1\"],\n+                        [\"cpy\",     \"__ sve_cpy(z0, __ B, p0, 127, true);\",               \"mov\\tz0.b, p0\/m, 127\"],\n+                        [\"cpy\",     \"__ sve_cpy(z1, __ H, p0, -128, true);\",              \"mov\\tz1.h, p0\/m, -128\"],\n+                        [\"cpy\",     \"__ sve_cpy(z2, __ S, p0, 32512, true);\",             \"mov\\tz2.s, p0\/m, 32512\"],\n+                        [\"cpy\",     \"__ sve_cpy(z5, __ D, p0, -32768, false);\",           \"mov\\tz5.d, p0\/z, -32768\"],\n+                        [\"cpy\",     \"__ sve_cpy(z10, __ B, p0, -1, false);\",              \"mov\\tz10.b, p0\/z, -1\"],\n+                        [\"cpy\",     \"__ sve_cpy(z11, __ S, p0, -1, false);\",              \"mov\\tz11.s, p0\/z, -1\"],\n+                        [\"inc\",     \"__ sve_inc(r0, __ S);\",                              \"incw\\tx0\"],\n+                        [\"dec\",     \"__ sve_dec(r1, __ H);\",                              \"dech\\tx1\"],\n+                        [\"lsl\",     \"__ sve_lsl(z0, __ B, z1, 7);\",                       \"lsl\\tz0.b, z1.b, #7\"],\n+                        [\"lsl\",     \"__ sve_lsl(z21, __ H, z1, 15);\",                     \"lsl\\tz21.h, z1.h, #15\"],\n+                        [\"lsl\",     \"__ sve_lsl(z0, __ S, z1, 31);\",                      \"lsl\\tz0.s, z1.s, #31\"],\n+                        [\"lsl\",     \"__ sve_lsl(z0, __ D, z1, 63);\",                      \"lsl\\tz0.d, z1.d, #63\"],\n+                        [\"lsr\",     \"__ sve_lsr(z0, __ B, z1, 7);\",                       \"lsr\\tz0.b, z1.b, #7\"],\n+                        [\"asr\",     \"__ sve_asr(z0, __ H, z11, 15);\",                     \"asr\\tz0.h, z11.h, #15\"],\n+                        [\"lsr\",     \"__ sve_lsr(z30, __ S, z1, 31);\",                     \"lsr\\tz30.s, z1.s, #31\"],\n+                        [\"asr\",     \"__ sve_asr(z0, __ D, z1, 63);\",                      \"asr\\tz0.d, z1.d, #63\"],\n+                        [\"addvl\",   \"__ sve_addvl(sp, r0, 31);\",                          \"addvl\\tsp, x0, #31\"],\n+                        [\"addpl\",   \"__ sve_addpl(r1, sp, -32);\",                         \"addpl\\tx1, sp, -32\"],\n+                        [\"cntp\",    \"__ sve_cntp(r8, __ B, p0, p1);\",                     \"cntp\\tx8, p0, p1.b\"],\n+                        [\"dup\",     \"__ sve_dup(z0, __ B, 127);\",                         \"dup\\tz0.b, 127\"],\n+                        [\"dup\",     \"__ sve_dup(z1, __ H, -128);\",                        \"dup\\tz1.h, -128\"],\n+                        [\"dup\",     \"__ sve_dup(z2, __ S, 32512);\",                       \"dup\\tz2.s, 32512\"],\n+                        [\"dup\",     \"__ sve_dup(z7, __ D, -32768);\",                      \"dup\\tz7.d, -32768\"],\n+                        [\"dup\",     \"__ sve_dup(z10, __ B, -1);\",                         \"dup\\tz10.b, -1\"],\n+                        [\"dup\",     \"__ sve_dup(z11, __ S, -1);\",                         \"dup\\tz11.s, -1\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ B, p0, Address(sp));\",            \"ld1b\\t{z0.b}, p0\/z, [sp]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ H, p1, Address(sp));\",            \"ld1b\\t{z0.h}, p1\/z, [sp]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ S, p2, Address(sp, r8));\",        \"ld1b\\t{z0.s}, p2\/z, [sp, x8]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ D, p3, Address(sp, 7));\",         \"ld1b\\t{z0.d}, p3\/z, [sp, #7, MUL VL]\"],\n+                        [\"ld1h\",    \"__ sve_ld1h(z10, __ H, p1, Address(sp, -8));\",       \"ld1h\\t{z10.h}, p1\/z, [sp, #-8, MUL VL]\"],\n+                        [\"ld1w\",    \"__ sve_ld1w(z20, __ S, p2, Address(r0, 7));\",        \"ld1w\\t{z20.s}, p2\/z, [x0, #7, MUL VL]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z30, __ B, p3, Address(sp, r8));\",       \"ld1b\\t{z30.b}, p3\/z, [sp, x8]\"],\n+                        [\"ld1w\",    \"__ sve_ld1w(z0, __ S, p4, Address(sp, r28));\",       \"ld1w\\t{z0.s}, p4\/z, [sp, x28, LSL #2]\"],\n+                        [\"ld1d\",    \"__ sve_ld1d(z11, __ D, p5, Address(r0, r1));\",       \"ld1d\\t{z11.d}, p5\/z, [x0, x1, LSL #3]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z22, __ B, p6, Address(sp));\",           \"st1b\\t{z22.b}, p6, [sp]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z31, __ B, p7, Address(sp, -8));\",       \"st1b\\t{z31.b}, p7, [sp, #-8, MUL VL]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ H, p1, Address(sp));\",            \"st1b\\t{z0.h}, p1, [sp]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ S, p2, Address(sp, r8));\",        \"st1b\\t{z0.s}, p2, [sp, x8]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ D, p3, Address(sp));\",            \"st1b\\t{z0.d}, p3, [sp]\"],\n+                        [\"st1w\",    \"__ sve_st1w(z0, __ S, p1, Address(r0, 7));\",         \"st1w\\t{z0.s}, p1, [x0, #7, MUL VL]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ B, p2, Address(sp, r1));\",        \"st1b\\t{z0.b}, p2, [sp, x1]\"],\n+                        [\"st1h\",    \"__ sve_st1h(z0, __ H, p3, Address(sp, r8));\",        \"st1h\\t{z0.h}, p3, [sp, x8, LSL #1]\"],\n+                        [\"st1d\",    \"__ sve_st1d(z0, __ D, p4, Address(r0, r17));\",       \"st1d\\t{z0.d}, p4, [x0, x17, LSL #3]\"],\n+                        [\"ldr\",     \"__ sve_ldr(z0, Address(sp));\",                       \"ldr\\tz0, [sp]\"],\n+                        [\"ldr\",     \"__ sve_ldr(z31, Address(sp, -256));\",                \"ldr\\tz31, [sp, #-256, MUL VL]\"],\n+                        [\"str\",     \"__ sve_str(z8, Address(r8, 255));\",                  \"str\\tz8, [x8, #255, MUL VL]\"],\n+                        [\"sel\",     \"__ sve_sel(z0, __ B, p0, z1, z2);\",                  \"sel\\tz0.b, p0, z1.b, z2.b\"],\n+                        [\"sel\",     \"__ sve_sel(z4, __ D, p0, z5, z6);\",                  \"sel\\tz4.d, p0, z5.d, z6.d\"],\n+                        [\"cmpeq\",   \"__ sve_cmpeq(p1, __ B, p0, z0, z1);\",                \"cmpeq\\tp1.b, p0\/z, z0.b, z1.b\"],\n+                        [\"cmpne\",   \"__ sve_cmpne(p1, __ H, p0, z2, z3);\",                \"cmpne\\tp1.h, p0\/z, z2.h, z3.h\"],\n+                        [\"cmpge\",   \"__ sve_cmpge(p1, __ S, p2, z4, z5);\",                \"cmpge\\tp1.s, p2\/z, z4.s, z5.s\"],\n+                        [\"cmpgt\",   \"__ sve_cmpgt(p1, __ D, p3, z6, z7);\",                \"cmpgt\\tp1.d, p3\/z, z6.d, z7.d\"],\n+                        [\"cmple\",   \"__ sve_cmpge(p2, __ B, p0, z10, z11);\",              \"cmple\\tp2.b, p0\/z, z11.b, z10.b\"],\n+                        [\"cmplt\",   \"__ sve_cmpgt(p3, __ S, p0, z16, z17);\",              \"cmplt\\tp3.s, p0\/z, z17.s, z16.s\"],\n+                        [\"cmpeq\",   \"__ sve_cmpeq(p1, __ B, p4, z0, 15);\",                \"cmpeq\\tp1.b, p4\/z, z0.b, #15\"],\n+                        [\"cmpne\",   \"__ sve_cmpne(p1, __ H, p0, z2, -16);\",               \"cmpne\\tp1.h, p0\/z, z2.h, #-16\"],\n+                        [\"cmple\",   \"__ sve_cmple(p1, __ S, p1, z4, 0);\",                 \"cmple\\tp1.s, p1\/z, z4.s, #0\"],\n+                        [\"cmplt\",   \"__ sve_cmplt(p1, __ D, p2, z6, -1);\",                \"cmplt\\tp1.d, p2\/z, z6.d, #-1\"],\n+                        [\"cmpge\",   \"__ sve_cmpge(p1, __ S, p3, z4, 5);\",                 \"cmpge\\tp1.s, p3\/z, z4.s, #5\"],\n+                        [\"cmpgt\",   \"__ sve_cmpgt(p1, __ B, p4, z6, -2);\",                \"cmpgt\\tp1.b, p4\/z, z6.b, #-2\"],\n+                        [\"fcmeq\",   \"__ sve_fcmeq(p1, __ S, p0, z0, z1);\",                \"fcmeq\\tp1.s, p0\/z, z0.s, z1.s\"],\n+                        [\"fcmne\",   \"__ sve_fcmne(p1, __ D, p0, z2, z3);\",                \"fcmne\\tp1.d, p0\/z, z2.d, z3.d\"],\n+                        [\"fcmgt\",   \"__ sve_fcmgt(p1, __ S, p2, z4, z5);\",                \"fcmgt\\tp1.s, p2\/z, z4.s, z5.s\"],\n+                        [\"fcmge\",   \"__ sve_fcmge(p1, __ D, p3, z6, z7);\",                \"fcmge\\tp1.d, p3\/z, z6.d, z7.d\"],\n+                        [\"fcmlt\",   \"__ sve_fcmgt(p2, __ S, p0, z10, z11);\",              \"fcmlt\\tp2.s, p0\/z, z11.s, z10.s\"],\n+                        [\"fcmle\",   \"__ sve_fcmge(p3, __ D, p0, z16, z17);\",              \"fcmle\\tp3.d, p0\/z, z17.d, z16.d\"],\n+                        [\"uunpkhi\", \"__ sve_uunpkhi(z0, __ H, z1);\",                      \"uunpkhi\\tz0.h, z1.b\"],\n+                        [\"uunpklo\", \"__ sve_uunpklo(z4, __ S, z5);\",                      \"uunpklo\\tz4.s, z5.h\"],\n+                        [\"sunpkhi\", \"__ sve_sunpkhi(z6, __ D, z7);\",                      \"sunpkhi\\tz6.d, z7.s\"],\n+                        [\"sunpklo\", \"__ sve_sunpklo(z10, __ H, z11);\",                    \"sunpklo\\tz10.h, z11.b\"],\n+                        [\"whilelt\", \"__ sve_whilelt(p0, __ B, r1, r2);\",                  \"whilelt\\tp0.b, x1, x2\"],\n+                        [\"whilelt\", \"__ sve_whileltw(p1, __ H, r3, r4);\",                 \"whilelt\\tp1.h, w3, w4\"],\n+                        [\"whilele\", \"__ sve_whilele(p2, __ S, r5, r6);\",                  \"whilele\\tp2.s, x5, x6\"],\n+                        [\"whilele\", \"__ sve_whilelew(p3, __ D, r10, r11);\",               \"whilele\\tp3.d, w10, w11\"],\n+                        [\"whilelo\", \"__ sve_whilelo(p4, __ B, r1, r2);\",                  \"whilelo\\tp4.b, x1, x2\"],\n+                        [\"whilelo\", \"__ sve_whilelow(p0, __ H, r3, r4);\",                 \"whilelo\\tp0.h, w3, w4\"],\n+                        [\"whilels\", \"__ sve_whilels(p1, __ S, r5, r6);\",                  \"whilels\\tp1.s, x5, x6\"],\n+                        [\"whilels\", \"__ sve_whilelsw(p2, __ D, r10, r11);\",               \"whilels\\tp2.d, w10, w11\"],\n+                        [\"scvtf\",   \"__ sve_scvtf(z1, __ D, p0, z0, __ S);\",              \"scvtf\\tz1.d, p0\/m, z0.s\"],\n+                        [\"ucvtf\",   \"__ sve_ucvtf(z3, __ D, p1, z2, __ S);\",              \"ucvtf\\tz3.d, p1\/m, z2.s\"],\n+                        [\"fcvt\",    \"__ sve_fcvt(z5, __ D, p3, z4, __ S);\",               \"fcvt\\tz5.d, p3\/m, z4.s\"],\n@@ -1612,0 +1661,2 @@\n+                       [\"uzp1\", \"ZZZ\"],\n+                       [\"uzp2\", \"ZZZ\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":84,"deletions":33,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -697,0 +697,6 @@\n+    __ sve_cpy(z0, __ B, p0, 127, true);               \/\/       mov     z0.b, p0\/m, 127\n+    __ sve_cpy(z1, __ H, p0, -128, true);              \/\/       mov     z1.h, p0\/m, -128\n+    __ sve_cpy(z2, __ S, p0, 32512, true);             \/\/       mov     z2.s, p0\/m, 32512\n+    __ sve_cpy(z5, __ D, p0, -32768, false);           \/\/       mov     z5.d, p0\/z, -32768\n+    __ sve_cpy(z10, __ B, p0, -1, false);              \/\/       mov     z10.b, p0\/z, -1\n+    __ sve_cpy(z11, __ S, p0, -1, false);              \/\/       mov     z11.s, p0\/z, -1\n@@ -714,0 +720,2 @@\n+    __ sve_dup(z10, __ B, -1);                         \/\/       dup     z10.b, -1\n+    __ sve_dup(z11, __ S, -1);                         \/\/       dup     z11.s, -1\n@@ -715,0 +723,3 @@\n+    __ sve_ld1b(z0, __ H, p1, Address(sp));            \/\/       ld1b    {z0.h}, p1\/z, [sp]\n+    __ sve_ld1b(z0, __ S, p2, Address(sp, r8));        \/\/       ld1b    {z0.s}, p2\/z, [sp, x8]\n+    __ sve_ld1b(z0, __ D, p3, Address(sp, 7));         \/\/       ld1b    {z0.d}, p3\/z, [sp, #7, MUL VL]\n@@ -722,0 +733,3 @@\n+    __ sve_st1b(z0, __ H, p1, Address(sp));            \/\/       st1b    {z0.h}, p1, [sp]\n+    __ sve_st1b(z0, __ S, p2, Address(sp, r8));        \/\/       st1b    {z0.s}, p2, [sp, x8]\n+    __ sve_st1b(z0, __ D, p3, Address(sp));            \/\/       st1b    {z0.d}, p3, [sp]\n@@ -729,0 +743,35 @@\n+    __ sve_sel(z0, __ B, p0, z1, z2);                  \/\/       sel     z0.b, p0, z1.b, z2.b\n+    __ sve_sel(z4, __ D, p0, z5, z6);                  \/\/       sel     z4.d, p0, z5.d, z6.d\n+    __ sve_cmpeq(p1, __ B, p0, z0, z1);                \/\/       cmpeq   p1.b, p0\/z, z0.b, z1.b\n+    __ sve_cmpne(p1, __ H, p0, z2, z3);                \/\/       cmpne   p1.h, p0\/z, z2.h, z3.h\n+    __ sve_cmpge(p1, __ S, p2, z4, z5);                \/\/       cmpge   p1.s, p2\/z, z4.s, z5.s\n+    __ sve_cmpgt(p1, __ D, p3, z6, z7);                \/\/       cmpgt   p1.d, p3\/z, z6.d, z7.d\n+    __ sve_cmpge(p2, __ B, p0, z10, z11);              \/\/       cmple   p2.b, p0\/z, z11.b, z10.b\n+    __ sve_cmpgt(p3, __ S, p0, z16, z17);              \/\/       cmplt   p3.s, p0\/z, z17.s, z16.s\n+    __ sve_cmpeq(p1, __ B, p4, z0, 15);                \/\/       cmpeq   p1.b, p4\/z, z0.b, #15\n+    __ sve_cmpne(p1, __ H, p0, z2, -16);               \/\/       cmpne   p1.h, p0\/z, z2.h, #-16\n+    __ sve_cmple(p1, __ S, p1, z4, 0);                 \/\/       cmple   p1.s, p1\/z, z4.s, #0\n+    __ sve_cmplt(p1, __ D, p2, z6, -1);                \/\/       cmplt   p1.d, p2\/z, z6.d, #-1\n+    __ sve_cmpge(p1, __ S, p3, z4, 5);                 \/\/       cmpge   p1.s, p3\/z, z4.s, #5\n+    __ sve_cmpgt(p1, __ B, p4, z6, -2);                \/\/       cmpgt   p1.b, p4\/z, z6.b, #-2\n+    __ sve_fcmeq(p1, __ S, p0, z0, z1);                \/\/       fcmeq   p1.s, p0\/z, z0.s, z1.s\n+    __ sve_fcmne(p1, __ D, p0, z2, z3);                \/\/       fcmne   p1.d, p0\/z, z2.d, z3.d\n+    __ sve_fcmgt(p1, __ S, p2, z4, z5);                \/\/       fcmgt   p1.s, p2\/z, z4.s, z5.s\n+    __ sve_fcmge(p1, __ D, p3, z6, z7);                \/\/       fcmge   p1.d, p3\/z, z6.d, z7.d\n+    __ sve_fcmgt(p2, __ S, p0, z10, z11);              \/\/       fcmlt   p2.s, p0\/z, z11.s, z10.s\n+    __ sve_fcmge(p3, __ D, p0, z16, z17);              \/\/       fcmle   p3.d, p0\/z, z17.d, z16.d\n+    __ sve_uunpkhi(z0, __ H, z1);                      \/\/       uunpkhi z0.h, z1.b\n+    __ sve_uunpklo(z4, __ S, z5);                      \/\/       uunpklo z4.s, z5.h\n+    __ sve_sunpkhi(z6, __ D, z7);                      \/\/       sunpkhi z6.d, z7.s\n+    __ sve_sunpklo(z10, __ H, z11);                    \/\/       sunpklo z10.h, z11.b\n+    __ sve_whilelt(p0, __ B, r1, r2);                  \/\/       whilelt p0.b, x1, x2\n+    __ sve_whileltw(p1, __ H, r3, r4);                 \/\/       whilelt p1.h, w3, w4\n+    __ sve_whilele(p2, __ S, r5, r6);                  \/\/       whilele p2.s, x5, x6\n+    __ sve_whilelew(p3, __ D, r10, r11);               \/\/       whilele p3.d, w10, w11\n+    __ sve_whilelo(p4, __ B, r1, r2);                  \/\/       whilelo p4.b, x1, x2\n+    __ sve_whilelow(p0, __ H, r3, r4);                 \/\/       whilelo p0.h, w3, w4\n+    __ sve_whilels(p1, __ S, r5, r6);                  \/\/       whilels p1.s, x5, x6\n+    __ sve_whilelsw(p2, __ D, r10, r11);               \/\/       whilels p2.d, w10, w11\n+    __ sve_scvtf(z1, __ D, p0, z0, __ S);              \/\/       scvtf   z1.d, p0\/m, z0.s\n+    __ sve_ucvtf(z3, __ D, p1, z2, __ S);              \/\/       ucvtf   z3.d, p1\/m, z2.s\n+    __ sve_fcvt(z5, __ D, p3, z4, __ S);               \/\/       fcvt    z5.d, p3\/m, z4.s\n@@ -903,0 +952,2 @@\n+    __ sve_uzp1(z13, __ B, z22, z11);                  \/\/       uzp1    z13.b, z22.b, z11.b\n+    __ sve_uzp2(z13, __ S, z8, z20);                   \/\/       uzp2    z13.s, z8.s, z20.s\n@@ -905,9 +956,9 @@\n-    __ sve_andv(v13, __ B, p5, z11);                   \/\/       andv b13, p5, z11.b\n-    __ sve_orv(v13, __ S, p2, z20);                    \/\/       orv s13, p2, z20.s\n-    __ sve_eorv(v25, __ B, p3, z4);                    \/\/       eorv b25, p3, z4.b\n-    __ sve_smaxv(v17, __ D, p2, z6);                   \/\/       smaxv d17, p2, z6.d\n-    __ sve_sminv(v4, __ D, p7, z16);                   \/\/       sminv d4, p7, z16.d\n-    __ sve_fminv(v26, __ S, p2, z14);                  \/\/       fminv s26, p2, z14.s\n-    __ sve_fmaxv(v11, __ S, p7, z3);                   \/\/       fmaxv s11, p7, z3.s\n-    __ sve_fadda(v1, __ D, p6, z21);                   \/\/       fadda d1, p6, d1, z21.d\n-    __ sve_uaddv(v14, __ S, p2, z17);                  \/\/       uaddv d14, p2, z17.s\n+    __ sve_andv(v25, __ B, p3, z4);                    \/\/       andv b25, p3, z4.b\n+    __ sve_orv(v17, __ D, p2, z6);                     \/\/       orv d17, p2, z6.d\n+    __ sve_eorv(v4, __ D, p7, z16);                    \/\/       eorv d4, p7, z16.d\n+    __ sve_smaxv(v26, __ B, p2, z14);                  \/\/       smaxv b26, p2, z14.b\n+    __ sve_sminv(v11, __ B, p7, z3);                   \/\/       sminv b11, p7, z3.b\n+    __ sve_fminv(v1, __ D, p6, z21);                   \/\/       fminv d1, p6, z21.d\n+    __ sve_fmaxv(v14, __ D, p2, z17);                  \/\/       fmaxv d14, p2, z17.d\n+    __ sve_fadda(v24, __ D, p1, z19);                  \/\/       fadda d24, p1, d24, z19.d\n+    __ sve_uaddv(v17, __ D, p5, z16);                  \/\/       uaddv d17, p5, z16.d\n@@ -932,7 +983,7 @@\n-    0x14000000,     0x17ffffd7,     0x140002db,     0x94000000,\n-    0x97ffffd4,     0x940002d8,     0x3400000a,     0x34fffa2a,\n-    0x34005aaa,     0x35000008,     0x35fff9c8,     0x35005a48,\n-    0xb400000b,     0xb4fff96b,     0xb40059eb,     0xb500001d,\n-    0xb5fff91d,     0xb500599d,     0x10000013,     0x10fff8b3,\n-    0x10005933,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363058b6,     0x3758000c,     0x375ff7cc,     0x3758584c,\n+    0x14000000,     0x17ffffd7,     0x1400030e,     0x94000000,\n+    0x97ffffd4,     0x9400030b,     0x3400000a,     0x34fffa2a,\n+    0x3400610a,     0x35000008,     0x35fff9c8,     0x350060a8,\n+    0xb400000b,     0xb4fff96b,     0xb400604b,     0xb500001d,\n+    0xb5fff91d,     0xb5005ffd,     0x10000013,     0x10fff8b3,\n+    0x10005f93,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36305f16,     0x3758000c,     0x375ff7cc,     0x37585eac,\n@@ -943,13 +994,13 @@\n-    0x54005620,     0x54000001,     0x54fff541,     0x540055c1,\n-    0x54000002,     0x54fff4e2,     0x54005562,     0x54000002,\n-    0x54fff482,     0x54005502,     0x54000003,     0x54fff423,\n-    0x540054a3,     0x54000003,     0x54fff3c3,     0x54005443,\n-    0x54000004,     0x54fff364,     0x540053e4,     0x54000005,\n-    0x54fff305,     0x54005385,     0x54000006,     0x54fff2a6,\n-    0x54005326,     0x54000007,     0x54fff247,     0x540052c7,\n-    0x54000008,     0x54fff1e8,     0x54005268,     0x54000009,\n-    0x54fff189,     0x54005209,     0x5400000a,     0x54fff12a,\n-    0x540051aa,     0x5400000b,     0x54fff0cb,     0x5400514b,\n-    0x5400000c,     0x54fff06c,     0x540050ec,     0x5400000d,\n-    0x54fff00d,     0x5400508d,     0x5400000e,     0x54ffefae,\n-    0x5400502e,     0x5400000f,     0x54ffef4f,     0x54004fcf,\n+    0x54005c80,     0x54000001,     0x54fff541,     0x54005c21,\n+    0x54000002,     0x54fff4e2,     0x54005bc2,     0x54000002,\n+    0x54fff482,     0x54005b62,     0x54000003,     0x54fff423,\n+    0x54005b03,     0x54000003,     0x54fff3c3,     0x54005aa3,\n+    0x54000004,     0x54fff364,     0x54005a44,     0x54000005,\n+    0x54fff305,     0x540059e5,     0x54000006,     0x54fff2a6,\n+    0x54005986,     0x54000007,     0x54fff247,     0x54005927,\n+    0x54000008,     0x54fff1e8,     0x540058c8,     0x54000009,\n+    0x54fff189,     0x54005869,     0x5400000a,     0x54fff12a,\n+    0x5400580a,     0x5400000b,     0x54fff0cb,     0x540057ab,\n+    0x5400000c,     0x54fff06c,     0x5400574c,     0x5400000d,\n+    0x54fff00d,     0x540056ed,     0x5400000e,     0x54ffefae,\n+    0x5400568e,     0x5400000f,     0x54ffef4f,     0x5400562f,\n@@ -987,1 +1038,1 @@\n-    0xbd1b1869,     0x5800401b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x5800467b,     0x1800000b,     0xf8945060,\n@@ -1067,49 +1118,62 @@\n-    0x4cc0ac3f,     0x05a08020,     0x04b0e3e0,     0x0470e7e1,\n-    0x042f9c20,     0x043f9c35,     0x047f9c20,     0x04ff9c20,\n-    0x04299420,     0x04319160,     0x0461943e,     0x04a19020,\n-    0x042053ff,     0x047f5401,     0x25208028,     0x2538cfe0,\n-    0x2578d001,     0x25b8efe2,     0x25f8f007,     0xa400a3e0,\n-    0xa4a8a7ea,     0xa547a814,     0xa4084ffe,     0xa55c53e0,\n-    0xa5e1540b,     0xe400fbf6,     0xe408ffff,     0xe547e400,\n-    0xe4014be0,     0xe4a84fe0,     0xe5f15000,     0x858043e0,\n-    0x85a043ff,     0xe59f5d08,     0x1e601000,     0x1e603000,\n-    0x1e621000,     0x1e623000,     0x1e641000,     0x1e643000,\n-    0x1e661000,     0x1e663000,     0x1e681000,     0x1e683000,\n-    0x1e6a1000,     0x1e6a3000,     0x1e6c1000,     0x1e6c3000,\n-    0x1e6e1000,     0x1e6e3000,     0x1e701000,     0x1e703000,\n-    0x1e721000,     0x1e723000,     0x1e741000,     0x1e743000,\n-    0x1e761000,     0x1e763000,     0x1e781000,     0x1e783000,\n-    0x1e7a1000,     0x1e7a3000,     0x1e7c1000,     0x1e7c3000,\n-    0x1e7e1000,     0x1e7e3000,     0xf8238358,     0xf83702af,\n-    0xf8231118,     0xf8392214,     0xf8313022,     0xf8205098,\n-    0xf82343ec,     0xf83c734a,     0xf82261ec,     0xf8bf81a1,\n-    0xf8bd0260,     0xf8ac12d1,     0xf8ad23dc,     0xf8bf3341,\n-    0xf8bc53c4,     0xf8a443c6,     0xf8ba7130,     0xf8a8600c,\n-    0xf8f48301,     0xf8e20120,     0xf8f8121a,     0xf8fe2143,\n-    0xf8f7308a,     0xf8f05162,     0xf8e841ea,     0xf8f17142,\n-    0xf8ec61ec,     0xf86d80e2,     0xf874021a,     0xf8641082,\n-    0xf86c22b0,     0xf8703170,     0xf8755197,     0xf87a4397,\n-    0xf86e730b,     0xf86163ec,     0xb82a80f0,     0xb82201a3,\n-    0xb8331211,     0xb8232161,     0xb83e3105,     0xb82f53dd,\n-    0xb82040f4,     0xb8347397,     0xb835633b,     0xb8a582e1,\n-    0xb8b000bf,     0xb8ac1389,     0xb8af22dd,     0xb8bf33f3,\n-    0xb8a551ee,     0xb8bf4370,     0xb8b47190,     0xb8ab60c9,\n-    0xb8fe8371,     0xb8fc00fe,     0xb8ea1154,     0xb8e42238,\n-    0xb8f13076,     0xb8fd52cf,     0xb8f342d3,     0xb8e270cf,\n-    0xb8ec6170,     0xb86d8037,     0xb87e00b3,     0xb8711202,\n-    0xb876214d,     0xb875337d,     0xb86c507b,     0xb861431f,\n-    0xb8737131,     0xb87c61fb,     0xce367a86,     0xce1e6858,\n-    0xce768d51,     0xce910451,     0xce768338,     0xce6c8622,\n-    0xcec08363,     0xce708b9d,     0x04e900da,     0x042404f1,\n-    0x6596012f,     0x65d40b62,     0x65c00745,     0x0456a72e,\n-    0x04c0175b,     0x04109418,     0x041ab006,     0x0413812f,\n-    0x04118b65,     0x04101694,     0x04d7aa0a,     0x045eb046,\n-    0x04c81c5d,     0x044a1dd6,     0x040112fb,     0x04dcad42,\n-    0x65809aca,     0x658d9603,     0x65c69201,     0x65878d8c,\n-    0x65c28290,     0x04dda4e5,     0x65c2be0c,     0x6580a386,\n-    0x65c1a624,     0x658dae6d,     0x65819638,     0x65f318ca,\n-    0x65a030cd,     0x65a8532e,     0x65bb76d6,     0x04144e23,\n-    0x04407ce4,     0x04363270,     0x04b6312f,     0x047e30b9,\n-    0x041a356d,     0x04982a8d,     0x04192c99,     0x04c828d1,\n-    0x04ca3e04,     0x658729da,     0x65863c6b,     0x65d83aa1,\n-    0x04812a2e,\n+    0x4cc0ac3f,     0x05a08020,     0x05104fe0,     0x05505001,\n+    0x05906fe2,     0x05d03005,     0x05101fea,     0x05901feb,\n+    0x04b0e3e0,     0x0470e7e1,     0x042f9c20,     0x043f9c35,\n+    0x047f9c20,     0x04ff9c20,     0x04299420,     0x04319160,\n+    0x0461943e,     0x04a19020,     0x042053ff,     0x047f5401,\n+    0x25208028,     0x2538cfe0,     0x2578d001,     0x25b8efe2,\n+    0x25f8f007,     0x2538dfea,     0x25b8dfeb,     0xa400a3e0,\n+    0xa420a7e0,     0xa4484be0,     0xa467afe0,     0xa4a8a7ea,\n+    0xa547a814,     0xa4084ffe,     0xa55c53e0,     0xa5e1540b,\n+    0xe400fbf6,     0xe408ffff,     0xe420e7e0,     0xe4484be0,\n+    0xe460efe0,     0xe547e400,     0xe4014be0,     0xe4a84fe0,\n+    0xe5f15000,     0x858043e0,     0x85a043ff,     0xe59f5d08,\n+    0x0522c020,     0x05e6c0a4,     0x2401a001,     0x2443a051,\n+    0x24858881,     0x24c78cd1,     0x240b8142,     0x24918213,\n+    0x250f9001,     0x25508051,     0x25802491,     0x25df28c1,\n+    0x25850c81,     0x251e10d1,     0x65816001,     0x65c36051,\n+    0x65854891,     0x65c74cc1,     0x658b4152,     0x65d14203,\n+    0x05733820,     0x05b238a4,     0x05f138e6,     0x0570396a,\n+    0x25221420,     0x25640461,     0x25a614b2,     0x25eb0553,\n+    0x25221c24,     0x25640c60,     0x25a61cb1,     0x25eb0d52,\n+    0x65d0a001,     0x65d1a443,     0x65cbac85,     0x1e601000,\n+    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n+    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n+    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n+    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n+    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n+    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n+    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n+    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf8238358,\n+    0xf83702af,     0xf8231118,     0xf8392214,     0xf8313022,\n+    0xf8205098,     0xf82343ec,     0xf83c734a,     0xf82261ec,\n+    0xf8bf81a1,     0xf8bd0260,     0xf8ac12d1,     0xf8ad23dc,\n+    0xf8bf3341,     0xf8bc53c4,     0xf8a443c6,     0xf8ba7130,\n+    0xf8a8600c,     0xf8f48301,     0xf8e20120,     0xf8f8121a,\n+    0xf8fe2143,     0xf8f7308a,     0xf8f05162,     0xf8e841ea,\n+    0xf8f17142,     0xf8ec61ec,     0xf86d80e2,     0xf874021a,\n+    0xf8641082,     0xf86c22b0,     0xf8703170,     0xf8755197,\n+    0xf87a4397,     0xf86e730b,     0xf86163ec,     0xb82a80f0,\n+    0xb82201a3,     0xb8331211,     0xb8232161,     0xb83e3105,\n+    0xb82f53dd,     0xb82040f4,     0xb8347397,     0xb835633b,\n+    0xb8a582e1,     0xb8b000bf,     0xb8ac1389,     0xb8af22dd,\n+    0xb8bf33f3,     0xb8a551ee,     0xb8bf4370,     0xb8b47190,\n+    0xb8ab60c9,     0xb8fe8371,     0xb8fc00fe,     0xb8ea1154,\n+    0xb8e42238,     0xb8f13076,     0xb8fd52cf,     0xb8f342d3,\n+    0xb8e270cf,     0xb8ec6170,     0xb86d8037,     0xb87e00b3,\n+    0xb8711202,     0xb876214d,     0xb875337d,     0xb86c507b,\n+    0xb861431f,     0xb8737131,     0xb87c61fb,     0xce367a86,\n+    0xce1e6858,     0xce768d51,     0xce910451,     0xce768338,\n+    0xce6c8622,     0xcec08363,     0xce708b9d,     0x04e900da,\n+    0x042404f1,     0x6596012f,     0x65d40b62,     0x65c00745,\n+    0x0456a72e,     0x04c0175b,     0x04109418,     0x041ab006,\n+    0x0413812f,     0x04118b65,     0x04101694,     0x04d7aa0a,\n+    0x045eb046,     0x04c81c5d,     0x044a1dd6,     0x040112fb,\n+    0x04dcad42,     0x65809aca,     0x658d9603,     0x65c69201,\n+    0x65878d8c,     0x65c28290,     0x04dda4e5,     0x65c2be0c,\n+    0x6580a386,     0x65c1a624,     0x658dae6d,     0x65819638,\n+    0x65f318ca,     0x65a030cd,     0x65a8532e,     0x65bb76d6,\n+    0x04144e23,     0x04407ce4,     0x04363270,     0x04b6312f,\n+    0x047e30b9,     0x052b6acd,     0x05b46d0d,     0x041a2c99,\n+    0x04d828d1,     0x04d93e04,     0x040829da,     0x040a3c6b,\n+    0x65c73aa1,     0x65c62a2e,     0x65d82678,     0x04c13611,\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":143,"deletions":79,"binary":false,"changes":222,"status":"modified"}]}