{"files":[{"patch":"@@ -34,2 +34,0 @@\n-import java.nio.Buffer;\n-import java.nio.ByteBuffer;\n@@ -337,217 +335,1 @@\n-    \/\/ ByteBuffer vector access ops\n-\n-    \/\/ Buffer access constants, to be initalized when required.\n-    \/\/ Avoids a null value for NIO_ACCESS, due to class initalization dependencies\n-    static final class BufferAccess {\n-        \/\/ Buffer.address\n-        static final long BUFFER_ADDRESS\n-                = UNSAFE.objectFieldOffset(Buffer.class, \"address\");\n-\n-        \/\/ ByteBuffer.hb\n-        static final long BYTE_BUFFER_HB\n-                = UNSAFE.objectFieldOffset(ByteBuffer.class, \"hb\");\n-\n-        static final long BYTE_BUFFER_IS_READ_ONLY\n-                = UNSAFE.objectFieldOffset(ByteBuffer.class, \"isReadOnly\");\n-\n-        @ForceInline\n-        static Object bufferBase(ByteBuffer bb) {\n-            return UNSAFE.getReference(bb, BYTE_BUFFER_HB);\n-        }\n-\n-        @ForceInline\n-        static long bufferAddress(ByteBuffer bb, long offset) {\n-            return UNSAFE.getLong(bb, BUFFER_ADDRESS) + offset;\n-        }\n-\n-        static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n-\n-        @ForceInline\n-        static ScopedMemoryAccess.Scope scope(ByteBuffer bb) {\n-            MemorySegmentProxy segmentProxy = NIO_ACCESS.bufferSegment(bb);\n-            return segmentProxy != null ?\n-                    segmentProxy.scope() : null;\n-        }\n-    }\n-\n-    @ForceInline\n-    public static boolean isReadOnly(ByteBuffer bb) {\n-        return UNSAFE.getBoolean(bb, BufferAccess.BYTE_BUFFER_IS_READ_ONLY);\n-    }\n-\n-    @ForceInline\n-    public static\n-    <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>>\n-    V loadFromByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n-                          ByteBuffer bb, int offset,\n-                          S s,\n-                          VectorSupport.LoadOperation<ByteBuffer, V, S> defaultImpl) {\n-        try {\n-            return loadFromByteBufferScopedInternal(\n-                    BufferAccess.scope(bb),\n-                    vmClass, e, length,\n-                    bb, offset,\n-                    s,\n-                    defaultImpl);\n-        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n-            throw new IllegalStateException(\"This segment is already closed\");\n-        }\n-    }\n-\n-    @Scoped\n-    @ForceInline\n-    private static\n-    <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>>\n-    V loadFromByteBufferScopedInternal(ScopedMemoryAccess.Scope scope,\n-                                       Class<? extends V> vmClass, Class<E> e, int length,\n-                                       ByteBuffer bb, int offset,\n-                                       S s,\n-                                       VectorSupport.LoadOperation<ByteBuffer, V, S> defaultImpl) {\n-        try {\n-            if (scope != null) {\n-                scope.checkValidState();\n-            }\n-\n-            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n-\n-            return VectorSupport.load(vmClass, e, length,\n-                      base, BufferAccess.bufferAddress(bb, offset),\n-                      bb, offset, s,\n-                      defaultImpl);\n-        } finally {\n-            Reference.reachabilityFence(scope);\n-        }\n-    }\n-\n-    @ForceInline\n-    public static\n-    <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>,\n-     M extends VectorSupport.VectorMask<E>>\n-    V loadFromByteBufferMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n-                               int length, ByteBuffer bb, int offset, M m, S s,\n-                               VectorSupport.LoadVectorMaskedOperation<ByteBuffer, V, S, M> defaultImpl) {\n-        try {\n-            return loadFromByteBufferMaskedScopedInternal(\n-                    BufferAccess.scope(bb),\n-                    vmClass, maskClass, e, length,\n-                    bb, offset, m,\n-                    s,\n-                    defaultImpl);\n-        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n-            throw new IllegalStateException(\"This segment is already closed\");\n-        }\n-    }\n-\n-    @Scoped\n-    @ForceInline\n-    private static\n-    <V extends VectorSupport.Vector<E>, E, S extends VectorSupport.VectorSpecies<E>,\n-     M extends VectorSupport.VectorMask<E>>\n-    V loadFromByteBufferMaskedScopedInternal(ScopedMemoryAccess.Scope scope, Class<? extends V> vmClass,\n-                                             Class<M> maskClass, Class<E> e, int length,\n-                                             ByteBuffer bb, int offset, M m,\n-                                             S s,\n-                                             VectorSupport.LoadVectorMaskedOperation<ByteBuffer, V, S, M> defaultImpl) {\n-        try {\n-            if (scope != null) {\n-                scope.checkValidState();\n-            }\n-\n-            return VectorSupport.loadMasked(vmClass, maskClass, e, length,\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset), m,\n-                    bb, offset, s,\n-                    defaultImpl);\n-        } finally {\n-            Reference.reachabilityFence(scope);\n-        }\n-    }\n-\n-    @ForceInline\n-    public static\n-    <V extends VectorSupport.Vector<E>, E>\n-    void storeIntoByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n-                             V v,\n-                             ByteBuffer bb, int offset,\n-                             VectorSupport.StoreVectorOperation<ByteBuffer, V> defaultImpl) {\n-        try {\n-            storeIntoByteBufferScopedInternal(\n-                    BufferAccess.scope(bb),\n-                    vmClass, e, length,\n-                    v,\n-                    bb, offset,\n-                    defaultImpl);\n-        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n-            throw new IllegalStateException(\"This segment is already closed\");\n-        }\n-    }\n-\n-    @Scoped\n-    @ForceInline\n-    private static\n-    <V extends VectorSupport.Vector<E>, E>\n-    void storeIntoByteBufferScopedInternal(ScopedMemoryAccess.Scope scope,\n-                                           Class<? extends V> vmClass, Class<E> e, int length,\n-                                           V v,\n-                                           ByteBuffer bb, int offset,\n-                                           VectorSupport.StoreVectorOperation<ByteBuffer, V> defaultImpl) {\n-        try {\n-            if (scope != null) {\n-                scope.checkValidState();\n-            }\n-\n-            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n-\n-            VectorSupport.store(vmClass, e, length,\n-                                base, BufferAccess.bufferAddress(bb, offset),\n-                                v,\n-                                bb, offset,\n-                                defaultImpl);\n-        } finally {\n-            Reference.reachabilityFence(scope);\n-        }\n-    }\n-\n-    @ForceInline\n-    public static\n-    <V extends VectorSupport.Vector<E>, E, M extends VectorSupport.VectorMask<E>>\n-    void storeIntoByteBufferMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n-                                   int length, V v, M m,\n-                                   ByteBuffer bb, int offset,\n-                                   VectorSupport.StoreVectorMaskedOperation<ByteBuffer, V, M> defaultImpl) {\n-        try {\n-            storeIntoByteBufferMaskedScopedInternal(\n-                    BufferAccess.scope(bb),\n-                    vmClass, maskClass, e, length,\n-                    v, m,\n-                    bb, offset,\n-                    defaultImpl);\n-        } catch (ScopedMemoryAccess.Scope.ScopedAccessError ex) {\n-            throw new IllegalStateException(\"This segment is already closed\");\n-        }\n-    }\n-\n-    @Scoped\n-    @ForceInline\n-    private static\n-    <V extends VectorSupport.Vector<E>, E, M extends VectorSupport.VectorMask<E>>\n-    void storeIntoByteBufferMaskedScopedInternal(ScopedMemoryAccess.Scope scope,\n-                                                 Class<? extends V> vmClass, Class<M> maskClass,\n-                                                 Class<E> e, int length, V v, M m,\n-                                                 ByteBuffer bb, int offset,\n-                                                 VectorSupport.StoreVectorMaskedOperation<ByteBuffer, V, M> defaultImpl) {\n-        try {\n-            if (scope != null) {\n-                scope.checkValidState();\n-            }\n-\n-            VectorSupport.storeMasked(vmClass, maskClass, e, length,\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n-                    v, m,\n-                    bb, offset,\n-                    defaultImpl);\n-        } finally {\n-            Reference.reachabilityFence(scope);\n-        }\n-    }\n-\n-\n+    \/\/ MemorySegment vector access ops\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":1,"deletions":219,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -29,1 +30,0 @@\n-import java.nio.ByteOrder;\n@@ -31,0 +31,1 @@\n+import java.nio.ByteOrder;\n@@ -364,1 +365,1 @@\n-    public final Vector<E> fromByteArray(byte[] a, int offset, ByteOrder bo) {\n+    public final Vector<E> fromMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n@@ -366,1 +367,1 @@\n-            .fromByteArray0(a, offset)\n+            .fromMemorySegment0(ms, offset)\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -30,1 +31,0 @@\n-import java.nio.ByteBuffer;\n@@ -197,1 +197,1 @@\n-    abstract AbstractVector<E> fromByteArray0(byte[] a, int offset);\n+    abstract AbstractVector<E> fromMemorySegment0(MemorySegment ms, long offset);\n@@ -507,2 +507,2 @@\n-        ByteBuffer bb = ByteBuffer.allocate(blen);\n-        this.intoByteBuffer(bb, 0, bo);\n+        MemorySegment ms = MemorySegment.ofArray(new byte[blen]);\n+        this.intoMemorySegment(ms, 0, bo);\n@@ -513,1 +513,1 @@\n-            return ByteVector.fromByteBuffer(rsp.check(byte.class), bb, 0, bo, m.check(byte.class)).check0(rsp);\n+            return ByteVector.fromMemorySegment(rsp.check(byte.class), ms, 0, bo, m.check(byte.class)).check0(rsp);\n@@ -515,1 +515,1 @@\n-            return ShortVector.fromByteBuffer(rsp.check(short.class), bb, 0, bo, m.check(short.class)).check0(rsp);\n+            return ShortVector.fromMemorySegment(rsp.check(short.class), ms, 0, bo, m.check(short.class)).check0(rsp);\n@@ -517,1 +517,1 @@\n-            return IntVector.fromByteBuffer(rsp.check(int.class), bb, 0, bo, m.check(int.class)).check0(rsp);\n+            return IntVector.fromMemorySegment(rsp.check(int.class), ms, 0, bo, m.check(int.class)).check0(rsp);\n@@ -519,1 +519,1 @@\n-            return LongVector.fromByteBuffer(rsp.check(long.class), bb, 0, bo, m.check(long.class)).check0(rsp);\n+            return LongVector.fromMemorySegment(rsp.check(long.class), ms, 0, bo, m.check(long.class)).check0(rsp);\n@@ -521,1 +521,1 @@\n-            return FloatVector.fromByteBuffer(rsp.check(float.class), bb, 0, bo, m.check(float.class)).check0(rsp);\n+            return FloatVector.fromMemorySegment(rsp.check(float.class), ms, 0, bo, m.check(float.class)).check0(rsp);\n@@ -523,1 +523,1 @@\n-            return DoubleVector.fromByteBuffer(rsp.check(double.class), bb, 0, bo, m.check(double.class)).check0(rsp);\n+            return DoubleVector.fromMemorySegment(rsp.check(double.class), ms, 0, bo, m.check(double.class)).check0(rsp);\n@@ -733,9 +733,0 @@\n-    \/\/ Byte buffer wrappers.\n-    static ByteBuffer wrapper(ByteBuffer bb, ByteOrder bo) {\n-        return bb.duplicate().order(bo);\n-    }\n-\n-    static ByteBuffer wrapper(byte[] a, ByteOrder bo) {\n-        return ByteBuffer.wrap(a).order(bo);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -902,28 +901,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        return super.fromByteArray0Template(Byte128Mask.class, a, offset, (Byte128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        return super.fromByteBuffer0Template(Byte128Mask.class, bb, offset, (Byte128Mask) m);  \/\/ specialize\n-    }\n-\n@@ -966,21 +937,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoByteArray0Template(Byte128Mask.class, a, offset, (Byte128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        super.intoByteBuffer0Template(Byte128Mask.class, bb, offset, (Byte128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -934,28 +933,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        return super.fromByteArray0Template(Byte256Mask.class, a, offset, (Byte256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        return super.fromByteBuffer0Template(Byte256Mask.class, bb, offset, (Byte256Mask) m);  \/\/ specialize\n-    }\n-\n@@ -998,21 +969,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoByteArray0Template(Byte256Mask.class, a, offset, (Byte256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        super.intoByteBuffer0Template(Byte256Mask.class, bb, offset, (Byte256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -998,28 +997,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        return super.fromByteArray0Template(Byte512Mask.class, a, offset, (Byte512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        return super.fromByteBuffer0Template(Byte512Mask.class, bb, offset, (Byte512Mask) m);  \/\/ specialize\n-    }\n-\n@@ -1062,21 +1033,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoByteArray0Template(Byte512Mask.class, a, offset, (Byte512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        super.intoByteBuffer0Template(Byte512Mask.class, bb, offset, (Byte512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -886,28 +885,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        return super.fromByteArray0Template(Byte64Mask.class, a, offset, (Byte64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        return super.fromByteBuffer0Template(Byte64Mask.class, bb, offset, (Byte64Mask) m);  \/\/ specialize\n-    }\n-\n@@ -950,21 +921,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoByteArray0Template(Byte64Mask.class, a, offset, (Byte64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        super.intoByteBuffer0Template(Byte64Mask.class, bb, offset, (Byte64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -872,28 +871,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        return super.fromByteArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        return super.fromByteBuffer0Template(ByteMaxMask.class, bb, offset, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n@@ -936,21 +907,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoByteArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        super.intoByteBuffer0Template(ByteMaxMask.class, bb, offset, (ByteMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -63,0 +60,2 @@\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+\n@@ -358,2 +357,2 @@\n-    interface FLdLongOp<M> {\n-        byte apply(M memory, long offset, int i);\n+    interface FLdLongOp {\n+        byte apply(MemorySegment memory, long offset, int i);\n@@ -365,2 +364,2 @@\n-    <M> ByteVector ldLongOp(M memory, long offset,\n-                                  FLdLongOp<M> f) {\n+    ByteVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n@@ -378,1 +377,1 @@\n-    <M> ByteVector ldLongOp(M memory, long offset,\n+    ByteVector ldLongOp(MemorySegment memory, long offset,\n@@ -380,1 +379,1 @@\n-                                  FLdLongOp<M> f) {\n+                                  FLdLongOp f) {\n@@ -392,28 +391,2 @@\n-    static ByteVector expandHelper(Vector<Byte> v, VectorMask<Byte> m) {\n-        VectorSpecies<Byte> vsp = m.vectorSpecies();\n-        ByteVector r  = (ByteVector) vsp.zero();\n-        ByteVector vi = (ByteVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(i, vi.lane(j++));\n-            }\n-        }\n-        return r;\n-    }\n-\n-    static ByteVector compressHelper(Vector<Byte> v, VectorMask<Byte> m) {\n-        VectorSpecies<Byte> vsp = m.vectorSpecies();\n-        ByteVector r  = (ByteVector) vsp.zero();\n-        ByteVector vi = (ByteVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(j++, vi.lane(i));\n-            }\n-        }\n-        return r;\n+    static byte memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 1L);\n@@ -452,2 +425,2 @@\n-    interface FStLongOp<M> {\n-        void apply(M memory, long offset, int i, byte a);\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, byte a);\n@@ -459,2 +432,2 @@\n-    <M> void stLongOp(M memory, long offset,\n-                  FStLongOp<M> f) {\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n@@ -470,1 +443,1 @@\n-    <M> void stLongOp(M memory, long offset,\n+    void stLongOp(MemorySegment memory, long offset,\n@@ -472,1 +445,1 @@\n-                  FStLongOp<M> f) {\n+                  FStLongOp f) {\n@@ -482,0 +455,4 @@\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, byte e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 1L, e);\n+    }\n+\n@@ -532,0 +509,30 @@\n+    static ByteVector expandHelper(Vector<Byte> v, VectorMask<Byte> m) {\n+        VectorSpecies<Byte> vsp = m.vectorSpecies();\n+        ByteVector r  = (ByteVector) vsp.zero();\n+        ByteVector vi = (ByteVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static ByteVector compressHelper(Vector<Byte> v, VectorMask<Byte> m) {\n+        VectorSpecies<Byte> vsp = m.vectorSpecies();\n+        ByteVector r  = (ByteVector) vsp.zero();\n+        ByteVector vi = (ByteVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -2956,84 +2963,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    ByteVector fromByteArray(VectorSpecies<Byte> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        ByteSpecies vsp = (ByteSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code byte} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    ByteVector fromByteArray(VectorSpecies<Byte> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Byte> m) {\n-        ByteSpecies vsp = (ByteSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Byte>)m,\n-                   (wb_, o, i)  -> wb_.get(o + i * 1));\n-    }\n-\n@@ -3345,92 +3268,0 @@\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*1 < 0}\n-     *         or {@code offset+N*1 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    ByteVector fromByteBuffer(VectorSpecies<Byte> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n-        ByteSpecies vsp = (ByteSpecies) species;\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code byte} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * The following pseudocode illustrates the behavior:\n-     * <pre>{@code\n-     * ByteBuffer eb = bb.duplicate()\n-     *     .position(offset);\n-     * byte[] ar = new byte[species.length()];\n-     * for (int n = 0; n < ar.length; n++) {\n-     *     if (m.laneIsSet(n)) {\n-     *         ar[n] = eb.get(n);\n-     *     }\n-     * }\n-     * ByteVector r = ByteVector.fromArray(species, ar, 0);\n-     * }<\/pre>\n-     * @implNote\n-     * The byte order argument is ignored.\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*1 < 0}\n-     *         or {@code offset+N*1 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    ByteVector fromByteBuffer(VectorSpecies<Byte> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Byte> m) {\n-        ByteSpecies vsp = (ByteSpecies) species;\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 1, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Byte>)m,\n-                   (wb_, o, i)  -> wb_.get(o + i * 1));\n-    }\n-\n@@ -3531,3 +3362,1 @@\n-        var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n-        return vsp.ldLongOp(ms, offset, (AbstractMask<Byte>)m,\n-                   (ms_, o, i)  -> ms_.get(layout, o + i * 1L));\n+        return vsp.ldLongOp(ms, offset, m, ByteVector::memorySegmentGet);\n@@ -3850,66 +3679,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Byte> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            ByteSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n-        }\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Byte> m) {\n-        if (m.allTrue()) {\n-            intoByteBuffer(bb, offset, bo);\n-        } else {\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n-            }\n-            ByteSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 1, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n-        }\n-    }\n-\n@@ -4038,71 +3801,0 @@\n-    @Override\n-    abstract\n-    ByteVector fromByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    ByteVector fromByteArray0Template(byte[] a, int offset) {\n-        ByteSpecies vsp = vspecies();\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off,\n-                        (wb_, o, i) -> wb_.get(o + i * 1));\n-            });\n-    }\n-\n-    abstract\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Byte>>\n-    ByteVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        ByteSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off, vm,\n-                        (wb_, o, i) -> wb_.get(o + i * 1));\n-            });\n-    }\n-\n-    abstract\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    ByteVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        ByteSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off,\n-                            (wb_, o, i) -> wb_.get(o + i * 1));\n-                });\n-    }\n-\n-    abstract\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Byte>>\n-    ByteVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        ByteSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off, vm,\n-                            (wb_, o, i) -> wb_.get(o + i * 1));\n-                });\n-    }\n-\n@@ -4119,3 +3811,1 @@\n-                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 1L));\n+                    return s.ldLongOp((MemorySegment) msp, off, ByteVector::memorySegmentGet);\n@@ -4137,3 +3827,1 @@\n-                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 1L));\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentGet);\n@@ -4198,68 +3886,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        ByteSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off,\n-                        (tb_, o, i, e) -> tb_.put(o + i * 1, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Byte>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        ByteSpecies vsp = vspecies();\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off, vm,\n-                        (tb_, o, i, e) -> tb_.put(o + i * 1, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        ByteSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off,\n-                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n-                });\n-    }\n-\n-    abstract\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Byte>>\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        ByteSpecies vsp = vspecies();\n-        m.check(vsp);\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off, vm,\n-                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n-                });\n-    }\n-\n@@ -4275,3 +3895,1 @@\n-                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 1L, e));\n+                    v.stLongOp((MemorySegment) msp, off, ByteVector::memorySegmentSet);\n@@ -4294,3 +3912,1 @@\n-                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 1L, e));\n+                    v.stLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentSet);\n@@ -4644,2 +4260,2 @@\n-        <M> ByteVector ldLongOp(M memory, long offset,\n-                                      FLdLongOp<M> f) {\n+        ByteVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n@@ -4651,1 +4267,1 @@\n-        <M> ByteVector ldLongOp(M memory, long offset,\n+        ByteVector ldLongOp(MemorySegment memory, long offset,\n@@ -4653,1 +4269,1 @@\n-                                      FLdLongOp<M> f) {\n+                                      FLdLongOp f) {\n@@ -4673,1 +4289,1 @@\n-        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n@@ -4679,1 +4295,1 @@\n-        <M> void stLongOp(M memory, long offset,\n+        void stLongOp(MemorySegment memory, long offset,\n@@ -4681,1 +4297,1 @@\n-                      FStLongOp<M> f) {\n+                      FStLongOp f) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":62,"deletions":446,"binary":false,"changes":508,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -856,28 +855,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        return super.fromByteArray0Template(Double128Mask.class, a, offset, (Double128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        return super.fromByteBuffer0Template(Double128Mask.class, bb, offset, (Double128Mask) m);  \/\/ specialize\n-    }\n-\n@@ -920,21 +891,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        super.intoByteArray0Template(Double128Mask.class, a, offset, (Double128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        super.intoByteBuffer0Template(Double128Mask.class, bb, offset, (Double128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -860,28 +859,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        return super.fromByteArray0Template(Double256Mask.class, a, offset, (Double256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        return super.fromByteBuffer0Template(Double256Mask.class, bb, offset, (Double256Mask) m);  \/\/ specialize\n-    }\n-\n@@ -924,21 +895,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        super.intoByteArray0Template(Double256Mask.class, a, offset, (Double256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        super.intoByteBuffer0Template(Double256Mask.class, bb, offset, (Double256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -868,28 +867,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        return super.fromByteArray0Template(Double512Mask.class, a, offset, (Double512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        return super.fromByteBuffer0Template(Double512Mask.class, bb, offset, (Double512Mask) m);  \/\/ specialize\n-    }\n-\n@@ -932,21 +903,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        super.intoByteArray0Template(Double512Mask.class, a, offset, (Double512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        super.intoByteBuffer0Template(Double512Mask.class, bb, offset, (Double512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -854,28 +853,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        return super.fromByteArray0Template(Double64Mask.class, a, offset, (Double64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        return super.fromByteBuffer0Template(Double64Mask.class, bb, offset, (Double64Mask) m);  \/\/ specialize\n-    }\n-\n@@ -918,21 +889,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        super.intoByteArray0Template(Double64Mask.class, a, offset, (Double64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        super.intoByteBuffer0Template(Double64Mask.class, bb, offset, (Double64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -853,28 +852,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        return super.fromByteArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        return super.fromByteBuffer0Template(DoubleMaxMask.class, bb, offset, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n@@ -917,21 +888,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        super.intoByteArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        super.intoByteBuffer0Template(DoubleMaxMask.class, bb, offset, (DoubleMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -63,0 +60,2 @@\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+\n@@ -358,2 +357,2 @@\n-    interface FLdLongOp<M> {\n-        double apply(M memory, long offset, int i);\n+    interface FLdLongOp {\n+        double apply(MemorySegment memory, long offset, int i);\n@@ -365,2 +364,2 @@\n-    <M> DoubleVector ldLongOp(M memory, long offset,\n-                                  FLdLongOp<M> f) {\n+    DoubleVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n@@ -378,1 +377,1 @@\n-    <M> DoubleVector ldLongOp(M memory, long offset,\n+    DoubleVector ldLongOp(MemorySegment memory, long offset,\n@@ -380,1 +379,1 @@\n-                                  FLdLongOp<M> f) {\n+                                  FLdLongOp f) {\n@@ -392,28 +391,2 @@\n-    static DoubleVector expandHelper(Vector<Double> v, VectorMask<Double> m) {\n-        VectorSpecies<Double> vsp = m.vectorSpecies();\n-        DoubleVector r  = (DoubleVector) vsp.zero();\n-        DoubleVector vi = (DoubleVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(i, vi.lane(j++));\n-            }\n-        }\n-        return r;\n-    }\n-\n-    static DoubleVector compressHelper(Vector<Double> v, VectorMask<Double> m) {\n-        VectorSpecies<Double> vsp = m.vectorSpecies();\n-        DoubleVector r  = (DoubleVector) vsp.zero();\n-        DoubleVector vi = (DoubleVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(j++, vi.lane(i));\n-            }\n-        }\n-        return r;\n+    static double memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 8L);\n@@ -452,2 +425,2 @@\n-    interface FStLongOp<M> {\n-        void apply(M memory, long offset, int i, double a);\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, double a);\n@@ -459,2 +432,2 @@\n-    <M> void stLongOp(M memory, long offset,\n-                  FStLongOp<M> f) {\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n@@ -470,1 +443,1 @@\n-    <M> void stLongOp(M memory, long offset,\n+    void stLongOp(MemorySegment memory, long offset,\n@@ -472,1 +445,1 @@\n-                  FStLongOp<M> f) {\n+                  FStLongOp f) {\n@@ -482,0 +455,4 @@\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, double e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 8L, e);\n+    }\n+\n@@ -521,0 +498,30 @@\n+    static DoubleVector expandHelper(Vector<Double> v, VectorMask<Double> m) {\n+        VectorSpecies<Double> vsp = m.vectorSpecies();\n+        DoubleVector r  = (DoubleVector) vsp.zero();\n+        DoubleVector vi = (DoubleVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static DoubleVector compressHelper(Vector<Double> v, VectorMask<Double> m) {\n+        VectorSpecies<Double> vsp = m.vectorSpecies();\n+        DoubleVector r  = (DoubleVector) vsp.zero();\n+        DoubleVector vi = (DoubleVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -2748,84 +2755,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    DoubleVector fromByteArray(VectorSpecies<Double> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        DoubleSpecies vsp = (DoubleSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code double} (positive zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    DoubleVector fromByteArray(VectorSpecies<Double> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Double> m) {\n-        DoubleSpecies vsp = (DoubleSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 8, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Double>)m,\n-                   (wb_, o, i)  -> wb_.getDouble(o + i * 8));\n-    }\n-\n@@ -3021,98 +2944,0 @@\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*8 < 0}\n-     *         or {@code offset+N*8 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    DoubleVector fromByteBuffer(VectorSpecies<Double> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n-        DoubleSpecies vsp = (DoubleSpecies) species;\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code double} (positive zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * The following pseudocode illustrates the behavior:\n-     * <pre>{@code\n-     * DoubleBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asDoubleBuffer();\n-     * double[] ar = new double[species.length()];\n-     * for (int n = 0; n < ar.length; n++) {\n-     *     if (m.laneIsSet(n)) {\n-     *         ar[n] = eb.get(n);\n-     *     }\n-     * }\n-     * DoubleVector r = DoubleVector.fromArray(species, ar, 0);\n-     * }<\/pre>\n-     * @implNote\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*8 < 0}\n-     *         or {@code offset+N*8 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    DoubleVector fromByteBuffer(VectorSpecies<Double> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Double> m) {\n-        DoubleSpecies vsp = (DoubleSpecies) species;\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 8, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Double>)m,\n-                   (wb_, o, i)  -> wb_.getDouble(o + i * 8));\n-    }\n-\n@@ -3218,3 +3043,1 @@\n-        var layout = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n-        return vsp.ldLongOp(ms, offset, (AbstractMask<Double>)m,\n-                   (ms_, o, i)  -> ms_.get(layout, o + i * 8L));\n+        return vsp.ldLongOp(ms, offset, m, DoubleVector::memorySegmentGet);\n@@ -3408,66 +3231,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Double> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            DoubleSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 8, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n-        }\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Double> m) {\n-        if (m.allTrue()) {\n-            intoByteBuffer(bb, offset, bo);\n-        } else {\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n-            }\n-            DoubleSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 8, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n-        }\n-    }\n-\n@@ -3616,71 +3373,0 @@\n-    @Override\n-    abstract\n-    DoubleVector fromByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    DoubleVector fromByteArray0Template(byte[] a, int offset) {\n-        DoubleSpecies vsp = vspecies();\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off,\n-                        (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-            });\n-    }\n-\n-    abstract\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Double>>\n-    DoubleVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        DoubleSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off, vm,\n-                        (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-            });\n-    }\n-\n-    abstract\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    DoubleVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        DoubleSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off,\n-                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-                });\n-    }\n-\n-    abstract\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Double>>\n-    DoubleVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        DoubleSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off, vm,\n-                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-                });\n-    }\n-\n@@ -3697,3 +3383,1 @@\n-                    var layout = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 8L));\n+                    return s.ldLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentGet);\n@@ -3715,3 +3399,1 @@\n-                    var layout = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 8L));\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentGet);\n@@ -3811,68 +3493,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        DoubleSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off,\n-                        (tb_, o, i, e) -> tb_.putDouble(o + i * 8, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Double>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        DoubleSpecies vsp = vspecies();\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off, vm,\n-                        (tb_, o, i, e) -> tb_.putDouble(o + i * 8, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        DoubleSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off,\n-                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n-                });\n-    }\n-\n-    abstract\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Double>>\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        DoubleSpecies vsp = vspecies();\n-        m.check(vsp);\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off, vm,\n-                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n-                });\n-    }\n-\n@@ -3888,3 +3502,1 @@\n-                    var layout = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 8L, e));\n+                    v.stLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentSet);\n@@ -3907,3 +3519,1 @@\n-                    var layout = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 8L, e));\n+                    v.stLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentSet);\n@@ -4248,2 +3858,2 @@\n-        <M> DoubleVector ldLongOp(M memory, long offset,\n-                                      FLdLongOp<M> f) {\n+        DoubleVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n@@ -4255,1 +3865,1 @@\n-        <M> DoubleVector ldLongOp(M memory, long offset,\n+        DoubleVector ldLongOp(MemorySegment memory, long offset,\n@@ -4257,1 +3867,1 @@\n-                                      FLdLongOp<M> f) {\n+                                      FLdLongOp f) {\n@@ -4277,1 +3887,1 @@\n-        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n@@ -4283,1 +3893,1 @@\n-        <M> void stLongOp(M memory, long offset,\n+        void stLongOp(MemorySegment memory, long offset,\n@@ -4285,1 +3895,1 @@\n-                      FStLongOp<M> f) {\n+                      FStLongOp f) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":62,"deletions":452,"binary":false,"changes":514,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -860,28 +859,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        return super.fromByteArray0Template(Float128Mask.class, a, offset, (Float128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        return super.fromByteBuffer0Template(Float128Mask.class, bb, offset, (Float128Mask) m);  \/\/ specialize\n-    }\n-\n@@ -924,21 +895,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        super.intoByteArray0Template(Float128Mask.class, a, offset, (Float128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        super.intoByteBuffer0Template(Float128Mask.class, bb, offset, (Float128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -868,28 +867,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        return super.fromByteArray0Template(Float256Mask.class, a, offset, (Float256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        return super.fromByteBuffer0Template(Float256Mask.class, bb, offset, (Float256Mask) m);  \/\/ specialize\n-    }\n-\n@@ -932,21 +903,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        super.intoByteArray0Template(Float256Mask.class, a, offset, (Float256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        super.intoByteBuffer0Template(Float256Mask.class, bb, offset, (Float256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -884,28 +883,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        return super.fromByteArray0Template(Float512Mask.class, a, offset, (Float512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        return super.fromByteBuffer0Template(Float512Mask.class, bb, offset, (Float512Mask) m);  \/\/ specialize\n-    }\n-\n@@ -948,21 +919,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        super.intoByteArray0Template(Float512Mask.class, a, offset, (Float512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        super.intoByteBuffer0Template(Float512Mask.class, bb, offset, (Float512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -856,28 +855,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        return super.fromByteArray0Template(Float64Mask.class, a, offset, (Float64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        return super.fromByteBuffer0Template(Float64Mask.class, bb, offset, (Float64Mask) m);  \/\/ specialize\n-    }\n-\n@@ -920,21 +891,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        super.intoByteArray0Template(Float64Mask.class, a, offset, (Float64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        super.intoByteBuffer0Template(Float64Mask.class, bb, offset, (Float64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -853,28 +852,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        return super.fromByteArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        return super.fromByteBuffer0Template(FloatMaxMask.class, bb, offset, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n@@ -917,21 +888,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        super.intoByteArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        super.intoByteBuffer0Template(FloatMaxMask.class, bb, offset, (FloatMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -63,0 +60,2 @@\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+\n@@ -358,2 +357,2 @@\n-    interface FLdLongOp<M> {\n-        float apply(M memory, long offset, int i);\n+    interface FLdLongOp {\n+        float apply(MemorySegment memory, long offset, int i);\n@@ -365,2 +364,2 @@\n-    <M> FloatVector ldLongOp(M memory, long offset,\n-                                  FLdLongOp<M> f) {\n+    FloatVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n@@ -378,1 +377,1 @@\n-    <M> FloatVector ldLongOp(M memory, long offset,\n+    FloatVector ldLongOp(MemorySegment memory, long offset,\n@@ -380,1 +379,1 @@\n-                                  FLdLongOp<M> f) {\n+                                  FLdLongOp f) {\n@@ -392,28 +391,2 @@\n-    static FloatVector expandHelper(Vector<Float> v, VectorMask<Float> m) {\n-        VectorSpecies<Float> vsp = m.vectorSpecies();\n-        FloatVector r  = (FloatVector) vsp.zero();\n-        FloatVector vi = (FloatVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(i, vi.lane(j++));\n-            }\n-        }\n-        return r;\n-    }\n-\n-    static FloatVector compressHelper(Vector<Float> v, VectorMask<Float> m) {\n-        VectorSpecies<Float> vsp = m.vectorSpecies();\n-        FloatVector r  = (FloatVector) vsp.zero();\n-        FloatVector vi = (FloatVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(j++, vi.lane(i));\n-            }\n-        }\n-        return r;\n+    static float memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 4L);\n@@ -452,2 +425,2 @@\n-    interface FStLongOp<M> {\n-        void apply(M memory, long offset, int i, float a);\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, float a);\n@@ -459,2 +432,2 @@\n-    <M> void stLongOp(M memory, long offset,\n-                  FStLongOp<M> f) {\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n@@ -470,1 +443,1 @@\n-    <M> void stLongOp(M memory, long offset,\n+    void stLongOp(MemorySegment memory, long offset,\n@@ -472,1 +445,1 @@\n-                  FStLongOp<M> f) {\n+                  FStLongOp f) {\n@@ -482,0 +455,4 @@\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, float e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 4L, e);\n+    }\n+\n@@ -521,0 +498,30 @@\n+    static FloatVector expandHelper(Vector<Float> v, VectorMask<Float> m) {\n+        VectorSpecies<Float> vsp = m.vectorSpecies();\n+        FloatVector r  = (FloatVector) vsp.zero();\n+        FloatVector vi = (FloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static FloatVector compressHelper(Vector<Float> v, VectorMask<Float> m) {\n+        VectorSpecies<Float> vsp = m.vectorSpecies();\n+        FloatVector r  = (FloatVector) vsp.zero();\n+        FloatVector vi = (FloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -2772,84 +2779,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    FloatVector fromByteArray(VectorSpecies<Float> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        FloatSpecies vsp = (FloatSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code float} (positive zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    FloatVector fromByteArray(VectorSpecies<Float> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Float> m) {\n-        FloatSpecies vsp = (FloatSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 4, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Float>)m,\n-                   (wb_, o, i)  -> wb_.getFloat(o + i * 4));\n-    }\n-\n@@ -3027,98 +2950,0 @@\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*4 < 0}\n-     *         or {@code offset+N*4 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    FloatVector fromByteBuffer(VectorSpecies<Float> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n-        FloatSpecies vsp = (FloatSpecies) species;\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code float} (positive zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * The following pseudocode illustrates the behavior:\n-     * <pre>{@code\n-     * FloatBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asFloatBuffer();\n-     * float[] ar = new float[species.length()];\n-     * for (int n = 0; n < ar.length; n++) {\n-     *     if (m.laneIsSet(n)) {\n-     *         ar[n] = eb.get(n);\n-     *     }\n-     * }\n-     * FloatVector r = FloatVector.fromArray(species, ar, 0);\n-     * }<\/pre>\n-     * @implNote\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*4 < 0}\n-     *         or {@code offset+N*4 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    FloatVector fromByteBuffer(VectorSpecies<Float> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Float> m) {\n-        FloatSpecies vsp = (FloatSpecies) species;\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 4, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Float>)m,\n-                   (wb_, o, i)  -> wb_.getFloat(o + i * 4));\n-    }\n-\n@@ -3224,3 +3049,1 @@\n-        var layout = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n-        return vsp.ldLongOp(ms, offset, (AbstractMask<Float>)m,\n-                   (ms_, o, i)  -> ms_.get(layout, o + i * 4L));\n+        return vsp.ldLongOp(ms, offset, m, FloatVector::memorySegmentGet);\n@@ -3395,66 +3218,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Float> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            FloatSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 4, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n-        }\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Float> m) {\n-        if (m.allTrue()) {\n-            intoByteBuffer(bb, offset, bo);\n-        } else {\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n-            }\n-            FloatSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 4, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n-        }\n-    }\n-\n@@ -3585,71 +3342,0 @@\n-    @Override\n-    abstract\n-    FloatVector fromByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    FloatVector fromByteArray0Template(byte[] a, int offset) {\n-        FloatSpecies vsp = vspecies();\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off,\n-                        (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-            });\n-    }\n-\n-    abstract\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Float>>\n-    FloatVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        FloatSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off, vm,\n-                        (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-            });\n-    }\n-\n-    abstract\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    FloatVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        FloatSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off,\n-                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-                });\n-    }\n-\n-    abstract\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Float>>\n-    FloatVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        FloatSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off, vm,\n-                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-                });\n-    }\n-\n@@ -3666,3 +3352,1 @@\n-                    var layout = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 4L));\n+                    return s.ldLongOp((MemorySegment) msp, off, FloatVector::memorySegmentGet);\n@@ -3684,3 +3368,1 @@\n-                    var layout = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 4L));\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentGet);\n@@ -3761,68 +3443,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        FloatSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off,\n-                        (tb_, o, i, e) -> tb_.putFloat(o + i * 4, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Float>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        FloatSpecies vsp = vspecies();\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off, vm,\n-                        (tb_, o, i, e) -> tb_.putFloat(o + i * 4, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        FloatSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off,\n-                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n-                });\n-    }\n-\n-    abstract\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Float>>\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        FloatSpecies vsp = vspecies();\n-        m.check(vsp);\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off, vm,\n-                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n-                });\n-    }\n-\n@@ -3838,3 +3452,1 @@\n-                    var layout = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 4L, e));\n+                    v.stLongOp((MemorySegment) msp, off, FloatVector::memorySegmentSet);\n@@ -3857,3 +3469,1 @@\n-                    var layout = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 4L, e));\n+                    v.stLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentSet);\n@@ -4198,2 +3808,2 @@\n-        <M> FloatVector ldLongOp(M memory, long offset,\n-                                      FLdLongOp<M> f) {\n+        FloatVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n@@ -4205,1 +3815,1 @@\n-        <M> FloatVector ldLongOp(M memory, long offset,\n+        FloatVector ldLongOp(MemorySegment memory, long offset,\n@@ -4207,1 +3817,1 @@\n-                                      FLdLongOp<M> f) {\n+                                      FLdLongOp f) {\n@@ -4227,1 +3837,1 @@\n-        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n@@ -4233,1 +3843,1 @@\n-        <M> void stLongOp(M memory, long offset,\n+        void stLongOp(MemorySegment memory, long offset,\n@@ -4235,1 +3845,1 @@\n-                      FStLongOp<M> f) {\n+                      FStLongOp f) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":62,"deletions":452,"binary":false,"changes":514,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -871,28 +870,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        return super.fromByteArray0Template(Int128Mask.class, a, offset, (Int128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        return super.fromByteBuffer0Template(Int128Mask.class, bb, offset, (Int128Mask) m);  \/\/ specialize\n-    }\n-\n@@ -935,21 +906,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        super.intoByteArray0Template(Int128Mask.class, a, offset, (Int128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        super.intoByteBuffer0Template(Int128Mask.class, bb, offset, (Int128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -879,28 +878,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        return super.fromByteArray0Template(Int256Mask.class, a, offset, (Int256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        return super.fromByteBuffer0Template(Int256Mask.class, bb, offset, (Int256Mask) m);  \/\/ specialize\n-    }\n-\n@@ -943,21 +914,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        super.intoByteArray0Template(Int256Mask.class, a, offset, (Int256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        super.intoByteBuffer0Template(Int256Mask.class, bb, offset, (Int256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -895,28 +894,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        return super.fromByteArray0Template(Int512Mask.class, a, offset, (Int512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        return super.fromByteBuffer0Template(Int512Mask.class, bb, offset, (Int512Mask) m);  \/\/ specialize\n-    }\n-\n@@ -959,21 +930,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        super.intoByteArray0Template(Int512Mask.class, a, offset, (Int512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        super.intoByteBuffer0Template(Int512Mask.class, bb, offset, (Int512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -867,28 +866,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        return super.fromByteArray0Template(Int64Mask.class, a, offset, (Int64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        return super.fromByteBuffer0Template(Int64Mask.class, bb, offset, (Int64Mask) m);  \/\/ specialize\n-    }\n-\n@@ -931,21 +902,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        super.intoByteArray0Template(Int64Mask.class, a, offset, (Int64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        super.intoByteBuffer0Template(Int64Mask.class, bb, offset, (Int64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -876,28 +875,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        return super.fromByteArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        return super.fromByteBuffer0Template(IntMaxMask.class, bb, offset, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n@@ -940,21 +911,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        super.intoByteArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        super.intoByteBuffer0Template(IntMaxMask.class, bb, offset, (IntMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -63,0 +60,2 @@\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+\n@@ -358,2 +357,2 @@\n-    interface FLdLongOp<M> {\n-        int apply(M memory, long offset, int i);\n+    interface FLdLongOp {\n+        int apply(MemorySegment memory, long offset, int i);\n@@ -365,2 +364,2 @@\n-    <M> IntVector ldLongOp(M memory, long offset,\n-                                  FLdLongOp<M> f) {\n+    IntVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n@@ -378,1 +377,1 @@\n-    <M> IntVector ldLongOp(M memory, long offset,\n+    IntVector ldLongOp(MemorySegment memory, long offset,\n@@ -380,1 +379,1 @@\n-                                  FLdLongOp<M> f) {\n+                                  FLdLongOp f) {\n@@ -392,28 +391,2 @@\n-    static IntVector expandHelper(Vector<Integer> v, VectorMask<Integer> m) {\n-        VectorSpecies<Integer> vsp = m.vectorSpecies();\n-        IntVector r  = (IntVector) vsp.zero();\n-        IntVector vi = (IntVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(i, vi.lane(j++));\n-            }\n-        }\n-        return r;\n-    }\n-\n-    static IntVector compressHelper(Vector<Integer> v, VectorMask<Integer> m) {\n-        VectorSpecies<Integer> vsp = m.vectorSpecies();\n-        IntVector r  = (IntVector) vsp.zero();\n-        IntVector vi = (IntVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(j++, vi.lane(i));\n-            }\n-        }\n-        return r;\n+    static int memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 4L);\n@@ -452,2 +425,2 @@\n-    interface FStLongOp<M> {\n-        void apply(M memory, long offset, int i, int a);\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, int a);\n@@ -459,2 +432,2 @@\n-    <M> void stLongOp(M memory, long offset,\n-                  FStLongOp<M> f) {\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n@@ -470,1 +443,1 @@\n-    <M> void stLongOp(M memory, long offset,\n+    void stLongOp(MemorySegment memory, long offset,\n@@ -472,1 +445,1 @@\n-                  FStLongOp<M> f) {\n+                  FStLongOp f) {\n@@ -482,0 +455,4 @@\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, int e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 4L, e);\n+    }\n+\n@@ -532,0 +509,30 @@\n+    static IntVector expandHelper(Vector<Integer> v, VectorMask<Integer> m) {\n+        VectorSpecies<Integer> vsp = m.vectorSpecies();\n+        IntVector r  = (IntVector) vsp.zero();\n+        IntVector vi = (IntVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static IntVector compressHelper(Vector<Integer> v, VectorMask<Integer> m) {\n+        VectorSpecies<Integer> vsp = m.vectorSpecies();\n+        IntVector r  = (IntVector) vsp.zero();\n+        IntVector vi = (IntVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -2930,84 +2937,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    IntVector fromByteArray(VectorSpecies<Integer> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        IntSpecies vsp = (IntSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code int} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    IntVector fromByteArray(VectorSpecies<Integer> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Integer> m) {\n-        IntSpecies vsp = (IntSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 4, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Integer>)m,\n-                   (wb_, o, i)  -> wb_.getInt(o + i * 4));\n-    }\n-\n@@ -3185,98 +3108,0 @@\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*4 < 0}\n-     *         or {@code offset+N*4 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    IntVector fromByteBuffer(VectorSpecies<Integer> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n-        IntSpecies vsp = (IntSpecies) species;\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code int} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * The following pseudocode illustrates the behavior:\n-     * <pre>{@code\n-     * IntBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asIntBuffer();\n-     * int[] ar = new int[species.length()];\n-     * for (int n = 0; n < ar.length; n++) {\n-     *     if (m.laneIsSet(n)) {\n-     *         ar[n] = eb.get(n);\n-     *     }\n-     * }\n-     * IntVector r = IntVector.fromArray(species, ar, 0);\n-     * }<\/pre>\n-     * @implNote\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*4 < 0}\n-     *         or {@code offset+N*4 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    IntVector fromByteBuffer(VectorSpecies<Integer> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Integer> m) {\n-        IntSpecies vsp = (IntSpecies) species;\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 4, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Integer>)m,\n-                   (wb_, o, i)  -> wb_.getInt(o + i * 4));\n-    }\n-\n@@ -3382,3 +3207,1 @@\n-        var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n-        return vsp.ldLongOp(ms, offset, (AbstractMask<Integer>)m,\n-                   (ms_, o, i)  -> ms_.get(layout, o + i * 4L));\n+        return vsp.ldLongOp(ms, offset, m, IntVector::memorySegmentGet);\n@@ -3553,66 +3376,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Integer> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            IntSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 4, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n-        }\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Integer> m) {\n-        if (m.allTrue()) {\n-            intoByteBuffer(bb, offset, bo);\n-        } else {\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n-            }\n-            IntSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 4, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n-        }\n-    }\n-\n@@ -3743,71 +3500,0 @@\n-    @Override\n-    abstract\n-    IntVector fromByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    IntVector fromByteArray0Template(byte[] a, int offset) {\n-        IntSpecies vsp = vspecies();\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off,\n-                        (wb_, o, i) -> wb_.getInt(o + i * 4));\n-            });\n-    }\n-\n-    abstract\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Integer>>\n-    IntVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        IntSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off, vm,\n-                        (wb_, o, i) -> wb_.getInt(o + i * 4));\n-            });\n-    }\n-\n-    abstract\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    IntVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        IntSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off,\n-                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n-                });\n-    }\n-\n-    abstract\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Integer>>\n-    IntVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        IntSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off, vm,\n-                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n-                });\n-    }\n-\n@@ -3824,3 +3510,1 @@\n-                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 4L));\n+                    return s.ldLongOp((MemorySegment) msp, off, IntVector::memorySegmentGet);\n@@ -3842,3 +3526,1 @@\n-                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 4L));\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentGet);\n@@ -3919,68 +3601,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        IntSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off,\n-                        (tb_, o, i, e) -> tb_.putInt(o + i * 4, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Integer>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        IntSpecies vsp = vspecies();\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off, vm,\n-                        (tb_, o, i, e) -> tb_.putInt(o + i * 4, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        IntSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off,\n-                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n-                });\n-    }\n-\n-    abstract\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Integer>>\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        IntSpecies vsp = vspecies();\n-        m.check(vsp);\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off, vm,\n-                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n-                });\n-    }\n-\n@@ -3996,3 +3610,1 @@\n-                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 4L, e));\n+                    v.stLongOp((MemorySegment) msp, off, IntVector::memorySegmentSet);\n@@ -4015,3 +3627,1 @@\n-                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 4L, e));\n+                    v.stLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentSet);\n@@ -4356,2 +3966,2 @@\n-        <M> IntVector ldLongOp(M memory, long offset,\n-                                      FLdLongOp<M> f) {\n+        IntVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n@@ -4363,1 +3973,1 @@\n-        <M> IntVector ldLongOp(M memory, long offset,\n+        IntVector ldLongOp(MemorySegment memory, long offset,\n@@ -4365,1 +3975,1 @@\n-                                      FLdLongOp<M> f) {\n+                                      FLdLongOp f) {\n@@ -4385,1 +3995,1 @@\n-        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n@@ -4391,1 +4001,1 @@\n-        <M> void stLongOp(M memory, long offset,\n+        void stLongOp(MemorySegment memory, long offset,\n@@ -4393,1 +4003,1 @@\n-                      FStLongOp<M> f) {\n+                      FStLongOp f) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":62,"deletions":452,"binary":false,"changes":514,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -857,28 +856,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        return super.fromByteArray0Template(Long128Mask.class, a, offset, (Long128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        return super.fromByteBuffer0Template(Long128Mask.class, bb, offset, (Long128Mask) m);  \/\/ specialize\n-    }\n-\n@@ -921,21 +892,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        super.intoByteArray0Template(Long128Mask.class, a, offset, (Long128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        super.intoByteBuffer0Template(Long128Mask.class, bb, offset, (Long128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -861,28 +860,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        return super.fromByteArray0Template(Long256Mask.class, a, offset, (Long256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        return super.fromByteBuffer0Template(Long256Mask.class, bb, offset, (Long256Mask) m);  \/\/ specialize\n-    }\n-\n@@ -925,21 +896,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        super.intoByteArray0Template(Long256Mask.class, a, offset, (Long256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        super.intoByteBuffer0Template(Long256Mask.class, bb, offset, (Long256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -869,28 +868,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        return super.fromByteArray0Template(Long512Mask.class, a, offset, (Long512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        return super.fromByteBuffer0Template(Long512Mask.class, bb, offset, (Long512Mask) m);  \/\/ specialize\n-    }\n-\n@@ -933,21 +904,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        super.intoByteArray0Template(Long512Mask.class, a, offset, (Long512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        super.intoByteBuffer0Template(Long512Mask.class, bb, offset, (Long512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -855,28 +854,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        return super.fromByteArray0Template(Long64Mask.class, a, offset, (Long64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        return super.fromByteBuffer0Template(Long64Mask.class, bb, offset, (Long64Mask) m);  \/\/ specialize\n-    }\n-\n@@ -919,21 +890,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        super.intoByteArray0Template(Long64Mask.class, a, offset, (Long64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        super.intoByteBuffer0Template(Long64Mask.class, bb, offset, (Long64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -855,28 +854,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        return super.fromByteArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        return super.fromByteBuffer0Template(LongMaxMask.class, bb, offset, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n@@ -919,21 +890,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        super.intoByteArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        super.intoByteBuffer0Template(LongMaxMask.class, bb, offset, (LongMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -63,0 +60,2 @@\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+\n@@ -358,2 +357,2 @@\n-    interface FLdLongOp<M> {\n-        long apply(M memory, long offset, int i);\n+    interface FLdLongOp {\n+        long apply(MemorySegment memory, long offset, int i);\n@@ -365,2 +364,2 @@\n-    <M> LongVector ldLongOp(M memory, long offset,\n-                                  FLdLongOp<M> f) {\n+    LongVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n@@ -378,1 +377,1 @@\n-    <M> LongVector ldLongOp(M memory, long offset,\n+    LongVector ldLongOp(MemorySegment memory, long offset,\n@@ -380,1 +379,1 @@\n-                                  FLdLongOp<M> f) {\n+                                  FLdLongOp f) {\n@@ -392,28 +391,2 @@\n-    static LongVector expandHelper(Vector<Long> v, VectorMask<Long> m) {\n-        VectorSpecies<Long> vsp = m.vectorSpecies();\n-        LongVector r  = (LongVector) vsp.zero();\n-        LongVector vi = (LongVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(i, vi.lane(j++));\n-            }\n-        }\n-        return r;\n-    }\n-\n-    static LongVector compressHelper(Vector<Long> v, VectorMask<Long> m) {\n-        VectorSpecies<Long> vsp = m.vectorSpecies();\n-        LongVector r  = (LongVector) vsp.zero();\n-        LongVector vi = (LongVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(j++, vi.lane(i));\n-            }\n-        }\n-        return r;\n+    static long memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 8L);\n@@ -452,2 +425,2 @@\n-    interface FStLongOp<M> {\n-        void apply(M memory, long offset, int i, long a);\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, long a);\n@@ -459,2 +432,2 @@\n-    <M> void stLongOp(M memory, long offset,\n-                  FStLongOp<M> f) {\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n@@ -470,1 +443,1 @@\n-    <M> void stLongOp(M memory, long offset,\n+    void stLongOp(MemorySegment memory, long offset,\n@@ -472,1 +445,1 @@\n-                  FStLongOp<M> f) {\n+                  FStLongOp f) {\n@@ -482,0 +455,4 @@\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, long e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 8L, e);\n+    }\n+\n@@ -532,0 +509,30 @@\n+    static LongVector expandHelper(Vector<Long> v, VectorMask<Long> m) {\n+        VectorSpecies<Long> vsp = m.vectorSpecies();\n+        LongVector r  = (LongVector) vsp.zero();\n+        LongVector vi = (LongVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static LongVector compressHelper(Vector<Long> v, VectorMask<Long> m) {\n+        VectorSpecies<Long> vsp = m.vectorSpecies();\n+        LongVector r  = (LongVector) vsp.zero();\n+        LongVector vi = (LongVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -2791,84 +2798,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    LongVector fromByteArray(VectorSpecies<Long> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        LongSpecies vsp = (LongSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code long} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    LongVector fromByteArray(VectorSpecies<Long> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Long> m) {\n-        LongSpecies vsp = (LongSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 8, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Long>)m,\n-                   (wb_, o, i)  -> wb_.getLong(o + i * 8));\n-    }\n-\n@@ -3064,98 +2987,0 @@\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*8 < 0}\n-     *         or {@code offset+N*8 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    LongVector fromByteBuffer(VectorSpecies<Long> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n-        LongSpecies vsp = (LongSpecies) species;\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code long} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * The following pseudocode illustrates the behavior:\n-     * <pre>{@code\n-     * LongBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asLongBuffer();\n-     * long[] ar = new long[species.length()];\n-     * for (int n = 0; n < ar.length; n++) {\n-     *     if (m.laneIsSet(n)) {\n-     *         ar[n] = eb.get(n);\n-     *     }\n-     * }\n-     * LongVector r = LongVector.fromArray(species, ar, 0);\n-     * }<\/pre>\n-     * @implNote\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*8 < 0}\n-     *         or {@code offset+N*8 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    LongVector fromByteBuffer(VectorSpecies<Long> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Long> m) {\n-        LongSpecies vsp = (LongSpecies) species;\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 8, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Long>)m,\n-                   (wb_, o, i)  -> wb_.getLong(o + i * 8));\n-    }\n-\n@@ -3261,3 +3086,1 @@\n-        var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n-        return vsp.ldLongOp(ms, offset, (AbstractMask<Long>)m,\n-                   (ms_, o, i)  -> ms_.get(layout, o + i * 8L));\n+        return vsp.ldLongOp(ms, offset, m, LongVector::memorySegmentGet);\n@@ -3451,66 +3274,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Long> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            LongSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 8, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n-        }\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Long> m) {\n-        if (m.allTrue()) {\n-            intoByteBuffer(bb, offset, bo);\n-        } else {\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n-            }\n-            LongSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 8, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n-        }\n-    }\n-\n@@ -3659,71 +3416,0 @@\n-    @Override\n-    abstract\n-    LongVector fromByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    LongVector fromByteArray0Template(byte[] a, int offset) {\n-        LongSpecies vsp = vspecies();\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off,\n-                        (wb_, o, i) -> wb_.getLong(o + i * 8));\n-            });\n-    }\n-\n-    abstract\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Long>>\n-    LongVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        LongSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off, vm,\n-                        (wb_, o, i) -> wb_.getLong(o + i * 8));\n-            });\n-    }\n-\n-    abstract\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    LongVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        LongSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off,\n-                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n-                });\n-    }\n-\n-    abstract\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Long>>\n-    LongVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        LongSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off, vm,\n-                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n-                });\n-    }\n-\n@@ -3740,3 +3426,1 @@\n-                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 8L));\n+                    return s.ldLongOp((MemorySegment) msp, off, LongVector::memorySegmentGet);\n@@ -3758,3 +3442,1 @@\n-                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 8L));\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentGet);\n@@ -3854,68 +3536,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        LongSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off,\n-                        (tb_, o, i, e) -> tb_.putLong(o + i * 8, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Long>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        LongSpecies vsp = vspecies();\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off, vm,\n-                        (tb_, o, i, e) -> tb_.putLong(o + i * 8, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        LongSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off,\n-                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n-                });\n-    }\n-\n-    abstract\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Long>>\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        LongSpecies vsp = vspecies();\n-        m.check(vsp);\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off, vm,\n-                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n-                });\n-    }\n-\n@@ -3931,3 +3545,1 @@\n-                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 8L, e));\n+                    v.stLongOp((MemorySegment) msp, off, LongVector::memorySegmentSet);\n@@ -3950,3 +3562,1 @@\n-                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 8L, e));\n+                    v.stLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentSet);\n@@ -4282,2 +3892,2 @@\n-        <M> LongVector ldLongOp(M memory, long offset,\n-                                      FLdLongOp<M> f) {\n+        LongVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n@@ -4289,1 +3899,1 @@\n-        <M> LongVector ldLongOp(M memory, long offset,\n+        LongVector ldLongOp(MemorySegment memory, long offset,\n@@ -4291,1 +3901,1 @@\n-                                      FLdLongOp<M> f) {\n+                                      FLdLongOp f) {\n@@ -4311,1 +3921,1 @@\n-        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n@@ -4317,1 +3927,1 @@\n-        <M> void stLongOp(M memory, long offset,\n+        void stLongOp(MemorySegment memory, long offset,\n@@ -4319,1 +3929,1 @@\n-                      FStLongOp<M> f) {\n+                      FStLongOp f) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":62,"deletions":452,"binary":false,"changes":514,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -886,28 +885,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        return super.fromByteArray0Template(Short128Mask.class, a, offset, (Short128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        return super.fromByteBuffer0Template(Short128Mask.class, bb, offset, (Short128Mask) m);  \/\/ specialize\n-    }\n-\n@@ -944,21 +915,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        super.intoByteArray0Template(Short128Mask.class, a, offset, (Short128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        super.intoByteBuffer0Template(Short128Mask.class, bb, offset, (Short128Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -902,28 +901,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        return super.fromByteArray0Template(Short256Mask.class, a, offset, (Short256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        return super.fromByteBuffer0Template(Short256Mask.class, bb, offset, (Short256Mask) m);  \/\/ specialize\n-    }\n-\n@@ -960,21 +931,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        super.intoByteArray0Template(Short256Mask.class, a, offset, (Short256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        super.intoByteBuffer0Template(Short256Mask.class, bb, offset, (Short256Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -934,28 +933,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        return super.fromByteArray0Template(Short512Mask.class, a, offset, (Short512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        return super.fromByteBuffer0Template(Short512Mask.class, bb, offset, (Short512Mask) m);  \/\/ specialize\n-    }\n-\n@@ -992,21 +963,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        super.intoByteArray0Template(Short512Mask.class, a, offset, (Short512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        super.intoByteBuffer0Template(Short512Mask.class, bb, offset, (Short512Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -878,28 +877,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        return super.fromByteArray0Template(Short64Mask.class, a, offset, (Short64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        return super.fromByteBuffer0Template(Short64Mask.class, bb, offset, (Short64Mask) m);  \/\/ specialize\n-    }\n-\n@@ -936,21 +907,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        super.intoByteArray0Template(Short64Mask.class, a, offset, (Short64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        super.intoByteBuffer0Template(Short64Mask.class, bb, offset, (Short64Mask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -872,28 +871,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        return super.fromByteArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        return super.fromByteBuffer0Template(ShortMaxMask.class, bb, offset, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n@@ -930,21 +901,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        super.intoByteArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        super.intoByteBuffer0Template(ShortMaxMask.class, bb, offset, (ShortMaxMask) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -63,0 +60,2 @@\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+\n@@ -358,2 +357,2 @@\n-    interface FLdLongOp<M> {\n-        short apply(M memory, long offset, int i);\n+    interface FLdLongOp {\n+        short apply(MemorySegment memory, long offset, int i);\n@@ -365,2 +364,2 @@\n-    <M> ShortVector ldLongOp(M memory, long offset,\n-                                  FLdLongOp<M> f) {\n+    ShortVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n@@ -378,1 +377,1 @@\n-    <M> ShortVector ldLongOp(M memory, long offset,\n+    ShortVector ldLongOp(MemorySegment memory, long offset,\n@@ -380,1 +379,1 @@\n-                                  FLdLongOp<M> f) {\n+                                  FLdLongOp f) {\n@@ -392,28 +391,2 @@\n-    static ShortVector expandHelper(Vector<Short> v, VectorMask<Short> m) {\n-        VectorSpecies<Short> vsp = m.vectorSpecies();\n-        ShortVector r  = (ShortVector) vsp.zero();\n-        ShortVector vi = (ShortVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(i, vi.lane(j++));\n-            }\n-        }\n-        return r;\n-    }\n-\n-    static ShortVector compressHelper(Vector<Short> v, VectorMask<Short> m) {\n-        VectorSpecies<Short> vsp = m.vectorSpecies();\n-        ShortVector r  = (ShortVector) vsp.zero();\n-        ShortVector vi = (ShortVector) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(j++, vi.lane(i));\n-            }\n-        }\n-        return r;\n+    static short memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 2L);\n@@ -452,2 +425,2 @@\n-    interface FStLongOp<M> {\n-        void apply(M memory, long offset, int i, short a);\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, short a);\n@@ -459,2 +432,2 @@\n-    <M> void stLongOp(M memory, long offset,\n-                  FStLongOp<M> f) {\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n@@ -470,1 +443,1 @@\n-    <M> void stLongOp(M memory, long offset,\n+    void stLongOp(MemorySegment memory, long offset,\n@@ -472,1 +445,1 @@\n-                  FStLongOp<M> f) {\n+                  FStLongOp f) {\n@@ -482,0 +455,4 @@\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, short e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 2L, e);\n+    }\n+\n@@ -532,0 +509,30 @@\n+    static ShortVector expandHelper(Vector<Short> v, VectorMask<Short> m) {\n+        VectorSpecies<Short> vsp = m.vectorSpecies();\n+        ShortVector r  = (ShortVector) vsp.zero();\n+        ShortVector vi = (ShortVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static ShortVector compressHelper(Vector<Short> v, VectorMask<Short> m) {\n+        VectorSpecies<Short> vsp = m.vectorSpecies();\n+        ShortVector r  = (ShortVector) vsp.zero();\n+        ShortVector vi = (ShortVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -2957,84 +2964,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    ShortVector fromByteArray(VectorSpecies<Short> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        ShortSpecies vsp = (ShortSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code short} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    ShortVector fromByteArray(VectorSpecies<Short> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Short> m) {\n-        ShortSpecies vsp = (ShortSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 2, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Short>)m,\n-                   (wb_, o, i)  -> wb_.getShort(o + i * 2));\n-    }\n-\n@@ -3339,98 +3262,0 @@\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*2 < 0}\n-     *         or {@code offset+N*2 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    ShortVector fromByteBuffer(VectorSpecies<Short> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n-        ShortSpecies vsp = (ShortSpecies) species;\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code short} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * The following pseudocode illustrates the behavior:\n-     * <pre>{@code\n-     * ShortBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asShortBuffer();\n-     * short[] ar = new short[species.length()];\n-     * for (int n = 0; n < ar.length; n++) {\n-     *     if (m.laneIsSet(n)) {\n-     *         ar[n] = eb.get(n);\n-     *     }\n-     * }\n-     * ShortVector r = ShortVector.fromArray(species, ar, 0);\n-     * }<\/pre>\n-     * @implNote\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*2 < 0}\n-     *         or {@code offset+N*2 >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    ShortVector fromByteBuffer(VectorSpecies<Short> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Short> m) {\n-        ShortSpecies vsp = (ShortSpecies) species;\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 2, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Short>)m,\n-                   (wb_, o, i)  -> wb_.getShort(o + i * 2));\n-    }\n-\n@@ -3536,3 +3361,1 @@\n-        var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n-        return vsp.ldLongOp(ms, offset, (AbstractMask<Short>)m,\n-                   (ms_, o, i)  -> ms_.get(layout, o + i * 2L));\n+        return vsp.ldLongOp(ms, offset, m, ShortVector::memorySegmentGet);\n@@ -3842,66 +3665,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Short> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            ShortSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 2, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n-        }\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Short> m) {\n-        if (m.allTrue()) {\n-            intoByteBuffer(bb, offset, bo);\n-        } else {\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n-            }\n-            ShortSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 2, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n-        }\n-    }\n-\n@@ -4030,71 +3787,0 @@\n-    @Override\n-    abstract\n-    ShortVector fromByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    ShortVector fromByteArray0Template(byte[] a, int offset) {\n-        ShortSpecies vsp = vspecies();\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off,\n-                        (wb_, o, i) -> wb_.getShort(o + i * 2));\n-            });\n-    }\n-\n-    abstract\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Short>>\n-    ShortVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        ShortSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off, vm,\n-                        (wb_, o, i) -> wb_.getShort(o + i * 2));\n-            });\n-    }\n-\n-    abstract\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    ShortVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        ShortSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off,\n-                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n-                });\n-    }\n-\n-    abstract\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Short>>\n-    ShortVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        ShortSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off, vm,\n-                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n-                });\n-    }\n-\n@@ -4111,3 +3797,1 @@\n-                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 2L));\n+                    return s.ldLongOp((MemorySegment) msp, off, ShortVector::memorySegmentGet);\n@@ -4129,3 +3813,1 @@\n-                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * 2L));\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentGet);\n@@ -4173,68 +3855,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        ShortSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off,\n-                        (tb_, o, i, e) -> tb_.putShort(o + i * 2, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Short>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        ShortSpecies vsp = vspecies();\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off, vm,\n-                        (tb_, o, i, e) -> tb_.putShort(o + i * 2, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        ShortSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off,\n-                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n-                });\n-    }\n-\n-    abstract\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Short>>\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        ShortSpecies vsp = vspecies();\n-        m.check(vsp);\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off, vm,\n-                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n-                });\n-    }\n-\n@@ -4250,3 +3864,1 @@\n-                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 2L, e));\n+                    v.stLongOp((MemorySegment) msp, off, ShortVector::memorySegmentSet);\n@@ -4269,3 +3881,1 @@\n-                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * 2L, e));\n+                    v.stLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentSet);\n@@ -4644,2 +4254,2 @@\n-        <M> ShortVector ldLongOp(M memory, long offset,\n-                                      FLdLongOp<M> f) {\n+        ShortVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n@@ -4651,1 +4261,1 @@\n-        <M> ShortVector ldLongOp(M memory, long offset,\n+        ShortVector ldLongOp(MemorySegment memory, long offset,\n@@ -4653,1 +4263,1 @@\n-                                      FLdLongOp<M> f) {\n+                                      FLdLongOp f) {\n@@ -4673,1 +4283,1 @@\n-        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n@@ -4679,1 +4289,1 @@\n-        <M> void stLongOp(M memory, long offset,\n+        void stLongOp(MemorySegment memory, long offset,\n@@ -4681,1 +4291,1 @@\n-                      FStLongOp<M> f) {\n+                      FStLongOp f) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":62,"deletions":452,"binary":false,"changes":514,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.nio.ByteBuffer;\n@@ -768,1 +767,1 @@\n- * in a {@link java.nio.ByteBuffer}.\n+ * in a {@link jdk.incubator.foreign.MemorySegment}.\n@@ -772,1 +771,1 @@\n- * within the array or buffer that holds the vector, producing the\n+ * within the array or segment that holds the vector, producing the\n@@ -2903,3 +2902,2 @@\n-     * buffer or array using little-endian byte ordering and then the\n-     * desired vector is loaded from the same byte buffer or array\n-     * using the same ordering.\n+     * array using little-endian byte ordering and then the desired vector is loaded from the same byte\n+     * array using the same ordering.\n@@ -2914,1 +2912,1 @@\n-     * byte[] ra = new byte[Math.max(domSize, ranSize)];\n+     * MemorySegment ms = MemorySegment.ofArray(new byte[Math.max(domSize, ranSize)]);\n@@ -2916,1 +2914,1 @@\n-     *     this.intoByteArray(ra, 0, ByteOrder.native());\n+     *     this.intoMemorySegment(ms, 0, ByteOrder.native());\n@@ -2918,1 +2916,1 @@\n-     *     return species.fromByteArray(ra, origin, ByteOrder.native());\n+     *     return species.fromMemorySegment(ms, origin, ByteOrder.native());\n@@ -2921,2 +2919,2 @@\n-     *     this.intoByteArray(ra, origin, ByteOrder.native());\n-     *     return species.fromByteArray(ra, 0, ByteOrder.native());\n+     *     this.intoMemorySegment(ms, origin, ByteOrder.native());\n+     *     return species.fromMemorySegment(ms, 0, ByteOrder.native());\n@@ -2959,2 +2957,2 @@\n-     * @see IntVector#intoByteArray(byte[], int, ByteOrder)\n-     * @see FloatVector#intoByteArray(byte[], int, ByteOrder)\n+     * @see IntVector#intoMemorySegment(jdk.incubator.foreign.MemorySegment, long, java.nio.ByteOrder)\n+     * @see FloatVector#intoMemorySegment(jdk.incubator.foreign.MemorySegment, long, java.nio.ByteOrder)\n@@ -3367,148 +3365,0 @@\n-    \/**\n-     * Stores this vector into a byte array starting at an offset\n-     * using explicit byte order.\n-     * <p>\n-     * Bytes are extracted from primitive lane elements according\n-     * to the specified byte ordering.\n-     * The lanes are stored according to their\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it calls\n-     * {@link #intoByteBuffer(ByteBuffer,int,ByteOrder,VectorMask)\n-     * intoByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = maskAll(true);\n-     * intoByteBuffer(bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    public abstract void intoByteArray(byte[] a, int offset,\n-                                       ByteOrder bo);\n-\n-    \/**\n-     * Stores this vector into a byte array starting at an offset\n-     * using explicit byte order and a mask.\n-     * <p>\n-     * Bytes are extracted from primitive lane elements according\n-     * to the specified byte ordering.\n-     * The lanes are stored according to their\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it calls\n-     * {@link #intoByteBuffer(ByteBuffer,int,ByteOrder,VectorMask)\n-     * intoByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * intoByteBuffer(bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    public abstract void intoByteArray(byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<E> m);\n-\n-    \/**\n-     * Stores this vector into a byte buffer starting at an offset\n-     * using explicit byte order.\n-     * <p>\n-     * Bytes are extracted from primitive lane elements according\n-     * to the specified byte ordering.\n-     * The lanes are stored according to their\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it calls\n-     * {@link #intoByteBuffer(ByteBuffer,int,ByteOrder,VectorMask)\n-     * intoByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var m = maskAll(true);\n-     * intoByteBuffer(bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param bb the byte buffer\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     * @throws java.nio.ReadOnlyBufferException\n-     *         if the byte buffer is read-only\n-     *\/\n-    public abstract void intoByteBuffer(ByteBuffer bb, int offset, ByteOrder bo);\n-\n-    \/**\n-     * Stores this vector into a byte buffer starting at an offset\n-     * using explicit byte order and a mask.\n-     * <p>\n-     * Bytes are extracted from primitive lane elements according\n-     * to the specified byte ordering.\n-     * The lanes are stored according to their\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * The following pseudocode illustrates the behavior, where\n-     * the primitive element type is not of {@code byte},\n-     * {@code EBuffer} is the primitive buffer type, {@code ETYPE} is the\n-     * primitive element type, and {@code EVector} is the primitive\n-     * vector type for this vector:\n-     * <pre>{@code\n-     * EBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asEBuffer();\n-     * ETYPE[] a = this.toArray();\n-     * for (int n = 0; n < a.length; n++) {\n-     *     if (m.laneIsSet(n)) {\n-     *         eb.put(n, a[n]);\n-     *     }\n-     * }\n-     * }<\/pre>\n-     * When the primitive element type is of {@code byte} the primitive\n-     * byte buffer is obtained as follows, where operation on the buffer\n-     * remains the same as in the prior pseudocode:\n-     * <pre>{@code\n-     * ByteBuffer eb = bb.duplicate()\n-     *     .position(offset);\n-     * }<\/pre>\n-     *\n-     * @implNote\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-     * In the special case where {@code ETYPE} is\n-     * {@code byte}, the byte order argument is\n-     * ignored.\n-     *\n-     * @param bb the byte buffer\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     * @throws java.nio.ReadOnlyBufferException\n-     *         if the byte buffer is read-only\n-     *\/\n-    public abstract void intoByteBuffer(ByteBuffer bb, int offset,\n-                                        ByteOrder bo, VectorMask<E> m);\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":11,"deletions":161,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.incubator.foreign.MemorySegment;\n+\n@@ -477,3 +479,3 @@\n-    \/**\n-     * Loads a vector of this species from a byte array starting\n-     * at an offset.\n+     \/**\n+     * Loads a vector of this species from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n@@ -486,2 +488,1 @@\n-     * {@code IntVector.fromByteArray(this,a,offset,bo)}\n-     * or an equivalent {@code fromByteArray} method,\n+     * {@code IntVector.fromMemorySegment(this,ms,offset,bo)},\n@@ -491,2 +492,2 @@\n-     * @param a a byte array\n-     * @param offset the index of the first byte to load\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -494,1 +495,1 @@\n-     * @return a vector of the given species filled from the byte array\n+     * @return a vector of the given species filled from the memory segment\n@@ -499,2 +500,2 @@\n-     * @see IntVector#fromByteArray(VectorSpecies,byte[],int,ByteOrder)\n-     * @see FloatVector#fromByteArray(VectorSpecies,byte[],int,ByteOrder)\n+     * @see IntVector#fromMemorySegment(VectorSpecies, jdk.incubator.foreign.MemorySegment, long, java.nio.ByteOrder)\n+     * @see FloatVector#fromMemorySegment(VectorSpecies, jdk.incubator.foreign.MemorySegment, long, java.nio.ByteOrder)\n@@ -502,1 +503,1 @@\n-    Vector<E> fromByteArray(byte[] a, int offset, ByteOrder bo);\n+    Vector<E> fromMemorySegment(MemorySegment ms, long offset, ByteOrder bo);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorSpecies.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -67,0 +64,2 @@\n+    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+\n@@ -362,2 +361,2 @@\n-    interface FLdLongOp<M> {\n-        $type$ apply(M memory, long offset, int i);\n+    interface FLdLongOp {\n+        $type$ apply(MemorySegment memory, long offset, int i);\n@@ -369,2 +368,2 @@\n-    <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n-                                  FLdLongOp<M> f) {\n+    $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n@@ -382,1 +381,1 @@\n-    <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n+    $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n@@ -384,1 +383,1 @@\n-                                  FLdLongOp<M> f) {\n+                                  FLdLongOp f) {\n@@ -396,28 +395,2 @@\n-    static $abstractvectortype$ expandHelper(Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n-        VectorSpecies<$Boxtype$> vsp = m.vectorSpecies();\n-        $abstractvectortype$ r  = ($abstractvectortype$) vsp.zero();\n-        $abstractvectortype$ vi = ($abstractvectortype$) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(i, vi.lane(j++));\n-            }\n-        }\n-        return r;\n-    }\n-\n-    static $abstractvectortype$ compressHelper(Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n-        VectorSpecies<$Boxtype$> vsp = m.vectorSpecies();\n-        $abstractvectortype$ r  = ($abstractvectortype$) vsp.zero();\n-        $abstractvectortype$ vi = ($abstractvectortype$) v;\n-        if (m.allTrue()) {\n-            return vi;\n-        }\n-        for (int i = 0, j = 0; i < vsp.length(); i++) {\n-            if (m.laneIsSet(i)) {\n-                r = r.withLane(j++, vi.lane(i));\n-            }\n-        }\n-        return r;\n+    static $type$ memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * $sizeInBytes$L);\n@@ -456,2 +429,2 @@\n-    interface FStLongOp<M> {\n-        void apply(M memory, long offset, int i, $type$ a);\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, $type$ a);\n@@ -463,2 +436,2 @@\n-    <M> void stLongOp(M memory, long offset,\n-                  FStLongOp<M> f) {\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n@@ -474,1 +447,1 @@\n-    <M> void stLongOp(M memory, long offset,\n+    void stLongOp(MemorySegment memory, long offset,\n@@ -476,1 +449,1 @@\n-                  FStLongOp<M> f) {\n+                  FStLongOp f) {\n@@ -486,0 +459,4 @@\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, $type$ e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * $sizeInBytes$L, e);\n+    }\n+\n@@ -546,0 +523,30 @@\n+    static $abstractvectortype$ expandHelper(Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+        VectorSpecies<$Boxtype$> vsp = m.vectorSpecies();\n+        $abstractvectortype$ r  = ($abstractvectortype$) vsp.zero();\n+        $abstractvectortype$ vi = ($abstractvectortype$) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static $abstractvectortype$ compressHelper(Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+        VectorSpecies<$Boxtype$> vsp = m.vectorSpecies();\n+        $abstractvectortype$ r  = ($abstractvectortype$) vsp.zero();\n+        $abstractvectortype$ vi = ($abstractvectortype$) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -3525,84 +3532,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    $abstractvectortype$ fromByteArray(VectorSpecies<$Boxtype$> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        $Type$Species vsp = ($Type$Species) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code $type$} ({#if[FP]?positive }zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    $abstractvectortype$ fromByteArray(VectorSpecies<$Boxtype$> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<$Boxtype$> m) {\n-        $Type$Species vsp = ($Type$Species) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<$Boxtype$>)m,\n-                   (wb_, o, i)  -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-    }\n-\n@@ -4139,104 +4062,0 @@\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*$sizeInBytes$ < 0}\n-     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n-        $Type$Species vsp = ($Type$Species) species;\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code $type$} ({#if[FP]?positive }zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * The following pseudocode illustrates the behavior:\n-     * <pre>{@code\n-     * $Type$Buffer eb = bb.duplicate()\n-     *     .position(offset){#if[byte]?;}\n-#if[!byte]\n-     *     .order(bo).as$Type$Buffer();\n-#end[!byte]\n-     * $type$[] ar = new $type$[species.length()];\n-     * for (int n = 0; n < ar.length; n++) {\n-     *     if (m.laneIsSet(n)) {\n-     *         ar[n] = eb.get(n);\n-     *     }\n-     * }\n-     * $abstractvectortype$ r = $abstractvectortype$.fromArray(species, ar, 0);\n-     * }<\/pre>\n-     * @implNote\n-#if[!byte]\n-     * This operation is likely to be more efficient if\n-     * the specified byte order is the same as\n-     * {@linkplain ByteOrder#nativeOrder()\n-     * the platform native order},\n-     * since this method will not need to reorder\n-     * the bytes of lane values.\n-#else[!byte]\n-     * The byte order argument is ignored.\n-#end[!byte]\n-     *\n-     * @param species species of desired vector\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte buffer\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*$sizeInBytes$ < 0}\n-     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<$Boxtype$> m) {\n-        $Type$Species vsp = ($Type$Species) species;\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<$Boxtype$>)m,\n-                   (wb_, o, i)  -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-    }\n-\n@@ -4346,3 +4165,1 @@\n-        var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n-        return vsp.ldLongOp(ms, offset, (AbstractMask<$Boxtype$>)m,\n-                   (ms_, o, i)  -> ms_.get(layout, o + i * $sizeInBytes$L));\n+        return vsp.ldLongOp(ms, offset, m, $abstractvectortype$::memorySegmentGet);\n@@ -4891,66 +4708,0 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<$Boxtype$> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            $Type$Species vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n-        }\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<$Boxtype$> m) {\n-        if (m.allTrue()) {\n-            intoByteBuffer(bb, offset, bo);\n-        } else {\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n-            }\n-            $Type$Species vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n-        }\n-    }\n-\n@@ -5174,71 +4925,0 @@\n-    @Override\n-    abstract\n-    $abstractvectortype$ fromByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    $abstractvectortype$ fromByteArray0Template(byte[] a, int offset) {\n-        $Type$Species vsp = vspecies();\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off,\n-                        (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-            });\n-    }\n-\n-    abstract\n-    $abstractvectortype$ fromByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<$Boxtype$>>\n-    $abstractvectortype$ fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        $Type$Species vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, (int) off, vm,\n-                        (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-            });\n-    }\n-\n-    abstract\n-    $abstractvectortype$ fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    $abstractvectortype$ fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        $Type$Species vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off,\n-                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-                });\n-    }\n-\n-    abstract\n-    $abstractvectortype$ fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<$Boxtype$>>\n-    $abstractvectortype$ fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        $Type$Species vsp = vspecies();\n-        m.check(vsp);\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, (int) off, vm,\n-                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-                });\n-    }\n-\n@@ -5255,3 +4935,1 @@\n-                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * $sizeInBytes$L));\n+                    return s.ldLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentGet);\n@@ -5273,3 +4951,1 @@\n-                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n-                    return s.ldLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i) -> ms_.get(layout, o + i * $sizeInBytes$L));\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentGet);\n@@ -5397,68 +5073,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        $Type$Species vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off,\n-                        (tb_, o, i, e) -> tb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<$Boxtype$>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        $Type$Species vsp = vspecies();\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, (int) off, vm,\n-                        (tb_, o, i, e) -> tb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        $Type$Species vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off,\n-                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-                });\n-    }\n-\n-    abstract\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<$Boxtype$>>\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n-        $Type$Species vsp = vspecies();\n-        m.check(vsp);\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n-                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, (int) off, vm,\n-                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-                });\n-    }\n-\n@@ -5474,3 +5082,1 @@\n-                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * $sizeInBytes$L, e));\n+                    v.stLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentSet);\n@@ -5493,3 +5099,1 @@\n-                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n-                    v.stLongOp((MemorySegment) msp, off, vm,\n-                            (ms_, o, i, e) -> ms_.set(layout, o + i * $sizeInBytes$L, e));\n+                    v.stLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentSet);\n@@ -5911,2 +5515,2 @@\n-        <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n-                                      FLdLongOp<M> f) {\n+        $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n@@ -5918,1 +5522,1 @@\n-        <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n+        $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n@@ -5920,1 +5524,1 @@\n-                                      FLdLongOp<M> f) {\n+                                      FLdLongOp f) {\n@@ -5940,1 +5544,1 @@\n-        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n@@ -5946,1 +5550,1 @@\n-        <M> void stLongOp(M memory, long offset,\n+        void stLongOp(MemorySegment memory, long offset,\n@@ -5948,1 +5552,1 @@\n-                      FStLongOp<M> f) {\n+                      FStLongOp f) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":62,"deletions":458,"binary":false,"changes":520,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -1185,28 +1184,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    $abstractvectortype$ fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    $abstractvectortype$ fromByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m) {\n-        return super.fromByteArray0Template($masktype$.class, a, offset, ($masktype$) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    $abstractvectortype$ fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    $abstractvectortype$ fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m) {\n-        return super.fromByteBuffer0Template($masktype$.class, bb, offset, ($masktype$) m);  \/\/ specialize\n-    }\n-\n@@ -1259,21 +1230,0 @@\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m) {\n-        super.intoByteArray0Template($masktype$.class, a, offset, ($masktype$) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m) {\n-        super.intoByteBuffer0Template($masktype$.class, bb, offset, ($masktype$) m);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, 2022, THL A29 Limited, a Tencent company. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -43,0 +44,2 @@\n+  static MemorySegment msa = MemorySegment.ofArray(a);\n+  static MemorySegment msr = MemorySegment.ofArray(r);\n@@ -45,2 +48,2 @@\n-    DoubleVector av = DoubleVector.fromByteArray(SPECIES256, a, 0, ByteOrder.BIG_ENDIAN);\n-    av.intoByteArray(r, 0, ByteOrder.BIG_ENDIAN);\n+    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES256, msa, 0, ByteOrder.BIG_ENDIAN);\n+    av.intoMemorySegment(msr, 0, ByteOrder.BIG_ENDIAN);\n@@ -48,2 +51,2 @@\n-    DoubleVector bv = DoubleVector.fromByteArray(SPECIES256, a, 32, ByteOrder.LITTLE_ENDIAN);\n-    bv.intoByteArray(r, 32, ByteOrder.LITTLE_ENDIAN);\n+    DoubleVector bv = DoubleVector.fromMemorySegment(SPECIES256, msa, 32, ByteOrder.LITTLE_ENDIAN);\n+    bv.intoMemorySegment(msr, 32, ByteOrder.LITTLE_ENDIAN);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestIntrinsicBailOut.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.nio.ByteBuffer;\n@@ -41,0 +40,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -56,1 +56,1 @@\n-    final var bb = ByteBuffer.wrap(arr);\n+    final var ms = MemorySegment.ofArray(arr);\n@@ -62,1 +62,1 @@\n-    res.add(ones).intoByteBuffer(bb, 0, ByteOrder.nativeOrder());\n+    res.add(ones).intoMemorySegment(ms, 0L, ByteOrder.nativeOrder());\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,2 +23,0 @@\n-import jdk.incubator.vector.*;\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -29,2 +27,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -36,2 +32,3 @@\n-import jdk.incubator.vector.VectorShape;\n-import jdk.incubator.vector.VectorSpecies;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.vector.*;\n@@ -46,1 +43,1 @@\n- * @run testng\/othervm -XX:CompileCommand=compileonly,jdk\/incubator\/vector\/ByteVector.fromByteBuffer\n+ * @run testng\/othervm -XX:CompileCommand=compileonly,jdk\/incubator\/vector\/ByteVector.fromMemorySegment\n@@ -127,2 +124,4 @@\n-    void testVectorRebracket(VectorSpecies<E> a, VectorSpecies<F> b, byte[] input, byte[] output) {\n-        Vector<E> av = a.fromByteArray(input, 0, ByteOrder.nativeOrder());\n+    void testVectorRebracket(VectorSpecies<E> a, VectorSpecies<F> b,\n+                             byte[] input, byte[] output,\n+                             MemorySegment msInput, MemorySegment msOutput) {\n+        Vector<E> av = a.fromMemorySegment(msInput, 0, ByteOrder.nativeOrder());\n@@ -142,1 +141,1 @@\n-        bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+        bv.intoMemorySegment(msOutput, 0, ByteOrder.nativeOrder());\n@@ -155,0 +154,2 @@\n+        MemorySegment msin = MemorySegment.ofArray(barr);\n+        MemorySegment msout = MemorySegment.ofArray(bout);\n@@ -156,3 +157,3 @@\n-            testVectorRebracket(bspec128, bspec128, barr, bout);\n-            testVectorRebracket(bspec128, sspec128, barr, bout);\n-            testVectorRebracket(bspec128, ispec128, barr, bout);\n+            testVectorRebracket(bspec128, bspec128, barr, bout, msin, msout);\n+            testVectorRebracket(bspec128, sspec128, barr, bout, msin, msout);\n+            testVectorRebracket(bspec128, ispec128, barr, bout, msin, msout);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorRebracket128Test.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -41,1 +42,1 @@\n-    public static void testB64toB128(byte[] input, byte[] output) {\n+    public static void testB64toB128(MemorySegment input, MemorySegment output) {\n@@ -52,1 +53,1 @@\n-    public static void testB64toB256(byte[] input, byte[] output) {\n+    public static void testB64toB256(MemorySegment input, MemorySegment output) {\n@@ -63,1 +64,1 @@\n-    public static void testB64toB512(byte[] input, byte[] output) {\n+    public static void testB64toB512(MemorySegment input, MemorySegment output) {\n@@ -74,1 +75,1 @@\n-    public static void testB128toB64(byte[] input, byte[] output) {\n+    public static void testB128toB64(MemorySegment input, MemorySegment output) {\n@@ -85,1 +86,1 @@\n-    public static void testB128toB256(byte[] input, byte[] output) {\n+    public static void testB128toB256(MemorySegment input, MemorySegment output) {\n@@ -96,1 +97,1 @@\n-    public static void testB128toB512(byte[] input, byte[] output) {\n+    public static void testB128toB512(MemorySegment input, MemorySegment output) {\n@@ -107,1 +108,1 @@\n-    public static void testB256toB64(byte[] input, byte[] output) {\n+    public static void testB256toB64(MemorySegment input, MemorySegment output) {\n@@ -118,1 +119,1 @@\n-    public static void testB256toB128(byte[] input, byte[] output) {\n+    public static void testB256toB128(MemorySegment input, MemorySegment output) {\n@@ -129,1 +130,1 @@\n-    public static void testB256toB512(byte[] input, byte[] output) {\n+    public static void testB256toB512(MemorySegment input, MemorySegment output) {\n@@ -140,1 +141,1 @@\n-    public static void testB512toB64(byte[] input, byte[] output) {\n+    public static void testB512toB64(MemorySegment input, MemorySegment output) {\n@@ -151,1 +152,1 @@\n-    public static void testB512toB128(byte[] input, byte[] output) {\n+    public static void testB512toB128(MemorySegment input, MemorySegment output) {\n@@ -162,1 +163,1 @@\n-    public static void testB512toB256(byte[] input, byte[] output) {\n+    public static void testB512toB256(MemorySegment input, MemorySegment output) {\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorDoubleExpandShrink.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -41,1 +42,1 @@\n-    public static void testB64toB128(byte[] input, byte[] output) {\n+    public static void testB64toB128(MemorySegment input, MemorySegment output) {\n@@ -52,1 +53,1 @@\n-    public static void testB64toB256(byte[] input, byte[] output) {\n+    public static void testB64toB256(MemorySegment input, MemorySegment output) {\n@@ -63,1 +64,1 @@\n-    public static void testB64toB512(byte[] input, byte[] output) {\n+    public static void testB64toB512(MemorySegment input, MemorySegment output) {\n@@ -74,1 +75,1 @@\n-    public static void testB128toB64(byte[] input, byte[] output) {\n+    public static void testB128toB64(MemorySegment input, MemorySegment output) {\n@@ -85,1 +86,1 @@\n-    public static void testB128toB256(byte[] input, byte[] output) {\n+    public static void testB128toB256(MemorySegment input, MemorySegment output) {\n@@ -96,1 +97,1 @@\n-    public static void testB128toB512(byte[] input, byte[] output) {\n+    public static void testB128toB512(MemorySegment input, MemorySegment output) {\n@@ -107,1 +108,1 @@\n-    public static void testB256toB64(byte[] input, byte[] output) {\n+    public static void testB256toB64(MemorySegment input, MemorySegment output) {\n@@ -118,1 +119,1 @@\n-    public static void testB256toB128(byte[] input, byte[] output) {\n+    public static void testB256toB128(MemorySegment input, MemorySegment output) {\n@@ -129,1 +130,1 @@\n-    public static void testB256toB512(byte[] input, byte[] output) {\n+    public static void testB256toB512(MemorySegment input, MemorySegment output) {\n@@ -140,1 +141,1 @@\n-    public static void testB512toB64(byte[] input, byte[] output) {\n+    public static void testB512toB64(MemorySegment input, MemorySegment output) {\n@@ -151,1 +152,1 @@\n-    public static void testB512toB128(byte[] input, byte[] output) {\n+    public static void testB512toB128(MemorySegment input, MemorySegment output) {\n@@ -162,1 +163,1 @@\n-    public static void testB512toB256(byte[] input, byte[] output) {\n+    public static void testB512toB256(MemorySegment input, MemorySegment output) {\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorExpandShrink.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -215,2 +216,3 @@\n-    public static void vectorExpandShrink(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp, byte[] input, byte[] output) {\n-        isp.fromByteArray(input, 0, ByteOrder.nativeOrder())\n+    public static void vectorExpandShrink(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp,\n+                                          MemorySegment input, MemorySegment output) {\n+        isp.fromMemorySegment(input, 0, ByteOrder.nativeOrder())\n@@ -218,1 +220,1 @@\n-                .intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                .intoMemorySegment(output, 0, ByteOrder.nativeOrder());\n@@ -227,1 +229,1 @@\n-                MethodType.methodType(void.class, byte.class.arrayType(), byte.class.arrayType()));\n+                MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n@@ -230,0 +232,2 @@\n+        MemorySegment msInput = MemorySegment.ofArray(input);\n+        MemorySegment msOutput = MemorySegment.ofArray(output);\n@@ -233,1 +237,1 @@\n-            testMethod.invokeExact(input, output);\n+            testMethod.invokeExact(msInput, msOutput);\n@@ -244,2 +248,3 @@\n-    public static void vectorDoubleExpandShrink(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp, byte[] input, byte[] output) {\n-        isp.fromByteArray(input, 0, ByteOrder.nativeOrder())\n+    public static void vectorDoubleExpandShrink(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp,\n+                                                MemorySegment input, MemorySegment output) {\n+        isp.fromMemorySegment(input, 0, ByteOrder.nativeOrder())\n@@ -248,1 +253,1 @@\n-                .intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                .intoMemorySegment(output, 0, ByteOrder.nativeOrder());\n@@ -257,1 +262,1 @@\n-                MethodType.methodType(void.class, byte.class.arrayType(), byte.class.arrayType()));\n+                MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n@@ -260,0 +265,2 @@\n+        MemorySegment msInput = MemorySegment.ofArray(input);\n+        MemorySegment msOutput = MemorySegment.ofArray(output);\n@@ -263,1 +270,1 @@\n-            testMethod.invokeExact(input, output);\n+            testMethod.invokeExact(msInput, msOutput);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorReshapeHelper.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import java.nio.ByteBuffer;\n@@ -47,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -72,1 +70,0 @@\n-\n@@ -182,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] byteByteBufferProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -224,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] byteByteArrayProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -262,15 +219,0 @@\n-    static ByteBuffer toBuffer(byte[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static byte[] bufferToArray(ByteBuffer bb) {\n-        ByteBuffer db = bb;\n-        byte[] d = new byte[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -289,9 +231,0 @@\n-    static byte[] toByteArray(byte[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ByteBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -334,40 +267,0 @@\n-    @DontInline\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -564,221 +457,0 @@\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<byte[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        byte[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -992,174 +664,0 @@\n-\n-    @Test(dataProvider = \"byteByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<byte[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<byte[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":0,"deletions":502,"binary":false,"changes":502,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import java.nio.ByteBuffer;\n@@ -47,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -72,1 +70,0 @@\n-\n@@ -182,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] byteByteBufferProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -224,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] byteByteArrayProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -262,15 +219,0 @@\n-    static ByteBuffer toBuffer(byte[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static byte[] bufferToArray(ByteBuffer bb) {\n-        ByteBuffer db = bb;\n-        byte[] d = new byte[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -289,9 +231,0 @@\n-    static byte[] toByteArray(byte[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ByteBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -334,40 +267,0 @@\n-    @DontInline\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -564,221 +457,0 @@\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<byte[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        byte[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -992,174 +664,0 @@\n-\n-    @Test(dataProvider = \"byteByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<byte[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<byte[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":0,"deletions":502,"binary":false,"changes":502,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import java.nio.ByteBuffer;\n@@ -47,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -72,1 +70,0 @@\n-\n@@ -182,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] byteByteBufferProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -224,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] byteByteArrayProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -262,15 +219,0 @@\n-    static ByteBuffer toBuffer(byte[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static byte[] bufferToArray(ByteBuffer bb) {\n-        ByteBuffer db = bb;\n-        byte[] d = new byte[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -289,9 +231,0 @@\n-    static byte[] toByteArray(byte[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ByteBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -334,40 +267,0 @@\n-    @DontInline\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -564,221 +457,0 @@\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<byte[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        byte[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -992,174 +664,0 @@\n-\n-    @Test(dataProvider = \"byteByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<byte[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<byte[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":0,"deletions":502,"binary":false,"changes":502,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import java.nio.ByteBuffer;\n@@ -47,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -72,1 +70,0 @@\n-\n@@ -182,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] byteByteBufferProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -224,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] byteByteArrayProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -262,15 +219,0 @@\n-    static ByteBuffer toBuffer(byte[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static byte[] bufferToArray(ByteBuffer bb) {\n-        ByteBuffer db = bb;\n-        byte[] d = new byte[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -289,9 +231,0 @@\n-    static byte[] toByteArray(byte[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ByteBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -334,40 +267,0 @@\n-    @DontInline\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -564,221 +457,0 @@\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<byte[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        byte[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -992,174 +664,0 @@\n-\n-    @Test(dataProvider = \"byteByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<byte[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<byte[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":0,"deletions":502,"binary":false,"changes":502,"status":"modified"},{"patch":"@@ -47,3 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n@@ -51,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -81,1 +77,0 @@\n-\n@@ -191,21 +186,0 @@\n-    @DataProvider\n-    public Object[][] byteByteBufferProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -233,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] byteByteArrayProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -271,15 +226,0 @@\n-    static ByteBuffer toBuffer(byte[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static byte[] bufferToArray(ByteBuffer bb) {\n-        ByteBuffer db = bb;\n-        byte[] d = new byte[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -298,9 +238,0 @@\n-    static byte[] toByteArray(byte[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ByteBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -343,40 +274,0 @@\n-    @DontInline\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -573,221 +464,0 @@\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<byte[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        byte[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1001,174 +671,0 @@\n-\n-    @Test(dataProvider = \"byteByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<byte[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<byte[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":0,"deletions":504,"binary":false,"changes":504,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.DoubleBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteBufferProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteArrayProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(double[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (double v : a) {\n-            bb.putDouble(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static double[] bufferToArray(ByteBuffer bb) {\n-        DoubleBuffer db = bb.asDoubleBuffer();\n-        double[] d = new double[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(double[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        DoubleBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asDoubleBuffer();\n-        for (double v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<double[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        double[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"doubleByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<double[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<double[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.DoubleBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteBufferProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteArrayProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(double[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (double v : a) {\n-            bb.putDouble(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static double[] bufferToArray(ByteBuffer bb) {\n-        DoubleBuffer db = bb.asDoubleBuffer();\n-        double[] d = new double[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(double[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        DoubleBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asDoubleBuffer();\n-        for (double v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<double[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        double[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"doubleByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<double[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<double[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.DoubleBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteBufferProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteArrayProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(double[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (double v : a) {\n-            bb.putDouble(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static double[] bufferToArray(ByteBuffer bb) {\n-        DoubleBuffer db = bb.asDoubleBuffer();\n-        double[] d = new double[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(double[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        DoubleBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asDoubleBuffer();\n-        for (double v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<double[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        double[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"doubleByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<double[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<double[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.DoubleBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteBufferProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteArrayProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(double[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (double v : a) {\n-            bb.putDouble(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static double[] bufferToArray(ByteBuffer bb) {\n-        DoubleBuffer db = bb.asDoubleBuffer();\n-        double[] d = new double[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(double[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        DoubleBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asDoubleBuffer();\n-        for (double v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<double[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        double[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"doubleByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<double[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<double[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -47,4 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.DoubleBuffer;\n@@ -52,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -82,11 +77,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -202,21 +186,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteBufferProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -244,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteArrayProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -282,15 +226,0 @@\n-    static ByteBuffer toBuffer(double[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (double v : a) {\n-            bb.putDouble(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static double[] bufferToArray(ByteBuffer bb) {\n-        DoubleBuffer db = bb.asDoubleBuffer();\n-        double[] d = new double[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -309,9 +238,0 @@\n-    static byte[] toByteArray(double[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        DoubleBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asDoubleBuffer();\n-        for (double v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -354,40 +274,0 @@\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -584,221 +464,0 @@\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<double[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        double[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1012,174 +671,0 @@\n-\n-    @Test(dataProvider = \"doubleByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<double[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<double[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":0,"deletions":515,"binary":false,"changes":515,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.FloatBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] floatByteBufferProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] floatByteArrayProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(float[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (float v : a) {\n-            bb.putFloat(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static float[] bufferToArray(ByteBuffer bb) {\n-        FloatBuffer db = bb.asFloatBuffer();\n-        float[] d = new float[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(float[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        FloatBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asFloatBuffer();\n-        for (float v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<float[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        float[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"floatByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<float[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<float[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.FloatBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] floatByteBufferProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] floatByteArrayProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(float[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (float v : a) {\n-            bb.putFloat(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static float[] bufferToArray(ByteBuffer bb) {\n-        FloatBuffer db = bb.asFloatBuffer();\n-        float[] d = new float[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(float[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        FloatBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asFloatBuffer();\n-        for (float v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<float[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        float[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"floatByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<float[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<float[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.FloatBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] floatByteBufferProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] floatByteArrayProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(float[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (float v : a) {\n-            bb.putFloat(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static float[] bufferToArray(ByteBuffer bb) {\n-        FloatBuffer db = bb.asFloatBuffer();\n-        float[] d = new float[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(float[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        FloatBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asFloatBuffer();\n-        for (float v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<float[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        float[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"floatByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<float[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<float[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.FloatBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] floatByteBufferProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] floatByteArrayProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(float[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (float v : a) {\n-            bb.putFloat(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static float[] bufferToArray(ByteBuffer bb) {\n-        FloatBuffer db = bb.asFloatBuffer();\n-        float[] d = new float[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(float[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        FloatBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asFloatBuffer();\n-        for (float v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<float[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        float[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"floatByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<float[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<float[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -47,4 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.FloatBuffer;\n@@ -52,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -82,11 +77,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -202,21 +186,0 @@\n-    @DataProvider\n-    public Object[][] floatByteBufferProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -244,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] floatByteArrayProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -282,15 +226,0 @@\n-    static ByteBuffer toBuffer(float[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (float v : a) {\n-            bb.putFloat(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static float[] bufferToArray(ByteBuffer bb) {\n-        FloatBuffer db = bb.asFloatBuffer();\n-        float[] d = new float[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -309,9 +238,0 @@\n-    static byte[] toByteArray(float[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        FloatBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asFloatBuffer();\n-        for (float v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -354,40 +274,0 @@\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -584,221 +464,0 @@\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<float[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        float[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1012,174 +671,0 @@\n-\n-    @Test(dataProvider = \"floatByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<float[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<float[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":0,"deletions":515,"binary":false,"changes":515,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] intByteBufferProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] intByteArrayProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(int[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (int v : a) {\n-            bb.putInt(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static int[] bufferToArray(ByteBuffer bb) {\n-        IntBuffer db = bb.asIntBuffer();\n-        int[] d = new int[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(int[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        IntBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asIntBuffer();\n-        for (int v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<int[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        int[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"intByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<int[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<int[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] intByteBufferProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] intByteArrayProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(int[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (int v : a) {\n-            bb.putInt(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static int[] bufferToArray(ByteBuffer bb) {\n-        IntBuffer db = bb.asIntBuffer();\n-        int[] d = new int[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(int[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        IntBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asIntBuffer();\n-        for (int v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<int[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        int[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"intByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<int[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<int[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] intByteBufferProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] intByteArrayProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(int[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (int v : a) {\n-            bb.putInt(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static int[] bufferToArray(ByteBuffer bb) {\n-        IntBuffer db = bb.asIntBuffer();\n-        int[] d = new int[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(int[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        IntBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asIntBuffer();\n-        for (int v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<int[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        int[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"intByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<int[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<int[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] intByteBufferProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] intByteArrayProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(int[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (int v : a) {\n-            bb.putInt(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static int[] bufferToArray(ByteBuffer bb) {\n-        IntBuffer db = bb.asIntBuffer();\n-        int[] d = new int[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(int[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        IntBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asIntBuffer();\n-        for (int v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<int[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        int[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"intByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<int[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<int[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -47,4 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n@@ -52,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -82,11 +77,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -202,21 +186,0 @@\n-    @DataProvider\n-    public Object[][] intByteBufferProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -244,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] intByteArrayProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -282,15 +226,0 @@\n-    static ByteBuffer toBuffer(int[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (int v : a) {\n-            bb.putInt(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static int[] bufferToArray(ByteBuffer bb) {\n-        IntBuffer db = bb.asIntBuffer();\n-        int[] d = new int[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -309,9 +238,0 @@\n-    static byte[] toByteArray(int[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        IntBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asIntBuffer();\n-        for (int v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -354,40 +274,0 @@\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -584,221 +464,0 @@\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<int[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        int[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1012,174 +671,0 @@\n-\n-    @Test(dataProvider = \"intByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<int[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<int[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":0,"deletions":515,"binary":false,"changes":515,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.LongBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] longByteBufferProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] longByteArrayProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(long[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (long v : a) {\n-            bb.putLong(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static long[] bufferToArray(ByteBuffer bb) {\n-        LongBuffer db = bb.asLongBuffer();\n-        long[] d = new long[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(long[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        LongBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asLongBuffer();\n-        for (long v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<long[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        long[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"longByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<long[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<long[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.LongBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] longByteBufferProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] longByteArrayProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(long[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (long v : a) {\n-            bb.putLong(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static long[] bufferToArray(ByteBuffer bb) {\n-        LongBuffer db = bb.asLongBuffer();\n-        long[] d = new long[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(long[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        LongBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asLongBuffer();\n-        for (long v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<long[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        long[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"longByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<long[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<long[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.LongBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] longByteBufferProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] longByteArrayProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(long[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (long v : a) {\n-            bb.putLong(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static long[] bufferToArray(ByteBuffer bb) {\n-        LongBuffer db = bb.asLongBuffer();\n-        long[] d = new long[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(long[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        LongBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asLongBuffer();\n-        for (long v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<long[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        long[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"longByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<long[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<long[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.LongBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] longByteBufferProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] longByteArrayProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(long[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (long v : a) {\n-            bb.putLong(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static long[] bufferToArray(ByteBuffer bb) {\n-        LongBuffer db = bb.asLongBuffer();\n-        long[] d = new long[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(long[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        LongBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asLongBuffer();\n-        for (long v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<long[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        long[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"longByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<long[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<long[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -47,4 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.LongBuffer;\n@@ -52,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -82,11 +77,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -202,21 +186,0 @@\n-    @DataProvider\n-    public Object[][] longByteBufferProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -244,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] longByteArrayProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -282,15 +226,0 @@\n-    static ByteBuffer toBuffer(long[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (long v : a) {\n-            bb.putLong(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static long[] bufferToArray(ByteBuffer bb) {\n-        LongBuffer db = bb.asLongBuffer();\n-        long[] d = new long[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -309,9 +238,0 @@\n-    static byte[] toByteArray(long[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        LongBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asLongBuffer();\n-        for (long v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -354,40 +274,0 @@\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -584,221 +464,0 @@\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<long[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        long[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1012,174 +671,0 @@\n-\n-    @Test(dataProvider = \"longByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<long[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<long[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":0,"deletions":515,"binary":false,"changes":515,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ShortBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] shortByteBufferProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] shortByteArrayProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(short[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (short v : a) {\n-            bb.putShort(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static short[] bufferToArray(ByteBuffer bb) {\n-        ShortBuffer db = bb.asShortBuffer();\n-        short[] d = new short[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(short[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ShortBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asShortBuffer();\n-        for (short v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<short[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        short[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"shortByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<short[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<short[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ShortBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] shortByteBufferProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] shortByteArrayProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(short[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (short v : a) {\n-            bb.putShort(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static short[] bufferToArray(ByteBuffer bb) {\n-        ShortBuffer db = bb.asShortBuffer();\n-        short[] d = new short[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(short[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ShortBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asShortBuffer();\n-        for (short v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<short[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        short[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"shortByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<short[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<short[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ShortBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] shortByteBufferProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] shortByteArrayProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(short[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (short v : a) {\n-            bb.putShort(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static short[] bufferToArray(ByteBuffer bb) {\n-        ShortBuffer db = bb.asShortBuffer();\n-        short[] d = new short[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(short[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ShortBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asShortBuffer();\n-        for (short v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<short[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        short[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"shortByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<short[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<short[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ShortBuffer;\n@@ -48,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -73,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -193,21 +179,0 @@\n-    @DataProvider\n-    public Object[][] shortByteBufferProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -235,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] shortByteArrayProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -273,15 +219,0 @@\n-    static ByteBuffer toBuffer(short[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (short v : a) {\n-            bb.putShort(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static short[] bufferToArray(ByteBuffer bb) {\n-        ShortBuffer db = bb.asShortBuffer();\n-        short[] d = new short[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -300,9 +231,0 @@\n-    static byte[] toByteArray(short[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ShortBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asShortBuffer();\n-        for (short v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -345,40 +267,0 @@\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -575,221 +457,0 @@\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<short[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        short[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1003,174 +664,0 @@\n-\n-    @Test(dataProvider = \"shortByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<short[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<short[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -47,4 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.ShortBuffer;\n@@ -52,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -82,11 +77,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -202,21 +186,0 @@\n-    @DataProvider\n-    public Object[][] shortByteBufferProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -244,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] shortByteArrayProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -282,15 +226,0 @@\n-    static ByteBuffer toBuffer(short[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (short v : a) {\n-            bb.putShort(v);\n-        }\n-        return bb.clear();\n-    }\n-\n-    static short[] bufferToArray(ByteBuffer bb) {\n-        ShortBuffer db = bb.asShortBuffer();\n-        short[] d = new short[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -309,9 +238,0 @@\n-    static byte[] toByteArray(short[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ShortBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asShortBuffer();\n-        for (short v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -354,40 +274,0 @@\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -584,221 +464,0 @@\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<short[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        short[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n@@ -1012,174 +671,0 @@\n-\n-    @Test(dataProvider = \"shortByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<short[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<short[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":0,"deletions":515,"binary":false,"changes":515,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -29,2 +30,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -335,1 +334,3 @@\n-        Vector<E> av = a.fromByteArray(input, 0, ByteOrder.nativeOrder());\n+        MemorySegment inputMs = MemorySegment.ofArray(input);\n+        MemorySegment outputMs = MemorySegment.ofArray(output);\n+        Vector<E> av = a.fromMemorySegment(inputMs, 0, ByteOrder.nativeOrder());\n@@ -350,1 +351,1 @@\n-                bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n@@ -365,1 +366,1 @@\n-                bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n@@ -383,1 +384,1 @@\n-            bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+            bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n@@ -712,1 +713,3 @@\n-        Vector<E> av = a.fromByteArray(input, 0, ByteOrder.nativeOrder());\n+        MemorySegment inputMs = MemorySegment.ofArray(input);\n+        MemorySegment outputMs = MemorySegment.ofArray(output);\n+        Vector<E> av = a.fromMemorySegment(inputMs, 0, ByteOrder.nativeOrder());\n@@ -739,1 +742,1 @@\n-                bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n@@ -754,1 +757,1 @@\n-                bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n@@ -772,1 +775,1 @@\n-            bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+            bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorReshapeTests.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -53,8 +53,0 @@\n-#if[MaxBit]\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-#end[MaxBit]\n-import java.nio.ByteBuffer;\n-#if[!byte]\n-import java.nio.$Type$Buffer;\n-#end[!byte]\n@@ -62,1 +54,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -99,13 +90,0 @@\n-#if[!byte]\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-#end[!byte]\n-\n@@ -151,1 +129,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -221,21 +199,0 @@\n-    @DataProvider\n-    public Object[][] $type$ByteBufferProvider() {\n-        return $TYPE$_GENERATORS.stream().\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                        flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, bo};\n-                        }))).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] $type$ByteBufferMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> $TYPE$_GENERATORS.stream().\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n-                                flatMap(fb -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                            return new Object[]{fa, fb, fm, bo};\n-                        })))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -263,19 +220,0 @@\n-    @DataProvider\n-    public Object[][] $type$ByteArrayProvider() {\n-        return $TYPE$_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] $type$ByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> $TYPE$_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -301,15 +239,0 @@\n-    static ByteBuffer toBuffer($type$[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for ($type$ v : a) {\n-            bb.{#if[byte]?put(v):put$Type$(v)};\n-        }\n-        return bb.clear();\n-    }\n-\n-    static $type$[] bufferToArray(ByteBuffer bb) {\n-        $Type$Buffer db = bb{#if[byte]?;:.as$Type$Buffer();}\n-        $type$[] d = new $type$[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n@@ -328,13 +251,0 @@\n-    static byte[] toByteArray($type$[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-#if[byte]\n-        $Type$Buffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-#else[byte]\n-        $Type$Buffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).as$Type$Buffer();\n-#end[byte]\n-        for ($type$ v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n-    }\n-\n@@ -377,40 +287,0 @@\n-    @DontInline\n-    static $abstractvectortype$ fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return $abstractvectortype$.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static $abstractvectortype$ fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        return $abstractvectortype$.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray($abstractvectortype$ v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray($abstractvectortype$ v, byte[] a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static $abstractvectortype$ fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return $abstractvectortype$.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static $abstractvectortype$ fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        return $abstractvectortype$.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer($abstractvectortype$ v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer($abstractvectortype$ v, ByteBuffer a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n@@ -607,223 +477,0 @@\n-    @Test(dataProvider = \"$type$ByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<$type$[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n-    }\n-\n-    @Test(dataProvider = \"$type$ByteProviderForIOOBE\")\n-    static void loadByteBufferIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"$type$ByteProviderForIOOBE\")\n-    static void storeByteBufferIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n-        try {\n-            $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"$type$ByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<$type$[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n-        $type$[] _a = fa.apply(SPECIES.length());\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-\n-\n-        r = fb.apply(a.limit());\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n-            }\n-        }\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n-    }\n-\n-    @Test(dataProvider = \"$type$ByteMaskProviderForIOOBE\")\n-    static void loadByteBufferMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"$type$ByteMaskProviderForIOOBE\")\n-    static void storeByteBufferMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"$type$ByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<$type$[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<$Boxtype$> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n@@ -1036,173 +683,0 @@\n-    @Test(dataProvider = \"$type$ByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<$type$[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"$type$ByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"$type$ByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"$type$ByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<$type$[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"$type$ByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"$type$ByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n@@ -1223,0 +697,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":2,"deletions":527,"binary":false,"changes":529,"status":"modified"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n- *\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package org.openjdk.bench.jdk.incubator.vector;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.util.concurrent.TimeUnit;\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.VectorSpecies;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Benchmark)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 1, jvmArgsAppend = {\n-    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n-    \"-Dforeign.restricted=permit\",\n-    \"--enable-native-access\", \"ALL-UNNAMED\"})\n-public class ByteBufferVectorAccess {\n-  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n-\n-  @Param(\"1024\")\n-  private int size;\n-\n-  ByteBuffer directIn, directOut;\n-  ByteBuffer heapIn, heapOut;\n-\n-  ByteBuffer directInRo, directOutRo;\n-  ByteBuffer heapInRo, heapOutRo;\n-\n-  @Setup\n-  public void setup() {\n-    directIn = ByteBuffer.allocateDirect(size);\n-    directOut = ByteBuffer.allocateDirect(size);\n-\n-    heapIn = ByteBuffer.wrap(new byte[size]);\n-    heapOut = ByteBuffer.wrap(new byte[size]);\n-\n-    directInRo = directIn.asReadOnlyBuffer();\n-    directOutRo = directOut.asReadOnlyBuffer();\n-\n-    heapInRo = heapIn.asReadOnlyBuffer();\n-    heapOutRo = heapOut.asReadOnlyBuffer();\n-  }\n-\n-  @Benchmark\n-  public void directBuffers() {\n-    copyMemory(directIn, directOut);\n-  }\n-\n-  @Benchmark\n-  public void heapBuffers() {\n-    copyMemory(heapIn, heapOut);\n-  }\n-\n-  @Benchmark\n-  public void pollutedBuffers2() {\n-    copyIntoNotInlined(directIn, directOut);\n-    copyIntoNotInlined(heapIn, heapOut);\n-  }\n-\n-  @Benchmark\n-  public void pollutedBuffers3() {\n-    copyIntoNotInlined(directIn, directOut);\n-    copyIntoNotInlined(heapIn, heapOut);\n-\n-    copyIntoNotInlined(directInRo, directOut);\n-    copyIntoNotInlined(heapInRo, heapOut);\n-  }\n-\n-  @Benchmark\n-  public void pollutedBuffers4() {\n-    copyIntoNotInlined(directIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n-    copyIntoNotInlined(heapIn, heapOut);\n-\n-    copyIntoNotInlined(heapIn, directIn); \/\/ Pollute if unswitch on 1st param\n-    copyIntoNotInlined(heapIn, directOut);\n-  }\n-\n-\n-  boolean readOnlyException;\n-\n-  @Benchmark\n-  public void pollutedBuffers5() {\n-    copyIntoNotInlined(directIn, heapOut);\n-    copyIntoNotInlined(heapIn, heapOut);\n-\n-    copyIntoNotInlined(heapIn, directIn);\n-    copyIntoNotInlined(heapIn, directOut);\n-\n-    if (readOnlyException) {\n-      try {\n-        copyIntoNotInlined(heapIn, directOutRo);\n-      } catch (Exception ignored) {}\n-      readOnlyException = !readOnlyException;\n-    }\n-  }\n-\n-  @Benchmark\n-  public void arrayCopy() {\n-    byte[] in = heapIn.array();\n-    byte[] out = heapOut.array();\n-\n-    for (int i=0; i < SPECIES.loopBound(in.length); i += SPECIES.vectorByteSize()) {\n-      final var v = ByteVector.fromArray(SPECIES, in, i);\n-      v.intoArray(out, i);\n-    }\n-  }\n-\n-  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-  protected void copyIntoNotInlined(ByteBuffer in, ByteBuffer out) {\n-    copyMemory(in, out);\n-  }\n-\n-  @CompilerControl(CompilerControl.Mode.INLINE)\n-  protected void copyMemory(ByteBuffer in, ByteBuffer out) {\n-    for (int i=0; i < SPECIES.loopBound(in.limit()); i += SPECIES.vectorByteSize()) {\n-      final var v = ByteVector.fromByteBuffer(SPECIES, in, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(out, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ByteBufferVectorAccess.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class MemorySegmentVectorAccess {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  byte[] byteIn;\n+  byte[] byteOut;\n+\n+  MemorySegment nativeIn, nativeOut;\n+  MemorySegment heapIn, heapOut;\n+\n+  MemorySegment nativeInRo, nativeOutRo;\n+  MemorySegment heapInRo, heapOutRo;\n+\n+  @Setup\n+  public void setup() {\n+    nativeIn = MemorySegment.allocateNative(size, ResourceScope.newImplicitScope());\n+    nativeOut = MemorySegment.allocateNative(size, ResourceScope.newImplicitScope());\n+\n+    byteIn = new byte[size];\n+    byteOut = new byte[size];\n+\n+    heapIn = MemorySegment.ofArray(byteIn);\n+    heapOut = MemorySegment.ofArray(byteOut);\n+\n+    nativeInRo = nativeIn.asReadOnly();\n+    nativeOutRo = nativeOut.asReadOnly();\n+\n+    heapInRo = heapIn.asReadOnly();\n+    heapOutRo = heapOut.asReadOnly();\n+  }\n+\n+  @Benchmark\n+  public void directSegments() {\n+    copyMemory(nativeIn, nativeOut);\n+  }\n+\n+  @Benchmark\n+  public void heapSegments() {\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedSegments2() {\n+    copyIntoNotInlined(nativeIn, nativeOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedSegments3() {\n+    copyIntoNotInlined(nativeIn, nativeOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(nativeInRo, nativeOut);\n+    copyIntoNotInlined(heapInRo, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedSegments4() {\n+    copyIntoNotInlined(nativeIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, nativeIn); \/\/ Pollute if unswitch on 1st param\n+    copyIntoNotInlined(heapIn, nativeOut);\n+  }\n+\n+\n+  boolean readOnlyException;\n+\n+  @Benchmark\n+  public void pollutedSegments5() {\n+    copyIntoNotInlined(nativeIn, heapOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, nativeIn);\n+    copyIntoNotInlined(heapIn, nativeOut);\n+\n+    if (readOnlyException) {\n+      try {\n+        copyIntoNotInlined(heapIn, nativeOutRo);\n+      } catch (Exception ignored) {}\n+      readOnlyException = !readOnlyException;\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayCopy() {\n+    byte[] in = byteIn;\n+    byte[] out = byteOut;\n+\n+    for (int i = 0; i < SPECIES.loopBound(in.length); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromArray(SPECIES, in, i);\n+      v.intoArray(out, i);\n+    }\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+  protected void copyIntoNotInlined(MemorySegment in, MemorySegment out) {\n+    copyMemory(in, out);\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.INLINE)\n+  protected void copyMemory(MemorySegment in, MemorySegment out) {\n+    for (long i = 0; i < SPECIES.loopBound(in.byteSize()); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromMemorySegment(SPECIES, in, i, ByteOrder.nativeOrder());\n+      v.intoMemorySegment(out, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.nio.ByteBuffer;\n@@ -70,1 +69,1 @@\n-  private ByteBuffer srcBufferHeap;\n+  private MemorySegment srcSegmentHeap;\n@@ -72,5 +71,1 @@\n-  private ByteBuffer dstBufferHeap;\n-\n-  private ByteBuffer srcBufferNative;\n-\n-  private ByteBuffer dstBufferNative;\n+  private MemorySegment dstSegmentHeap;\n@@ -81,3 +76,1 @@\n-  private MemorySegment srcSegmentImplicit;\n-\n-  private MemorySegment dstSegmentImplicit;\n+  private MemorySegment srcSegment;\n@@ -85,3 +78,1 @@\n-  private ByteBuffer srcBufferSegmentImplicit;\n-\n-  private ByteBuffer dstBufferSegmentImplicit;\n+  private MemorySegment dstSegment;\n@@ -94,1 +85,1 @@\n-  byte[] a, b, c;\n+  private byte[] a, b, c;\n@@ -104,7 +95,2 @@\n-\n-    srcBufferHeap = ByteBuffer.allocate(size);\n-    dstBufferHeap = ByteBuffer.allocate(size);\n-\n-    srcBufferNative = ByteBuffer.allocateDirect(size);\n-    dstBufferNative = ByteBuffer.allocateDirect(size);\n-\n+    srcSegmentHeap = MemorySegment.ofArray(new byte[size]);\n+    dstSegmentHeap = MemorySegment.ofArray(new byte[size]);\n@@ -113,4 +99,2 @@\n-    srcSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    srcBufferSegmentImplicit = srcSegmentImplicit.asByteBuffer();\n-    dstSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    dstBufferSegmentImplicit = dstSegmentImplicit.asByteBuffer();\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n@@ -118,3 +102,2 @@\n-\n-    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n-    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n+    srcAddress = srcSegment.address();\n+    dstAddress = dstSegment.address();\n@@ -130,1 +113,0 @@\n-\/\/    final var srcArray = this.srcArray;\n@@ -137,9 +119,0 @@\n-  @Benchmark\n-  public void array2() {\n-\/\/    final var srcArray = this.srcArray;\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ByteVector.fromByteArray(SPECIES, srcArray, i, ByteOrder.nativeOrder());\n-      v.intoByteArray(dstArray, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n@@ -190,38 +163,4 @@\n-  public void bufferHeap() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferHeap, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferHeap, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferHeapScalar() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n-      var v = srcBufferHeap.get(i);\n-      dstBufferHeap.put(i, v);\n-    }\n-  }\n-\n-  @Benchmark\n-  @CompilerControl(CompilerControl.Mode.PRINT)\n-  public void bufferNative() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferNativeScalar() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n-      var v = srcBufferNative.get(i);\n-      dstBufferNative.put(i, v);\n-    }\n-  }\n-\n-\n-  @Benchmark\n-  public void bufferSegmentImplicit() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n+  public void segmentHeap() {\n+    for (long i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromMemorySegment(SPECIES, srcSegmentHeap, i, ByteOrder.nativeOrder());\n+      v.intoMemorySegment(dstSegmentHeap, i, ByteOrder.nativeOrder());\n@@ -232,5 +171,4 @@\n-  @CompilerControl(CompilerControl.Mode.PRINT)\n-  public void segmentImplicitScalar() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n-      var v = srcSegmentImplicit.get(JAVA_BYTE, i);\n-      dstSegmentImplicit.set(JAVA_BYTE, i, v);\n+  public void segmentNativeImplicit() {\n+    for (long i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromMemorySegment(SPECIES, srcSegment, i, ByteOrder.nativeOrder());\n+      v.intoMemorySegment(dstSegment, i, ByteOrder.nativeOrder());\n@@ -241,1 +179,1 @@\n-  public void bufferSegmentConfined() {\n+  public void segmentNativeConfined() {\n@@ -243,2 +181,2 @@\n-      final var srcBufferSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope).asByteBuffer();\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope);\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope);\n@@ -246,3 +184,3 @@\n-      for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-        var v = ByteVector.fromByteBuffer(SPECIES, srcBufferSegmentConfined, i, ByteOrder.nativeOrder());\n-        v.intoByteBuffer(dstBufferSegmentConfined, i, ByteOrder.nativeOrder());\n+      for (long i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+        var v = ByteVector.fromMemorySegment(SPECIES, srcSegmentConfined, i, ByteOrder.nativeOrder());\n+        v.intoMemorySegment(dstSegmentConfined, i, ByteOrder.nativeOrder());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":26,"deletions":88,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -1,222 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package org.openjdk.bench.jdk.incubator.vector;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.util.concurrent.TimeUnit;\n-\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.vector.ShortVector;\n-import jdk.incubator.vector.VectorOperators;\n-import jdk.incubator.vector.VectorSpecies;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 1, jvmArgsAppend = {\n-    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n-    \"-Dforeign.restricted=permit\",\n-    \"--enable-native-access\", \"ALL-UNNAMED\"})\n-public class TestLoadStoreShort {\n-  private static final VectorSpecies<Short> SPECIES = VectorSpecies.ofLargestShape(short.class);\n-\n-  @Param(\"256\")\n-  private int size;\n-\n-  private int longSize;\n-\n-  private short[] srcArray;\n-\n-  private short[] dstArray;\n-\n-\n-  private ByteBuffer srcBufferHeap;\n-\n-  private ByteBuffer dstBufferHeap;\n-\n-  private ByteBuffer srcBufferNative;\n-\n-  private ByteBuffer dstBufferNative;\n-\n-\n-  private ResourceScope implicitScope;\n-\n-  private MemorySegment srcSegmentImplicit;\n-\n-  private MemorySegment dstSegmentImplicit;\n-\n-  private ByteBuffer srcBufferSegmentImplicit;\n-\n-  private ByteBuffer dstBufferSegmentImplicit;\n-\n-\n-  private MemoryAddress srcAddress;\n-\n-  private MemoryAddress dstAddress;\n-\n-\/\/  private byte[] bigArray = new byte[Integer.MAX_VALUE];\n-\n-  private volatile short[] a, b, c;\n-  @Setup\n-  public void setup() {\n-    var longSize = size \/ Short.BYTES;\n-    srcArray = new short[longSize];\n-    dstArray = srcArray.clone();\n-    for (int i = 0; i < srcArray.length; i++) {\n-      srcArray[i] = (short) i;\n-    }\n-\n-\n-    srcBufferHeap = ByteBuffer.allocate(size);\n-    dstBufferHeap = ByteBuffer.allocate(size);\n-\n-    srcBufferNative = ByteBuffer.allocateDirect(size);\n-    dstBufferNative = ByteBuffer.allocateDirect(size);\n-\n-\n-    implicitScope = ResourceScope.newSharedScope();\n-    srcSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    srcBufferSegmentImplicit = srcSegmentImplicit.asByteBuffer();\n-    dstSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    dstBufferSegmentImplicit = dstSegmentImplicit.asByteBuffer();\n-\n-\n-    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n-    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n-\n-    this.longSize = longSize;\n-\n-    a = new short[size];\n-    b = new short[size];\n-    c = new short[size];\n-\n-  }\n-\n-  @Benchmark\n-  @CompilerControl(CompilerControl.Mode.PRINT)\n-  public void array() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n-      v.intoArray(dstArray, i);\n-    }\n-  }\n-\n-  @Benchmark\n-  public void vectAdd1() {\n-    var a = this.a;\n-    var b = this.b;\n-    var c = this.c;\n-\n-    for (int i = 0; i < a.length; i += SPECIES.length()) {\n-      ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-      ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n-      av.lanewise(VectorOperators.ADD, bv).intoArray(c, i);\n-    }\n-  }\n-\n-  @Benchmark\n-  public void vectAdd2() {\n-    var a = this.a;\n-    var b = this.b;\n-    var c = this.c;\n-\n-    for (int i = 0; i < a.length\/SPECIES.length(); i++) {\n-      ShortVector av = ShortVector.fromArray(SPECIES, a, (i*SPECIES.length()));\n-      ShortVector bv = ShortVector.fromArray(SPECIES, b, (i*SPECIES.length()));\n-      av.lanewise(VectorOperators.ADD, bv).intoArray(c, (i*SPECIES.length()));\n-    }\n-  }\n-\n-  @Benchmark\n-  public void arrayAdd() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n-      v = v.add(v);\n-      v.intoArray(dstArray, i);\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferHeap() {\n-    for (int i = 0; i < SPECIES.loopBound(longSize); i += SPECIES.length()) {\n-      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferHeap, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferHeap, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferNative() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferNativeAdd() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n-      v = v.add(v);\n-      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferSegmentImplicit() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferSegmentConfined() {\n-    try (final var scope = ResourceScope.newConfinedScope()) {\n-      final var srcBufferSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope).asByteBuffer();\n-\n-      for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-        var v = ShortVector.fromByteBuffer(SPECIES, srcBufferSegmentConfined, i, ByteOrder.nativeOrder());\n-        v.intoByteBuffer(dstBufferSegmentConfined, i, ByteOrder.nativeOrder());\n-      }\n-    }\n-  }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":0,"deletions":222,"binary":false,"changes":222,"status":"deleted"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class TestLoadStoreShorts {\n+  private static final VectorSpecies<Short> SPECIES = VectorSpecies.ofLargestShape(short.class);\n+\n+  @Param(\"256\")\n+  private int size;\n+\n+  private int longSize;\n+\n+  private short[] srcArray;\n+\n+  private short[] dstArray;\n+\n+\n+  private MemorySegment srcSegmentHeap;\n+\n+  private MemorySegment dstSegmentHeap;\n+\n+\n+  private ResourceScope implicitScope;\n+\n+  private MemorySegment srcSegment;\n+\n+  private MemorySegment dstSegment;\n+\n+\n+  private MemoryAddress srcAddress;\n+\n+  private MemoryAddress dstAddress;\n+\n+  private short[] a, b, c;\n+\n+  @Setup\n+  public void setup() {\n+    var longSize = size \/ Short.BYTES;\n+    srcArray = new short[longSize];\n+    dstArray = srcArray.clone();\n+    for (int i = 0; i < srcArray.length; i++) {\n+      srcArray[i] = (short) i;\n+    }\n+\n+    srcSegmentHeap = MemorySegment.ofArray(new byte[size]);\n+    dstSegmentHeap = MemorySegment.ofArray(new byte[size]);\n+\n+    implicitScope = ResourceScope.newImplicitScope();\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+\n+    srcAddress = srcSegment.address();\n+    dstAddress = dstSegment.address();\n+\n+    this.longSize = longSize;\n+\n+    a = new short[size];\n+    b = new short[size];\n+    c = new short[size];\n+  }\n+\n+  @Benchmark\n+  public void array() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd1() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length; i += SPECIES.length()) {\n+      ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+      ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd2() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length\/SPECIES.length(); i++) {\n+      ShortVector av = ShortVector.fromArray(SPECIES, a, (i*SPECIES.length()));\n+      ShortVector bv = ShortVector.fromArray(SPECIES, b, (i*SPECIES.length()));\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, (i*SPECIES.length()));\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayAdd() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n+      v = v.add(v);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void heapSegment() {\n+    for (long i = 0; i < SPECIES.loopBound(longSize); i += SPECIES.length()) {\n+      var v = ShortVector.fromMemorySegment(SPECIES, srcSegmentHeap, i, ByteOrder.nativeOrder());\n+      v.intoMemorySegment(dstSegmentHeap, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void segmentNativeImplicit() {\n+    for (long i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromMemorySegment(SPECIES, srcSegment, i, ByteOrder.nativeOrder());\n+      v.intoMemorySegment(dstSegment, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void segmentNativeConfined() {\n+    try (final var scope = ResourceScope.newConfinedScope()) {\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope);\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope);\n+\n+      for (long i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+        var v = ShortVector.fromMemorySegment(SPECIES, srcSegmentConfined, i, ByteOrder.nativeOrder());\n+        v.intoMemorySegment(dstSegmentConfined, i, ByteOrder.nativeOrder());\n+      }\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -46,3 +47,3 @@\n-    private byte[] in;\n-    private byte[] out;\n-    \n+    private MemorySegment in;\n+    private MemorySegment out;\n+\n@@ -61,3 +62,2 @@\n-        \n-        in = new byte[dataSize];\n-        out = new byte[dataSize];\n+        in = MemorySegment.ofArray(new byte[dataSize]);\n+        out = MemorySegment.ofArray(new byte[dataSize]);\n@@ -224,1 +224,1 @@\n-            byte[] in, byte[] out) {\n+            MemorySegment in, MemorySegment out) {\n@@ -236,1 +236,1 @@\n-            int numStates = (in.length + stateLenBytes - 1) \/ stateLenBytes;\n+            int numStates = (((int) in.byteSize()) + stateLenBytes - 1) \/ stateLenBytes;\n@@ -343,4 +343,4 @@\n-                IntVector ina = IntVector.fromByteArray(intSpecies, in, inOff, ByteOrder.LITTLE_ENDIAN);\n-                IntVector inb = IntVector.fromByteArray(intSpecies, in, inOff + 4 * len, ByteOrder.LITTLE_ENDIAN);\n-                IntVector inc = IntVector.fromByteArray(intSpecies, in, inOff + 8 * len, ByteOrder.LITTLE_ENDIAN);\n-                IntVector ind = IntVector.fromByteArray(intSpecies, in, inOff + 12 * len, ByteOrder.LITTLE_ENDIAN);\n+                IntVector ina = IntVector.fromMemorySegment(intSpecies, in, inOff, ByteOrder.LITTLE_ENDIAN);\n+                IntVector inb = IntVector.fromMemorySegment(intSpecies, in, inOff + 4L * len, ByteOrder.LITTLE_ENDIAN);\n+                IntVector inc = IntVector.fromMemorySegment(intSpecies, in, inOff + 8L * len, ByteOrder.LITTLE_ENDIAN);\n+                IntVector ind = IntVector.fromMemorySegment(intSpecies, in, inOff + 12L * len, ByteOrder.LITTLE_ENDIAN);\n@@ -348,4 +348,4 @@\n-                ina.lanewise(VectorOperators.XOR, a).intoByteArray(out, inOff, ByteOrder.LITTLE_ENDIAN);\n-                inb.lanewise(VectorOperators.XOR, b).intoByteArray(out, inOff + 4 * len, ByteOrder.LITTLE_ENDIAN);\n-                inc.lanewise(VectorOperators.XOR, c).intoByteArray(out, inOff + 8 * len, ByteOrder.LITTLE_ENDIAN);\n-                ind.lanewise(VectorOperators.XOR, d).intoByteArray(out, inOff + 12 * len, ByteOrder.LITTLE_ENDIAN);\n+                ina.lanewise(VectorOperators.XOR, a).intoMemorySegment(out, inOff, ByteOrder.LITTLE_ENDIAN);\n+                inb.lanewise(VectorOperators.XOR, b).intoMemorySegment(out, inOff + 4L * len, ByteOrder.LITTLE_ENDIAN);\n+                inc.lanewise(VectorOperators.XOR, c).intoMemorySegment(out, inOff + 8L * len, ByteOrder.LITTLE_ENDIAN);\n+                ind.lanewise(VectorOperators.XOR, d).intoMemorySegment(out, inOff + 12L * len, ByteOrder.LITTLE_ENDIAN);\n@@ -388,1 +388,1 @@\n-        cc20.chacha20(key, nonce, counter, in, out);\n+        cc20.chacha20(key, nonce, counter, MemorySegment.ofArray(in), MemorySegment.ofArray(out));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/crypto\/ChaChaBench.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -291,1 +292,2 @@\n-            LongVector longMsg0 = LongVector.fromByteArray(longSpecies, msg, 0, ByteOrder.LITTLE_ENDIAN);\n+            MemorySegment msMsg = MemorySegment.ofArray(msg);\n+            LongVector longMsg0 = LongVector.fromMemorySegment(longSpecies, msMsg, 0, ByteOrder.LITTLE_ENDIAN);\n@@ -293,1 +295,1 @@\n-                LongVector.fromByteArray(longSpecies, msg, vectorWidth * 8, ByteOrder.LITTLE_ENDIAN);\n+                LongVector.fromMemorySegment(longSpecies, msMsg, vectorWidth * 8L, ByteOrder.LITTLE_ENDIAN);\n@@ -376,3 +378,3 @@\n-                longMsg0 = LongVector.fromByteArray(longSpecies, msg, start, ByteOrder.LITTLE_ENDIAN);\n-                longMsg1 = LongVector.fromByteArray(longSpecies, msg,\n-                    start + vectorWidth * 8, ByteOrder.LITTLE_ENDIAN);\n+                longMsg0 = LongVector.fromMemorySegment(longSpecies, msMsg, start, ByteOrder.LITTLE_ENDIAN);\n+                longMsg1 = LongVector.fromMemorySegment(longSpecies, msMsg,\n+                    start + vectorWidth * 8L, ByteOrder.LITTLE_ENDIAN);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/crypto\/Poly1305Bench.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"}]}