{"files":[{"patch":"@@ -2461,0 +2461,10 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n@@ -8774,0 +8784,55 @@\n+instruct castFF(vRegF dst)\n+%{\n+  match(Set dst (CastFF dst));\n+\n+  size(0);\n+  format %{ \"# castFF of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct castDD(vRegD dst)\n+%{\n+  match(Set dst (CastDD dst));\n+\n+  size(0);\n+  format %{ \"# castDD of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct castVVD(vecD dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct castVVX(vecX dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct castVV(vReg dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1533,1 +1533,1 @@\n-    T8B, T16B, T4H, T8H, T2S, T4S, T1D, T2D, T1Q\n+    T8B, T16B, T4H, T8H, T2S, T4S, T1D, T2D, T1Q, INVALID_ARRANGEMENT\n@@ -1536,0 +1536,8 @@\n+private:\n+\n+  static SIMD_Arrangement _esize2arrangement_table[9][2];\n+\n+public:\n+\n+  static SIMD_Arrangement esize2arrangement(int esize, bool isQ);\n+\n@@ -2407,0 +2415,2 @@\n+  INSN(smaxp,  0, 0b101001, false); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S\n+  INSN(sminp,  0, 0b101011, false); \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S\n@@ -2411,0 +2421,1 @@\n+  INSN(cmhs,   1, 0b001111, true);  \/\/ accepted arrangements: T8B, T16B, T4H, T8H, T2S, T4S, T2D\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -681,0 +681,5 @@\n+  \/\/ lr could be poisoned with PAC signature during throw_pending_exception\n+  \/\/ if it was tail-call optimized by compiler, since lr is not callee-saved\n+  \/\/ reload it with proper value\n+  adr(lr, l);\n+\n@@ -5427,0 +5432,43 @@\n+void MacroAssembler::neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1,\n+                                  FloatRegister src2, int cond, bool isQ) {\n+  SIMD_Arrangement size = esize2arrangement(type2aelembytes(bt), isQ);\n+  if (bt == T_FLOAT || bt == T_DOUBLE) {\n+    switch (cond) {\n+      case BoolTest::eq: fcmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        fcmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: fcmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: fcmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: fcmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: fcmgt(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (cond) {\n+      case BoolTest::eq: cmeq(dst, size, src1, src2); break;\n+      case BoolTest::ne: {\n+        cmeq(dst, size, src1, src2);\n+        notr(dst, T16B, dst);\n+        break;\n+      }\n+      case BoolTest::ge: cmge(dst, size, src1, src2); break;\n+      case BoolTest::gt: cmgt(dst, size, src1, src2); break;\n+      case BoolTest::le: cmge(dst, size, src2, src1); break;\n+      case BoolTest::lt: cmgt(dst, size, src2, src1); break;\n+      case BoolTest::uge: cmhs(dst, size, src1, src2); break;\n+      case BoolTest::ugt: cmhi(dst, size, src1, src2); break;\n+      case BoolTest::ult: cmhi(dst, size, src2, src1); break;\n+      case BoolTest::ule: cmhs(dst, size, src2, src1); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1066,0 +1066,3 @@\n+\n+  \/\/ SIMD&FP comparison\n+  void neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1, FloatRegister src2, int cond, bool isQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -980,1 +980,1 @@\n-  bool ret_value = match_rule_supported(opcode);\n+  bool ret_value = match_rule_supported(opcode) && vector_size_supported(bt, vlen);\n@@ -998,0 +998,10 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n@@ -5189,0 +5199,33 @@\n+instruct castFF( regF dst ) %{\n+  match(Set dst (CastFF dst));\n+  format %{ \"! castFF of $dst\" %}\n+  ins_encode( \/*empty encoding*\/ );\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castDD( regD dst ) %{\n+  match(Set dst (CastDD dst));\n+  format %{ \"! castDD of $dst\" %}\n+  ins_encode( \/*empty encoding*\/ );\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castVVD( vecD dst ) %{\n+  match(Set dst (CastVV dst));\n+  format %{ \"! castVV of $dst\" %}\n+  ins_encode( \/*empty encoding*\/ );\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castVVX( vecX dst ) %{\n+  match(Set dst (CastVV dst));\n+  format %{ \"! castVV of $dst\" %}\n+  ins_encode( \/*empty encoding*\/ );\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2190,0 +2190,10 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n@@ -10342,0 +10352,32 @@\n+instruct castFF(regF dst) %{\n+  match(Set dst (CastFF dst));\n+  format %{ \" -- \\t\/\/ castFF of $dst\" %}\n+  size(0);\n+  ins_encode( \/*empty*\/ );\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct castDD(regD dst) %{\n+  match(Set dst (CastDD dst));\n+  format %{ \" -- \\t\/\/ castDD of $dst\" %}\n+  size(0);\n+  ins_encode( \/*empty*\/ );\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct castVV8(iRegLdst dst) %{\n+  match(Set dst (CastVV dst));\n+  format %{ \" -- \\t\/\/ castVV of $dst\" %}\n+  size(0);\n+  ins_encode( \/*empty*\/ );\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct castVV16(vecX dst) %{\n+  match(Set dst (CastVV dst));\n+  format %{ \" -- \\t\/\/ castVV of $dst\" %}\n+  size(0);\n+  ins_encode( \/*empty*\/ );\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1551,0 +1551,10 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n@@ -5267,0 +5277,24 @@\n+instruct castFF(regF dst) %{\n+  match(Set dst (CastFF dst));\n+  size(0);\n+  format %{ \"# castFF of $dst\" %}\n+  ins_encode(\/*empty*\/);\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct castDD(regD dst) %{\n+  match(Set dst (CastDD dst));\n+  size(0);\n+  format %{ \"# castDD of $dst\" %}\n+  ins_encode(\/*empty*\/);\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n+instruct castVV(iRegL dst) %{\n+  match(Set dst (CastVV dst));\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/*empty*\/);\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1581,0 +1581,1 @@\n+    case Op_VectorCmpMasked:\n@@ -1588,0 +1589,7 @@\n+    case Op_VectorMaskFirstTrue:\n+    case Op_VectorMaskLastTrue:\n+    case Op_VectorMaskTrueCount:\n+      if (!is_LP64 || UseAVX < 1) {\n+         return false;\n+      }\n+      break;\n@@ -1674,0 +1682,1 @@\n+    case Op_VectorCmpMasked:\n@@ -6890,1 +6899,1 @@\n-  predicate((UseAVX <= 2 || !VM_Version::supports_avx512vl()) && \n+  predicate((UseAVX <= 2 || !VM_Version::supports_avx512vl()) &&\n@@ -6908,1 +6917,1 @@\n-  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) && \n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) &&\n@@ -6927,1 +6936,1 @@\n-  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) && \n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) &&\n@@ -6945,2 +6954,2 @@\n-  predicate(UseAVX > 2 && \n-            (VM_Version::supports_avx512vl() ||  \n+  predicate(UseAVX > 2 &&\n+            (VM_Version::supports_avx512vl() ||\n@@ -8085,1 +8094,28 @@\n-\/\/ ---------------------------------- Masked Block Copy ------------------------------------\n+\/\/ ---------------------------------- Masked Operations ------------------------------------\n+\n+instruct vmask_cmp_node(rRegI dst, vec src1, vec src2, kReg mask, kReg ktmp1, kReg ktmp2, rFlagsReg cr) %{\n+  match(Set dst (VectorCmpMasked src1 (Binary src2 mask)));\n+  effect(TEMP_DEF dst, TEMP ktmp1, TEMP ktmp2, KILL cr);\n+  format %{ \"vector_mask_cmp $src1, $src2, $mask \\t! vector mask comparison\" %}\n+  ins_encode %{\n+    assert(vector_length_encoding(this, $src1) == vector_length_encoding(this, $src2), \"mismatch\");\n+    assert(vector_element_basic_type(this, $src1) == vector_element_basic_type(this, $src2), \"mismatch\");\n+\n+    Label DONE;\n+    int vlen_enc = vector_length_encoding(this, $src1);\n+    BasicType elem_bt = vector_element_basic_type(this, $src1);\n+\n+    __ knotql($ktmp2$$KRegister, $mask$$KRegister);\n+    __ mov64($dst$$Register, -1L);\n+    __ evpcmp(elem_bt, $ktmp1$$KRegister, $mask$$KRegister, $src1$$XMMRegister, $src2$$XMMRegister, Assembler::eq, vlen_enc);\n+    __ kortestql($ktmp2$$KRegister, $ktmp1$$KRegister);\n+    __ jccb(Assembler::carrySet, DONE);\n+    __ kmovql($dst$$Register, $ktmp1$$KRegister);\n+    __ notq($dst$$Register);\n+    __ tzcntq($dst$$Register, $dst$$Register);\n+    __ bind(DONE);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n@@ -8129,0 +8165,62 @@\n+\n+instruct vmask_truecount_evex(rRegI dst, vec mask, rRegL tmp, kReg ktmp, vec xtmp) %{\n+  predicate(VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorMaskTrueCount mask));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP ktmp, TEMP xtmp);\n+  format %{ \"vector_truecount_evex $mask \\t! vector mask true count\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    int mask_len = vector_length(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, $ktmp$$KRegister, mask_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_first_or_last_true_evex(rRegI dst, vec mask, rRegL tmp, kReg ktmp, vec xtmp, rFlagsReg cr) %{\n+  predicate(VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorMaskFirstTrue mask));\n+  match(Set dst (VectorMaskLastTrue mask));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP ktmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_evex $mask \\t! vector first\/last true location\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    int mask_len = vector_length(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, $ktmp$$KRegister, mask_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_truecount_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1) %{\n+  predicate(!VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorMaskTrueCount mask));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1);\n+  format %{ \"vector_truecount_avx $mask \\t! vector mask true count\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    int mask_len = vector_length(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorMaskFirstTrue mask));\n+  match(Set dst (VectorMaskLastTrue mask));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_avx $mask \\t! vector first\/last true location\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    int mask_len = vector_length(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -8130,0 +8228,22 @@\n+\n+instruct castVV(vec dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n+instruct castVVLeg(legVec dst)\n+%{\n+  match(Set dst (CastVV dst));\n+\n+  size(0);\n+  format %{ \"# castVV of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":126,"deletions":6,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -769,0 +769,5 @@\n+       !strcmp(_matrule->_rChild->_opType,\"CastDD\")       ||\n+       !strcmp(_matrule->_rChild->_opType,\"CastFF\")       ||\n+       !strcmp(_matrule->_rChild->_opType,\"CastII\")       ||\n+       !strcmp(_matrule->_rChild->_opType,\"CastLL\")       ||\n+       !strcmp(_matrule->_rChild->_opType,\"CastVV\")       ||\n@@ -787,0 +792,1 @@\n+       !strcmp(_matrule->_rChild->_opType,\"VectorCmpMasked\")||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -935,1 +935,5 @@\n-                                                                                                                               \\\n+  do_intrinsic(_VectorMaskOp, jdk_internal_vm_vector_VectorSupport, vector_mask_oper_name, vector_mask_oper_sig, F_S)                          \\\n+    do_signature(vector_mask_oper_sig, \"(ILjava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;\"                                               \\\n+                                        \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMaskOp;)I\")                                               \\\n+    do_name(vector_mask_oper_name, \"maskReductionCoerced\")                                                                                     \\\n+                                                                                                                                               \\\n@@ -1044,1 +1048,1 @@\n-  LAST_COMPILER_INLINE = _VectorScatterOp,\n+  LAST_COMPILER_INLINE = _VectorMaskOp,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -680,0 +680,1 @@\n+  case vmIntrinsics::_VectorMaskOp:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,0 +60,4 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n+\n@@ -640,0 +644,2 @@\n+  case vmIntrinsics::_VectorMaskOp:\n+    return inline_vector_mask_operation();\n@@ -2805,5 +2811,17 @@\n-\/*\n-* oop -> myklass\n-* myklass->trace_id |= USED\n-* return myklass->trace_id & ~0x3\n-*\/\n+\/**\n+ * if oop->klass != null\n+ *   \/\/ normal class\n+ *   epoch = _epoch_state ? 2 : 1\n+ *   if oop->klass->trace_id & ((epoch << META_SHIFT) | epoch)) != epoch {\n+ *     ... \/\/ enter slow path when the klass is first recorded or the epoch of JFR shifts\n+ *   }\n+ *   id = oop->klass->trace_id >> TRACE_ID_SHIFT \/\/ normal class path\n+ * else\n+ *   \/\/ primitive class\n+ *   if oop->array_klass != null\n+ *     id = (oop->array_klass->trace_id >> TRACE_ID_SHIFT) + 1 \/\/ primitive class path\n+ *   else\n+ *     id = LAST_TYPE_ID + 1 \/\/ void class path\n+ *   if (!signaled)\n+ *     signaled = true\n+ *\/\n@@ -2811,12 +2829,1 @@\n-  Node* cls = null_check(argument(0), T_OBJECT);\n-  Node* kls = load_klass_from_mirror(cls, false, NULL, 0);\n-  kls = null_check(kls, T_OBJECT);\n-\n-  ByteSize offset = KLASS_TRACE_ID_OFFSET;\n-  Node* insp = basic_plus_adr(kls, in_bytes(offset));\n-  Node* tvalue = make_load(NULL, insp, TypeLong::LONG, T_LONG, MemNode::unordered);\n-\n-  Node* clsused = longcon(0x01l); \/\/ set the class bit\n-  Node* orl = _gvn.transform(new OrLNode(tvalue, clsused));\n-  const TypePtr *adr_type = _gvn.type(insp)->isa_ptr();\n-  store_to_memory(control(), insp, orl, T_LONG, adr_type, MemNode::unordered);\n+  Node* cls = argument(0);\n@@ -2824,10 +2831,56 @@\n-#ifdef TRACE_ID_META_BITS\n-  Node* mbits = longcon(~TRACE_ID_META_BITS);\n-  tvalue = _gvn.transform(new AndLNode(tvalue, mbits));\n-#endif\n-#ifdef TRACE_ID_SHIFT\n-  Node* cbits = intcon(TRACE_ID_SHIFT);\n-  tvalue = _gvn.transform(new URShiftLNode(tvalue, cbits));\n-#endif\n-\n-  set_result(tvalue);\n+  IdealKit ideal(this);\n+#define __ ideal.\n+  IdealVariable result(ideal); __ declarations_done();\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+                                                 basic_plus_adr(cls, java_lang_Class::klass_offset()),\n+                                                 TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+\n+\n+  __ if_then(kls, BoolTest::ne, null()); {\n+    Node* kls_trace_id_addr = basic_plus_adr(kls, in_bytes(KLASS_TRACE_ID_OFFSET));\n+    Node* kls_trace_id_raw = ideal.load(ideal.ctrl(), kls_trace_id_addr,TypeLong::LONG, T_LONG, Compile::AliasIdxRaw);\n+\n+    Node* epoch_address = makecon(TypeRawPtr::make(Jfr::epoch_address()));\n+    Node* epoch = ideal.load(ideal.ctrl(), epoch_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n+    epoch = _gvn.transform(new LShiftLNode(longcon(1), epoch));\n+    Node* mask = _gvn.transform(new LShiftLNode(epoch, intcon(META_SHIFT)));\n+    mask = _gvn.transform(new OrLNode(mask, epoch));\n+    Node* kls_trace_id_raw_and_mask = _gvn.transform(new AndLNode(kls_trace_id_raw, mask));\n+\n+    float unlikely  = PROB_UNLIKELY(0.999);\n+    __ if_then(kls_trace_id_raw_and_mask, BoolTest::ne, epoch, unlikely); {\n+      sync_kit(ideal);\n+      make_runtime_call(RC_LEAF,\n+                        OptoRuntime::get_class_id_intrinsic_Type(),\n+                        CAST_FROM_FN_PTR(address, Jfr::get_class_id_intrinsic),\n+                        \"get_class_id_intrinsic\",\n+                        TypePtr::BOTTOM,\n+                        kls);\n+      ideal.sync_kit(this);\n+    } __ end_if();\n+\n+    ideal.set(result,  _gvn.transform(new URShiftLNode(kls_trace_id_raw, ideal.ConI(TRACE_ID_SHIFT))));\n+  } __ else_(); {\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+                                                   basic_plus_adr(cls, java_lang_Class::array_klass_offset()),\n+                                                   TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+    __ if_then(array_kls, BoolTest::ne, null()); {\n+      Node* array_kls_trace_id_addr = basic_plus_adr(array_kls, in_bytes(KLASS_TRACE_ID_OFFSET));\n+      Node* array_kls_trace_id_raw = ideal.load(ideal.ctrl(), array_kls_trace_id_addr, TypeLong::LONG, T_LONG, Compile::AliasIdxRaw);\n+      Node* array_kls_trace_id = _gvn.transform(new URShiftLNode(array_kls_trace_id_raw, ideal.ConI(TRACE_ID_SHIFT)));\n+      ideal.set(result, _gvn.transform(new AddLNode(array_kls_trace_id, longcon(1))));\n+    } __ else_(); {\n+      \/\/ void class case\n+      ideal.set(result, _gvn.transform(longcon(LAST_TYPE_ID + 1)));\n+    } __ end_if();\n+\n+    Node* signaled_flag_address = makecon(TypeRawPtr::make(Jfr::signal_address()));\n+    Node* signaled = ideal.load(ideal.ctrl(), signaled_flag_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw, true, MemNode::acquire);\n+    __ if_then(signaled, BoolTest::ne, ideal.ConI(1)); {\n+      ideal.store(ideal.ctrl(), signaled_flag_address, ideal.ConI(1), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::release, true);\n+    } __ end_if();\n+  } __ end_if();\n+\n+  final_sync(ideal);\n+  set_result(ideal.value(result));\n+#undef __\n@@ -2835,1 +2888,0 @@\n-\n@@ -4186,1 +4238,1 @@\n-      if (bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Parsing)) {\n+      if (bs->array_copy_requires_gc_barriers(true, T_OBJECT, true, false, BarrierSetC2::Parsing)) {\n@@ -5189,1 +5241,1 @@\n-  assert(UseVectorizedMismatchIntrinsic, \"not implementated on this platform\");\n+  assert(UseVectorizedMismatchIntrinsic, \"not implemented on this platform\");\n@@ -5191,6 +5243,6 @@\n-  address stubAddr = StubRoutines::vectorizedMismatch();\n-  if (stubAddr == NULL) {\n-    return false; \/\/ Intrinsic's stub is not implemented on this platform\n-  }\n-  const char* stubName = \"vectorizedMismatch\";\n-  int size_l = callee()->signature()->size();\n+  Node* obja    = argument(0); \/\/ Object\n+  Node* aoffset = argument(1); \/\/ long\n+  Node* objb    = argument(3); \/\/ Object\n+  Node* boffset = argument(4); \/\/ long\n+  Node* length  = argument(6); \/\/ int\n+  Node* scale   = argument(7); \/\/ int\n@@ -5199,15 +5251,6 @@\n-  Node* obja = argument(0);\n-  Node* aoffset = argument(1);\n-  Node* objb = argument(3);\n-  Node* boffset = argument(4);\n-  Node* length = argument(6);\n-  Node* scale = argument(7);\n-\n-  const Type* a_type = obja->Value(&_gvn);\n-  const Type* b_type = objb->Value(&_gvn);\n-  const TypeAryPtr* top_a = a_type->isa_aryptr();\n-  const TypeAryPtr* top_b = b_type->isa_aryptr();\n-  if (top_a == NULL || top_a->klass() == NULL ||\n-    top_b == NULL || top_b->klass() == NULL) {\n-    \/\/ failed array check\n-    return false;\n+  const TypeAryPtr* obja_t = _gvn.type(obja)->isa_aryptr();\n+  const TypeAryPtr* objb_t = _gvn.type(objb)->isa_aryptr();\n+  if (obja_t == NULL || obja_t->klass() == NULL ||\n+      objb_t == NULL || objb_t->klass() == NULL ||\n+      scale == top()) {\n+    return false; \/\/ failed input validation\n@@ -5216,3 +5259,0 @@\n-  Node* call;\n-  jvms()->set_should_reexecute(true);\n-\n@@ -5222,4 +5262,106 @@\n-  call = make_runtime_call(RC_LEAF,\n-    OptoRuntime::vectorizedMismatch_Type(),\n-    stubAddr, stubName, TypePtr::BOTTOM,\n-    obja_adr, objb_adr, length, scale);\n+  \/\/ Partial inlining handling for inputs smaller than ArrayOperationPartialInlineSize bytes in size.\n+  \/\/\n+  \/\/    inline_limit = ArrayOperationPartialInlineSize \/ element_size;\n+  \/\/    if (length <= inline_limit) {\n+  \/\/      inline_path:\n+  \/\/        vmask   = VectorMaskGen length\n+  \/\/        vload1  = LoadVectorMasked obja, vmask\n+  \/\/        vload2  = LoadVectorMasked objb, vmask\n+  \/\/        result1 = VectorCmpMasked vload1, vload2, vmask\n+  \/\/    } else {\n+  \/\/      call_stub_path:\n+  \/\/        result2 = call vectorizedMismatch_stub(obja, objb, length, scale)\n+  \/\/    }\n+  \/\/    exit_block:\n+  \/\/      return Phi(result1, result2);\n+  \/\/\n+  enum { inline_path = 1,  \/\/ input is small enough to process it all at once\n+         stub_path   = 2,  \/\/ input is too large; call into the VM\n+         PATH_LIMIT  = 3\n+  };\n+\n+  Node* exit_block = new RegionNode(PATH_LIMIT);\n+  Node* result_phi = new PhiNode(exit_block, TypeInt::INT);\n+  Node* memory_phi = new PhiNode(exit_block, Type::MEMORY, TypePtr::BOTTOM);\n+\n+  Node* call_stub_path = control();\n+\n+  BasicType elem_bt = T_ILLEGAL;\n+\n+  const TypeInt* scale_t = _gvn.type(scale)->is_int();\n+  if (scale_t->is_con()) {\n+    switch (scale_t->get_con()) {\n+      case 0: elem_bt = T_BYTE;  break;\n+      case 1: elem_bt = T_SHORT; break;\n+      case 2: elem_bt = T_INT;   break;\n+      case 3: elem_bt = T_LONG;  break;\n+\n+      default: elem_bt = T_ILLEGAL; break; \/\/ not supported\n+    }\n+  }\n+\n+  int inline_limit = 0;\n+  bool do_partial_inline = false;\n+\n+  if (elem_bt != T_ILLEGAL && ArrayOperationPartialInlineSize > 0) {\n+    inline_limit = ArrayOperationPartialInlineSize \/ type2aelembytes(elem_bt);\n+    do_partial_inline = inline_limit >= 16;\n+  }\n+\n+  if (do_partial_inline) {\n+    assert(elem_bt != T_ILLEGAL, \"sanity\");\n+\n+    const TypeVect* vt = TypeVect::make(elem_bt, inline_limit);\n+\n+    if (Matcher::match_rule_supported_vector(Op_VectorMaskGen,    inline_limit, elem_bt) &&\n+        Matcher::match_rule_supported_vector(Op_LoadVectorMasked, inline_limit, elem_bt) &&\n+        Matcher::match_rule_supported_vector(Op_VectorCmpMasked,  inline_limit, elem_bt)) {\n+\n+      Node* cmp_length = _gvn.transform(new CmpINode(length, intcon(inline_limit)));\n+      Node* bol_gt     = _gvn.transform(new BoolNode(cmp_length, BoolTest::gt));\n+\n+      call_stub_path = generate_guard(bol_gt, NULL, PROB_MIN);\n+\n+      if (!stopped()) {\n+        Node* casted_length = _gvn.transform(new CastIINode(control(), length, TypeInt::make(0, inline_limit, Type::WidenMin)));\n+\n+        const TypePtr* obja_adr_t = _gvn.type(obja_adr)->isa_ptr();\n+        const TypePtr* objb_adr_t = _gvn.type(objb_adr)->isa_ptr();\n+        Node* obja_adr_mem = memory(C->get_alias_index(obja_adr_t));\n+        Node* objb_adr_mem = memory(C->get_alias_index(objb_adr_t));\n+\n+        Node* vmask      = _gvn.transform(new VectorMaskGenNode(ConvI2X(casted_length), TypeVect::VECTMASK, elem_bt));\n+        Node* vload_obja = _gvn.transform(new LoadVectorMaskedNode(control(), obja_adr_mem, obja_adr, obja_adr_t, vt, vmask));\n+        Node* vload_objb = _gvn.transform(new LoadVectorMaskedNode(control(), objb_adr_mem, objb_adr, objb_adr_t, vt, vmask));\n+        Node* result     = _gvn.transform(new VectorCmpMaskedNode(vload_obja, vload_objb, vmask, TypeInt::INT));\n+\n+        exit_block->init_req(inline_path, control());\n+        memory_phi->init_req(inline_path, map()->memory());\n+        result_phi->init_req(inline_path, result);\n+\n+        C->set_max_vector_size(MAX2((uint)ArrayOperationPartialInlineSize, C->max_vector_size()));\n+        clear_upper_avx();\n+      }\n+    }\n+  }\n+\n+  if (call_stub_path != NULL) {\n+    set_control(call_stub_path);\n+\n+    Node* call = make_runtime_call(RC_LEAF,\n+                                   OptoRuntime::vectorizedMismatch_Type(),\n+                                   StubRoutines::vectorizedMismatch(), \"vectorizedMismatch\", TypePtr::BOTTOM,\n+                                   obja_adr, objb_adr, length, scale);\n+\n+    exit_block->init_req(stub_path, control());\n+    memory_phi->init_req(stub_path, map()->memory());\n+    result_phi->init_req(stub_path, _gvn.transform(new ProjNode(call, TypeFunc::Parms)));\n+  }\n+\n+  exit_block = _gvn.transform(exit_block);\n+  memory_phi = _gvn.transform(memory_phi);\n+  result_phi = _gvn.transform(result_phi);\n+\n+  set_control(exit_block);\n+  set_all_memory(memory_phi);\n+  set_result(result_phi);\n@@ -5227,2 +5369,0 @@\n-  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  set_result(result);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":200,"deletions":60,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -317,0 +317,1 @@\n+  bool inline_vector_mask_operation();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1402,2 +1402,2 @@\n-      if( !first->is_valid() &&\n-          !second->is_valid() ) {\n+      if(!first->is_valid() &&\n+         !second->is_valid()) {\n@@ -2262,0 +2262,1 @@\n+    case Op_VectorCmpMasked:\n@@ -2355,0 +2356,6 @@\n+    case Op_VectorCmpMasked: {\n+      Node* pair1 = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair1);\n+      n->del_req(3);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -422,0 +422,4 @@\n+  \/\/ Java-Native vector calling convention\n+  static const bool supports_vector_calling_convention();\n+  static OptoRegPair vector_return_value(uint ideal_reg);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1098,0 +1098,1 @@\n+    case Type::VectorMask:\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -411,1 +412,4 @@\n-        tty->print_cr(\"  ** svml call failed\");\n+        tty->print_cr(\"  ** svml call failed for %s_%s_%d\",\n+                         (elem_bt == T_FLOAT)?\"float\":\"double\",\n+                         VectorSupport::svmlname[opr->get_con() - VectorSupport::VECTOR_OP_SVML_START],\n+                         num_elem * type2aelembytes(elem_bt));\n@@ -549,0 +553,54 @@\n+\/\/ <E, M>\n+\/\/ int maskReductionCoerced(int oper, Class<? extends M> maskClass, Class<?> elemClass,\n+\/\/                          int length, M m, VectorMaskOp<M> defaultImpl)\n+bool LibraryCallKit::inline_vector_mask_operation() {\n+  const TypeInt*     oper       = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* mask_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* elem_klass = gvn().type(argument(2))->isa_instptr();\n+  const TypeInt*     vlen       = gvn().type(argument(3))->isa_int();\n+  Node*              mask       = argument(4);\n+\n+  if (mask_klass == NULL || elem_klass == NULL || mask->is_top() || vlen == NULL) {\n+    return false; \/\/ dead code\n+  }\n+\n+  if (!is_klass_initialized(mask_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType elem_bt = elem_type->basic_type();\n+\n+  if (!arch_supports_vector(Op_LoadVector, num_elem, T_BOOLEAN, VecMaskNotUsed)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n+                    Op_LoadVector, num_elem, type2name(T_BOOLEAN));\n+    }\n+    return false; \/\/ not supported\n+  }\n+\n+  int mopc = VectorSupport::vop2ideal(oper->get_con(), elem_bt);\n+  if (!arch_supports_vector(mopc, num_elem, elem_bt, VecMaskNotUsed)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n+                    mopc, num_elem, type2name(elem_bt));\n+    }\n+    return false; \/\/ not supported\n+  }\n+\n+  const Type* elem_ty = Type::get_const_basic_type(elem_bt);\n+  ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* mask_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);\n+  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem, true);\n+  Node* store_mask = gvn().transform(VectorStoreMaskNode::make(gvn(), mask_vec, elem_bt, num_elem));\n+  Node* maskoper = gvn().transform(VectorMaskOpNode::make(store_mask, TypeInt::INT, mopc));\n+  set_result(maskoper);\n+\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n@@ -594,1 +652,5 @@\n-  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, elem_bt, num_elem, true);\n+  \/\/ shuffle is a byte array\n+  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem, true);\n+\n+  \/\/ cast byte to target element type\n+  shuffle_vec = gvn().transform(VectorCastNode::make(cast_vopc, shuffle_vec, elem_bt, num_elem));\n@@ -1438,1 +1500,1 @@\n-    if (!Matcher::supports_unsigned_vector_comparison(num_elem, elem_bt)) {\n+    if (!Matcher::supports_vector_comparison_unsigned(num_elem, elem_bt)) {\n@@ -1557,1 +1619,2 @@\n-static void get_svml_address(int op, int bits, BasicType bt, const char** name_ptr, address* addr_ptr) {\n+static address get_svml_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n+  address addr = NULL;\n@@ -1560,380 +1623,22 @@\n-  assert(addr_ptr != NULL, \"unexpected\");\n-\n-#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n-  \/\/ Since the addresses are resolved at runtime, using switch instead of table - otherwise might get NULL addresses.\n-  if (bt == T_FLOAT) {\n-    switch(op) {\n-      case VectorSupport::VECTOR_OP_EXP: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_exp_float64\";  *addr_ptr = StubRoutines::vector_exp_float64();  break;\n-            case 128: *name_ptr = \"vector_exp_float128\"; *addr_ptr = StubRoutines::vector_exp_float128(); break;\n-            case 256: *name_ptr = \"vector_exp_float256\"; *addr_ptr = StubRoutines::vector_exp_float256(); break;\n-            case 512: *name_ptr = \"vector_exp_float512\"; *addr_ptr = StubRoutines::vector_exp_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_LOG1P: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_log1p_float64\";  *addr_ptr = StubRoutines::vector_log1p_float64();  break;\n-            case 128: *name_ptr = \"vector_log1p_float128\"; *addr_ptr = StubRoutines::vector_log1p_float128(); break;\n-            case 256: *name_ptr = \"vector_log1p_float256\"; *addr_ptr = StubRoutines::vector_log1p_float256(); break;\n-            case 512: *name_ptr = \"vector_log1p_float512\"; *addr_ptr = StubRoutines::vector_log1p_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_LOG: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_log_float64\";  *addr_ptr = StubRoutines::vector_log_float64();  break;\n-            case 128: *name_ptr = \"vector_log_float128\"; *addr_ptr = StubRoutines::vector_log_float128(); break;\n-            case 256: *name_ptr = \"vector_log_float256\"; *addr_ptr = StubRoutines::vector_log_float256(); break;\n-            case 512: *name_ptr = \"vector_log_float512\"; *addr_ptr = StubRoutines::vector_log_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_LOG10: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_log10_float64\";  *addr_ptr = StubRoutines::vector_log10_float64();  break;\n-            case 128: *name_ptr = \"vector_log10_float128\"; *addr_ptr = StubRoutines::vector_log10_float128(); break;\n-            case 256: *name_ptr = \"vector_log10_float256\"; *addr_ptr = StubRoutines::vector_log10_float256(); break;\n-            case 512: *name_ptr = \"vector_log10_float512\"; *addr_ptr = StubRoutines::vector_log10_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_EXPM1: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_expm1_float64\";  *addr_ptr = StubRoutines::vector_expm1_float64();  break;\n-            case 128: *name_ptr = \"vector_expm1_float128\"; *addr_ptr = StubRoutines::vector_expm1_float128(); break;\n-            case 256: *name_ptr = \"vector_expm1_float256\"; *addr_ptr = StubRoutines::vector_expm1_float256(); break;\n-            case 512: *name_ptr = \"vector_expm1_float512\"; *addr_ptr = StubRoutines::vector_expm1_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_SIN: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_sin_float64\";  *addr_ptr = StubRoutines::vector_sin_float64();  break;\n-            case 128: *name_ptr = \"vector_sin_float128\"; *addr_ptr = StubRoutines::vector_sin_float128(); break;\n-            case 256: *name_ptr = \"vector_sin_float256\"; *addr_ptr = StubRoutines::vector_sin_float256(); break;\n-            case 512: *name_ptr = \"vector_sin_float512\"; *addr_ptr = StubRoutines::vector_sin_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_COS: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_cos_float64\";  *addr_ptr = StubRoutines::vector_cos_float64();  break;\n-            case 128: *name_ptr = \"vector_cos_float128\"; *addr_ptr = StubRoutines::vector_cos_float128(); break;\n-            case 256: *name_ptr = \"vector_cos_float256\"; *addr_ptr = StubRoutines::vector_cos_float256(); break;\n-            case 512: *name_ptr = \"vector_cos_float512\"; *addr_ptr = StubRoutines::vector_cos_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_TAN: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_tan_float64\";  *addr_ptr = StubRoutines::vector_tan_float64();  break;\n-            case 128: *name_ptr = \"vector_tan_float128\"; *addr_ptr = StubRoutines::vector_tan_float128(); break;\n-            case 256: *name_ptr = \"vector_tan_float256\"; *addr_ptr = StubRoutines::vector_tan_float256(); break;\n-            case 512: *name_ptr = \"vector_tan_float512\"; *addr_ptr = StubRoutines::vector_tan_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_SINH: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_sinh_float64\";  *addr_ptr = StubRoutines::vector_sinh_float64();  break;\n-            case 128: *name_ptr = \"vector_sinh_float128\"; *addr_ptr = StubRoutines::vector_sinh_float128(); break;\n-            case 256: *name_ptr = \"vector_sinh_float256\"; *addr_ptr = StubRoutines::vector_sinh_float256(); break;\n-            case 512: *name_ptr = \"vector_sinh_float512\"; *addr_ptr = StubRoutines::vector_sinh_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_COSH: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_cosh_float64\";  *addr_ptr = StubRoutines::vector_cosh_float64();  break;\n-            case 128: *name_ptr = \"vector_cosh_float128\"; *addr_ptr = StubRoutines::vector_cosh_float128(); break;\n-            case 256: *name_ptr = \"vector_cosh_float256\"; *addr_ptr = StubRoutines::vector_cosh_float256(); break;\n-            case 512: *name_ptr = \"vector_cosh_float512\"; *addr_ptr = StubRoutines::vector_cosh_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_TANH: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_tanh_float64\";  *addr_ptr = StubRoutines::vector_tanh_float64();  break;\n-            case 128: *name_ptr = \"vector_tanh_float128\"; *addr_ptr = StubRoutines::vector_tanh_float128(); break;\n-            case 256: *name_ptr = \"vector_tanh_float256\"; *addr_ptr = StubRoutines::vector_tanh_float256(); break;\n-            case 512: *name_ptr = \"vector_tanh_float512\"; *addr_ptr = StubRoutines::vector_tanh_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_ASIN: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_asin_float64\";  *addr_ptr = StubRoutines::vector_asin_float64();  break;\n-            case 128: *name_ptr = \"vector_asin_float128\"; *addr_ptr = StubRoutines::vector_asin_float128(); break;\n-            case 256: *name_ptr = \"vector_asin_float256\"; *addr_ptr = StubRoutines::vector_asin_float256(); break;\n-            case 512: *name_ptr = \"vector_asin_float512\"; *addr_ptr = StubRoutines::vector_asin_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_ACOS: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_acos_float64\";  *addr_ptr = StubRoutines::vector_acos_float64();  break;\n-            case 128: *name_ptr = \"vector_acos_float128\"; *addr_ptr = StubRoutines::vector_acos_float128(); break;\n-            case 256: *name_ptr = \"vector_acos_float256\"; *addr_ptr = StubRoutines::vector_acos_float256(); break;\n-            case 512: *name_ptr = \"vector_acos_float512\"; *addr_ptr = StubRoutines::vector_acos_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_ATAN: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_atan_float64\";  *addr_ptr = StubRoutines::vector_atan_float64();  break;\n-            case 128: *name_ptr = \"vector_atan_float128\"; *addr_ptr = StubRoutines::vector_atan_float128(); break;\n-            case 256: *name_ptr = \"vector_atan_float256\"; *addr_ptr = StubRoutines::vector_atan_float256(); break;\n-            case 512: *name_ptr = \"vector_atan_float512\"; *addr_ptr = StubRoutines::vector_atan_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_CBRT: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_cbrt_float64\";  *addr_ptr = StubRoutines::vector_cbrt_float64();  break;\n-            case 128: *name_ptr = \"vector_cbrt_float128\"; *addr_ptr = StubRoutines::vector_cbrt_float128(); break;\n-            case 256: *name_ptr = \"vector_cbrt_float256\"; *addr_ptr = StubRoutines::vector_cbrt_float256(); break;\n-            case 512: *name_ptr = \"vector_cbrt_float512\"; *addr_ptr = StubRoutines::vector_cbrt_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-       case VectorSupport::VECTOR_OP_HYPOT: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_hypot_float64\";  *addr_ptr = StubRoutines::vector_hypot_float64();  break;\n-            case 128: *name_ptr = \"vector_hypot_float128\"; *addr_ptr = StubRoutines::vector_hypot_float128(); break;\n-            case 256: *name_ptr = \"vector_hypot_float256\"; *addr_ptr = StubRoutines::vector_hypot_float256(); break;\n-            case 512: *name_ptr = \"vector_hypot_float512\"; *addr_ptr = StubRoutines::vector_hypot_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_POW: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_pow_float64\";  *addr_ptr = StubRoutines::vector_pow_float64();  break;\n-            case 128: *name_ptr = \"vector_pow_float128\"; *addr_ptr = StubRoutines::vector_pow_float128(); break;\n-            case 256: *name_ptr = \"vector_pow_float256\"; *addr_ptr = StubRoutines::vector_pow_float256(); break;\n-            case 512: *name_ptr = \"vector_pow_float512\"; *addr_ptr = StubRoutines::vector_pow_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_ATAN2: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_atan2_float64\";  *addr_ptr = StubRoutines::vector_atan2_float64();  break;\n-            case 128: *name_ptr = \"vector_atan2_float128\"; *addr_ptr = StubRoutines::vector_atan2_float128(); break;\n-            case 256: *name_ptr = \"vector_atan2_float256\"; *addr_ptr = StubRoutines::vector_atan2_float256(); break;\n-            case 512: *name_ptr = \"vector_atan2_float512\"; *addr_ptr = StubRoutines::vector_atan2_float512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      default:\n-        *name_ptr = \"invalid\";\n-        *addr_ptr = NULL;\n-        break;\n-    }\n-  } else {\n-    assert(bt == T_DOUBLE, \"must be FP type only\");\n-    switch(op) {\n-      case VectorSupport::VECTOR_OP_EXP: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_exp_double64\";  *addr_ptr = StubRoutines::vector_exp_double64();  break;\n-            case 128: *name_ptr = \"vector_exp_double128\"; *addr_ptr = StubRoutines::vector_exp_double128(); break;\n-            case 256: *name_ptr = \"vector_exp_double256\"; *addr_ptr = StubRoutines::vector_exp_double256(); break;\n-            case 512: *name_ptr = \"vector_exp_double512\"; *addr_ptr = StubRoutines::vector_exp_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_LOG1P: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_log1p_double64\";  *addr_ptr = StubRoutines::vector_log1p_double64();  break;\n-            case 128: *name_ptr = \"vector_log1p_double128\"; *addr_ptr = StubRoutines::vector_log1p_double128(); break;\n-            case 256: *name_ptr = \"vector_log1p_double256\"; *addr_ptr = StubRoutines::vector_log1p_double256(); break;\n-            case 512: *name_ptr = \"vector_log1p_double512\"; *addr_ptr = StubRoutines::vector_log1p_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_LOG: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_log_double64\";  *addr_ptr = StubRoutines::vector_log_double64();  break;\n-            case 128: *name_ptr = \"vector_log_double128\"; *addr_ptr = StubRoutines::vector_log_double128(); break;\n-            case 256: *name_ptr = \"vector_log_double256\"; *addr_ptr = StubRoutines::vector_log_double256(); break;\n-            case 512: *name_ptr = \"vector_log_double512\"; *addr_ptr = StubRoutines::vector_log_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_LOG10: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_log10_double64\";  *addr_ptr = StubRoutines::vector_log10_double64();  break;\n-            case 128: *name_ptr = \"vector_log10_double128\"; *addr_ptr = StubRoutines::vector_log10_double128(); break;\n-            case 256: *name_ptr = \"vector_log10_double256\"; *addr_ptr = StubRoutines::vector_log10_double256(); break;\n-            case 512: *name_ptr = \"vector_log10_double512\"; *addr_ptr = StubRoutines::vector_log10_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_EXPM1: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_expm1_double64\";  *addr_ptr = StubRoutines::vector_expm1_double64();  break;\n-            case 128: *name_ptr = \"vector_expm1_double128\"; *addr_ptr = StubRoutines::vector_expm1_double128(); break;\n-            case 256: *name_ptr = \"vector_expm1_double256\"; *addr_ptr = StubRoutines::vector_expm1_double256(); break;\n-            case 512: *name_ptr = \"vector_expm1_double512\"; *addr_ptr = StubRoutines::vector_expm1_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_SIN: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_sin_double64\";  *addr_ptr = StubRoutines::vector_sin_double64();  break;\n-            case 128: *name_ptr = \"vector_sin_double128\"; *addr_ptr = StubRoutines::vector_sin_double128(); break;\n-            case 256: *name_ptr = \"vector_sin_double256\"; *addr_ptr = StubRoutines::vector_sin_double256(); break;\n-            case 512: *name_ptr = \"vector_sin_double512\"; *addr_ptr = StubRoutines::vector_sin_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_COS: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_cos_double64\";  *addr_ptr = StubRoutines::vector_cos_double64();  break;\n-            case 128: *name_ptr = \"vector_cos_double128\"; *addr_ptr = StubRoutines::vector_cos_double128(); break;\n-            case 256: *name_ptr = \"vector_cos_double256\"; *addr_ptr = StubRoutines::vector_cos_double256(); break;\n-            case 512: *name_ptr = \"vector_cos_double512\"; *addr_ptr = StubRoutines::vector_cos_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_TAN: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_tan_double64\";  *addr_ptr = StubRoutines::vector_tan_double64();  break;\n-            case 128: *name_ptr = \"vector_tan_double128\"; *addr_ptr = StubRoutines::vector_tan_double128(); break;\n-            case 256: *name_ptr = \"vector_tan_double256\"; *addr_ptr = StubRoutines::vector_tan_double256(); break;\n-            case 512: *name_ptr = \"vector_tan_double512\"; *addr_ptr = StubRoutines::vector_tan_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_SINH: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_sinh_double64\";  *addr_ptr = StubRoutines::vector_sinh_double64();  break;\n-            case 128: *name_ptr = \"vector_sinh_double128\"; *addr_ptr = StubRoutines::vector_sinh_double128(); break;\n-            case 256: *name_ptr = \"vector_sinh_double256\"; *addr_ptr = StubRoutines::vector_sinh_double256(); break;\n-            case 512: *name_ptr = \"vector_sinh_double512\"; *addr_ptr = StubRoutines::vector_sinh_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_COSH: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_cosh_double64\";  *addr_ptr = StubRoutines::vector_cosh_double64();  break;\n-            case 128: *name_ptr = \"vector_cosh_double128\"; *addr_ptr = StubRoutines::vector_cosh_double128(); break;\n-            case 256: *name_ptr = \"vector_cosh_double256\"; *addr_ptr = StubRoutines::vector_cosh_double256(); break;\n-            case 512: *name_ptr = \"vector_cosh_double512\"; *addr_ptr = StubRoutines::vector_cosh_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_TANH: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_tanh_double64\";  *addr_ptr = StubRoutines::vector_tanh_double64();  break;\n-            case 128: *name_ptr = \"vector_tanh_double128\"; *addr_ptr = StubRoutines::vector_tanh_double128(); break;\n-            case 256: *name_ptr = \"vector_tanh_double256\"; *addr_ptr = StubRoutines::vector_tanh_double256(); break;\n-            case 512: *name_ptr = \"vector_tanh_double512\"; *addr_ptr = StubRoutines::vector_tanh_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_ASIN: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_asin_double64\";  *addr_ptr = StubRoutines::vector_asin_double64();  break;\n-            case 128: *name_ptr = \"vector_asin_double128\"; *addr_ptr = StubRoutines::vector_asin_double128(); break;\n-            case 256: *name_ptr = \"vector_asin_double256\"; *addr_ptr = StubRoutines::vector_asin_double256(); break;\n-            case 512: *name_ptr = \"vector_asin_double512\"; *addr_ptr = StubRoutines::vector_asin_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_ACOS: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_acos_double64\";  *addr_ptr = StubRoutines::vector_acos_double64();  break;\n-            case 128: *name_ptr = \"vector_acos_double128\"; *addr_ptr = StubRoutines::vector_acos_double128(); break;\n-            case 256: *name_ptr = \"vector_acos_double256\"; *addr_ptr = StubRoutines::vector_acos_double256(); break;\n-            case 512: *name_ptr = \"vector_acos_double512\"; *addr_ptr = StubRoutines::vector_acos_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_ATAN: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_atan_double64\";  *addr_ptr = StubRoutines::vector_atan_double64();  break;\n-            case 128: *name_ptr = \"vector_atan_double128\"; *addr_ptr = StubRoutines::vector_atan_double128(); break;\n-            case 256: *name_ptr = \"vector_atan_double256\"; *addr_ptr = StubRoutines::vector_atan_double256(); break;\n-            case 512: *name_ptr = \"vector_atan_double512\"; *addr_ptr = StubRoutines::vector_atan_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_CBRT: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_cbrt_double64\";  *addr_ptr = StubRoutines::vector_cbrt_double64();  break;\n-            case 128: *name_ptr = \"vector_cbrt_double128\"; *addr_ptr = StubRoutines::vector_cbrt_double128(); break;\n-            case 256: *name_ptr = \"vector_cbrt_double256\"; *addr_ptr = StubRoutines::vector_cbrt_double256(); break;\n-            case 512: *name_ptr = \"vector_cbrt_double512\"; *addr_ptr = StubRoutines::vector_cbrt_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_HYPOT: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_hypot_double64\";  *addr_ptr = StubRoutines::vector_hypot_double64();  break;\n-            case 128: *name_ptr = \"vector_hypot_double128\"; *addr_ptr = StubRoutines::vector_hypot_double128(); break;\n-            case 256: *name_ptr = \"vector_hypot_double256\"; *addr_ptr = StubRoutines::vector_hypot_double256(); break;\n-            case 512: *name_ptr = \"vector_hypot_double512\"; *addr_ptr = StubRoutines::vector_hypot_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_POW: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_pow_double64\";  *addr_ptr = StubRoutines::vector_pow_double64();  break;\n-            case 128: *name_ptr = \"vector_pow_double128\"; *addr_ptr = StubRoutines::vector_pow_double128(); break;\n-            case 256: *name_ptr = \"vector_pow_double256\"; *addr_ptr = StubRoutines::vector_pow_double256(); break;\n-            case 512: *name_ptr = \"vector_pow_double512\"; *addr_ptr = StubRoutines::vector_pow_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-      case VectorSupport::VECTOR_OP_ATAN2: {\n-          switch(bits) {\n-            case 64:  *name_ptr = \"vector_atan2_double64\";  *addr_ptr = StubRoutines::vector_atan2_double64();  break;\n-            case 128: *name_ptr = \"vector_atan2_double128\"; *addr_ptr = StubRoutines::vector_atan2_double128(); break;\n-            case 256: *name_ptr = \"vector_atan2_double256\"; *addr_ptr = StubRoutines::vector_atan2_double256(); break;\n-            case 512: *name_ptr = \"vector_atan2_double512\"; *addr_ptr = StubRoutines::vector_atan2_double512(); break;\n-            default: Unimplemented(); break;\n-          }\n-        }\n-        break;\n-\n-      default:\n-        *name_ptr = \"invalid\";\n-        *addr_ptr = NULL;\n-        break;\n-    }\n+  assert((vop >= VectorSupport::VECTOR_OP_SVML_START) && (vop <= VectorSupport::VECTOR_OP_SVML_END), \"unexpected\");\n+  int op = vop - VectorSupport::VECTOR_OP_SVML_START;\n+\n+  switch(bits) {\n+    case 64:  \/\/fallthough\n+    case 128: \/\/fallthough\n+    case 256: \/\/fallthough\n+    case 512:\n+      if (bt == T_FLOAT) {\n+        snprintf(name_ptr, name_len, \"vector_%s_float%d\", VectorSupport::svmlname[op], bits);\n+        addr = StubRoutines::_vector_f_math[exact_log2(bits\/64)][op];\n+      } else {\n+        assert(bt == T_DOUBLE, \"must be FP type only\");\n+        snprintf(name_ptr, name_len, \"vector_%s_double%d\", VectorSupport::svmlname[op], bits);\n+        addr = StubRoutines::_vector_d_math[exact_log2(bits\/64)][op];\n+      }\n+      break;\n+    default:\n+      snprintf(name_ptr, name_len, \"invalid\");\n+      addr = NULL;\n+      Unimplemented();\n+      break;\n@@ -1941,4 +1646,2 @@\n-#else\n-  *name_ptr = \"invalid\";\n-  *addr_ptr = NULL;\n-#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+\n+  return addr;\n@@ -1953,2 +1656,1 @@\n-  const char* name = NULL;\n-  address addr = NULL;\n+  char name[100] = \"\";\n@@ -1957,1 +1659,1 @@\n-  get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, &name, &addr);\n+  address addr = get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n@@ -2104,1 +1806,1 @@\n-  if (is_vector_shuffle(vbox_klass_from) || is_vector_shuffle(vbox_klass_to)) {\n+  if (is_vector_shuffle(vbox_klass_from)) {\n@@ -2119,2 +1821,2 @@\n-  if (is_mask && elem_bt_from != elem_bt_to) {\n-    return false; \/\/ type mismatch\n+  if (is_mask && (type2aelembytes(elem_bt_from) != type2aelembytes(elem_bt_to))) {\n+    return false; \/\/ elem size mismatch\n@@ -2122,0 +1824,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":97,"deletions":394,"binary":false,"changes":491,"status":"modified"},{"patch":"@@ -803,0 +803,2 @@\n+\/\/------------------------------StoreVectorMaskedNode--------------------------------\n+\/\/ Store Vector to memory under the influence of a predicate register(mask).\n@@ -821,0 +823,2 @@\n+\/\/------------------------------LoadVectorMaskedNode--------------------------------\n+\/\/ Load Vector from memory under the influence of a predicate register(mask).\n@@ -839,0 +843,15 @@\n+\n+\/\/------------------------------VectorCmpMaskedNode--------------------------------\n+\/\/ Vector Comparison under the influence of a predicate register(mask).\n+class VectorCmpMaskedNode : public TypeNode {\n+  public:\n+   VectorCmpMaskedNode(Node* src1, Node* src2, Node* mask, const Type* ty): TypeNode(ty, 4)  {\n+     init_req(1, src1);\n+     init_req(2, src2);\n+     init_req(3, mask);\n+   }\n+\n+  virtual int Opcode() const;\n+};\n+\n+\n@@ -841,1 +860,1 @@\n-  VectorMaskGenNode(Node* length, const Type* ty, const Type* ety): TypeNode(ty, 2), _elemType(ety) {\n+  VectorMaskGenNode(Node* length, const Type* ty, BasicType ety): TypeNode(ty, 2), _elemType(ety) {\n@@ -846,1 +865,1 @@\n-  const Type* get_elem_type()  { return _elemType;}\n+  BasicType get_elem_type()  { return _elemType;}\n@@ -853,1 +872,40 @@\n-   const Type* _elemType;\n+   BasicType _elemType;\n+};\n+\n+class VectorMaskOpNode : public TypeNode {\n+ public:\n+  VectorMaskOpNode(Node* mask, const Type* ty, int mopc):\n+    TypeNode(ty, 2), _mopc(mopc) {\n+    assert(mask->Opcode() == Op_VectorStoreMask, \"\");\n+    init_req(1, mask);\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual  uint  size_of() const { return sizeof(VectorMaskOpNode); }\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+  int get_mask_Opcode() const { return _mopc;}\n+  static Node* make(Node* mask, const Type* ty, int mopc);\n+\n+  private:\n+    int _mopc;\n+};\n+\n+class VectorMaskTrueCountNode : public VectorMaskOpNode {\n+ public:\n+  VectorMaskTrueCountNode(Node* mask, const Type* ty):\n+    VectorMaskOpNode(mask, ty, Op_VectorMaskTrueCount) {}\n+  virtual int Opcode() const;\n+};\n+\n+class VectorMaskFirstTrueNode : public VectorMaskOpNode {\n+ public:\n+  VectorMaskFirstTrueNode(Node* mask, const Type* ty):\n+    VectorMaskOpNode(mask, ty, Op_VectorMaskFirstTrue) {}\n+  virtual int Opcode() const;\n+};\n+\n+class VectorMaskLastTrueNode : public VectorMaskOpNode {\n+ public:\n+  VectorMaskLastTrueNode(Node* mask, const Type* ty):\n+    VectorMaskOpNode(mask, ty, Op_VectorMaskLastTrue) {}\n+  virtual int Opcode() const;\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":61,"deletions":3,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+    \/\/ Mask manipulation operations\n+    public static final int VECTOR_OP_MASK_TRUECOUNT = 19;\n+    public static final int VECTOR_OP_MASK_FIRSTTRUE = 20;\n+    public static final int VECTOR_OP_MASK_LASTTRUE  = 21;\n+\n@@ -107,1 +112,0 @@\n-\n@@ -507,0 +511,14 @@\n+    \/* ============================================================================ *\/\n+    public interface VectorMaskOp<M> {\n+        int apply(M m);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <E, M>\n+    int maskReductionCoerced(int oper, Class<? extends M> maskClass, Class<?> elemClass, int length, M m,\n+               VectorMaskOp<M> defaultImpl) {\n+       assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+       return defaultImpl.apply(m);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -135,36 +135,0 @@\n-    @Override\n-    public int trueCount() {\n-        \/\/FIXME: use a population count intrinsic here\n-        int c = 0;\n-        for (boolean i : getBits()) {\n-            if (i) c++;\n-        }\n-        return c;\n-    }\n-\n-    @Override\n-    public int firstTrue() {\n-        \/\/FIXME: use a count trailing zeros intrinsic here\n-        boolean[] bits = getBits();\n-        for (int i = 0; i < bits.length; i++) {\n-            if (bits[i])  return i;\n-        }\n-        return bits.length;\n-    }\n-\n-    @Override\n-    public int lastTrue() {\n-        \/\/FIXME: use a count leading zeros intrinsic here\n-        boolean[] bits = getBits();\n-        for (int i = bits.length-1; i >= 0; i--) {\n-            if (bits[i])  return i;\n-        }\n-        return -1;\n-    }\n-\n-    @Override\n-    public VectorMask<E> eq(VectorMask<E> m) {\n-        \/\/ FIXME: Generate good code here.\n-        return bOp(m, (i, a, b) -> a == b);\n-    }\n-\n@@ -194,0 +158,25 @@\n+    \/*package-private*\/\n+    static int trueCountHelper(boolean[] bits) {\n+        int c = 0;\n+        for (boolean i : bits) {\n+            if (i) c++;\n+        }\n+        return c;\n+    }\n+\n+    \/*package-private*\/\n+    static int firstTrueHelper(boolean[] bits) {\n+        for (int i = 0; i < bits.length; i++) {\n+            if (bits[i])  return i;\n+        }\n+        return bits.length;\n+    }\n+\n+    \/*package-private*\/\n+    static int lastTrueHelper(boolean[] bits) {\n+        for (int i = bits.length-1; i >= 0; i--) {\n+            if (bits[i])  return i;\n+        }\n+        return -1;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":25,"deletions":36,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        byte[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Byte128Shuffle.class); \/\/ specialize\n@@ -622,0 +616,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -624,2 +639,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -628,15 +643,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte128Mask::defaultMaskCast);\n@@ -644,0 +652,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -645,2 +655,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Byte128Mask eq(VectorMask<Byte> mask) {\n+            Objects.requireNonNull(mask);\n+            Byte128Mask m = (Byte128Mask)mask;\n+            return xor(m.not());\n@@ -689,0 +703,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte128Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Byte128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte128Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Byte128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte128Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Byte128Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        byte[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Byte256Shuffle.class); \/\/ specialize\n@@ -654,0 +648,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -656,2 +671,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -660,15 +675,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte256Mask::defaultMaskCast);\n@@ -676,0 +684,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -677,2 +687,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Byte256Mask eq(VectorMask<Byte> mask) {\n+            Objects.requireNonNull(mask);\n+            Byte256Mask m = (Byte256Mask)mask;\n+            return xor(m.not());\n@@ -721,0 +735,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte256Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Byte256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte256Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Byte256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte256Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Byte256Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        byte[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Byte512Shuffle.class); \/\/ specialize\n@@ -718,0 +712,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -720,2 +735,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -724,15 +739,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte512Mask::defaultMaskCast);\n@@ -740,0 +748,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -741,2 +751,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Byte512Mask eq(VectorMask<Byte> mask) {\n+            Objects.requireNonNull(mask);\n+            Byte512Mask m = (Byte512Mask)mask;\n+            return xor(m.not());\n@@ -785,0 +799,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte512Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Byte512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte512Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Byte512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte512Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Byte512Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        byte[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Byte64Shuffle.class); \/\/ specialize\n@@ -606,0 +600,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -608,2 +623,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -612,15 +627,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Byte64Mask::defaultMaskCast);\n@@ -628,0 +636,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -629,2 +639,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Byte64Mask eq(VectorMask<Byte> mask) {\n+            Objects.requireNonNull(mask);\n+            Byte64Mask m = (Byte64Mask)mask;\n+            return xor(m.not());\n@@ -673,0 +687,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Byte64Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Byte64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Byte64Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Byte64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Byte64Mask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Byte64Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        byte[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(ByteMaxShuffle.class); \/\/ specialize\n@@ -592,0 +586,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -594,2 +609,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -598,15 +613,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    ByteMaxMask::defaultMaskCast);\n@@ -614,0 +622,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -615,2 +625,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public ByteMaxMask eq(VectorMask<Byte> mask) {\n+            Objects.requireNonNull(mask);\n+            ByteMaxMask m = (ByteMaxMask)mask;\n+            return xor(m.not());\n@@ -659,0 +673,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ByteMaxMask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((ByteMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((ByteMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ByteMaxMask.class, byte.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((ByteMaxMask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2279,0 +2279,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Byte> toShuffle0(ByteSpecies dsp) {\n+        byte[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Byte> toShuffleTemplate(Class<?> shuffleType) {\n+        ByteSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), byte.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     ByteVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-    @Override\n@@ -350,6 +349,1 @@\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Double128Shuffle.class); \/\/ specialize\n@@ -590,0 +584,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -592,2 +607,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -596,15 +611,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double128Mask::defaultMaskCast);\n@@ -612,0 +620,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -613,2 +623,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Double128Mask eq(VectorMask<Double> mask) {\n+            Objects.requireNonNull(mask);\n+            Double128Mask m = (Double128Mask)mask;\n+            return xor(m.not());\n@@ -657,0 +671,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double128Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Double128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double128Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Double128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double128Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Double128Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-    @Override\n@@ -350,6 +349,1 @@\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Double256Shuffle.class); \/\/ specialize\n@@ -594,0 +588,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -596,2 +611,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -600,15 +615,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double256Mask::defaultMaskCast);\n@@ -616,0 +624,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -617,2 +627,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Double256Mask eq(VectorMask<Double> mask) {\n+            Objects.requireNonNull(mask);\n+            Double256Mask m = (Double256Mask)mask;\n+            return xor(m.not());\n@@ -661,0 +675,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double256Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Double256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double256Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Double256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double256Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Double256Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-    @Override\n@@ -350,6 +349,1 @@\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Double512Shuffle.class); \/\/ specialize\n@@ -602,0 +596,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -604,2 +619,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -608,15 +623,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double512Mask::defaultMaskCast);\n@@ -624,0 +632,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -625,2 +635,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Double512Mask eq(VectorMask<Double> mask) {\n+            Objects.requireNonNull(mask);\n+            Double512Mask m = (Double512Mask)mask;\n+            return xor(m.not());\n@@ -669,0 +683,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double512Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Double512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double512Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Double512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double512Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Double512Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-    @Override\n@@ -350,6 +349,1 @@\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Double64Shuffle.class); \/\/ specialize\n@@ -588,0 +582,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -590,2 +605,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -594,15 +609,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Double64Mask::defaultMaskCast);\n@@ -610,0 +618,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -611,2 +621,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Double64Mask eq(VectorMask<Double> mask) {\n+            Objects.requireNonNull(mask);\n+            Double64Mask m = (Double64Mask)mask;\n+            return xor(m.not());\n@@ -655,0 +669,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Double64Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Double64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Double64Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Double64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Double64Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Double64Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-    @Override\n@@ -350,6 +349,1 @@\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(DoubleMaxShuffle.class); \/\/ specialize\n@@ -587,0 +581,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -589,2 +604,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -593,15 +608,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    DoubleMaxMask::defaultMaskCast);\n@@ -609,0 +617,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -610,2 +620,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public DoubleMaxMask eq(VectorMask<Double> mask) {\n+            Objects.requireNonNull(mask);\n+            DoubleMaxMask m = (DoubleMaxMask)mask;\n+            return xor(m.not());\n@@ -654,0 +668,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, DoubleMaxMask.class, long.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((DoubleMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((DoubleMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, DoubleMaxMask.class, long.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((DoubleMaxMask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2158,0 +2158,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Double> toShuffle0(DoubleSpecies dsp) {\n+        double[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Double> toShuffleTemplate(Class<?> shuffleType) {\n+        DoubleSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), double.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     DoubleVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-    @Override\n@@ -350,6 +349,1 @@\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Float128Shuffle.class); \/\/ specialize\n@@ -594,0 +588,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -596,2 +611,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -600,15 +615,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float128Mask::defaultMaskCast);\n@@ -616,0 +624,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -617,2 +627,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Float128Mask eq(VectorMask<Float> mask) {\n+            Objects.requireNonNull(mask);\n+            Float128Mask m = (Float128Mask)mask;\n+            return xor(m.not());\n@@ -661,0 +675,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float128Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Float128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float128Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Float128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float128Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Float128Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-    @Override\n@@ -350,6 +349,1 @@\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Float256Shuffle.class); \/\/ specialize\n@@ -602,0 +596,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -604,2 +619,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -608,15 +623,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float256Mask::defaultMaskCast);\n@@ -624,0 +632,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -625,2 +635,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Float256Mask eq(VectorMask<Float> mask) {\n+            Objects.requireNonNull(mask);\n+            Float256Mask m = (Float256Mask)mask;\n+            return xor(m.not());\n@@ -669,0 +683,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float256Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Float256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float256Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Float256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float256Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Float256Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-    @Override\n@@ -350,6 +349,1 @@\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Float512Shuffle.class); \/\/ specialize\n@@ -618,0 +612,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -620,2 +635,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -624,15 +639,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float512Mask::defaultMaskCast);\n@@ -640,0 +648,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -641,2 +651,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Float512Mask eq(VectorMask<Float> mask) {\n+            Objects.requireNonNull(mask);\n+            Float512Mask m = (Float512Mask)mask;\n+            return xor(m.not());\n@@ -685,0 +699,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float512Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Float512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float512Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Float512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float512Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Float512Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-    @Override\n@@ -350,6 +349,1 @@\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Float64Shuffle.class); \/\/ specialize\n@@ -590,0 +584,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -592,2 +607,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -596,15 +611,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Float64Mask::defaultMaskCast);\n@@ -612,0 +620,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -613,2 +623,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Float64Mask eq(VectorMask<Float> mask) {\n+            Objects.requireNonNull(mask);\n+            Float64Mask m = (Float64Mask)mask;\n+            return xor(m.not());\n@@ -657,0 +671,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Float64Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Float64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Float64Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Float64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Float64Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Float64Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-    @Override\n@@ -350,6 +349,1 @@\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(FloatMaxShuffle.class); \/\/ specialize\n@@ -587,0 +581,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -589,2 +604,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -593,15 +608,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    FloatMaxMask::defaultMaskCast);\n@@ -609,0 +617,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -610,2 +620,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public FloatMaxMask eq(VectorMask<Float> mask) {\n+            Objects.requireNonNull(mask);\n+            FloatMaxMask m = (FloatMaxMask)mask;\n+            return xor(m.not());\n@@ -654,0 +668,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, FloatMaxMask.class, int.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((FloatMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((FloatMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, FloatMaxMask.class, int.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((FloatMaxMask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2170,0 +2170,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Float> toShuffle0(FloatSpecies dsp) {\n+        float[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Float> toShuffleTemplate(Class<?> shuffleType) {\n+        FloatSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), float.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     FloatVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        int[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Int128Shuffle.class); \/\/ specialize\n@@ -598,0 +592,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -600,2 +615,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -604,15 +619,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int128Mask::defaultMaskCast);\n@@ -620,0 +628,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -621,2 +631,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Int128Mask eq(VectorMask<Integer> mask) {\n+            Objects.requireNonNull(mask);\n+            Int128Mask m = (Int128Mask)mask;\n+            return xor(m.not());\n@@ -665,0 +679,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int128Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Int128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int128Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Int128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int128Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Int128Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        int[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Int256Shuffle.class); \/\/ specialize\n@@ -606,0 +600,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -608,2 +623,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -612,15 +627,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int256Mask::defaultMaskCast);\n@@ -628,0 +636,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -629,2 +639,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Int256Mask eq(VectorMask<Integer> mask) {\n+            Objects.requireNonNull(mask);\n+            Int256Mask m = (Int256Mask)mask;\n+            return xor(m.not());\n@@ -673,0 +687,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int256Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Int256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int256Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Int256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int256Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Int256Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        int[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Int512Shuffle.class); \/\/ specialize\n@@ -622,0 +616,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -624,2 +639,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -628,15 +643,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int512Mask::defaultMaskCast);\n@@ -644,0 +652,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -645,2 +655,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Int512Mask eq(VectorMask<Integer> mask) {\n+            Objects.requireNonNull(mask);\n+            Int512Mask m = (Int512Mask)mask;\n+            return xor(m.not());\n@@ -689,0 +703,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int512Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Int512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int512Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Int512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int512Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Int512Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        int[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Int64Shuffle.class); \/\/ specialize\n@@ -594,0 +588,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -596,2 +611,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -600,15 +615,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Int64Mask::defaultMaskCast);\n@@ -616,0 +624,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -617,2 +627,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Int64Mask eq(VectorMask<Integer> mask) {\n+            Objects.requireNonNull(mask);\n+            Int64Mask m = (Int64Mask)mask;\n+            return xor(m.not());\n@@ -661,0 +675,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Int64Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Int64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Int64Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Int64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Int64Mask.class, int.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Int64Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        int[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(IntMaxShuffle.class); \/\/ specialize\n@@ -592,0 +586,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -594,2 +609,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -598,15 +613,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    IntMaxMask::defaultMaskCast);\n@@ -614,0 +622,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -615,2 +625,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public IntMaxMask eq(VectorMask<Integer> mask) {\n+            Objects.requireNonNull(mask);\n+            IntMaxMask m = (IntMaxMask)mask;\n+            return xor(m.not());\n@@ -659,0 +673,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, IntMaxMask.class, int.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((IntMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((IntMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, IntMaxMask.class, int.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((IntMaxMask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2278,0 +2278,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Integer> toShuffle0(IntSpecies dsp) {\n+        int[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Integer> toShuffleTemplate(Class<?> shuffleType) {\n+        IntSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), int.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     IntVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -348,1 +348,0 @@\n-    @Override\n@@ -351,6 +350,1 @@\n-        long[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Long128Shuffle.class); \/\/ specialize\n@@ -584,0 +578,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -586,2 +601,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -590,15 +605,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long128Mask::defaultMaskCast);\n@@ -606,0 +614,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -607,2 +617,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Long128Mask eq(VectorMask<Long> mask) {\n+            Objects.requireNonNull(mask);\n+            Long128Mask m = (Long128Mask)mask;\n+            return xor(m.not());\n@@ -651,0 +665,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long128Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Long128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long128Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Long128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long128Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Long128Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -348,1 +348,0 @@\n-    @Override\n@@ -351,6 +350,1 @@\n-        long[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Long256Shuffle.class); \/\/ specialize\n@@ -588,0 +582,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -590,2 +605,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -594,15 +609,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long256Mask::defaultMaskCast);\n@@ -610,0 +618,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -611,2 +621,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Long256Mask eq(VectorMask<Long> mask) {\n+            Objects.requireNonNull(mask);\n+            Long256Mask m = (Long256Mask)mask;\n+            return xor(m.not());\n@@ -655,0 +669,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long256Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Long256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long256Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Long256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long256Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Long256Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -348,1 +348,0 @@\n-    @Override\n@@ -351,6 +350,1 @@\n-        long[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Long512Shuffle.class); \/\/ specialize\n@@ -596,0 +590,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -598,2 +613,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -602,15 +617,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long512Mask::defaultMaskCast);\n@@ -618,0 +626,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -619,2 +629,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Long512Mask eq(VectorMask<Long> mask) {\n+            Objects.requireNonNull(mask);\n+            Long512Mask m = (Long512Mask)mask;\n+            return xor(m.not());\n@@ -663,0 +677,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long512Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Long512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long512Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Long512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long512Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Long512Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -348,1 +348,0 @@\n-    @Override\n@@ -351,6 +350,1 @@\n-        long[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Long64Shuffle.class); \/\/ specialize\n@@ -582,0 +576,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -584,2 +599,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -588,15 +603,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Long64Mask::defaultMaskCast);\n@@ -604,0 +612,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -605,2 +615,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Long64Mask eq(VectorMask<Long> mask) {\n+            Objects.requireNonNull(mask);\n+            Long64Mask m = (Long64Mask)mask;\n+            return xor(m.not());\n@@ -649,0 +663,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Long64Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Long64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Long64Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Long64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Long64Mask.class, long.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Long64Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -348,1 +348,0 @@\n-    @Override\n@@ -351,6 +350,1 @@\n-        long[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(LongMaxShuffle.class); \/\/ specialize\n@@ -582,0 +576,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -584,2 +599,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -588,15 +603,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    LongMaxMask::defaultMaskCast);\n@@ -604,0 +612,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -605,2 +615,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public LongMaxMask eq(VectorMask<Long> mask) {\n+            Objects.requireNonNull(mask);\n+            LongMaxMask m = (LongMaxMask)mask;\n+            return xor(m.not());\n@@ -649,0 +663,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, LongMaxMask.class, long.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((LongMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((LongMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, LongMaxMask.class, long.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((LongMaxMask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2144,0 +2144,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Long> toShuffle0(LongSpecies dsp) {\n+        long[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Long> toShuffleTemplate(Class<?> shuffleType) {\n+        LongSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), long.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     LongVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        short[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Short128Shuffle.class); \/\/ specialize\n@@ -606,0 +600,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -608,2 +623,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -612,15 +627,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short128Mask::defaultMaskCast);\n@@ -628,0 +636,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -629,2 +639,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Short128Mask eq(VectorMask<Short> mask) {\n+            Objects.requireNonNull(mask);\n+            Short128Mask m = (Short128Mask)mask;\n+            return xor(m.not());\n@@ -673,0 +687,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short128Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Short128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short128Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Short128Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short128Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Short128Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        short[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Short256Shuffle.class); \/\/ specialize\n@@ -622,0 +616,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -624,2 +639,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -628,15 +643,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short256Mask::defaultMaskCast);\n@@ -644,0 +652,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -645,2 +655,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Short256Mask eq(VectorMask<Short> mask) {\n+            Objects.requireNonNull(mask);\n+            Short256Mask m = (Short256Mask)mask;\n+            return xor(m.not());\n@@ -689,0 +703,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short256Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Short256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short256Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Short256Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short256Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Short256Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        short[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Short512Shuffle.class); \/\/ specialize\n@@ -654,0 +648,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -656,2 +671,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -660,15 +675,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short512Mask::defaultMaskCast);\n@@ -676,0 +684,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -677,2 +687,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Short512Mask eq(VectorMask<Short> mask) {\n+            Objects.requireNonNull(mask);\n+            Short512Mask m = (Short512Mask)mask;\n+            return xor(m.not());\n@@ -721,0 +735,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short512Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Short512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short512Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Short512Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short512Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Short512Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        short[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(Short64Shuffle.class); \/\/ specialize\n@@ -598,0 +592,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -600,2 +615,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -604,15 +619,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    Short64Mask::defaultMaskCast);\n@@ -620,0 +628,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -621,2 +631,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public Short64Mask eq(VectorMask<Short> mask) {\n+            Objects.requireNonNull(mask);\n+            Short64Mask m = (Short64Mask)mask;\n+            return xor(m.not());\n@@ -665,0 +679,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, Short64Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((Short64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, Short64Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((Short64Mask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, Short64Mask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((Short64Mask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -353,1 +353,0 @@\n-    @Override\n@@ -356,6 +355,1 @@\n-        short[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate(ShortMaxShuffle.class); \/\/ specialize\n@@ -592,0 +586,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -594,2 +609,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -598,15 +613,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxMask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxMask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxMask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxMask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxMask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxMask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    ShortMaxMask::defaultMaskCast);\n@@ -614,0 +622,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -615,2 +625,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public ShortMaxMask eq(VectorMask<Short> mask) {\n+            Objects.requireNonNull(mask);\n+            ShortMaxMask m = (ShortMaxMask)mask;\n+            return xor(m.not());\n@@ -659,0 +673,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, ShortMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper(((ShortMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper(((ShortMaxMask)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, ShortMaxMask.class, short.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper(((ShortMaxMask)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2279,0 +2279,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<Short> toShuffle0(ShortSpecies dsp) {\n+        short[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<Short> toShuffleTemplate(Class<?> shuffleType) {\n+        ShortSpecies vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), short.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     ShortVector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2566,0 +2566,23 @@\n+    @ForceInline\n+    private final\n+    VectorShuffle<$Boxtype$> toShuffle0($Type$Species dsp) {\n+        $type$[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    VectorShuffle<$Boxtype$> toShuffleTemplate(Class<?> shuffleType) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+                                     getClass(), $type$.class, length(),\n+                                     shuffleType, byte.class, length(),\n+                                     this, vsp,\n+                                     $Type$Vector::toShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -357,1 +357,0 @@\n-    @Override\n@@ -360,6 +359,1 @@\n-        $type$[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(VSPECIES, sa, 0);\n+        return super.toShuffleTemplate($shuffletype$.class); \/\/ specialize\n@@ -865,0 +859,21 @@\n+        \/**\n+         * Helper function for lane-wise mask conversions.\n+         * This function kicks in after intrinsic failure.\n+         *\/\n+        @ForceInline\n+        private final <E>\n+        VectorMask<E> defaultMaskCast(AbstractSpecies<E> dsp) {\n+            assert(length() == dsp.laneCount());\n+            boolean[] maskArray = toArray();\n+            \/\/ enum-switches don't optimize properly JDK-8161245\n+            return switch (dsp.laneType.switchKey) {\n+                     case LaneType.SK_BYTE   -> new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(dsp);\n+                     case LaneType.SK_SHORT  -> new Short$bits$Vector.Short$bits$Mask(maskArray).check(dsp);\n+                     case LaneType.SK_INT    -> new Int$bits$Vector.Int$bits$Mask(maskArray).check(dsp);\n+                     case LaneType.SK_LONG   -> new Long$bits$Vector.Long$bits$Mask(maskArray).check(dsp);\n+                     case LaneType.SK_FLOAT  -> new Float$bits$Vector.Float$bits$Mask(maskArray).check(dsp);\n+                     case LaneType.SK_DOUBLE -> new Double$bits$Vector.Double$bits$Mask(maskArray).check(dsp);\n+                     default                 -> throw new AssertionError(dsp);\n+            };\n+        }\n+\n@@ -867,2 +882,2 @@\n-        public <E> VectorMask<E> cast(VectorSpecies<E> s) {\n-            AbstractSpecies<E> species = (AbstractSpecies<E>) s;\n+        public <E> VectorMask<E> cast(VectorSpecies<E> dsp) {\n+            AbstractSpecies<E> species = (AbstractSpecies<E>) dsp;\n@@ -871,15 +886,8 @@\n-            boolean[] maskArray = toArray();\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short$bits$Vector.Short$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int$bits$Vector.Int$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long$bits$Vector.Long$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float$bits$Vector.Float$bits$Mask(maskArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double$bits$Vector.Double$bits$Mask(maskArray).check(species);\n+            if (VSIZE == species.vectorBitSize()) {\n+                Class<?> dtype = species.elementType();\n+                Class<?> dmtype = species.maskType();\n+                return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    this.getClass(), ETYPE, VLENGTH,\n+                    dmtype, dtype, VLENGTH,\n+                    this, species,\n+                    $Type$$bits$Mask::defaultMaskCast);\n@@ -887,0 +895,2 @@\n+            return this.defaultMaskCast(species);\n+        }\n@@ -888,2 +898,6 @@\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+        @Override\n+        @ForceInline\n+        public $masktype$ eq(VectorMask<$Boxtype$> mask) {\n+            Objects.requireNonNull(mask);\n+            $masktype$ m = ($masktype$)mask;\n+            return xor(m.not());\n@@ -932,0 +946,23 @@\n+        \/\/ Mask Query operations\n+\n+        @Override\n+        @ForceInline\n+        public int trueCount() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_TRUECOUNT, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+                                                      (m) -> trueCountHelper((($masktype$)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int firstTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_FIRSTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+                                                      (m) -> firstTrueHelper((($masktype$)m).getBits()));\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public int lastTrue() {\n+            return VectorSupport.maskReductionCoerced(VECTOR_OP_MASK_LASTTRUE, $masktype$.class, $bitstype$.class, VLENGTH, this,\n+                                                      (m) -> lastTrueHelper((($masktype$)m).getBits()));\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"}]}