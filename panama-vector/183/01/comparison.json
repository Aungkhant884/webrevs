{"files":[{"patch":"@@ -26,0 +26,1 @@\n+      jdk_version: ${{ steps.check_jdk_versions.outputs.jdk_version }}\n@@ -73,0 +74,17 @@\n+      - name: Determine full JDK versions\n+        id: check_jdk_versions\n+        shell: bash\n+        run: |\n+          FEATURE=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\n+          INTERIM=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_INTERIM }}\n+          UPDATE=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\n+          if [ \"x${UPDATE}\" != \"x0\" ]; then\n+             V=${FEATURE}.${INTERIM}.${UPDATE}\n+          elif [ \"x${INTERIM}\" != \"x0\" ]; then\n+             V={FEATURE}.${INTERIM}\n+          else\n+             V=${FEATURE}\n+          fi\n+          echo \"::set-output name=jdk_version::${V}\"\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n@@ -128,1 +146,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -256,1 +274,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -438,1 +456,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -585,1 +603,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -721,1 +739,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -872,1 +890,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -960,1 +978,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1111,1 +1129,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1286,1 +1304,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1387,1 +1405,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1517,1 +1535,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n","filename":".github\/workflows\/submit.yml","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -166,0 +166,2 @@\n+<h4 id=\"branch-protection\">Branch Protection<\/h4>\n+<p>In order to use Branch Protection features in the VM, <code>--enable-branch-protection<\/code> must be used. This option requires C++ compiler support (GCC 9.1.0+ or Clang 10+). The resulting build can be run on both machines with and without support for branch protection in hardware. Branch Protection is only supported for Linux targets.<\/p>\n@@ -217,1 +219,1 @@\n-<p>It's possible to build both Windows and Linux binaries from WSL. To build Windows binaries, you must use a Windows boot JDK (located in a Windows-accessible directory). To build Linux binaries, you must use a Linux boot JDK. The default behavior is to build for Windows. To build for Linux, pass <code>--build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux-gnu<\/code> to <code>configure<\/code>.<\/p>\n+<p>It's possible to build both Windows and Linux binaries from WSL. To build Windows binaries, you must use a Windows boot JDK (located in a Windows-accessible directory). To build Linux binaries, you must use a Linux boot JDK. The default behavior is to build for Windows. To build for Linux, pass <code>--build=x86_64-unknown-linux-gnu --openjdk-target=x86_64-unknown-linux-gnu<\/code> to <code>configure<\/code>.<\/p>\n@@ -274,1 +276,1 @@\n-<td style=\"text-align: left;\">gcc 10.2.0<\/td>\n+<td style=\"text-align: left;\">gcc 11.2.0<\/td>\n@@ -289,1 +291,1 @@\n-<p>The JDK is currently known to be able to compile with at least version 10.2 of gcc.<\/p>\n+<p>The JDK is currently known to be able to compile with at least version 11.2 of gcc.<\/p>\n@@ -571,1 +573,2 @@\n-<p>You <em>must<\/em> specify the target platform when cross-compiling. Doing so will also automatically turn the build into a cross-compiling mode. The simplest way to do this is to use the <code>--openjdk-target<\/code> argument, e.g. <code>--openjdk-target=arm-linux-gnueabihf<\/code>. or <code>--openjdk-target=aarch64-oe-linux<\/code>. This will automatically set the <code>--build<\/code>, <code>--host<\/code> and <code>--target<\/code> options for autoconf, which can otherwise be confusing. (In autoconf terminology, the &quot;target&quot; is known as &quot;host&quot;, and &quot;target&quot; is used for building a Canadian cross-compiler.)<\/p>\n+<p>You <em>must<\/em> specify the target platform when cross-compiling. Doing so will also automatically turn the build into a cross-compiling mode. The simplest way to do this is to use the <code>--openjdk-target<\/code> argument, e.g. <code>--openjdk-target=arm-linux-gnueabihf<\/code>. or <code>--openjdk-target=aarch64-oe-linux<\/code>. This will automatically set the <code>--host<\/code> and <code>--target<\/code> options for autoconf, which can otherwise be confusing. (In autoconf terminology, the &quot;target&quot; is known as &quot;host&quot;, and &quot;target&quot; is used for building a Canadian cross-compiler.)<\/p>\n+<p>If <code>--build<\/code> has not been explicitly passed to configure, <code>--openjdk-target<\/code> will autodetect the build platform and internally set the flag automatically, otherwise the platform that was explicitly passed to <code>--build<\/code> will be used instead.<\/p>\n@@ -890,22 +893,21 @@\n-<p>Currently, it is not possible to build OpenJDK fully reproducibly, but getting there is an ongoing effort. There are some things you can do to minimize non-determinism and make a larger part of the build reproducible:<\/p>\n-<ul>\n-<li>Turn on build system support for reproducible builds<\/li>\n-<\/ul>\n-<p>Add the flag <code>--enable-reproducible-build<\/code> to your <code>configure<\/code> command line. This will turn on support for reproducible builds where it could otherwise be lacking.<\/p>\n-<ul>\n-<li>Do not rely on <code>configure<\/code>'s default adhoc version strings<\/li>\n-<\/ul>\n-<p>Default adhoc version strings OPT segment include user name, source directory and timestamp. You can either override just the OPT segment using <code>--with-version-opt=&lt;any fixed string&gt;<\/code>, or you can specify the entire version string using <code>--with-version-string=&lt;your version&gt;<\/code>.<\/p>\n-<ul>\n-<li>Specify how the build sets <code>SOURCE_DATE_EPOCH<\/code><\/li>\n-<\/ul>\n-<p>The JDK build system will set the <code>SOURCE_DATE_EPOCH<\/code> environment variable during building, depending on the value of the <code>--with-source-date<\/code> option for <code>configure<\/code>. The default value is <code>updated<\/code>, which means that <code>SOURCE_DATE_EPOCH<\/code> will be set to the current time each time you are running <code>make<\/code>.<\/p>\n-<p>The <a href=\"https:\/\/reproducible-builds.org\/docs\/source-date-epoch\/\"><code>SOURCE_DATE_EPOCH<\/code> environment variable<\/a> is an industry standard, that many tools, such as gcc, recognize, and use in place of the current time when generating output.<\/p>\n-<p>For reproducible builds, you need to set this to a fixed value. You can use the special value <code>version<\/code> which will use the nominal release date for the current JDK version, or a value describing a date, either an epoch based timestamp as an integer, or a valid ISO-8601 date.<\/p>\n-<p><strong>Hint:<\/strong> If your build environment already sets <code>SOURCE_DATE_EPOCH<\/code>, you can propagate this using <code>--with-source-date=$SOURCE_DATE_EPOCH<\/code>.<\/p>\n-<ul>\n-<li>Specify a hotspot build time<\/li>\n-<\/ul>\n-<p>Set a fixed hotspot build time. This will be included in the hotspot library (<code>libjvm.so<\/code> or <code>jvm.dll<\/code>) and defaults to the current time when building hotspot. Use <code>--with-hotspot-build-time=&lt;any fixed string&gt;<\/code> for reproducible builds. It's a string so you don't need to format it specifically, so e.g. <code>n\/a<\/code> will do. Another solution is to use the <code>SOURCE_DATE_EPOCH<\/code> variable, e.g. <code>--with-hotspot-build-time=$(date --date=@$SOURCE_DATE_EPOCH)<\/code>.<\/p>\n-<ul>\n-<li>Copyright year<\/li>\n+<p>Currently, it is not possible to build OpenJDK fully reproducibly, but getting there is an ongoing effort.<\/p>\n+<p>An absolute prerequisite for building reproducible is to speficy a fixed build time, since time stamps are embedded in many file formats. This is done by setting the <code>SOURCE_DATE_EPOCH<\/code> environment variable, which is an <a href=\"https:\/\/reproducible-builds.org\/docs\/source-date-epoch\/\">industry standard<\/a>, that many tools, such as gcc, recognize, and use in place of the current time when generating output.<\/p>\n+<p>To generate reproducible builds, you must set <code>SOURCE_DATE_EPOCH<\/code> before running <code>configure<\/code>. The value in <code>SOURCE_DATE_EPOCH<\/code> will be stored in the configuration, and used by <code>make<\/code>. Setting <code>SOURCE_DATE_EPOCH<\/code> before running <code>make<\/code> will have no effect on the build.<\/p>\n+<p>You must also make sure your build does not rely on <code>configure<\/code>'s default adhoc version strings. Default adhoc version strings <code>OPT<\/code> segment include user name and source directory. You can either override just the <code>OPT<\/code> segment using <code>--with-version-opt=&lt;any fixed string&gt;<\/code>, or you can specify the entire version string using <code>--with-version-string=&lt;your version&gt;<\/code>.<\/p>\n+<p>This is a typical example of how to build the JDK in a reproducible way:<\/p>\n+<pre><code>export SOURCE_DATE_EPOCH=946684800\n+bash configure --with-version-opt=adhoc\n+make<\/code><\/pre>\n+<p>Note that regardless if you specify a source date for <code>configure<\/code> or not, the JDK build system will set <code>SOURCE_DATE_EPOCH<\/code> for all build tools when building. If <code>--with-source-date<\/code> has the value <code>updated<\/code> (which is the default unless <code>SOURCE_DATE_EPOCH<\/code> is found by in the environment by <code>configure<\/code>), the source date value will be determined at build time.<\/p>\n+<p>There are several aspects of reproducible builds that can be individually adjusted by <code>configure<\/code> arguments. If any of these are given, they will override the value derived from <code>SOURCE_DATE_EPOCH<\/code>. These arguments are:<\/p>\n+<ul>\n+<li><p><code>--with-source-date<\/code><\/p>\n+<p>This option controls how the JDK build sets <code>SOURCE_DATE_EPOCH<\/code> when building. It can be set to a value describing a date, either an epoch based timestamp as an integer, or a valid ISO-8601 date.<\/p>\n+<p>It can also be set to one of the special values <code>current<\/code>, <code>updated<\/code> or <code>version<\/code>. <code>current<\/code> means that the time of running <code>configure<\/code> will be used. <code>version<\/code> will use the nominal release date for the current JDK version. <code>updated<\/code>, which means that <code>SOURCE_DATE_EPOCH<\/code> will be set to the current time each time you are running <code>make<\/code>. All choices, except for <code>updated<\/code>, will set a fixed value for the source date timestamp.<\/p>\n+<p>When <code>SOURCE_DATE_EPOCH<\/code> is set, the default value for <code>--with-source-date<\/code> will be the value given by <code>SOURCE_DATE_EPOCH<\/code>. Otherwise, the default value is <code>updated<\/code>.<\/p><\/li>\n+<li><p><code>--with-hotspot-build-time<\/code><\/p>\n+<p>This option controls the build time string that will be included in the hotspot library (<code>libjvm.so<\/code> or <code>jvm.dll<\/code>). When the source date is fixed (e.g. by setting <code>SOURCE_DATE_EPOCH<\/code>), the default value for <code>--with-hotspot-build-time<\/code> will be an ISO 8601 representation of that time stamp. Otherwise the default value will be the current time when building hotspot.<\/p><\/li>\n+<li><p><code>--with-copyright-year<\/code><\/p>\n+<p>This option controls the copyright year in some generated text files. When the source date is fixed (e.g. by setting <code>SOURCE_DATE_EPOCH<\/code>), the default value for <code>--with-copyright-year<\/code> will be the year of that time stamp. Otherwise the default is the current year at the time of running configure. This can be overridden by <code>--with-copyright-year=&lt;year&gt;<\/code>.<\/p><\/li>\n+<li><p><code>--enable-reproducible-build<\/code><\/p>\n+<p>This option controls some additional behavior needed to make the build reproducible. When the source date is fixed (e.g. by setting <code>SOURCE_DATE_EPOCH<\/code>), this flag will be turned on by default. Otherwise, the value is determined by heuristics. If it is explicitly turned off, the build might not be reproducible.<\/p><\/li>\n@@ -913,1 +915,0 @@\n-<p>The copyright year in some generated text files are normally set to the current year. This can be overridden by <code>--with-copyright-year=&lt;year&gt;<\/code>. For fully reproducible builds, this needs to be set to a fixed value.<\/p>\n","filename":"doc\/building.html","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -138,0 +138,8 @@\n+#### Branch Protection\n+\n+In order to use Branch Protection features in the VM, `--enable-branch-protection`\n+must be used. This option requires C++ compiler support (GCC 9.1.0+ or Clang\n+10+). The resulting build can be run on both machines with and without support\n+for branch protection in hardware. Branch Protection is only supported for\n+Linux targets.\n+\n@@ -239,2 +247,2 @@\n-`--build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux-gnu` to\n-`configure`.\n+`--build=x86_64-unknown-linux-gnu --openjdk-target=x86_64-unknown-linux-gnu`\n+to `configure`.\n@@ -324,1 +332,1 @@\n- Linux              gcc 10.2.0\n+ Linux              gcc 11.2.0\n@@ -338,1 +346,1 @@\n-The JDK is currently known to be able to compile with at least version 10.2 of\n+The JDK is currently known to be able to compile with at least version 11.2 of\n@@ -377,3 +385,3 @@\n-For aarch64 machines running Windows the minimum accepted version is Visual Studio 2019 \n-(16.8 or higher). For all other platforms the minimum accepted version of \n-Visual Studio is 2017. Older versions will not be accepted by `configure` and will \n+For aarch64 machines running Windows the minimum accepted version is Visual Studio 2019\n+(16.8 or higher). For all other platforms the minimum accepted version of\n+Visual Studio is 2017. Older versions will not be accepted by `configure` and will\n@@ -981,1 +989,1 @@\n-This will automatically set the `--build`, `--host` and `--target` options for\n+This will automatically set the `--host` and `--target` options for\n@@ -986,0 +994,5 @@\n+If `--build` has not been explicitly passed to configure, `--openjdk-target`\n+will autodetect the build platform and internally set the flag automatically,\n+otherwise the platform that was explicitly passed to `--build` will be used\n+instead.\n+\n@@ -1517,13 +1530,17 @@\n-there is an ongoing effort. There are some things you can do to minimize\n-non-determinism and make a larger part of the build reproducible:\n-\n-  * Turn on build system support for reproducible builds\n-\n-Add the flag `--enable-reproducible-build` to your `configure` command line.\n-This will turn on support for reproducible builds where it could otherwise be\n-lacking.\n-\n-  * Do not rely on `configure`'s default adhoc version strings\n-\n-Default adhoc version strings OPT segment include user name, source directory\n-and timestamp. You can either override just the OPT segment using\n+there is an ongoing effort.\n+\n+An absolute prerequisite for building reproducible is to speficy a fixed build\n+time, since time stamps are embedded in many file formats. This is done by\n+setting the `SOURCE_DATE_EPOCH` environment variable, which is an [industry\n+standard]( https:\/\/reproducible-builds.org\/docs\/source-date-epoch\/), that many\n+tools, such as gcc, recognize, and use in place of the current time when\n+generating output.\n+\n+To generate reproducible builds, you must set `SOURCE_DATE_EPOCH` before running\n+`configure`. The value in `SOURCE_DATE_EPOCH` will be stored in the\n+configuration, and used by `make`. Setting `SOURCE_DATE_EPOCH` before running\n+`make` will have no effect on the build.\n+\n+You must also make sure your build does not rely on `configure`'s default adhoc\n+version strings. Default adhoc version strings `OPT` segment include user name\n+and source directory. You can either override just the `OPT` segment using\n@@ -1533,7 +1550,1 @@\n-  * Specify how the build sets `SOURCE_DATE_EPOCH`\n-\n-The JDK build system will set the `SOURCE_DATE_EPOCH` environment variable\n-during building, depending on the value of the `--with-source-date` option for\n-`configure`. The default value is `updated`, which means that\n-`SOURCE_DATE_EPOCH` will be set to the current time each time you are running\n-`make`.\n+This is a typical example of how to build the JDK in a reproducible way:\n@@ -1541,23 +1552,5 @@\n-The [`SOURCE_DATE_EPOCH` environment variable](\n-https:\/\/reproducible-builds.org\/docs\/source-date-epoch\/) is an industry\n-standard, that many tools, such as gcc, recognize, and use in place of the\n-current time when generating output.\n-\n-For reproducible builds, you need to set this to a fixed value. You can use the\n-special value `version` which will use the nominal release date for the current\n-JDK version, or a value describing a date, either an epoch based timestamp as an\n-integer, or a valid ISO-8601 date.\n-\n-**Hint:** If your build environment already sets `SOURCE_DATE_EPOCH`, you can\n-propagate this using `--with-source-date=$SOURCE_DATE_EPOCH`.\n-\n-  * Specify a hotspot build time\n-\n-Set a fixed hotspot build time. This will be included in the hotspot library\n-(`libjvm.so` or `jvm.dll`) and defaults to the current time when building\n-hotspot. Use `--with-hotspot-build-time=<any fixed string>` for reproducible\n-builds. It's a string so you don't need to format it specifically, so e.g. `n\/a`\n-will do. Another solution is to use the `SOURCE_DATE_EPOCH` variable, e.g.\n-`--with-hotspot-build-time=$(date --date=@$SOURCE_DATE_EPOCH)`.\n-\n-  * Copyright year\n+```\n+export SOURCE_DATE_EPOCH=946684800\n+bash configure --with-version-opt=adhoc\n+make\n+```\n@@ -1565,3 +1558,51 @@\n-The copyright year in some generated text files are normally set to the current\n-year. This can be overridden by `--with-copyright-year=<year>`. For fully\n-reproducible builds, this needs to be set to a fixed value.\n+Note that regardless if you specify a source date for `configure` or not, the\n+JDK build system will set `SOURCE_DATE_EPOCH` for all build tools when building.\n+If `--with-source-date` has the value `updated` (which is the default unless\n+`SOURCE_DATE_EPOCH` is found by in the environment by `configure`), the source\n+date value will be determined at build time.\n+\n+There are several aspects of reproducible builds that can be individually\n+adjusted by `configure` arguments. If any of these are given, they will override\n+the value derived from `SOURCE_DATE_EPOCH`. These arguments are:\n+\n+ * `--with-source-date`\n+\n+    This option controls how the JDK build sets `SOURCE_DATE_EPOCH` when\n+    building. It can be set to a value describing a date, either an epoch based\n+    timestamp as an integer, or a valid ISO-8601 date.\n+\n+    It can also be set to one of the special values `current`, `updated` or\n+    `version`. `current` means that the time of running `configure` will be\n+    used. `version` will use the nominal release date for the current JDK\n+    version. `updated`, which means that `SOURCE_DATE_EPOCH` will be set to the\n+    current time each time you are running `make`. All choices, except for\n+    `updated`, will set a fixed value for the source date timestamp.\n+\n+    When `SOURCE_DATE_EPOCH` is set, the default value for `--with-source-date`\n+    will be the value given by `SOURCE_DATE_EPOCH`. Otherwise, the default value\n+    is `updated`.\n+\n+ * `--with-hotspot-build-time`\n+\n+    This option controls the build time string that will be included in the\n+    hotspot library (`libjvm.so` or `jvm.dll`). When the source date is fixed\n+    (e.g. by setting `SOURCE_DATE_EPOCH`), the default value for\n+    `--with-hotspot-build-time` will be an ISO 8601 representation of that time\n+    stamp. Otherwise the default value will be the current time when building\n+    hotspot.\n+\n+ * `--with-copyright-year`\n+\n+    This option controls the copyright year in some generated text files. When\n+    the source date is fixed (e.g. by setting `SOURCE_DATE_EPOCH`), the default\n+    value for `--with-copyright-year` will be the year of that time stamp.\n+    Otherwise the default is the current year at the time of running configure.\n+    This can be overridden by `--with-copyright-year=<year>`.\n+\n+ * `--enable-reproducible-build`\n+\n+    This option controls some additional behavior needed to make the build\n+    reproducible. When the source date is fixed (e.g. by setting\n+    `SOURCE_DATE_EPOCH`), this flag will be turned on by default. Otherwise, the\n+    value is determined by heuristics. If it is explicitly turned off, the build\n+    might not be reproducible.\n","filename":"doc\/building.md","additions":95,"deletions":54,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-<p>Substantive changes are approved by <a href=\"https:\/\/en.wikipedia.org\/wiki\/Rough_consensus\">rough consensus<\/a> of the <a href=\"https:\/\/openjdk.java.net\/census#hotspot\">HotSpot Group<\/a> Members. The Group Lead determines whether consensus has been reached.<\/p>\n+<p>Substantive changes are approved by <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc7282.html\">rough consensus<\/a> of the <a href=\"https:\/\/openjdk.java.net\/census#hotspot\">HotSpot Group<\/a> Members. The Group Lead determines whether consensus has been reached.<\/p>\n@@ -156,1 +156,1 @@\n-<li><p>Use One-True-Brace-Style. The opening brace for a function or class is normally at the end of the line; it is sometimes moved to the beginning of the next line for emphasis. Substatements are enclosed in braces, even if there is only a single statement. Extremely simple one-line statements may drop braces around a substatement.<\/p><\/li>\n+<li><p>Use <a href=\"https:\/\/en.wikipedia.org\/wiki\/Indentation_style#Variant:_1TBS_(OTBS)\">One-True-Brace-Style<\/a>. The opening brace for a function or class is normally at the end of the line; it is sometimes moved to the beginning of the next line for emphasis. Substatements are enclosed in braces, even if there is only a single statement. Extremely simple one-line statements may drop braces around a substatement.<\/p><\/li>\n@@ -441,1 +441,1 @@\n-<li><p>Avoid namespace-scoped variables with non-constexpr initialization. In particular, avoid variables with types requiring non-trivial initialization or destruction. Initialization order problems can be difficult to deal with and lead to surprises, as can destruction ordering. HotSpot doesn't generally try to cleanup on exit, and running destructors at exit can also lead to problems.<\/p><\/li>\n+<li><p>Avoid non-local variables with non-constexpr initialization. In particular, avoid variables with types requiring non-trivial initialization or destruction. Initialization order problems can be difficult to deal with and lead to surprises, as can destruction ordering. HotSpot doesn't generally try to cleanup on exit, and running destructors at exit can also lead to problems.<\/p><\/li>\n","filename":"doc\/hotspot-style.html","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-[rough consensus](https:\/\/en.wikipedia.org\/wiki\/Rough_consensus) of\n+[rough consensus](https:\/\/www.rfc-editor.org\/rfc\/rfc7282.html) of\n@@ -297,1 +297,3 @@\n-* Use One-True-Brace-Style. The opening brace for a function or class\n+* Use [One-True-Brace-Style](\n+https:\/\/en.wikipedia.org\/wiki\/Indentation_style#Variant:_1TBS_(OTBS)).\n+The opening brace for a function or class\n@@ -1067,1 +1069,1 @@\n-* Avoid namespace-scoped variables with non-constexpr initialization.\n+* Avoid non-local variables with non-constexpr initialization.\n","filename":"doc\/hotspot-style.md","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+REAL_HSDIS_NAME := hsdis-$(OPENJDK_TARGET_CPU_LEGACY_LIB)$(SHARED_LIBRARY_SUFFIX)\n+BUILT_HSDIS_LIB := $(HSDIS_OUTPUT_DIR)\/$(REAL_HSDIS_NAME)\n@@ -43,8 +45,0 @@\n-ifeq ($(call isTargetOs, windows), true)\n-  INSTALLED_HSDIS_DIR := $(JDK_OUTPUTDIR)\/bin\n-  IMAGE_HSDIS_DIR := $(JDK_IMAGE_DIR)\/bin\n-else\n-  INSTALLED_HSDIS_DIR := $(JDK_OUTPUTDIR)\/lib\n-  IMAGE_HSDIS_DIR := $(JDK_IMAGE_DIR)\/lib\n-endif\n-\n@@ -165,1 +159,4 @@\n-build: $(BUILD_HSDIS)\n+$(BUILT_HSDIS_LIB): $(BUILD_HSDIS_TARGET)\n+\t$(install-file)\n+\n+build: $(BUILD_HSDIS) $(BUILT_HSDIS_LIB)\n@@ -169,1 +166,1 @@\n-INSTALLED_HSDIS_NAME := hsdis-$(OPENJDK_TARGET_CPU_LEGACY_LIB)$(SHARED_LIBRARY_SUFFIX)\n+ifeq ($(ENABLE_HSDIS_BUNDLING), false)\n@@ -171,2 +168,7 @@\n-INSTALLED_HSDIS := $(INSTALLED_HSDIS_DIR)\/$(INSTALLED_HSDIS_NAME)\n-INSTALLED_HSDIS_IMAGE := $(IMAGE_HSDIS_DIR)\/$(INSTALLED_HSDIS_NAME)\n+  ifeq ($(call isTargetOs, windows), true)\n+    JDK_HSDIS_DIR := $(JDK_OUTPUTDIR)\/bin\n+    IMAGE_HSDIS_DIR := $(JDK_IMAGE_DIR)\/bin\n+  else\n+    JDK_HSDIS_DIR := $(JDK_OUTPUTDIR)\/lib\n+    IMAGE_HSDIS_DIR := $(JDK_IMAGE_DIR)\/lib\n+  endif\n@@ -174,4 +176,8 @@\n-$(INSTALLED_HSDIS): $(BUILD_HSDIS_TARGET)\n-        ifeq ($(HSDIS_BACKEND), binutils)\n-\t  $(call LogWarn, NOTE: The resulting build might not be redistributable. Seek legal advice before distributing.)\n-        endif\n+\n+  INSTALLED_HSDIS_JDK := $(JDK_HSDIS_DIR)\/$(REAL_HSDIS_NAME)\n+  INSTALLED_HSDIS_IMAGE := $(IMAGE_HSDIS_DIR)\/$(REAL_HSDIS_NAME)\n+\n+  $(INSTALLED_HSDIS_JDK): $(BUILT_HSDIS_LIB)\n+          ifeq ($(HSDIS_BACKEND), binutils)\n+\t    $(call LogWarn, NOTE: The resulting build might not be redistributable. Seek legal advice before distributing.)\n+          endif\n@@ -180,1 +186,1 @@\n-$(INSTALLED_HSDIS_IMAGE): $(INSTALLED_HSDIS)\n+  $(INSTALLED_HSDIS_IMAGE): $(BUILT_HSDIS_LIB)\n@@ -183,1 +189,8 @@\n-install: $(INSTALLED_HSDIS_IMAGE)\n+  install: $(INSTALLED_HSDIS_JDK) $(INSTALLED_HSDIS_IMAGE)\n+\n+else\n+\n+  install:\n+\t$(ECHO) NOTE: make install-hsdis is a no-op with --enable-hsdis-bundling\n+\n+endif\n","filename":"make\/Hsdis.gmk","additions":31,"deletions":18,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -313,11 +313,10 @@\n-      SOURCE_DATE := $$(shell $$(DATE) +\"%s\")\n-    endif\n-    export SOURCE_DATE_EPOCH := $$(SOURCE_DATE)\n-    ifeq ($$(IS_GNU_DATE), yes)\n-      export SOURCE_DATE_ISO_8601 := $$(shell $$(DATE) --utc \\\n-                                                       --date=\"@$$(SOURCE_DATE_EPOCH)\" \\\n-                                                       +\"%Y-%m-%dT%H:%M:%SZ\" 2> \/dev\/null)\n-    else\n-      export SOURCE_DATE_ISO_8601 := $$(shell $$(DATE) -u \\\n-                                                       -j -f \"%s\" \"$$(SOURCE_DATE_EPOCH)\" \\\n-                                                       +\"%Y-%m-%dT%H:%M:%SZ\" 2> \/dev\/null)\n+      # For static values of SOURCE_DATE (not \"updated\"), these are set in spec.gmk\n+      export SOURCE_DATE_EPOCH := $$(shell $$(DATE) +\"%s\")\n+      ifeq ($$(IS_GNU_DATE), yes)\n+        export SOURCE_DATE_ISO_8601 := $$(shell $$(DATE) --utc \\\n+            --date=\"@$$(SOURCE_DATE_EPOCH)\" +\"$$(ISO_8601_FORMAT_STRING)\" \\\n+            2> \/dev\/null)\n+      else\n+        export SOURCE_DATE_ISO_8601 := $$(shell $$(DATE) -u -j -f \"%s\" \\\n+            \"$$(SOURCE_DATE_EPOCH)\" +\"$$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n+      endif\n","filename":"make\/InitSupport.gmk","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -538,0 +538,1 @@\n+      DEPS := jdk-image, \\\n@@ -864,0 +865,4 @@\n+  ifeq ($(ENABLE_HSDIS_BUNDLING), true)\n+    java.base-copy: build-hsdis\n+  endif\n+\n","filename":"make\/Main.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  UTIL_LOOKUP_PROGS(GIT, git)\n@@ -342,1 +343,0 @@\n-  UTIL_LOOKUP_PROGS(GIT, git)\n","filename":"make\/autoconf\/basic_tools.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,0 +188,10 @@\n+\n+  if test \"x$GIT\" != x && test -e $TOPDIR\/.git; then\n+    git_autocrlf=`$GIT config core.autocrlf`\n+    if test \"x$git_autocrlf\" != x && test \"x$git_autocrlf\" != \"xfalse\"; then\n+      AC_MSG_NOTICE([Your git configuration does not set core.autocrlf to false.])\n+      AC_MSG_NOTICE([If you checked out this code using that setting, the build WILL fail.])\n+      AC_MSG_NOTICE([To correct, run \"git config --global core.autocrlf false\" and re-clone the repo.])\n+      AC_MSG_WARN([Code is potentially incorrectly cloned. HIGH RISK of build failure!])\n+    fi\n+  fi\n","filename":"make\/autoconf\/basic_windows.m4","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-      conf_legacy_crosscompile=\"$conf_legacy_crosscompile $conf_option\" ;;\n+      conf_build_set=true ;;\n@@ -279,1 +279,1 @@\n-      conf_legacy_crosscompile=\"$conf_legacy_crosscompile $conf_option\" ;;\n+      conf_incompatible_crosscompile=\"$conf_incompatible_crosscompile $conf_option\" ;;\n@@ -281,1 +281,1 @@\n-      conf_legacy_crosscompile=\"$conf_legacy_crosscompile $conf_option\" ;;\n+      conf_incompatible_crosscompile=\"$conf_incompatible_crosscompile $conf_option\" ;;\n@@ -290,1 +290,1 @@\n-if test \"x$conf_legacy_crosscompile\" != \"x\"; then\n+if test \"x$conf_incompatible_crosscompile\" != \"x\"; then\n@@ -292,4 +292,4 @@\n-    echo \"Error: Specifying --openjdk-target together with autoconf\"\n-    echo \"legacy cross-compilation flags is not supported.\"\n-    echo \"You specified: --openjdk-target=$conf_openjdk_target and $conf_legacy_crosscompile.\"\n-    echo \"The recommended use is just --openjdk-target.\"\n+    echo \"Error: --openjdk-target was specified together with\"\n+    echo \"incompatible autoconf cross-compilation flags.\"\n+    echo \"You specified: --openjdk-target=$conf_openjdk_target and $conf_incompatible_crosscompile.\"\n+    echo \"It is recommended that you only use --openjdk-target.\"\n@@ -298,2 +298,4 @@\n-    echo \"Warning: You are using legacy autoconf cross-compilation flags.\"\n-    echo \"It is recommended that you use --openjdk-target instead.\"\n+    echo \"Warning: You are using misleading autoconf cross-compilation flag(s).\"\n+    echo \"This is not encouraged as use of such flags during building can\"\n+    echo \"quickly become confusing.\"\n+    echo \"It is highly recommended that you use --openjdk-target instead.\"\n@@ -305,2 +307,7 @@\n-  conf_build_platform=`sh $conf_script_dir\/build-aux\/config.guess`\n-  conf_processed_arguments=(\"--build=$conf_build_platform\" \"--host=$conf_openjdk_target\" \"--target=$conf_openjdk_target\" \"${conf_processed_arguments[@]}\")\n+  conf_processed_arguments=(\"--host=$conf_openjdk_target\" \"--target=$conf_openjdk_target\" \"${conf_processed_arguments[@]}\")\n+\n+  # If --build has been explicitly set don't override that flag with our own\n+  if test \"x$conf_build_set\" != xtrue; then\n+    conf_build_platform=`sh $conf_script_dir\/build-aux\/config.guess`\n+    conf_processed_arguments=(\"--build=$conf_build_platform\" \"${conf_processed_arguments[@]}\")\n+  fi\n@@ -344,1 +351,3 @@\n-                          --build=<current platform>\n+                          --build=<current platform>, or the platform you\n+                          have provided if you have explicitly passed\n+                          --build to configure\n","filename":"make\/autoconf\/configure","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,0 +155,1 @@\n+JDKOPT_SETUP_REPRODUCIBLE_BUILD\n@@ -210,1 +211,0 @@\n-JDKOPT_SETUP_REPRODUCIBLE_BUILD\n@@ -252,1 +252,0 @@\n-JDKOPT_SETUP_HSDIS\n","filename":"make\/autoconf\/configure.ac","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -499,2 +499,2 @@\n-    TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -MP\"\n-    TOOLCHAIN_CFLAGS_JDK=\"-nologo -MD -Zc:wchar_t-\"\n+    TOOLCHAIN_CFLAGS_JVM=\"-nologo -MD -Zc:strictStrings -MP\"\n+    TOOLCHAIN_CFLAGS_JDK=\"-nologo -MD -Zc:strictStrings -Zc:wchar_t-\"\n@@ -806,0 +806,2 @@\n+  FLAGS_SETUP_BRANCH_PROTECTION\n+\n@@ -811,1 +813,1 @@\n-      $REPRODUCIBLE_CFLAGS\"\n+      $REPRODUCIBLE_CFLAGS $BRANCH_PROTECTION_CFLAGS\"\n@@ -816,1 +818,1 @@\n-      $FILE_MACRO_CFLAGS $REPRODUCIBLE_CFLAGS\"\n+      $FILE_MACRO_CFLAGS $REPRODUCIBLE_CFLAGS $BRANCH_PROTECTION_CFLAGS\"\n@@ -882,0 +884,21 @@\n+\n+AC_DEFUN_ONCE([FLAGS_SETUP_BRANCH_PROTECTION],\n+[\n+  # Is branch protection available?\n+  BRANCH_PROTECTION_AVAILABLE=false\n+  BRANCH_PROTECTION_FLAG=\"-mbranch-protection=standard\"\n+\n+  if test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+    if test \"x$TOOLCHAIN_TYPE\" = xgcc || test \"x$TOOLCHAIN_TYPE\" = xclang; then\n+      FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [${BRANCH_PROTECTION_FLAG}],\n+          IF_TRUE: [BRANCH_PROTECTION_AVAILABLE=true])\n+    fi\n+  fi\n+\n+  BRANCH_PROTECTION_CFLAGS=\"\"\n+  UTIL_ARG_ENABLE(NAME: branch-protection, DEFAULT: false,\n+      RESULT: USE_BRANCH_PROTECTION, AVAILABLE: $BRANCH_PROTECTION_AVAILABLE,\n+      DESC: [enable branch protection when compiling C\/C++],\n+      IF_ENABLED: [ BRANCH_PROTECTION_CFLAGS=${BRANCH_PROTECTION_FLAG}])\n+  AC_SUBST(BRANCH_PROTECTION_CFLAGS)\n+])\n","filename":"make\/autoconf\/flags-cflags.m4","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-    BASIC_LDFLAGS=\"-b64 -brtl -bnorwexec -bnolibpath -bexpall -bernotok -btextpsize:64K \\\n+    BASIC_LDFLAGS=\"-b64 -brtl -bnorwexec -bnolibpath -bnoexpall -bernotok -btextpsize:64K \\\n@@ -98,7 +98,4 @@\n-  if test \"x$TOOLCHAIN_TYPE\" = xclang || test \"x$TOOLCHAIN_TYPE\" = xgcc; then\n-    if test \"x$OPENJDK_TARGET_OS\" = xmacosx; then\n-      # Assume clang or gcc.\n-      # FIXME: We should really generalize SET_SHARED_LIBRARY_ORIGIN instead.\n-      OS_LDFLAGS_JVM_ONLY=\"-Wl,-rpath,@loader_path\/. -Wl,-rpath,@loader_path\/..\"\n-      OS_LDFLAGS=\"-mmacosx-version-min=$MACOSX_VERSION_MIN\"\n-    fi\n+  if test \"x$OPENJDK_TARGET_OS\" = xmacosx && test \"x$TOOLCHAIN_TYPE\" = xclang; then\n+    # FIXME: We should really generalize SET_SHARED_LIBRARY_ORIGIN instead.\n+    OS_LDFLAGS_JVM_ONLY=\"-Wl,-rpath,@loader_path\/. -Wl,-rpath,@loader_path\/..\"\n+    OS_LDFLAGS=\"-mmacosx-version-min=$MACOSX_VERSION_MIN\"\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -299,0 +299,7 @@\n+  if test \"x$SOURCE_DATE\" != xupdated; then\n+    source_date_info=\"$SOURCE_DATE ($SOURCE_DATE_ISO_8601)\"\n+  else\n+    source_date_info=\"Determined at build time\"\n+  fi\n+  printf \"* Source date:    $source_date_info\\n\"\n+\n","filename":"make\/autoconf\/help.m4","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,0 +117,1 @@\n+\n@@ -118,1 +119,3 @@\n-  [timestamp to use in hotspot version string, empty for on-the-fly @<:@empty@:>@])])\n+  [timestamp to use in hotspot version string, empty means determined at build time @<:@source-date\/empty@:>@])])\n+\n+  AC_MSG_CHECKING([what hotspot build time to use])\n@@ -122,0 +125,10 @@\n+    AC_MSG_RESULT([$HOTSPOT_BUILD_TIME (from --with-hotspot-build-time)])\n+  else\n+    if test \"x$SOURCE_DATE\" = xupdated; then\n+      HOTSPOT_BUILD_TIME=\"\"\n+      AC_MSG_RESULT([determined at build time (default)])\n+    else\n+      # If we have a fixed value for SOURCE_DATE, use it as default\n+      HOTSPOT_BUILD_TIME=\"$SOURCE_DATE_ISO_8601\"\n+      AC_MSG_RESULT([$HOTSPOT_BUILD_TIME (from --with-source-date)])\n+    fi\n@@ -123,0 +136,1 @@\n+\n","filename":"make\/autoconf\/hotspot.m4","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-      [Set copyright year value for build @<:@current year@:>@])])\n+      [Set copyright year value for build @<:@current year\/source-date@:>@])])\n@@ -219,1 +219,1 @@\n-  elif test \"x$SOURCE_DATE_EPOCH\" != x; then\n+  elif test \"x$SOURCE_DATE\" != xupdated; then\n@@ -221,1 +221,1 @@\n-      COPYRIGHT_YEAR=`date --date=@$SOURCE_DATE_EPOCH +%Y`\n+      COPYRIGHT_YEAR=`$DATE --date=@$SOURCE_DATE +%Y`\n@@ -223,1 +223,1 @@\n-      COPYRIGHT_YEAR=`date -j -f %s $SOURCE_DATE_EPOCH +%Y`\n+      COPYRIGHT_YEAR=`$DATE -j -f %s $SOURCE_DATE +%Y`\n@@ -665,1 +665,1 @@\n-      [how to set SOURCE_DATE_EPOCH ('updated', 'current', 'version' a timestamp or an ISO-8601 date) @<:@updated@:>@])],\n+      [how to set SOURCE_DATE_EPOCH ('updated', 'current', 'version' a timestamp or an ISO-8601 date) @<:@updated\/value of SOURCE_DATE_EPOCH@:>@])],\n@@ -668,0 +668,4 @@\n+  if test \"x$SOURCE_DATE_EPOCH\" != x && test \"x$with_source_date\" != x; then\n+    AC_MSG_WARN([--with-source-date will override SOURCE_DATE_EPOCH])\n+  fi\n+\n@@ -672,2 +676,11 @@\n-  elif test \"x$with_source_date\" = xupdated || test \"x$with_source_date\" = x; then\n-    # Tell the makefiles to update at each build\n+  elif test \"x$with_source_date\" = x; then\n+    if test \"x$SOURCE_DATE_EPOCH\" != x; then\n+      SOURCE_DATE=$SOURCE_DATE_EPOCH\n+      with_source_date_present=true\n+      AC_MSG_RESULT([$SOURCE_DATE, from SOURCE_DATE_EPOCH])\n+    else\n+      # Tell the makefiles to update at each build\n+      SOURCE_DATE=updated\n+      AC_MSG_RESULT([determined at build time (default)])\n+    fi\n+  elif test \"x$with_source_date\" = xupdated; then\n@@ -705,0 +718,12 @@\n+  ISO_8601_FORMAT_STRING=\"%Y-%m-%dT%H:%M:%SZ\"\n+  if test \"x$SOURCE_DATE\" != xupdated; then\n+    # If we have a fixed value for SOURCE_DATE, we need to set SOURCE_DATE_EPOCH\n+    # for the rest of configure.\n+    SOURCE_DATE_EPOCH=\"$SOURCE_DATE\"\n+    if test \"x$IS_GNU_DATE\" = xyes; then\n+      SOURCE_DATE_ISO_8601=`$DATE --utc --date=\"@$SOURCE_DATE\" +\"$ISO_8601_FORMAT_STRING\" 2> \/dev\/null`\n+    else\n+      SOURCE_DATE_ISO_8601=`$DATE -u -j -f \"%s\" \"$SOURCE_DATE\" +\"$ISO_8601_FORMAT_STRING\" 2> \/dev\/null`\n+    fi\n+  fi\n+\n@@ -729,266 +754,2 @@\n-])\n-\n-################################################################################\n-#\n-# Helper function to build binutils from source.\n-#\n-AC_DEFUN([JDKOPT_BUILD_BINUTILS],\n-[\n-  BINUTILS_SRC=\"$with_binutils_src\"\n-  UTIL_FIXUP_PATH(BINUTILS_SRC)\n-\n-  if ! test -d $BINUTILS_SRC; then\n-    AC_MSG_ERROR([--with-binutils-src is not pointing to a directory])\n-  fi\n-  if ! test -x $BINUTILS_SRC\/configure; then\n-    AC_MSG_ERROR([--with-binutils-src does not look like a binutils source directory])\n-  fi\n-\n-  if test -e $BINUTILS_SRC\/bfd\/libbfd.a && \\\n-      test -e $BINUTILS_SRC\/opcodes\/libopcodes.a && \\\n-      test -e $BINUTILS_SRC\/libiberty\/libiberty.a && \\\n-      test -e $BINUTILS_SRC\/zlib\/libz.a; then\n-    AC_MSG_NOTICE([Found binutils binaries in binutils source directory -- not building])\n-  else\n-    # On Windows, we cannot build with the normal Microsoft CL, but must instead use\n-    # a separate mingw toolchain.\n-    if test \"x$OPENJDK_BUILD_OS\" = xwindows; then\n-      if test \"x$OPENJDK_TARGET_CPU\" = \"xx86\"; then\n-        target_base=\"i686-w64-mingw32\"\n-      else\n-        target_base=\"$OPENJDK_TARGET_CPU-w64-mingw32\"\n-      fi\n-      binutils_cc=\"$target_base-gcc\"\n-      binutils_target=\"--host=$target_base --target=$target_base\"\n-      # Somehow the uint typedef is not included when building with mingw\n-      binutils_cflags=\"-Duint=unsigned\"\n-      compiler_version=`$binutils_cc --version 2>&1`\n-      if ! [ [[ \"$compiler_version\" =~ GCC ]] ]; then\n-        AC_MSG_NOTICE([Could not find correct mingw compiler $binutils_cc.])\n-        HELP_MSG_MISSING_DEPENDENCY([$binutils_cc])\n-        AC_MSG_ERROR([Cannot continue. $HELP_MSG])\n-      else\n-        AC_MSG_NOTICE([Using compiler $binutils_cc with version $compiler_version])\n-      fi\n-    elif test \"x$OPENJDK_BUILD_OS\" = xmacosx; then\n-      if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n-        binutils_target=\"--enable-targets=aarch64-darwin\"\n-      else\n-        binutils_target=\"\"\n-      fi\n-    else\n-      binutils_cc=\"$CC $SYSROOT_CFLAGS\"\n-      binutils_target=\"\"\n-    fi\n-    binutils_cflags=\"$binutils_cflags $MACHINE_FLAG $JVM_PICFLAG $C_O_FLAG_NORM\"\n-\n-    AC_MSG_NOTICE([Running binutils configure])\n-    AC_MSG_NOTICE([configure command line: .\/configure --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" $binutils_target])\n-    saved_dir=`pwd`\n-    cd \"$BINUTILS_SRC\"\n-    .\/configure --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" $binutils_target\n-    if test $? -ne 0 || ! test -e $BINUTILS_SRC\/Makefile; then\n-      AC_MSG_NOTICE([Automatic building of binutils failed on configure. Try building it manually])\n-      AC_MSG_ERROR([Cannot continue])\n-    fi\n-    AC_MSG_NOTICE([Running binutils make])\n-    $MAKE all-opcodes\n-    if test $? -ne 0; then\n-      AC_MSG_NOTICE([Automatic building of binutils failed on make. Try building it manually])\n-      AC_MSG_ERROR([Cannot continue])\n-    fi\n-    cd $saved_dir\n-    AC_MSG_NOTICE([Building of binutils done])\n-  fi\n-\n-  BINUTILS_DIR=\"$BINUTILS_SRC\"\n-])\n-\n-################################################################################\n-#\n-# Determine if hsdis should be built, and if so, with which backend.\n-#\n-AC_DEFUN_ONCE([JDKOPT_SETUP_HSDIS],\n-[\n-  AC_ARG_WITH([hsdis], [AS_HELP_STRING([--with-hsdis],\n-      [what hsdis backend to use ('none', 'capstone', 'llvm', 'binutils') @<:@none@:>@])])\n-\n-  AC_ARG_WITH(capstone, [AS_HELP_STRING([--with-capstone],\n-      [where to find the Capstone files needed for hsdis\/capstone])])\n-\n-  AC_ARG_WITH([llvm], [AS_HELP_STRING([--with-llvm],\n-      [where to find the LLVM files needed for hsdis\/llvm])])\n-\n-  AC_ARG_WITH([binutils], [AS_HELP_STRING([--with-binutils],\n-      [where to find the binutils files needed for hsdis\/binutils])])\n-\n-  AC_ARG_WITH([binutils-src], [AS_HELP_STRING([--with-binutils-src],\n-      [where to find the binutils source for building])])\n-\n-  AC_MSG_CHECKING([what hsdis backend to use])\n-\n-  if test \"x$with_hsdis\" = xyes; then\n-    AC_MSG_ERROR([--with-hsdis must have a value])\n-  elif test \"x$with_hsdis\" = xnone || test \"x$with_hsdis\" = xno || test \"x$with_hsdis\" = x; then\n-    HSDIS_BACKEND=none\n-    AC_MSG_RESULT(['none', hsdis will not be built])\n-  elif test \"x$with_hsdis\" = xcapstone; then\n-    HSDIS_BACKEND=capstone\n-    AC_MSG_RESULT(['capstone'])\n-\n-    if test \"x$with_capstone\" != x; then\n-      AC_MSG_CHECKING([for capstone])\n-      CAPSTONE=\"$with_capstone\"\n-      AC_MSG_RESULT([$CAPSTONE])\n-\n-      HSDIS_CFLAGS=\"-I${CAPSTONE}\/include\/capstone\"\n-      if test \"x$OPENJDK_TARGET_OS\" != xwindows; then\n-        HSDIS_LDFLAGS=\"-L${CAPSTONE}\/lib\"\n-        HSDIS_LIBS=\"-lcapstone\"\n-      else\n-        HSDIS_LDFLAGS=\"-nodefaultlib:libcmt.lib\"\n-        HSDIS_LIBS=\"${CAPSTONE}\/capstone.lib\"\n-      fi\n-    else\n-      if test \"x$OPENJDK_TARGET_OS\" = xwindows; then\n-        # There is no way to auto-detect capstone on Windowos\n-        AC_MSG_NOTICE([You must specify capstone location using --with-capstone=<path>])\n-        AC_MSG_ERROR([Cannot continue])\n-      fi\n-\n-      PKG_CHECK_MODULES(CAPSTONE, capstone, [CAPSTONE_FOUND=yes], [CAPSTONE_FOUND=no])\n-      if test \"x$CAPSTONE_FOUND\" = xyes; then\n-        HSDIS_CFLAGS=\"$CAPSTONE_CFLAGS\"\n-        HSDIS_LDFLAGS=\"$CAPSTONE_LDFLAGS\"\n-        HSDIS_LIBS=\"$CAPSTONE_LIBS\"\n-      else\n-        HELP_MSG_MISSING_DEPENDENCY([capstone])\n-        AC_MSG_NOTICE([Cannot locate capstone which is needed for hsdis\/capstone. Try using --with-capstone=<path>. $HELP_MSG])\n-        AC_MSG_ERROR([Cannot continue])\n-      fi\n-    fi\n-  elif test \"x$with_hsdis\" = xllvm; then\n-    HSDIS_BACKEND=llvm\n-    AC_MSG_RESULT(['llvm'])\n-\n-    if test \"x$with_llvm\" != x; then\n-      LLVM_DIR=\"$with_llvm\"\n-    fi\n-\n-    if test \"x$OPENJDK_TARGET_OS\" != xwindows; then\n-      if test \"x$LLVM_DIR\" = x; then\n-        # Macs with homebrew can have llvm in different places\n-        UTIL_LOOKUP_PROGS(LLVM_CONFIG, llvm-config, [$PATH:\/usr\/local\/opt\/llvm\/bin:\/opt\/homebrew\/opt\/llvm\/bin])\n-        if test \"x$LLVM_CONFIG\" = x; then\n-          AC_MSG_NOTICE([Cannot locate llvm-config which is needed for hsdis\/llvm. Try using --with-llvm=<LLVM home>.])\n-          AC_MSG_ERROR([Cannot continue])\n-        fi\n-      else\n-        UTIL_LOOKUP_PROGS(LLVM_CONFIG, llvm-config, [$LLVM_DIR\/bin])\n-        if test \"x$LLVM_CONFIG\" = x; then\n-          AC_MSG_NOTICE([Cannot locate llvm-config in $LLVM_DIR. Check your --with-llvm argument.])\n-          AC_MSG_ERROR([Cannot continue])\n-        fi\n-      fi\n-\n-      # We need the LLVM flags and libs, and llvm-config provides them for us.\n-      HSDIS_CFLAGS=`$LLVM_CONFIG --cflags`\n-      HSDIS_LDFLAGS=`$LLVM_CONFIG --ldflags`\n-      HSDIS_LIBS=`$LLVM_CONFIG --libs $OPENJDK_TARGET_CPU_ARCH ${OPENJDK_TARGET_CPU_ARCH}disassembler`\n-    else\n-      if test \"x$LLVM_DIR\" = x; then\n-        AC_MSG_NOTICE([--with-llvm is needed on Windows to point out the LLVM home])\n-        AC_MSG_ERROR([Cannot continue])\n-      fi\n-\n-      # Official Windows installation of LLVM do not ship llvm-config, and self-built llvm-config\n-      # produced unusable output, so just ignore it on Windows.\n-      if ! test -e $LLVM_DIR\/include\/llvm-c\/lto.h; then\n-        AC_MSG_NOTICE([$LLVM_DIR does not seem like a valid LLVM home; include dir is missing])\n-        AC_MSG_ERROR([Cannot continue])\n-      fi\n-      if ! test -e $LLVM_DIR\/include\/llvm-c\/Disassembler.h; then\n-        AC_MSG_NOTICE([$LLVM_DIR does not point to a complete LLVM installation. ])\n-        AC_MSG_NOTICE([The official LLVM distribution is missing crucical files; you need to build LLVM yourself or get all include files elsewhere])\n-        AC_MSG_ERROR([Cannot continue])\n-      fi\n-      if ! test -e $LLVM_DIR\/lib\/llvm-c.lib; then\n-        AC_MSG_NOTICE([$LLVM_DIR does not seem like a valid LLVM home; lib dir is missing])\n-        AC_MSG_ERROR([Cannot continue])\n-      fi\n-      HSDIS_CFLAGS=\"-I$LLVM_DIR\/include\"\n-      HSDIS_LDFLAGS=\"-libpath:$LLVM_DIR\/lib\"\n-      HSDIS_LIBS=\"llvm-c.lib\"\n-    fi\n-  elif test \"x$with_hsdis\" = xbinutils; then\n-    HSDIS_BACKEND=binutils\n-    AC_MSG_RESULT(['binutils'])\n-\n-    # We need the binutils static libs and includes.\n-    if test \"x$with_binutils_src\" != x; then\n-      # Try building the source first. If it succeeds, it sets $BINUTILS_DIR.\n-      JDKOPT_BUILD_BINUTILS\n-    fi\n-\n-    if test \"x$with_binutils\" != x; then\n-      BINUTILS_DIR=\"$with_binutils\"\n-    fi\n-\n-    binutils_system_error=\"\"\n-    HSDIS_LIBS=\"\"\n-    if test \"x$BINUTILS_DIR\" = xsystem; then\n-      AC_CHECK_LIB(bfd, bfd_openr, [ HSDIS_LIBS=\"-lbfd\" ], [ binutils_system_error=\"libbfd not found\" ])\n-      AC_CHECK_LIB(opcodes, disassembler, [ HSDIS_LIBS=\"$HSDIS_LIBS -lopcodes\" ], [ binutils_system_error=\"libopcodes not found\" ])\n-      AC_CHECK_LIB(iberty, xmalloc, [ HSDIS_LIBS=\"$HSDIS_LIBS -liberty\" ], [ binutils_system_error=\"libiberty not found\" ])\n-      AC_CHECK_LIB(z, deflate, [ HSDIS_LIBS=\"$HSDIS_LIBS -lz\" ], [ binutils_system_error=\"libz not found\" ])\n-      HSDIS_CFLAGS=\"-DLIBARCH_$OPENJDK_TARGET_CPU_LEGACY_LIB\"\n-    elif test \"x$BINUTILS_DIR\" != x; then\n-      if test -e $BINUTILS_DIR\/bfd\/libbfd.a && \\\n-          test -e $BINUTILS_DIR\/opcodes\/libopcodes.a && \\\n-          test -e $BINUTILS_DIR\/libiberty\/libiberty.a; then\n-        HSDIS_CFLAGS=\"-I$BINUTILS_DIR\/include -I$BINUTILS_DIR\/bfd -DLIBARCH_$OPENJDK_TARGET_CPU_LEGACY_LIB\"\n-        HSDIS_LDFLAGS=\"\"\n-        HSDIS_LIBS=\"$BINUTILS_DIR\/bfd\/libbfd.a $BINUTILS_DIR\/opcodes\/libopcodes.a $BINUTILS_DIR\/libiberty\/libiberty.a $BINUTILS_DIR\/zlib\/libz.a\"\n-      fi\n-    fi\n-\n-    AC_MSG_CHECKING([for binutils to use with hsdis])\n-    case \"x$BINUTILS_DIR\" in\n-      xsystem)\n-        if test \"x$OPENJDK_TARGET_OS\" != xlinux; then\n-          AC_MSG_RESULT([invalid])\n-          AC_MSG_ERROR([binutils on system is supported for Linux only])\n-        elif test \"x$binutils_system_error\" = x; then\n-          AC_MSG_RESULT([system])\n-          HSDIS_CFLAGS=\"$HSDIS_CFLAGS -DSYSTEM_BINUTILS\"\n-        else\n-          AC_MSG_RESULT([invalid])\n-          AC_MSG_ERROR([$binutils_system_error])\n-        fi\n-        ;;\n-      x)\n-        AC_MSG_RESULT([missing])\n-        AC_MSG_NOTICE([--with-hsdis=binutils requires specifying a binutils installation.])\n-        AC_MSG_NOTICE([Download binutils from https:\/\/www.gnu.org\/software\/binutils and unpack it,])\n-        AC_MSG_NOTICE([and point --with-binutils-src to the resulting directory, or use])\n-        AC_MSG_NOTICE([--with-binutils to point to a pre-built binutils installation.])\n-        AC_MSG_ERROR([Cannot continue])\n-        ;;\n-      *)\n-        if test \"x$HSDIS_LIBS\" != x; then\n-          AC_MSG_RESULT([$BINUTILS_DIR])\n-        else\n-          AC_MSG_RESULT([invalid])\n-          AC_MSG_ERROR([$BINUTILS_DIR does not contain a proper binutils installation])\n-        fi\n-        ;;\n-    esac\n-  else\n-    AC_MSG_RESULT([invalid])\n-    AC_MSG_ERROR([Incorrect hsdis backend \"$with_hsdis\"])\n-  fi\n-\n-  AC_SUBST(HSDIS_BACKEND)\n-  AC_SUBST(HSDIS_CFLAGS)\n-  AC_SUBST(HSDIS_LDFLAGS)\n-  AC_SUBST(HSDIS_LIBS)\n+  AC_SUBST(ISO_8601_FORMAT_STRING)\n+  AC_SUBST(SOURCE_DATE_ISO_8601)\n","filename":"make\/autoconf\/jdk-options.m4","additions":34,"deletions":273,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -75,1 +75,3 @@\n-  if test \"x$with_build_user\" != x; then\n+  if test \"x$with_build_user\" = xyes || test \"x$with_build_user\" = xno; then\n+    AC_MSG_ERROR([--with-build-user must have a value])\n+  elif test \"x$with_build_user\" != x; then\n@@ -87,1 +89,1 @@\n-  if test \"x$with_jdk_rc_name\" = xyes; then\n+  if test \"x$with_jdk_rc_name\" = xyes || test \"x$with_jdk_rc_name\" = xno; then\n@@ -104,1 +106,1 @@\n-  if test \"x$with_vendor_name\" = xyes; then\n+  if test \"x$with_vendor_name\" = xyes || test \"x$with_vendor_name\" = xno; then\n@@ -118,1 +120,1 @@\n-  if test \"x$with_vendor_url\" = xyes; then\n+  if test \"x$with_vendor_url\" = xyes || test \"x$with_vendor_url\" = xno; then\n@@ -132,1 +134,1 @@\n-  if test \"x$with_vendor_bug_url\" = xyes; then\n+  if test \"x$with_vendor_bug_url\" = xyes || test \"x$with_vendor_bug_url\" = xno; then\n@@ -146,1 +148,1 @@\n-  if test \"x$with_vendor_vm_bug_url\" = xyes; then\n+  if test \"x$with_vendor_vm_bug_url\" = xyes || test \"x$with_vendor_vm_bug_url\" = xno; then\n@@ -163,1 +165,1 @@\n-  if test \"x$with_version_string\" = xyes; then\n+  if test \"x$with_version_string\" = xyes || test \"x$with_version_string\" = xno; then\n@@ -296,1 +298,1 @@\n-    if test \"x$with_version_feature\" = xyes; then\n+    if test \"x$with_version_feature\" = xyes || test \"x$with_version_feature\" = xno; then\n@@ -483,1 +485,1 @@\n-  if test \"x$with_version_date\" = xyes; then\n+  if test \"x$with_version_date\" = xyes || test \"x$with_version_date\" = xno; then\n@@ -502,1 +504,4 @@\n-  else\n+  elif test \"x$with_vendor_version_string\" != xno; then\n+    # Set vendor version string if --without is not passed\n+    # Check not required if an empty value is passed, since VENDOR_VERSION_STRING\n+    # would then be set to \"\"\n@@ -510,1 +515,1 @@\n-  if test \"x$with_macosx_bundle_name_base\" = xyes; then\n+  if test \"x$with_macosx_bundle_name_base\" = xyes || test \"x$with_macosx_bundle_name_base\" = xno; then\n@@ -524,1 +529,1 @@\n-  if test \"x$with_macosx_bundle_id_base\" = xyes; then\n+  if test \"x$with_macosx_bundle_id_base\" = xyes || test \"x$with_macosx_bundle_id_base\" = xno; then\n@@ -545,1 +550,1 @@\n-  if test \"x$with_macosx_bundle_build_version\" = xyes; then\n+  if test \"x$with_macosx_bundle_build_version\" = xyes || test \"x$with_macosx_bundle_build_version\" = xno; then\n@@ -552,1 +557,6 @@\n-    MACOSX_BUNDLE_BUILD_VERSION=\"$VERSION_BUILD\"\n+    if test \"x$VERSION_BUILD\" != x; then\n+      MACOSX_BUNDLE_BUILD_VERSION=\"$VERSION_BUILD\"\n+    else\n+      MACOSX_BUNDLE_BUILD_VERSION=0\n+    fi\n+\n","filename":"make\/autoconf\/jdk-version.m4","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,336 @@\n+#\n+# Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+################################################################################\n+#\n+# Helper function to setup hsdis using Capstone\n+#\n+AC_DEFUN([LIB_SETUP_HSDIS_CAPSTONE],\n+[\n+  AC_ARG_WITH(capstone, [AS_HELP_STRING([--with-capstone],\n+      [where to find the Capstone files needed for hsdis\/capstone])])\n+\n+  if test \"x$with_capstone\" != x; then\n+    AC_MSG_CHECKING([for capstone])\n+    CAPSTONE=\"$with_capstone\"\n+    AC_MSG_RESULT([$CAPSTONE])\n+\n+    HSDIS_CFLAGS=\"-I${CAPSTONE}\/include\/capstone\"\n+    if test \"x$OPENJDK_TARGET_OS\" != xwindows; then\n+      HSDIS_LDFLAGS=\"-L${CAPSTONE}\/lib\"\n+      HSDIS_LIBS=\"-lcapstone\"\n+    else\n+      HSDIS_LDFLAGS=\"-nodefaultlib:libcmt.lib\"\n+      HSDIS_LIBS=\"${CAPSTONE}\/capstone.lib\"\n+    fi\n+  else\n+    if test \"x$OPENJDK_TARGET_OS\" = xwindows; then\n+      # There is no way to auto-detect capstone on Windowos\n+      AC_MSG_NOTICE([You must specify capstone location using --with-capstone=<path>])\n+      AC_MSG_ERROR([Cannot continue])\n+    fi\n+\n+    PKG_CHECK_MODULES(CAPSTONE, capstone, [CAPSTONE_FOUND=yes], [CAPSTONE_FOUND=no])\n+    if test \"x$CAPSTONE_FOUND\" = xyes; then\n+      HSDIS_CFLAGS=\"$CAPSTONE_CFLAGS\"\n+      HSDIS_LDFLAGS=\"$CAPSTONE_LDFLAGS\"\n+      HSDIS_LIBS=\"$CAPSTONE_LIBS\"\n+    else\n+      HELP_MSG_MISSING_DEPENDENCY([capstone])\n+      AC_MSG_NOTICE([Cannot locate capstone which is needed for hsdis\/capstone. Try using --with-capstone=<path>. $HELP_MSG])\n+      AC_MSG_ERROR([Cannot continue])\n+    fi\n+  fi\n+])\n+\n+################################################################################\n+#\n+# Helper function to setup hsdis using LLVM\n+#\n+AC_DEFUN([LIB_SETUP_HSDIS_LLVM],\n+[\n+  AC_ARG_WITH([llvm], [AS_HELP_STRING([--with-llvm],\n+      [where to find the LLVM files needed for hsdis\/llvm])])\n+\n+  if test \"x$with_llvm\" != x; then\n+    LLVM_DIR=\"$with_llvm\"\n+  fi\n+\n+  if test \"x$OPENJDK_TARGET_OS\" != xwindows; then\n+    if test \"x$LLVM_DIR\" = x; then\n+      # Macs with homebrew can have llvm in different places\n+      UTIL_LOOKUP_PROGS(LLVM_CONFIG, llvm-config, [$PATH:\/usr\/local\/opt\/llvm\/bin:\/opt\/homebrew\/opt\/llvm\/bin])\n+      if test \"x$LLVM_CONFIG\" = x; then\n+        AC_MSG_NOTICE([Cannot locate llvm-config which is needed for hsdis\/llvm. Try using --with-llvm=<LLVM home>.])\n+        AC_MSG_ERROR([Cannot continue])\n+      fi\n+    else\n+      UTIL_LOOKUP_PROGS(LLVM_CONFIG, llvm-config, [$LLVM_DIR\/bin])\n+      if test \"x$LLVM_CONFIG\" = x; then\n+        AC_MSG_NOTICE([Cannot locate llvm-config in $LLVM_DIR. Check your --with-llvm argument.])\n+        AC_MSG_ERROR([Cannot continue])\n+      fi\n+    fi\n+\n+    # We need the LLVM flags and libs, and llvm-config provides them for us.\n+    HSDIS_CFLAGS=`$LLVM_CONFIG --cflags`\n+    HSDIS_LDFLAGS=`$LLVM_CONFIG --ldflags`\n+    HSDIS_LIBS=`$LLVM_CONFIG --libs $OPENJDK_TARGET_CPU_ARCH ${OPENJDK_TARGET_CPU_ARCH}disassembler`\n+  else\n+    if test \"x$LLVM_DIR\" = x; then\n+      AC_MSG_NOTICE([--with-llvm is needed on Windows to point out the LLVM home])\n+      AC_MSG_ERROR([Cannot continue])\n+    fi\n+\n+    # Official Windows installation of LLVM do not ship llvm-config, and self-built llvm-config\n+    # produced unusable output, so just ignore it on Windows.\n+    if ! test -e $LLVM_DIR\/include\/llvm-c\/lto.h; then\n+      AC_MSG_NOTICE([$LLVM_DIR does not seem like a valid LLVM home; include dir is missing])\n+      AC_MSG_ERROR([Cannot continue])\n+    fi\n+    if ! test -e $LLVM_DIR\/include\/llvm-c\/Disassembler.h; then\n+      AC_MSG_NOTICE([$LLVM_DIR does not point to a complete LLVM installation. ])\n+      AC_MSG_NOTICE([The official LLVM distribution is missing crucical files; you need to build LLVM yourself or get all include files elsewhere])\n+      AC_MSG_ERROR([Cannot continue])\n+    fi\n+    if ! test -e $LLVM_DIR\/lib\/llvm-c.lib; then\n+      AC_MSG_NOTICE([$LLVM_DIR does not seem like a valid LLVM home; lib dir is missing])\n+      AC_MSG_ERROR([Cannot continue])\n+    fi\n+    HSDIS_CFLAGS=\"-I$LLVM_DIR\/include\"\n+    HSDIS_LDFLAGS=\"-libpath:$LLVM_DIR\/lib\"\n+    HSDIS_LIBS=\"llvm-c.lib\"\n+  fi\n+])\n+\n+################################################################################\n+#\n+# Helper function to build binutils from source.\n+#\n+AC_DEFUN([LIB_BUILD_BINUTILS],\n+[\n+  BINUTILS_SRC=\"$with_binutils_src\"\n+  UTIL_FIXUP_PATH(BINUTILS_SRC)\n+\n+  if ! test -d $BINUTILS_SRC; then\n+    AC_MSG_ERROR([--with-binutils-src is not pointing to a directory])\n+  fi\n+  if ! test -x $BINUTILS_SRC\/configure; then\n+    AC_MSG_ERROR([--with-binutils-src does not look like a binutils source directory])\n+  fi\n+\n+  if test -e $BINUTILS_SRC\/bfd\/libbfd.a && \\\n+      test -e $BINUTILS_SRC\/opcodes\/libopcodes.a && \\\n+      test -e $BINUTILS_SRC\/libiberty\/libiberty.a && \\\n+      test -e $BINUTILS_SRC\/zlib\/libz.a; then\n+    AC_MSG_NOTICE([Found binutils binaries in binutils source directory -- not building])\n+  else\n+    # On Windows, we cannot build with the normal Microsoft CL, but must instead use\n+    # a separate mingw toolchain.\n+    if test \"x$OPENJDK_BUILD_OS\" = xwindows; then\n+      if test \"x$OPENJDK_TARGET_CPU\" = \"xx86\"; then\n+        target_base=\"i686-w64-mingw32\"\n+      else\n+        target_base=\"$OPENJDK_TARGET_CPU-w64-mingw32\"\n+      fi\n+      binutils_cc=\"$target_base-gcc\"\n+      binutils_target=\"--host=$target_base --target=$target_base\"\n+      # Somehow the uint typedef is not included when building with mingw\n+      binutils_cflags=\"-Duint=unsigned\"\n+      compiler_version=`$binutils_cc --version 2>&1`\n+      if ! [ [[ \"$compiler_version\" =~ GCC ]] ]; then\n+        AC_MSG_NOTICE([Could not find correct mingw compiler $binutils_cc.])\n+        HELP_MSG_MISSING_DEPENDENCY([$binutils_cc])\n+        AC_MSG_ERROR([Cannot continue. $HELP_MSG])\n+      else\n+        AC_MSG_NOTICE([Using compiler $binutils_cc with version $compiler_version])\n+      fi\n+    elif test \"x$OPENJDK_BUILD_OS\" = xmacosx; then\n+      if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+        binutils_target=\"--enable-targets=aarch64-darwin\"\n+      else\n+        binutils_target=\"\"\n+      fi\n+    else\n+      binutils_cc=\"$CC $SYSROOT_CFLAGS\"\n+      binutils_target=\"\"\n+    fi\n+    binutils_cflags=\"$binutils_cflags $MACHINE_FLAG $JVM_PICFLAG $C_O_FLAG_NORM\"\n+\n+    AC_MSG_NOTICE([Running binutils configure])\n+    AC_MSG_NOTICE([configure command line: .\/configure --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" $binutils_target])\n+    saved_dir=`pwd`\n+    cd \"$BINUTILS_SRC\"\n+    .\/configure --disable-nls CFLAGS=\"$binutils_cflags\" CC=\"$binutils_cc\" $binutils_target\n+    if test $? -ne 0 || ! test -e $BINUTILS_SRC\/Makefile; then\n+      AC_MSG_NOTICE([Automatic building of binutils failed on configure. Try building it manually])\n+      AC_MSG_ERROR([Cannot continue])\n+    fi\n+    AC_MSG_NOTICE([Running binutils make])\n+    $MAKE all-opcodes\n+    if test $? -ne 0; then\n+      AC_MSG_NOTICE([Automatic building of binutils failed on make. Try building it manually])\n+      AC_MSG_ERROR([Cannot continue])\n+    fi\n+    cd $saved_dir\n+    AC_MSG_NOTICE([Building of binutils done])\n+  fi\n+\n+  BINUTILS_DIR=\"$BINUTILS_SRC\"\n+])\n+\n+################################################################################\n+#\n+# Helper function to setup hsdis using binutils\n+#\n+AC_DEFUN([LIB_SETUP_HSDIS_BINUTILS],\n+[\n+  AC_ARG_WITH([binutils], [AS_HELP_STRING([--with-binutils],\n+      [where to find the binutils files needed for hsdis\/binutils])])\n+\n+  AC_ARG_WITH([binutils-src], [AS_HELP_STRING([--with-binutils-src],\n+      [where to find the binutils source for building])])\n+\n+  # We need the binutils static libs and includes.\n+  if test \"x$with_binutils_src\" != x; then\n+    # Try building the source first. If it succeeds, it sets $BINUTILS_DIR.\n+    LIB_BUILD_BINUTILS\n+  fi\n+\n+  if test \"x$with_binutils\" != x; then\n+    BINUTILS_DIR=\"$with_binutils\"\n+  fi\n+\n+  binutils_system_error=\"\"\n+  HSDIS_LIBS=\"\"\n+  if test \"x$BINUTILS_DIR\" = xsystem; then\n+    AC_CHECK_LIB(bfd, bfd_openr, [ HSDIS_LIBS=\"-lbfd\" ], [ binutils_system_error=\"libbfd not found\" ])\n+    AC_CHECK_LIB(opcodes, disassembler, [ HSDIS_LIBS=\"$HSDIS_LIBS -lopcodes\" ], [ binutils_system_error=\"libopcodes not found\" ])\n+    AC_CHECK_LIB(iberty, xmalloc, [ HSDIS_LIBS=\"$HSDIS_LIBS -liberty\" ], [ binutils_system_error=\"libiberty not found\" ])\n+    AC_CHECK_LIB(z, deflate, [ HSDIS_LIBS=\"$HSDIS_LIBS -lz\" ], [ binutils_system_error=\"libz not found\" ])\n+    HSDIS_CFLAGS=\"-DLIBARCH_$OPENJDK_TARGET_CPU_LEGACY_LIB\"\n+  elif test \"x$BINUTILS_DIR\" != x; then\n+    if test -e $BINUTILS_DIR\/bfd\/libbfd.a && \\\n+        test -e $BINUTILS_DIR\/opcodes\/libopcodes.a && \\\n+        test -e $BINUTILS_DIR\/libiberty\/libiberty.a; then\n+      HSDIS_CFLAGS=\"-I$BINUTILS_DIR\/include -I$BINUTILS_DIR\/bfd -DLIBARCH_$OPENJDK_TARGET_CPU_LEGACY_LIB\"\n+      HSDIS_LDFLAGS=\"\"\n+      HSDIS_LIBS=\"$BINUTILS_DIR\/bfd\/libbfd.a $BINUTILS_DIR\/opcodes\/libopcodes.a $BINUTILS_DIR\/libiberty\/libiberty.a $BINUTILS_DIR\/zlib\/libz.a\"\n+    fi\n+  fi\n+\n+  AC_MSG_CHECKING([for binutils to use with hsdis])\n+  case \"x$BINUTILS_DIR\" in\n+    xsystem)\n+      if test \"x$OPENJDK_TARGET_OS\" != xlinux; then\n+        AC_MSG_RESULT([invalid])\n+        AC_MSG_ERROR([binutils on system is supported for Linux only])\n+      elif test \"x$binutils_system_error\" = x; then\n+        AC_MSG_RESULT([system])\n+        HSDIS_CFLAGS=\"$HSDIS_CFLAGS -DSYSTEM_BINUTILS\"\n+      else\n+        AC_MSG_RESULT([invalid])\n+        AC_MSG_ERROR([$binutils_system_error])\n+      fi\n+      ;;\n+    x)\n+      AC_MSG_RESULT([missing])\n+      AC_MSG_NOTICE([--with-hsdis=binutils requires specifying a binutils installation.])\n+      AC_MSG_NOTICE([Download binutils from https:\/\/www.gnu.org\/software\/binutils and unpack it,])\n+      AC_MSG_NOTICE([and point --with-binutils-src to the resulting directory, or use])\n+      AC_MSG_NOTICE([--with-binutils to point to a pre-built binutils installation.])\n+      AC_MSG_ERROR([Cannot continue])\n+      ;;\n+    *)\n+      if test \"x$HSDIS_LIBS\" != x; then\n+        AC_MSG_RESULT([$BINUTILS_DIR])\n+      else\n+        AC_MSG_RESULT([invalid])\n+        AC_MSG_ERROR([$BINUTILS_DIR does not contain a proper binutils installation])\n+      fi\n+      ;;\n+  esac\n+])\n+\n+################################################################################\n+#\n+# Determine if hsdis should be built, and if so, with which backend.\n+#\n+AC_DEFUN_ONCE([LIB_SETUP_HSDIS],\n+[\n+  AC_ARG_WITH([hsdis], [AS_HELP_STRING([--with-hsdis],\n+      [what hsdis backend to use ('none', 'capstone', 'llvm', 'binutils') @<:@none@:>@])])\n+\n+  UTIL_ARG_ENABLE(NAME: hsdis-bundling, DEFAULT: false,\n+    RESULT: ENABLE_HSDIS_BUNDLING,\n+    DESC: [enable bundling of hsdis to allow HotSpot disassembly out-of-the-box])\n+\n+  AC_MSG_CHECKING([what hsdis backend to use])\n+\n+  if test \"x$with_hsdis\" = xyes; then\n+    AC_MSG_ERROR([--with-hsdis must have a value])\n+  elif test \"x$with_hsdis\" = xnone || test \"x$with_hsdis\" = xno || test \"x$with_hsdis\" = x; then\n+    HSDIS_BACKEND=none\n+    AC_MSG_RESULT(['none', hsdis will not be built])\n+  elif test \"x$with_hsdis\" = xcapstone; then\n+    HSDIS_BACKEND=capstone\n+    AC_MSG_RESULT(['capstone'])\n+\n+    LIB_SETUP_HSDIS_CAPSTONE\n+  elif test \"x$with_hsdis\" = xllvm; then\n+    HSDIS_BACKEND=llvm\n+    AC_MSG_RESULT(['llvm'])\n+\n+    LIB_SETUP_HSDIS_LLVM\n+  elif test \"x$with_hsdis\" = xbinutils; then\n+    HSDIS_BACKEND=binutils\n+    AC_MSG_RESULT(['binutils'])\n+\n+    LIB_SETUP_HSDIS_BINUTILS\n+  else\n+    AC_MSG_RESULT([invalid])\n+    AC_MSG_ERROR([Incorrect hsdis backend \"$with_hsdis\"])\n+  fi\n+\n+  AC_SUBST(HSDIS_BACKEND)\n+  AC_SUBST(HSDIS_CFLAGS)\n+  AC_SUBST(HSDIS_LDFLAGS)\n+  AC_SUBST(HSDIS_LIBS)\n+\n+  AC_MSG_CHECKING([if hsdis should be bundled])\n+  if test \"x$ENABLE_HSDIS_BUNDLING\" = \"xtrue\"; then\n+    if test \"x$HSDIS_BACKEND\" = xnone; then\n+      AC_MSG_RESULT([no, backend missing])\n+      AC_MSG_ERROR([hsdis-bundling requires a hsdis backend. Please set --with-hsdis=<backend>]);\n+    fi\n+    AC_MSG_RESULT([yes])\n+    if test \"x$HSDIS_BACKEND\" = xbinutils; then\n+      AC_MSG_WARN([The resulting build might not be redistributable. Seek legal advice before distributing.])\n+    fi\n+  else\n+    AC_MSG_RESULT([no])\n+  fi\n+  AC_SUBST(ENABLE_HSDIS_BUNDLING)\n+])\n","filename":"make\/autoconf\/lib-hsdis.m4","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+m4_include([lib-fontconfig.m4])\n@@ -32,0 +33,1 @@\n+m4_include([lib-hsdis.m4])\n@@ -34,1 +36,1 @@\n-m4_include([lib-fontconfig.m4])\n+\n@@ -96,1 +98,3 @@\n-  LIB_SETUP_X11\n+\n+  LIB_SETUP_ALSA\n+  LIB_SETUP_BUNDLED_LIBS\n@@ -100,1 +104,1 @@\n-  LIB_SETUP_ALSA\n+  LIB_SETUP_HSDIS\n@@ -102,1 +106,0 @@\n-  LIB_SETUP_BUNDLED_LIBS\n@@ -104,0 +107,2 @@\n+  LIB_SETUP_X11\n+\n","filename":"make\/autoconf\/libraries.m4","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -133,0 +133,7 @@\n+ISO_8601_FORMAT_STRING := @ISO_8601_FORMAT_STRING@\n+\n+ifneq ($(SOURCE_DATE), updated)\n+  # For \"updated\" source date value, these are set in InitSupport.gmk\n+  export SOURCE_DATE_EPOCH := $(SOURCE_DATE)\n+  SOURCE_DATE_ISO_8601 := @SOURCE_DATE_ISO_8601@\n+endif\n@@ -363,0 +370,1 @@\n+ENABLE_HSDIS_BUNDLING := @ENABLE_HSDIS_BUNDLING@\n@@ -410,0 +418,1 @@\n+BRANCH_PROTECTION_CFLAGS := @BRANCH_PROTECTION_CFLAGS@\n","filename":"make\/autoconf\/spec.gmk.in","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-VALID_TOOLCHAINS_macosx=\"gcc clang\"\n+VALID_TOOLCHAINS_macosx=\"clang\"\n@@ -904,2 +904,2 @@\n-        UTIL_REQUIRE_PROGS(BUILD_CC, clang cc gcc)\n-        UTIL_REQUIRE_PROGS(BUILD_CXX, clang++ CC g++)\n+        UTIL_REQUIRE_PROGS(BUILD_CC, clang)\n+        UTIL_REQUIRE_PROGS(BUILD_CXX, clang++)\n","filename":"make\/autoconf\/toolchain.m4","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -484,0 +484,1 @@\n+  DLL_HELP=\"$2\"\n@@ -568,1 +569,1 @@\n-    AC_MSG_ERROR([Could not find $DLL_NAME. Please specify using --with-msvcr-dll.])\n+    AC_MSG_ERROR([Could not find $DLL_NAME. Please specify using ${DLL_HELP}.])\n@@ -591,1 +592,1 @@\n-    TOOLCHAIN_SETUP_MSVC_DLL([${MSVCR_NAME}])\n+    TOOLCHAIN_SETUP_MSVC_DLL([${MSVCR_NAME}], [--with-msvcr-dll])\n@@ -614,1 +615,1 @@\n-      TOOLCHAIN_SETUP_MSVC_DLL([${MSVCP_NAME}])\n+      TOOLCHAIN_SETUP_MSVC_DLL([${MSVCP_NAME}], [--with-msvcp-dll])\n@@ -639,1 +640,1 @@\n-      TOOLCHAIN_SETUP_MSVC_DLL([${VCRUNTIME_1_NAME}])\n+      TOOLCHAIN_SETUP_MSVC_DLL([${VCRUNTIME_1_NAME}], [--with-vcruntime-1-dll])\n","filename":"make\/autoconf\/toolchain_microsoft.m4","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,2 +233,0 @@\n-# Sets the specified variable to the resulting list.\n-#\n@@ -244,1 +242,1 @@\n-    timestamp=$($DATE -u -j -f \"%F %T\" \"$2\" \"+%s\" 2> \/dev\/null)\n+    timestamp=$($DATE -u -j -f \"%FZ %TZ\" \"$2\" \"+%s\" 2> \/dev\/null)\n@@ -246,3 +244,3 @@\n-      # Perhaps the time was missing\n-      timestamp=$($DATE -u -j -f \"%F %T\" \"$2 00:00:00\" \"+%s\" 2> \/dev\/null)\n-      # If this did not work, we give up and return the empty string\n+      # BSD date cannot handle trailing milliseconds.\n+      # Try again ignoring characters at end\n+      timestamp=$($DATE -u -j -f \"%Y-%m-%dT%H:%M:%S\" \"$2\" \"+%s\" 2> \/dev\/null)\n","filename":"make\/autoconf\/util.m4","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,1 +196,2 @@\n-        $$($1_JAR_CMD) --update $$($1_JAR_OPTIONS) --file $$@ @$$($1_BIN)\/_the.$$($1_JARNAME)_contents; \\\n+        $(SORT) $$($1_BIN)\/_the.$$($1_JARNAME)_contents > $$($1_BIN)\/_the.$$($1_JARNAME)_contents_sorted && \\\n+        $$($1_JAR_CMD) --update $$($1_JAR_OPTIONS) --file $$@ @$$($1_BIN)\/_the.$$($1_JARNAME)_contents_sorted; \\\n@@ -215,1 +216,3 @@\n-  $1_SUPDATE_CONTENTS=$$($1_JAR_CMD) --update $$($1_JAR_OPTIONS) --file $$@ @$$($1_BIN)\/_the.$$($1_JARNAME)_contents $$(NEWLINE)\n+  $1_SUPDATE_CONTENTS=\\\n+      $(SORT) $$($1_BIN)\/_the.$$($1_JARNAME)_contents > $$($1_BIN)\/_the.$$($1_JARNAME)_contents_sorted && \\\n+      $$($1_JAR_CMD) --update $$($1_JAR_OPTIONS) --file $$@ @$$($1_BIN)\/_the.$$($1_JARNAME)_contents_sorted $$(NEWLINE)\n","filename":"make\/common\/JarArchive.gmk","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-# On AIX\/xlc we need at least xlc 13.1 for the symbol hiding (see JDK-8214063)\n@@ -43,0 +42,2 @@\n+else ifeq ($(TOOLCHAIN_TYPE), xlc)\n+  LAUNCHER_CFLAGS += -qvisibility=hidden\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-# On AIX\/xlc we need at least xlc 13.1 for the symbol hiding (see JDK-8214063)\n@@ -50,0 +49,4 @@\n+else ifeq ($(TOOLCHAIN_TYPE), xlc)\n+  CFLAGS_JDKLIB += -qvisibility=hidden\n+  CXXFLAGS_JDKLIB += -qvisibility=hidden\n+  EXPORT_ALL_SYMBOLS := -qvisibility=default\n","filename":"make\/common\/modules\/LibCommon.gmk","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,1 +261,0 @@\n-            \"--with-source-date=current\",\n@@ -1056,1 +1055,1 @@\n-        linux_x64: \"gcc10.3.0-OL6.4+1.0\",\n+        linux_x64: \"gcc11.2.0-OL6.4+1.0\",\n@@ -1059,1 +1058,1 @@\n-        linux_aarch64: \"gcc10.3.0-OL7.6+1.0\",\n+        linux_aarch64: \"gcc11.2.0-OL7.6+1.0\",\n@@ -1450,0 +1449,8 @@\n+    var sourceDate\n+    if (input.build_id_data && input.build_id_data.creationTime) {\n+        sourceDate = Math.floor(Date.parse(input.build_id_data.creationTime)\/1000);\n+    } else {\n+        sourceDate = \"current\";\n+    }\n+    args = concat(args, \"--with-source-date=\" + sourceDate);\n+\n","filename":"make\/conf\/jib-profiles.js","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -90,2 +90,11 @@\n-GCC_VER := 10.3.0\n-ifeq ($(GCC_VER), 10.3.0)\n+GCC_VER := 11.2.0\n+ifeq ($(GCC_VER), 11.2.0)\n+  gcc_ver := gcc-11.2.0\n+  binutils_ver := binutils-2.37\n+  ccache_ver := ccache-3.7.12\n+  mpfr_ver := mpfr-4.1.0\n+  gmp_ver := gmp-6.2.1\n+  mpc_ver := mpc-1.2.1\n+  gdb_ver := gdb-11.1\n+  REQUIRED_MIN_MAKE_MAJOR_VERSION := 4\n+else ifeq ($(GCC_VER), 10.3.0)\n","filename":"make\/devkit\/Tools.gmk","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    DISABLED_WARNINGS_gcc := undef unused-result format-nonliteral, \\\n+    DISABLED_WARNINGS_gcc := undef unused-result format-nonliteral maybe-uninitialized, \\\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-                    String name = names[scripts[j][2]].toUpperCase(Locale.ENGLISH);;\n+                    String name = names[scripts[j][2]].toUpperCase(Locale.ENGLISH);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecharacter\/CharacterScript.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-                super.visitClassDef(tree);;\n+                super.visitClassDef(tree);\n","filename":"make\/langtools\/tools\/genstubs\/GenStubs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -249,0 +249,17 @@\n+################################################################################\n+# Optionally copy hsdis into the the image\n+\n+ifeq ($(ENABLE_HSDIS_BUNDLING), true)\n+  HSDIS_NAME := hsdis-$(OPENJDK_TARGET_CPU_LEGACY_LIB)$(SHARED_LIBRARY_SUFFIX)\n+  HSDIS_PATH := $(SUPPORT_OUTPUTDIR)\/hsdis\/$(HSDIS_NAME)\n+\n+  $(eval $(call SetupCopyFiles, COPY_HSDIS, \\\n+      FILES := $(HSDIS_PATH), \\\n+      DEST := $(call FindLibDirForModule, $(MODULE)), \\\n+      FLATTEN := true, \\\n+      MACRO := install-file-nolink, \\\n+  ))\n+\n+  TARGETS += $(COPY_HSDIS)\n+endif\n+\n","filename":"make\/modules\/java.base\/Copy.gmk","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,1 +327,1 @@\n-        ! -name \"*.tar.gz\" ! -name \"*.jsa\" ! -name \"gtestLauncher\" \\\n+        ! -name \"*.tar.gz\" ! -name \"classes_nocoops.jsa\" ! -name \"gtestLauncher\" \\\n","filename":"make\/scripts\/compare.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerResourceBundle := jvm.lib\n@@ -87,0 +88,1 @@\n+  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerResourceBundle := -ljvm\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1314,0 +1314,3 @@\n+  \/\/ Assert that the given node is not a variable shift.\n+  bool assert_not_var_shift(const Node* n);\n+\n@@ -1728,0 +1731,6 @@\n+\/\/ Assert that the given node is not a variable shift.\n+bool assert_not_var_shift(const Node* n) {\n+  assert(!n->as_ShiftV()->is_var_shift(), \"illegal variable shift\");\n+  return true;\n+}\n+\n@@ -1856,0 +1865,4 @@\n+  if (VM_Version::use_rop_protection()) {\n+    st->print(\"ldr zr, [lr]\\n\\t\");\n+    st->print(\"pacia  lr, rfp\\n\\t\");\n+  }\n@@ -1964,0 +1977,4 @@\n+  if (VM_Version::use_rop_protection()) {\n+    st->print(\"autia lr, rfp\\n\\t\");\n+    st->print(\"ldr zr, [lr]\\n\\t\");\n+  }\n@@ -17068,1 +17085,1 @@\n-instruct has_negatives(iRegP_R1 ary1, iRegI_R2 len, iRegI_R0 result, rFlagsReg cr)\n+instruct count_positives(iRegP_R1 ary1, iRegI_R2 len, iRegI_R0 result, rFlagsReg cr)\n@@ -17070,1 +17087,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -17072,1 +17089,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result\" %}\n+  format %{ \"count positives byte[] $ary1,$len -> $result\" %}\n@@ -17074,1 +17091,1 @@\n-    address tpc = __ has_negatives($ary1$$Register, $len$$Register, $result$$Register);\n+    address tpc = __ count_positives($ary1$$Register, $len$$Register, $result$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -4403,1 +4403,7 @@\n-instruct vshiftcnt8B(vecD dst, iRegIorL2I cnt) %{\n+\/\/ Vector shift count\n+\/\/ Note-1: Low 8 bits of each element are used, so it doesn't matter if we\n+\/\/         treat it as ints or bytes here.\n+\/\/ Note-2: Shift value is negated for RShiftCntV additionally. See the comments\n+\/\/         on vsra8B rule for more details.\n+\n+instruct vslcnt8B(vecD dst, iRegIorL2I cnt) %{\n@@ -4405,1 +4411,1 @@\n-            n->as_Vector()->length_in_bytes() == 8));\n+                            n->as_Vector()->length_in_bytes() == 8));\n@@ -4407,1 +4413,1 @@\n-  match(Set dst (RShiftCntV cnt));\n+  ins_cost(INSN_COST);\n@@ -4415,2 +4421,2 @@\n-instruct vshiftcnt16B(vecX dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && (n->as_Vector()->length_in_bytes() == 16));\n+instruct vslcnt16B(vecX dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE == 0 && n->as_Vector()->length_in_bytes() == 16);\n@@ -4418,1 +4424,1 @@\n-  match(Set dst (RShiftCntV cnt));\n+  ins_cost(INSN_COST);\n@@ -4426,0 +4432,27 @@\n+instruct vsrcnt8B(vecD dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE == 0 && (n->as_Vector()->length_in_bytes() == 4 ||\n+                            n->as_Vector()->length_in_bytes() == 8));\n+  match(Set dst (RShiftCntV cnt));\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"negw  rscratch1, $cnt\\t\"\n+            \"dup   $dst, rscratch1\\t# shift count vector (8B)\" %}\n+  ins_encode %{\n+    __ negw(rscratch1, as_Register($cnt$$reg));\n+    __ dup(as_FloatRegister($dst$$reg), __ T8B, rscratch1);\n+  %}\n+  ins_pipe(vdup_reg_reg64);\n+%}\n+\n+instruct vsrcnt16B(vecX dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE == 0 && n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (RShiftCntV cnt));\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"negw  rscratch1, $cnt\\t\"\n+            \"dup   $dst, rscratch1\\t# shift count vector (16B)\" %}\n+  ins_encode %{\n+    __ negw(rscratch1, as_Register($cnt$$reg));\n+    __ dup(as_FloatRegister($dst$$reg), __ T16B, rscratch1);\n+  %}\n+  ins_pipe(vdup_reg_reg128);\n+%}\n+\n@@ -4427,2 +4460,1 @@\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n+  predicate(n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8);\n@@ -4462,2 +4494,0 @@\n-\/\/ Note: In inner loop, multiple neg instructions are used, which can be\n-\/\/ moved to outer loop and merge into one neg instruction.\n@@ -4473,0 +4503,8 @@\n+\/\/ The negate is conducted in RShiftCntV rule for case 1, whereas it's done in\n+\/\/ RShiftV* rules for case 2. Because there exists an optimization opportunity\n+\/\/ for case 1, that is, multiple neg instructions in inner loop can be hoisted\n+\/\/ to outer loop and merged into one neg instruction.\n+\/\/\n+\/\/ Note that ShiftVNode::is_var_shift() indicates whether the vector shift\n+\/\/ count is a variable vector(case 2) or not(a vector generated by RShiftCntV,\n+\/\/ i.e. case 1).\n@@ -4474,3 +4512,3 @@\n-instruct vsra8B(vecD dst, vecD src, vecD shift, vecD tmp) %{\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n+instruct vsra8B(vecD dst, vecD src, vecD shift) %{\n+  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n+            !n->as_ShiftV()->is_var_shift());\n@@ -4479,3 +4517,17 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"sshl  $dst,$src,$tmp\\t# vector (8B)\" %}\n+  format %{ \"sshl  $dst,$src,$shift\\t# vector (8B)\" %}\n+  ins_encode %{\n+    __ sshl(as_FloatRegister($dst$$reg), __ T8B,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift64);\n+%}\n+\n+instruct vsra8B_var(vecD dst, vecD src, vecD shift) %{\n+  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n+            n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVB src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"sshl  $dst,$src,$dst\\t# vector (8B)\" %}\n@@ -4483,1 +4535,1 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T8B,\n+    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n@@ -4487,1 +4539,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4492,2 +4544,2 @@\n-instruct vsra16B(vecX dst, vecX src, vecX shift, vecX tmp) %{\n-  predicate(n->as_Vector()->length() == 16);\n+instruct vsra16B(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 16 && !n->as_ShiftV()->is_var_shift());\n@@ -4496,3 +4548,1 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"sshl  $dst,$src,$tmp\\t# vector (16B)\" %}\n+  format %{ \"sshl  $dst,$src,$shift\\t# vector (16B)\" %}\n@@ -4500,1 +4550,16 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T16B,\n+    __ sshl(as_FloatRegister($dst$$reg), __ T16B,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift128);\n+%}\n+\n+instruct vsra16B_var(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 16 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVB src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"sshl  $dst,$src,$dst\\t# vector (16B)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n@@ -4504,1 +4569,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4509,3 +4574,3 @@\n-instruct vsrl8B(vecD dst, vecD src, vecD shift, vecD tmp) %{\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n+instruct vsrl8B(vecD dst, vecD src, vecD shift) %{\n+  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n+            !n->as_ShiftV()->is_var_shift());\n@@ -4514,3 +4579,17 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"ushl  $dst,$src,$tmp\\t# vector (8B)\" %}\n+  format %{ \"ushl  $dst,$src,$shift\\t# vector (8B)\" %}\n+  ins_encode %{\n+    __ ushl(as_FloatRegister($dst$$reg), __ T8B,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift64);\n+%}\n+\n+instruct vsrl8B_var(vecD dst, vecD src, vecD shift) %{\n+  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n+            n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVB src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"ushl  $dst,$src,$dst\\t# vector (8B)\" %}\n@@ -4518,1 +4597,1 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T8B,\n+    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n@@ -4522,1 +4601,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4527,2 +4606,2 @@\n-instruct vsrl16B(vecX dst, vecX src, vecX shift, vecX tmp) %{\n-  predicate(n->as_Vector()->length() == 16);\n+instruct vsrl16B(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 16 && !n->as_ShiftV()->is_var_shift());\n@@ -4531,3 +4610,1 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"ushl  $dst,$src,$tmp\\t# vector (16B)\" %}\n+  format %{ \"ushl  $dst,$src,$shift\\t# vector (16B)\" %}\n@@ -4535,1 +4612,16 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T16B,\n+    __ ushl(as_FloatRegister($dst$$reg), __ T16B,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift128);\n+%}\n+\n+instruct vsrl16B_var(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 16 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVB src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"ushl  $dst,$src,$dst\\t# vector (16B)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n@@ -4539,1 +4631,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4545,2 +4637,2 @@\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n+  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n+            assert_not_var_shift(n));\n@@ -4549,1 +4641,1 @@\n-  format %{ \"shl    $dst, $src, $shift\\t# vector (8B)\" %}\n+  format %{ \"shl  $dst, $src, $shift\\t# vector (8B)\" %}\n@@ -4565,1 +4657,1 @@\n-  predicate(n->as_Vector()->length() == 16);\n+  predicate(n->as_Vector()->length() == 16 && assert_not_var_shift(n));\n@@ -4568,1 +4660,1 @@\n-  format %{ \"shl    $dst, $src, $shift\\t# vector (16B)\" %}\n+  format %{ \"shl  $dst, $src, $shift\\t# vector (16B)\" %}\n@@ -4584,2 +4676,2 @@\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n+  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n+            assert_not_var_shift(n));\n@@ -4588,1 +4680,1 @@\n-  format %{ \"sshr    $dst, $src, $shift\\t# vector (8B)\" %}\n+  format %{ \"sshr  $dst, $src, $shift\\t# vector (8B)\" %}\n@@ -4593,1 +4685,1 @@\n-           as_FloatRegister($src$$reg), sh);\n+            as_FloatRegister($src$$reg), sh);\n@@ -4599,1 +4691,1 @@\n-  predicate(n->as_Vector()->length() == 16);\n+  predicate(n->as_Vector()->length() == 16 && assert_not_var_shift(n));\n@@ -4602,1 +4694,1 @@\n-  format %{ \"sshr    $dst, $src, $shift\\t# vector (16B)\" %}\n+  format %{ \"sshr  $dst, $src, $shift\\t# vector (16B)\" %}\n@@ -4607,1 +4699,1 @@\n-           as_FloatRegister($src$$reg), sh);\n+            as_FloatRegister($src$$reg), sh);\n@@ -4613,2 +4705,2 @@\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n+  predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&\n+            assert_not_var_shift(n));\n@@ -4617,1 +4709,1 @@\n-  format %{ \"ushr    $dst, $src, $shift\\t# vector (8B)\" %}\n+  format %{ \"ushr  $dst, $src, $shift\\t# vector (8B)\" %}\n@@ -4626,1 +4718,1 @@\n-             as_FloatRegister($src$$reg), sh);\n+              as_FloatRegister($src$$reg), sh);\n@@ -4633,1 +4725,1 @@\n-  predicate(n->as_Vector()->length() == 16);\n+  predicate(n->as_Vector()->length() == 16 && assert_not_var_shift(n));\n@@ -4636,1 +4728,1 @@\n-  format %{ \"ushr    $dst, $src, $shift\\t# vector (16B)\" %}\n+  format %{ \"ushr  $dst, $src, $shift\\t# vector (16B)\" %}\n@@ -4645,1 +4737,1 @@\n-             as_FloatRegister($src$$reg), sh);\n+              as_FloatRegister($src$$reg), sh);\n@@ -4652,2 +4744,1 @@\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n+  predicate(n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4);\n@@ -4678,3 +4769,3 @@\n-instruct vsra4S(vecD dst, vecD src, vecD shift, vecD tmp) %{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n+instruct vsra4S(vecD dst, vecD src, vecD shift) %{\n+  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n+            !n->as_ShiftV()->is_var_shift());\n@@ -4683,3 +4774,1 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"sshl  $dst,$src,$tmp\\t# vector (4H)\" %}\n+  format %{ \"sshl  $dst,$src,$shift\\t# vector (4H)\" %}\n@@ -4687,1 +4776,17 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T8B,\n+    __ sshl(as_FloatRegister($dst$$reg), __ T4H,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift64);\n+%}\n+\n+instruct vsra4S_var(vecD dst, vecD src, vecD shift) %{\n+  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n+            n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVS src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"sshl  $dst,$src,$dst\\t# vector (4H)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n@@ -4691,1 +4796,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4696,2 +4801,2 @@\n-instruct vsra8S(vecX dst, vecX src, vecX shift, vecX tmp) %{\n-  predicate(n->as_Vector()->length() == 8);\n+instruct vsra8S(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 8 && !n->as_ShiftV()->is_var_shift());\n@@ -4700,3 +4805,16 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"sshl  $dst,$src,$tmp\\t# vector (8H)\" %}\n+  format %{ \"sshl  $dst,$src,$shift\\t# vector (8H)\" %}\n+  ins_encode %{\n+    __ sshl(as_FloatRegister($dst$$reg), __ T8H,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift128);\n+%}\n+\n+instruct vsra8S_var(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 8 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVS src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"sshl  $dst,$src,$dst\\t# vector (8H)\" %}\n@@ -4704,1 +4822,1 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T16B,\n+    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n@@ -4708,1 +4826,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4713,3 +4831,3 @@\n-instruct vsrl4S(vecD dst, vecD src, vecD shift, vecD tmp) %{\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n+instruct vsrl4S(vecD dst, vecD src, vecD shift) %{\n+  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n+            !n->as_ShiftV()->is_var_shift());\n@@ -4718,3 +4836,1 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"ushl  $dst,$src,$tmp\\t# vector (4H)\" %}\n+  format %{ \"ushl  $dst,$src,$shift\\t# vector (4H)\" %}\n@@ -4722,1 +4838,17 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T8B,\n+    __ ushl(as_FloatRegister($dst$$reg), __ T4H,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift64);\n+%}\n+\n+instruct vsrl4S_var(vecD dst, vecD src, vecD shift) %{\n+  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n+            n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVS src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"ushl  $dst,$src,$dst\\t# vector (4H)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n@@ -4726,1 +4858,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4731,2 +4863,2 @@\n-instruct vsrl8S(vecX dst, vecX src, vecX shift, vecX tmp) %{\n-  predicate(n->as_Vector()->length() == 8);\n+instruct vsrl8S(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 8 && !n->as_ShiftV()->is_var_shift());\n@@ -4735,3 +4867,1 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"ushl  $dst,$src,$tmp\\t# vector (8H)\" %}\n+  format %{ \"ushl  $dst,$src,$shift\\t# vector (8H)\" %}\n@@ -4739,1 +4869,16 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T16B,\n+    __ ushl(as_FloatRegister($dst$$reg), __ T8H,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift128);\n+%}\n+\n+instruct vsrl8S_var(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 8 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVS src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"ushl  $dst,$src,$dst\\t# vector (8H)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n@@ -4743,1 +4888,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4749,2 +4894,2 @@\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n+  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n+            assert_not_var_shift(n));\n@@ -4753,1 +4898,1 @@\n-  format %{ \"shl    $dst, $src, $shift\\t# vector (4H)\" %}\n+  format %{ \"shl  $dst, $src, $shift\\t# vector (4H)\" %}\n@@ -4769,1 +4914,1 @@\n-  predicate(n->as_Vector()->length() == 8);\n+  predicate(n->as_Vector()->length() == 8 && assert_not_var_shift(n));\n@@ -4772,1 +4917,1 @@\n-  format %{ \"shl    $dst, $src, $shift\\t# vector (8H)\" %}\n+  format %{ \"shl  $dst, $src, $shift\\t# vector (8H)\" %}\n@@ -4788,2 +4933,2 @@\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n+  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n+            assert_not_var_shift(n));\n@@ -4792,1 +4937,1 @@\n-  format %{ \"sshr    $dst, $src, $shift\\t# vector (4H)\" %}\n+  format %{ \"sshr  $dst, $src, $shift\\t# vector (4H)\" %}\n@@ -4797,1 +4942,1 @@\n-           as_FloatRegister($src$$reg), sh);\n+            as_FloatRegister($src$$reg), sh);\n@@ -4803,1 +4948,1 @@\n-  predicate(n->as_Vector()->length() == 8);\n+  predicate(n->as_Vector()->length() == 8 && assert_not_var_shift(n));\n@@ -4806,1 +4951,1 @@\n-  format %{ \"sshr    $dst, $src, $shift\\t# vector (8H)\" %}\n+  format %{ \"sshr  $dst, $src, $shift\\t# vector (8H)\" %}\n@@ -4811,1 +4956,1 @@\n-           as_FloatRegister($src$$reg), sh);\n+            as_FloatRegister($src$$reg), sh);\n@@ -4817,2 +4962,2 @@\n-  predicate(n->as_Vector()->length() == 2 ||\n-            n->as_Vector()->length() == 4);\n+  predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&\n+            assert_not_var_shift(n));\n@@ -4821,1 +4966,1 @@\n-  format %{ \"ushr    $dst, $src, $shift\\t# vector (4H)\" %}\n+  format %{ \"ushr  $dst, $src, $shift\\t# vector (4H)\" %}\n@@ -4830,1 +4975,1 @@\n-             as_FloatRegister($src$$reg), sh);\n+              as_FloatRegister($src$$reg), sh);\n@@ -4837,1 +4982,1 @@\n-  predicate(n->as_Vector()->length() == 8);\n+  predicate(n->as_Vector()->length() == 8 && assert_not_var_shift(n));\n@@ -4840,1 +4985,1 @@\n-  format %{ \"ushr    $dst, $src, $shift\\t# vector (8H)\" %}\n+  format %{ \"ushr  $dst, $src, $shift\\t# vector (8H)\" %}\n@@ -4849,1 +4994,1 @@\n-             as_FloatRegister($src$$reg), sh);\n+              as_FloatRegister($src$$reg), sh);\n@@ -4881,2 +5026,2 @@\n-instruct vsra2I(vecD dst, vecD src, vecD shift, vecD tmp) %{\n-  predicate(n->as_Vector()->length() == 2);\n+instruct vsra2I(vecD dst, vecD src, vecD shift) %{\n+  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n@@ -4885,3 +5030,1 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"sshl  $dst,$src,$tmp\\t# vector (2S)\" %}\n+  format %{ \"sshl  $dst,$src,$shift\\t# vector (2S)\" %}\n@@ -4889,1 +5032,16 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T8B,\n+    __ sshl(as_FloatRegister($dst$$reg), __ T2S,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift64);\n+%}\n+\n+instruct vsra2I_var(vecD dst, vecD src, vecD shift) %{\n+  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVI src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"sshl  $dst,$src,$dst\\t# vector (2S)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n@@ -4893,1 +5051,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4898,2 +5056,2 @@\n-instruct vsra4I(vecX dst, vecX src, vecX shift, vecX tmp) %{\n-  predicate(n->as_Vector()->length() == 4);\n+instruct vsra4I(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 4 && !n->as_ShiftV()->is_var_shift());\n@@ -4902,3 +5060,16 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"sshl  $dst,$src,$tmp\\t# vector (4S)\" %}\n+  format %{ \"sshl  $dst,$src,$shift\\t# vector (4S)\" %}\n+  ins_encode %{\n+    __ sshl(as_FloatRegister($dst$$reg), __ T4S,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift128);\n+%}\n+\n+instruct vsra4I_var(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 4 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVI src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"sshl  $dst,$src,$dst\\t# vector (4S)\" %}\n@@ -4906,1 +5077,1 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T16B,\n+    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n@@ -4910,1 +5081,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4915,2 +5086,2 @@\n-instruct vsrl2I(vecD dst, vecD src, vecD shift, vecD tmp) %{\n-  predicate(n->as_Vector()->length() == 2);\n+instruct vsrl2I(vecD dst, vecD src, vecD shift) %{\n+  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n@@ -4919,3 +5090,1 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"ushl  $dst,$src,$tmp\\t# vector (2S)\" %}\n+  format %{ \"ushl  $dst,$src,$shift\\t# vector (2S)\" %}\n@@ -4923,1 +5092,16 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T8B,\n+    __ ushl(as_FloatRegister($dst$$reg), __ T2S,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift64);\n+%}\n+\n+instruct vsrl2I_var(vecD dst, vecD src, vecD shift) %{\n+  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVI src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"ushl  $dst,$src,$dst\\t# vector (2S)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T8B,\n@@ -4927,1 +5111,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4932,2 +5116,2 @@\n-instruct vsrl4I(vecX dst, vecX src, vecX shift, vecX tmp) %{\n-  predicate(n->as_Vector()->length() == 4);\n+instruct vsrl4I(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 4 && !n->as_ShiftV()->is_var_shift());\n@@ -4936,3 +5120,1 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"ushl  $dst,$src,$tmp\\t# vector (4S)\" %}\n+  format %{ \"ushl  $dst,$src,$shift\\t# vector (4S)\" %}\n@@ -4940,1 +5122,16 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T16B,\n+    __ ushl(as_FloatRegister($dst$$reg), __ T4S,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift128);\n+%}\n+\n+instruct vsrl4I_var(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 4 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVI src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"ushl  $dst,$src,$dst\\t# vector (4S)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n@@ -4944,1 +5141,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -4950,1 +5147,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n@@ -4953,1 +5150,1 @@\n-  format %{ \"shl    $dst, $src, $shift\\t# vector (2S)\" %}\n+  format %{ \"shl  $dst, $src, $shift\\t# vector (2S)\" %}\n@@ -4963,1 +5160,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(n->as_Vector()->length() == 4 && assert_not_var_shift(n));\n@@ -4966,1 +5163,1 @@\n-  format %{ \"shl    $dst, $src, $shift\\t# vector (4S)\" %}\n+  format %{ \"shl  $dst, $src, $shift\\t# vector (4S)\" %}\n@@ -4976,1 +5173,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n@@ -4979,1 +5176,1 @@\n-  format %{ \"sshr    $dst, $src, $shift\\t# vector (2S)\" %}\n+  format %{ \"sshr  $dst, $src, $shift\\t# vector (2S)\" %}\n@@ -4989,1 +5186,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(n->as_Vector()->length() == 4 && assert_not_var_shift(n));\n@@ -4992,1 +5189,1 @@\n-  format %{ \"sshr    $dst, $src, $shift\\t# vector (4S)\" %}\n+  format %{ \"sshr  $dst, $src, $shift\\t# vector (4S)\" %}\n@@ -5002,1 +5199,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n@@ -5005,1 +5202,1 @@\n-  format %{ \"ushr    $dst, $src, $shift\\t# vector (2S)\" %}\n+  format %{ \"ushr  $dst, $src, $shift\\t# vector (2S)\" %}\n@@ -5015,1 +5212,1 @@\n-  predicate(n->as_Vector()->length() == 4);\n+  predicate(n->as_Vector()->length() == 4 && assert_not_var_shift(n));\n@@ -5018,1 +5215,1 @@\n-  format %{ \"ushr    $dst, $src, $shift\\t# vector (4S)\" %}\n+  format %{ \"ushr  $dst, $src, $shift\\t# vector (4S)\" %}\n@@ -5040,2 +5237,2 @@\n-instruct vsra2L(vecX dst, vecX src, vecX shift, vecX tmp) %{\n-  predicate(n->as_Vector()->length() == 2);\n+instruct vsra2L(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n@@ -5044,3 +5241,1 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"sshl  $dst,$src,$tmp\\t# vector (2D)\" %}\n+  format %{ \"sshl  $dst,$src,$shift\\t# vector (2D)\" %}\n@@ -5048,1 +5243,16 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T16B,\n+    __ sshl(as_FloatRegister($dst$$reg), __ T2D,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift128);\n+%}\n+\n+instruct vsra2L_var(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVL src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"sshl  $dst,$src,$dst\\t# vector (2D)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n@@ -5052,1 +5262,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -5057,2 +5267,2 @@\n-instruct vsrl2L(vecX dst, vecX src, vecX shift, vecX tmp) %{\n-  predicate(n->as_Vector()->length() == 2);\n+instruct vsrl2L(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 2 && !n->as_ShiftV()->is_var_shift());\n@@ -5061,3 +5271,16 @@\n-  effect(TEMP tmp);\n-  format %{ \"negr  $tmp,$shift\\t\"\n-            \"ushl  $dst,$src,$tmp\\t# vector (2D)\" %}\n+  format %{ \"ushl  $dst,$src,$shift\\t# vector (2D)\" %}\n+  ins_encode %{\n+    __ ushl(as_FloatRegister($dst$$reg), __ T2D,\n+            as_FloatRegister($src$$reg),\n+            as_FloatRegister($shift$$reg));\n+  %}\n+  ins_pipe(vshift128);\n+%}\n+\n+instruct vsrl2L_var(vecX dst, vecX src, vecX shift) %{\n+  predicate(n->as_Vector()->length() == 2 && n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVL src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"ushl  $dst,$src,$dst\\t# vector (2D)\" %}\n@@ -5065,1 +5288,1 @@\n-    __ negr(as_FloatRegister($tmp$$reg), __ T16B,\n+    __ negr(as_FloatRegister($dst$$reg), __ T16B,\n@@ -5069,1 +5292,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -5075,1 +5298,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n@@ -5078,1 +5301,1 @@\n-  format %{ \"shl    $dst, $src, $shift\\t# vector (2D)\" %}\n+  format %{ \"shl  $dst, $src, $shift\\t# vector (2D)\" %}\n@@ -5088,1 +5311,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n@@ -5091,1 +5314,1 @@\n-  format %{ \"sshr    $dst, $src, $shift\\t# vector (2D)\" %}\n+  format %{ \"sshr  $dst, $src, $shift\\t# vector (2D)\" %}\n@@ -5101,1 +5324,1 @@\n-  predicate(n->as_Vector()->length() == 2);\n+  predicate(n->as_Vector()->length() == 2 && assert_not_var_shift(n));\n@@ -5104,1 +5327,1 @@\n-  format %{ \"ushr    $dst, $src, $shift\\t# vector (2D)\" %}\n+  format %{ \"ushr  $dst, $src, $shift\\t# vector (2D)\" %}\n@@ -5117,1 +5340,1 @@\n-  format %{ \"ssra    $dst, $src, $shift\\t# vector (8B)\" %}\n+  format %{ \"ssra  $dst, $src, $shift\\t# vector (8B)\" %}\n@@ -5122,1 +5345,1 @@\n-           as_FloatRegister($src$$reg), sh);\n+            as_FloatRegister($src$$reg), sh);\n@@ -5131,1 +5354,1 @@\n-  format %{ \"ssra    $dst, $src, $shift\\t# vector (16B)\" %}\n+  format %{ \"ssra  $dst, $src, $shift\\t# vector (16B)\" %}\n@@ -5136,1 +5359,1 @@\n-           as_FloatRegister($src$$reg), sh);\n+            as_FloatRegister($src$$reg), sh);\n@@ -5145,1 +5368,1 @@\n-  format %{ \"ssra    $dst, $src, $shift\\t# vector (4H)\" %}\n+  format %{ \"ssra  $dst, $src, $shift\\t# vector (4H)\" %}\n@@ -5150,1 +5373,1 @@\n-           as_FloatRegister($src$$reg), sh);\n+            as_FloatRegister($src$$reg), sh);\n@@ -5159,1 +5382,1 @@\n-  format %{ \"ssra    $dst, $src, $shift\\t# vector (8H)\" %}\n+  format %{ \"ssra  $dst, $src, $shift\\t# vector (8H)\" %}\n@@ -5164,1 +5387,1 @@\n-           as_FloatRegister($src$$reg), sh);\n+            as_FloatRegister($src$$reg), sh);\n@@ -5173,1 +5396,1 @@\n-  format %{ \"ssra    $dst, $src, $shift\\t# vector (2S)\" %}\n+  format %{ \"ssra  $dst, $src, $shift\\t# vector (2S)\" %}\n@@ -5186,1 +5409,1 @@\n-  format %{ \"ssra    $dst, $src, $shift\\t# vector (4S)\" %}\n+  format %{ \"ssra  $dst, $src, $shift\\t# vector (4S)\" %}\n@@ -5199,1 +5422,1 @@\n-  format %{ \"ssra    $dst, $src, $shift\\t# vector (2D)\" %}\n+  format %{ \"ssra  $dst, $src, $shift\\t# vector (2D)\" %}\n@@ -5212,1 +5435,1 @@\n-  format %{ \"usra    $dst, $src, $shift\\t# vector (8B)\" %}\n+  format %{ \"usra  $dst, $src, $shift\\t# vector (8B)\" %}\n@@ -5217,1 +5440,1 @@\n-             as_FloatRegister($src$$reg), sh);\n+              as_FloatRegister($src$$reg), sh);\n@@ -5227,1 +5450,1 @@\n-  format %{ \"usra    $dst, $src, $shift\\t# vector (16B)\" %}\n+  format %{ \"usra  $dst, $src, $shift\\t# vector (16B)\" %}\n@@ -5232,1 +5455,1 @@\n-             as_FloatRegister($src$$reg), sh);\n+              as_FloatRegister($src$$reg), sh);\n@@ -5242,1 +5465,1 @@\n-  format %{ \"usra    $dst, $src, $shift\\t# vector (4H)\" %}\n+  format %{ \"usra  $dst, $src, $shift\\t# vector (4H)\" %}\n@@ -5247,1 +5470,1 @@\n-             as_FloatRegister($src$$reg), sh);\n+              as_FloatRegister($src$$reg), sh);\n@@ -5257,1 +5480,1 @@\n-  format %{ \"usra    $dst, $src, $shift\\t# vector (8H)\" %}\n+  format %{ \"usra  $dst, $src, $shift\\t# vector (8H)\" %}\n@@ -5262,1 +5485,1 @@\n-             as_FloatRegister($src$$reg), sh);\n+              as_FloatRegister($src$$reg), sh);\n@@ -5272,1 +5495,1 @@\n-  format %{ \"usra    $dst, $src, $shift\\t# vector (2S)\" %}\n+  format %{ \"usra  $dst, $src, $shift\\t# vector (2S)\" %}\n@@ -5285,1 +5508,1 @@\n-  format %{ \"usra    $dst, $src, $shift\\t# vector (4S)\" %}\n+  format %{ \"usra  $dst, $src, $shift\\t# vector (4S)\" %}\n@@ -5298,1 +5521,1 @@\n-  format %{ \"usra    $dst, $src, $shift\\t# vector (2D)\" %}\n+  format %{ \"usra  $dst, $src, $shift\\t# vector (2D)\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":415,"deletions":192,"binary":false,"changes":607,"status":"modified"},{"patch":"@@ -1975,4 +1975,6 @@\n-define(`VSHIFTCNT', `\n-instruct vshiftcnt$3$4`'(vec$5 dst, iRegIorL2I cnt) %{\n-  predicate(UseSVE == 0 && (ifelse($3, 8, n->as_Vector()->length_in_bytes() == 4 ||`\n-            ')n->as_Vector()->length_in_bytes() == $3));\n+define(`VSLCNT', `\n+instruct vslcnt$1$2`'(vec$3 dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE == 0 && ifelse($1, 8,\n+                                  (n->as_Vector()->length_in_bytes() == 4 ||`\n+                            'n->as_Vector()->length_in_bytes() == $1),\n+                                  n->as_Vector()->length_in_bytes() == $1));\n@@ -1980,0 +1982,14 @@\n+  ins_cost(INSN_COST);\n+  format %{ \"dup  $dst, $cnt\\t# shift count vector ($1$2)\" %}\n+  ins_encode %{\n+    __ dup(as_FloatRegister($dst$$reg), __ T$1$2, as_Register($cnt$$reg));\n+  %}\n+  ins_pipe(vdup_reg_reg`'ifelse($3, D, 64, 128));\n+%}')dnl\n+dnl\n+define(`VSRCNT', `\n+instruct vsrcnt$1$2`'(vec$3 dst, iRegIorL2I cnt) %{\n+  predicate(UseSVE == 0 && ifelse($1, 8,\n+                                  (n->as_Vector()->length_in_bytes() == 4 ||`\n+                            'n->as_Vector()->length_in_bytes() == $1),\n+                                  n->as_Vector()->length_in_bytes() == $1));\n@@ -1981,1 +1997,3 @@\n-  format %{ \"$1  $dst, $cnt\\t# shift count vector ($3$4)\" %}\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"negw  rscratch1, $cnt\\t\"\n+            \"dup   $dst, rscratch1\\t# shift count vector ($1$2)\" %}\n@@ -1983,1 +2001,2 @@\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$4, as_Register($cnt$$reg));\n+    __ negw(rscratch1, as_Register($cnt$$reg));\n+    __ dup(as_FloatRegister($dst$$reg), __ T$1$2, rscratch1);\n@@ -1985,1 +2004,1 @@\n-  ins_pipe(vdup_reg_reg`'ifelse($5, D, 64, 128));\n+  ins_pipe(vdup_reg_reg`'ifelse($3, D, 64, 128));\n@@ -1987,3 +2006,24 @@\n-dnl       $1   $2   $3  $4 $5\n-VSHIFTCNT(dup, dup, 8,  B, D)\n-VSHIFTCNT(dup, dup, 16, B, X)\n+dnl\n+\n+\/\/ Vector shift count\n+\/\/ Note-1: Low 8 bits of each element are used, so it doesn't matter if we\n+\/\/         treat it as ints or bytes here.\n+\/\/ Note-2: Shift value is negated for RShiftCntV additionally. See the comments\n+\/\/         on vsra8B rule for more details.\n+dnl    $1  $2 $3\n+VSLCNT(8,  B, D)\n+VSLCNT(16, B, X)\n+VSRCNT(8,  B, D)\n+VSRCNT(16, B, X)\n+dnl\n+define(`PREDICATE',\n+`ifelse($1, 8B,\n+            ifelse($3, `', `predicate(n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8);',\n+                           `predicate((n->as_Vector()->length() == 4 || n->as_Vector()->length() == 8) &&`\n+            '$3);'),\n+        $1, 4S,\n+            ifelse($3, `', `predicate(n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4);',\n+                           `predicate((n->as_Vector()->length() == 2 || n->as_Vector()->length() == 4) &&`\n+            '$3);'),\n+        ifelse($3, `', `predicate(n->as_Vector()->length() == $2);',\n+                       `predicate(n->as_Vector()->length() == $2 && $3);'))')dnl\n@@ -1992,6 +2032,3 @@\n-instruct vsll$3$4`'(vec$6 dst, vec$6 src, vec$6 shift) %{\n-  predicate(ifelse($3$4, 8B, n->as_Vector()->length() == 4 ||`\n-            ',\n-  $3$4, 4S, n->as_Vector()->length() == 2 ||`\n-            ')n->as_Vector()->length() == $3);\n-  match(Set dst (LShiftV$4 src shift));\n+instruct vsll$1$2`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n+  PREDICATE(`$1$2', $1, )\n+  match(Set dst (LShiftV$2 src shift));\n@@ -1999,1 +2036,1 @@\n-  format %{ \"$1  $dst,$src,$shift\\t# vector ($3$5)\" %}\n+  format %{ \"sshl  $dst,$src,$shift\\t# vector ($1$3)\" %}\n@@ -2001,1 +2038,1 @@\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n+    __ sshl(as_FloatRegister($dst$$reg), __ T$1$3,\n@@ -2005,1 +2042,1 @@\n-  ins_pipe(vshift`'ifelse($6, D, 64, 128));\n+  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n@@ -2009,12 +2046,8 @@\n-instruct vsra$3$4`'(vec$6 dst, vec$6 src, vec$6 shift, vec$6 tmp) %{\n-  predicate(ifelse($3$4, 8B, n->as_Vector()->length() == 4 ||`\n-            ',\n-  $3$4, 4S, n->as_Vector()->length() == 2 ||`\n-            ')n->as_Vector()->length() == $3);\n-  match(Set dst (RShiftV$4 src shift));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp);\n-  format %{ \"$1  $tmp,$shift\\t\"\n-            \"$2  $dst,$src,$tmp\\t# vector ($3$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($tmp$$reg), __ T`'ifelse($6, D, 8B, 16B),\n+instruct vsra$1$2`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n+  PREDICATE(`$1$2', $1, !n->as_ShiftV()->is_var_shift())\n+  match(Set dst (RShiftV$2 src shift));\n+  ins_cost(INSN_COST);\n+  format %{ \"sshl  $dst,$src,$shift\\t# vector ($1$3)\" %}\n+  ins_encode %{\n+    __ sshl(as_FloatRegister($dst$$reg), __ T$1$3,\n+            as_FloatRegister($src$$reg),\n@@ -2022,1 +2055,16 @@\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n+  %}\n+  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n+%}')dnl\n+dnl\n+define(`VSRA_VAR', `\n+instruct vsra$1$2_var`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n+  PREDICATE(`$1$2', $1, n->as_ShiftV()->is_var_shift())\n+  match(Set dst (RShiftV$2 src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"sshl  $dst,$src,$dst\\t# vector ($1$3)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T`'ifelse($4, D, 8B, 16B),\n+            as_FloatRegister($shift$$reg));\n+    __ sshl(as_FloatRegister($dst$$reg), __ T$1$3,\n@@ -2024,1 +2072,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -2026,1 +2074,1 @@\n-  ins_pipe(vshift`'ifelse($6, D, 64, 128));\n+  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n@@ -2030,12 +2078,8 @@\n-instruct vsrl$3$4`'(vec$6 dst, vec$6 src, vec$6 shift, vec$6 tmp) %{\n-  predicate(ifelse($3$4, 8B, n->as_Vector()->length() == 4 ||`\n-            ',\n-  $3$4, 4S, n->as_Vector()->length() == 2 ||`\n-            ')n->as_Vector()->length() == $3);\n-  match(Set dst (URShiftV$4 src shift));\n-  ins_cost(INSN_COST);\n-  effect(TEMP tmp);\n-  format %{ \"$1  $tmp,$shift\\t\"\n-            \"$2  $dst,$src,$tmp\\t# vector ($3$5)\" %}\n-  ins_encode %{\n-    __ $1(as_FloatRegister($tmp$$reg), __ T`'ifelse($6, D, 8B, 16B),\n+instruct vsrl$1$2`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n+  PREDICATE(`$1$2', $1, !n->as_ShiftV()->is_var_shift())\n+  match(Set dst (URShiftV$2 src shift));\n+  ins_cost(INSN_COST);\n+  format %{ \"ushl  $dst,$src,$shift\\t# vector ($1$3)\" %}\n+  ins_encode %{\n+    __ ushl(as_FloatRegister($dst$$reg), __ T$1$3,\n+            as_FloatRegister($src$$reg),\n@@ -2043,1 +2087,16 @@\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n+  %}\n+  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n+%}')dnl\n+dnl\n+define(`VSRL_VAR', `\n+instruct vsrl$1$2_var`'(vec$4 dst, vec$4 src, vec$4 shift) %{\n+  PREDICATE(`$1$2', $1, n->as_ShiftV()->is_var_shift())\n+  match(Set dst (URShiftV$2 src shift));\n+  ins_cost(INSN_COST * 2);\n+  effect(TEMP_DEF dst);\n+  format %{ \"negr  $dst,$shift\\t\"\n+            \"ushl  $dst,$src,$dst\\t# vector ($1$3)\" %}\n+  ins_encode %{\n+    __ negr(as_FloatRegister($dst$$reg), __ T`'ifelse($4, D, 8B, 16B),\n+            as_FloatRegister($shift$$reg));\n+    __ ushl(as_FloatRegister($dst$$reg), __ T$1$3,\n@@ -2045,1 +2104,1 @@\n-            as_FloatRegister($tmp$$reg));\n+            as_FloatRegister($dst$$reg));\n@@ -2047,1 +2106,1 @@\n-  ins_pipe(vshift`'ifelse($6, D, 64, 128));\n+  ins_pipe(vshift`'ifelse($4, D, 64, 128));\n@@ -2051,9 +2110,6 @@\n-instruct vsll$3$4_imm`'(vec$6 dst, vec$6 src, immI shift) %{\n-  predicate(ifelse($3$4, 8B, n->as_Vector()->length() == 4 ||`\n-            ',\n-  $3$4, 4S, n->as_Vector()->length() == 2 ||`\n-            ')n->as_Vector()->length() == $3);\n-  match(Set dst (LShiftV$4 src (LShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1    $dst, $src, $shift\\t# vector ($3$5)\" %}\n-  ins_encode %{ifelse($4, B,`\n+instruct vsll$1$2_imm`'(vec$4 dst, vec$4 src, immI shift) %{\n+  PREDICATE(`$1$2', $1, assert_not_var_shift(n))\n+  match(Set dst (LShiftV$2 src (LShiftCntV shift)));\n+  ins_cost(INSN_COST);\n+  format %{ \"shl  $dst, $src, $shift\\t# vector ($1$3)\" %}\n+  ins_encode %{ifelse($2, B,`\n@@ -2062,1 +2118,1 @@\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($6, D, T8B, T16B),\n+      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n@@ -2066,1 +2122,1 @@\n-      __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n+      __ shl(as_FloatRegister($dst$$reg), __ T$1$3,\n@@ -2068,1 +2124,1 @@\n-    }', $4, S,`\n+    }', $2, S,`\n@@ -2071,1 +2127,1 @@\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($6, D, T8B, T16B),\n+      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n@@ -2075,1 +2131,1 @@\n-      __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n+      __ shl(as_FloatRegister($dst$$reg), __ T$1$3,\n@@ -2078,1 +2134,1 @@\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n+    __ shl(as_FloatRegister($dst$$reg), __ T$1$3,\n@@ -2082,1 +2138,1 @@\n-  ins_pipe(vshift`'ifelse($6, D, 64, 128)_imm);\n+  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n@@ -2084,0 +2140,1 @@\n+dnl\n@@ -2085,9 +2142,6 @@\n-instruct vsra$3$4_imm`'(vec$6 dst, vec$6 src, immI shift) %{\n-  predicate(ifelse($3$4, 8B, n->as_Vector()->length() == 4 ||`\n-            ',\n-  $3$4, 4S, n->as_Vector()->length() == 2 ||`\n-            ')n->as_Vector()->length() == $3);\n-  match(Set dst (RShiftV$4 src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1    $dst, $src, $shift\\t# vector ($3$5)\" %}\n-  ins_encode %{ifelse($4, B,`\n+instruct vsra$1$2_imm`'(vec$4 dst, vec$4 src, immI shift) %{\n+  PREDICATE(`$1$2', $1, assert_not_var_shift(n))\n+  match(Set dst (RShiftV$2 src (RShiftCntV shift)));\n+  ins_cost(INSN_COST);\n+  format %{ \"sshr  $dst, $src, $shift\\t# vector ($1$3)\" %}\n+  ins_encode %{ifelse($2, B,`\n@@ -2096,2 +2150,2 @@\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n-           as_FloatRegister($src$$reg), sh);', $4, S,`\n+    __ sshr(as_FloatRegister($dst$$reg), __ T$1$3,\n+            as_FloatRegister($src$$reg), sh);', $2, S,`\n@@ -2100,3 +2154,3 @@\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n-           as_FloatRegister($src$$reg), sh);', `\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n+    __ sshr(as_FloatRegister($dst$$reg), __ T$1$3,\n+            as_FloatRegister($src$$reg), sh);', `\n+    __ sshr(as_FloatRegister($dst$$reg), __ T$1$3,\n@@ -2106,1 +2160,1 @@\n-  ins_pipe(vshift`'ifelse($6, D, 64, 128)_imm);\n+  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n@@ -2110,9 +2164,6 @@\n-instruct vsrl$3$4_imm`'(vec$6 dst, vec$6 src, immI shift) %{\n-  predicate(ifelse($3$4, 8B, n->as_Vector()->length() == 4 ||`\n-            ',\n-  $3$4, 4S, n->as_Vector()->length() == 2 ||`\n-            ')n->as_Vector()->length() == $3);\n-  match(Set dst (URShiftV$4 src (RShiftCntV shift)));\n-  ins_cost(INSN_COST);\n-  format %{ \"$1    $dst, $src, $shift\\t# vector ($3$5)\" %}\n-  ins_encode %{ifelse($4, B,`\n+instruct vsrl$1$2_imm`'(vec$4 dst, vec$4 src, immI shift) %{\n+  PREDICATE(`$1$2', $1, assert_not_var_shift(n))\n+  match(Set dst (URShiftV$2 src (RShiftCntV shift)));\n+  ins_cost(INSN_COST);\n+  format %{ \"ushr  $dst, $src, $shift\\t# vector ($1$3)\" %}\n+  ins_encode %{ifelse($2, B,`\n@@ -2121,1 +2172,1 @@\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($6, D, T8B, T16B),\n+      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n@@ -2125,3 +2176,3 @@\n-      __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n-             as_FloatRegister($src$$reg), sh);\n-    }', $4, S,`\n+      __ ushr(as_FloatRegister($dst$$reg), __ T$1$3,\n+              as_FloatRegister($src$$reg), sh);\n+    }', $2, S,`\n@@ -2130,1 +2181,1 @@\n-      __ eor(as_FloatRegister($dst$$reg), __ ifelse($6, D, T8B, T16B),\n+      __ eor(as_FloatRegister($dst$$reg), __ ifelse($4, D, T8B, T16B),\n@@ -2134,2 +2185,2 @@\n-      __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n-             as_FloatRegister($src$$reg), sh);\n+      __ ushr(as_FloatRegister($dst$$reg), __ T$1$3,\n+              as_FloatRegister($src$$reg), sh);\n@@ -2137,1 +2188,1 @@\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n+    __ ushr(as_FloatRegister($dst$$reg), __ T$1$3,\n@@ -2141,1 +2192,1 @@\n-  ins_pipe(vshift`'ifelse($6, D, 64, 128)_imm);\n+  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n@@ -2145,3 +2196,3 @@\n-instruct vsrla$3$4_imm`'(vec$6 dst, vec$6 src, immI shift) %{\n-  predicate(n->as_Vector()->length() == $3);\n-  match(Set dst (AddV$4 dst (URShiftV$4 src (RShiftCntV shift))));\n+instruct vsrla$1$2_imm`'(vec$4 dst, vec$4 src, immI shift) %{\n+  predicate(n->as_Vector()->length() == $1);\n+  match(Set dst (AddV$2 dst (URShiftV$2 src (RShiftCntV shift))));\n@@ -2149,2 +2200,2 @@\n-  format %{ \"$1    $dst, $src, $shift\\t# vector ($3$5)\" %}\n-  ins_encode %{ifelse($4, B,`\n+  format %{ \"usra  $dst, $src, $shift\\t# vector ($1$3)\" %}\n+  ins_encode %{ifelse($2, B,`\n@@ -2153,3 +2204,3 @@\n-      __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n-             as_FloatRegister($src$$reg), sh);\n-    }', $4, S,`\n+      __ usra(as_FloatRegister($dst$$reg), __ T$1$3,\n+              as_FloatRegister($src$$reg), sh);\n+    }', $2, S,`\n@@ -2158,2 +2209,2 @@\n-      __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n-             as_FloatRegister($src$$reg), sh);\n+      __ usra(as_FloatRegister($dst$$reg), __ T$1$3,\n+              as_FloatRegister($src$$reg), sh);\n@@ -2161,1 +2212,1 @@\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n+    __ usra(as_FloatRegister($dst$$reg), __ T$1$3,\n@@ -2165,1 +2216,1 @@\n-  ins_pipe(vshift`'ifelse($6, D, 64, 128)_imm);\n+  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n@@ -2169,3 +2220,3 @@\n-instruct vsraa$3$4_imm`'(vec$6 dst, vec$6 src, immI shift) %{\n-  predicate(n->as_Vector()->length() == $3);\n-  match(Set dst (AddV$4 dst (RShiftV$4 src (RShiftCntV shift))));\n+instruct vsraa$1$2_imm`'(vec$4 dst, vec$4 src, immI shift) %{\n+  predicate(n->as_Vector()->length() == $1);\n+  match(Set dst (AddV$2 dst (RShiftV$2 src (RShiftCntV shift))));\n@@ -2173,2 +2224,2 @@\n-  format %{ \"$1    $dst, $src, $shift\\t# vector ($3$5)\" %}\n-  ins_encode %{ifelse($4, B,`\n+  format %{ \"ssra  $dst, $src, $shift\\t# vector ($1$3)\" %}\n+  ins_encode %{ifelse($2, B,`\n@@ -2177,2 +2228,2 @@\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n-           as_FloatRegister($src$$reg), sh);', $4, S,`\n+    __ ssra(as_FloatRegister($dst$$reg), __ T$1$3,\n+            as_FloatRegister($src$$reg), sh);', $2, S,`\n@@ -2181,3 +2232,3 @@\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n-           as_FloatRegister($src$$reg), sh);', `\n-    __ $2(as_FloatRegister($dst$$reg), __ T$3$5,\n+    __ ssra(as_FloatRegister($dst$$reg), __ T$1$3,\n+            as_FloatRegister($src$$reg), sh);', `\n+    __ ssra(as_FloatRegister($dst$$reg), __ T$1$3,\n@@ -2187,1 +2238,1 @@\n-  ins_pipe(vshift`'ifelse($6, D, 64, 128)_imm);\n+  ins_pipe(vshift`'ifelse($4, D, 64, 128)_imm);\n@@ -2189,3 +2240,6 @@\n-dnl  $1    $2    $3  $4 $5 $6\n-VSLL(sshl, sshl, 8,  B, B, D)\n-VSLL(sshl, sshl, 16, B, B, X)\n+dnl\n+undefine(PREDICATE)dnl\n+dnl\n+dnl  $1  $2 $3 $4\n+VSLL(8,  B, B, D)\n+VSLL(16, B, B, X)\n@@ -2202,2 +2256,0 @@\n-\/\/ Note: In inner loop, multiple neg instructions are used, which can be\n-\/\/ moved to outer loop and merge into one neg instruction.\n@@ -2213,55 +2265,77 @@\n-dnl  $1    $2    $3  $4 $5 $6\n-VSRA(negr, sshl, 8,  B, B, D)\n-VSRA(negr, sshl, 16, B, B, X)\n-VSRL(negr, ushl, 8,  B, B, D)\n-VSRL(negr, ushl, 16, B, B, X)\n-VSLL_IMM(shl, shl, 8,  B, B, D)\n-VSLL_IMM(shl, shl, 16, B, B, X)\n-VSRA_IMM(sshr, sshr, 8,  B, B, D)\n-VSRA_IMM(sshr, sshr, 16, B, B, X)\n-VSRL_IMM(ushr, ushr, 8,  B, B, D)\n-VSRL_IMM(ushr, ushr, 16, B, B, X)\n-VSLL(sshl, sshl, 4,  S, H, D)\n-VSLL(sshl, sshl, 8,  S, H, X)\n-VSRA(negr, sshl, 4,  S, H, D)\n-VSRA(negr, sshl, 8,  S, H, X)\n-VSRL(negr, ushl, 4,  S, H, D)\n-VSRL(negr, ushl, 8,  S, H, X)\n-VSLL_IMM(shl, shl, 4,  S, H, D)\n-VSLL_IMM(shl, shl, 8,  S, H, X)\n-VSRA_IMM(sshr, sshr, 4,  S, H, D)\n-VSRA_IMM(sshr, sshr, 8,  S, H, X)\n-VSRL_IMM(ushr, ushr, 4,  S, H, D)\n-VSRL_IMM(ushr, ushr, 8,  S, H, X)\n-VSLL(sshl, sshl, 2,  I, S, D)\n-VSLL(sshl, sshl, 4,  I, S, X)\n-VSRA(negr, sshl, 2,  I, S, D)\n-VSRA(negr, sshl, 4,  I, S, X)\n-VSRL(negr, ushl, 2,  I, S, D)\n-VSRL(negr, ushl, 4,  I, S, X)\n-VSLL_IMM(shl, shl, 2,  I, S, D)\n-VSLL_IMM(shl, shl, 4,  I, S, X)\n-VSRA_IMM(sshr, sshr, 2,  I, S, D)\n-VSRA_IMM(sshr, sshr, 4,  I, S, X)\n-VSRL_IMM(ushr, ushr, 2,  I, S, D)\n-VSRL_IMM(ushr, ushr, 4,  I, S, X)\n-VSLL(sshl, sshl, 2,  L, D, X)\n-VSRA(negr, sshl, 2,  L, D, X)\n-VSRL(negr, ushl, 2,  L, D, X)\n-VSLL_IMM(shl, shl, 2,  L, D, X)\n-VSRA_IMM(sshr, sshr, 2,  L, D, X)\n-VSRL_IMM(ushr, ushr, 2,  L, D, X)\n-VSRAA_IMM(ssra, ssra, 8,  B, B, D)\n-VSRAA_IMM(ssra, ssra, 16, B, B, X)\n-VSRAA_IMM(ssra, ssra, 4,  S, H, D)\n-VSRAA_IMM(ssra, ssra, 8,  S, H, X)\n-VSRAA_IMM(ssra, ssra, 2,  I, S, D)\n-VSRAA_IMM(ssra, ssra, 4,  I, S, X)\n-VSRAA_IMM(ssra, ssra, 2,  L, D, X)\n-VSRLA_IMM(usra, usra, 8,  B, B, D)\n-VSRLA_IMM(usra, usra, 16, B, B, X)\n-VSRLA_IMM(usra, usra, 4,  S, H, D)\n-VSRLA_IMM(usra, usra, 8,  S, H, X)\n-VSRLA_IMM(usra, usra, 2,  I, S, D)\n-VSRLA_IMM(usra, usra, 4,  I, S, X)\n-VSRLA_IMM(usra, usra, 2,  L, D, X)\n+\/\/ The negate is conducted in RShiftCntV rule for case 1, whereas it's done in\n+\/\/ RShiftV* rules for case 2. Because there exists an optimization opportunity\n+\/\/ for case 1, that is, multiple neg instructions in inner loop can be hoisted\n+\/\/ to outer loop and merged into one neg instruction.\n+\/\/\n+\/\/ Note that ShiftVNode::is_var_shift() indicates whether the vector shift\n+\/\/ count is a variable vector(case 2) or not(a vector generated by RShiftCntV,\n+\/\/ i.e. case 1).\n+dnl  $1  $2 $3 $4\n+VSRA(8,  B, B, D)\n+VSRA_VAR(8,  B, B, D)\n+VSRA(16, B, B, X)\n+VSRA_VAR(16, B, B, X)\n+VSRL(8,  B, B, D)\n+VSRL_VAR(8,  B, B, D)\n+VSRL(16, B, B, X)\n+VSRL_VAR(16, B, B, X)\n+VSLL_IMM(8,  B, B, D)\n+VSLL_IMM(16, B, B, X)\n+VSRA_IMM(8,  B, B, D)\n+VSRA_IMM(16, B, B, X)\n+VSRL_IMM(8,  B, B, D)\n+VSRL_IMM(16, B, B, X)\n+VSLL(4,  S, H, D)\n+VSLL(8,  S, H, X)\n+VSRA(4,  S, H, D)\n+VSRA_VAR(4,  S, H, D)\n+VSRA(8,  S, H, X)\n+VSRA_VAR(8,  S, H, X)\n+VSRL(4,  S, H, D)\n+VSRL_VAR(4,  S, H, D)\n+VSRL(8,  S, H, X)\n+VSRL_VAR(8,  S, H, X)\n+VSLL_IMM(4,  S, H, D)\n+VSLL_IMM(8,  S, H, X)\n+VSRA_IMM(4,  S, H, D)\n+VSRA_IMM(8,  S, H, X)\n+VSRL_IMM(4,  S, H, D)\n+VSRL_IMM(8,  S, H, X)\n+VSLL(2,  I, S, D)\n+VSLL(4,  I, S, X)\n+VSRA(2,  I, S, D)\n+VSRA_VAR(2,  I, S, D)\n+VSRA(4,  I, S, X)\n+VSRA_VAR(4,  I, S, X)\n+VSRL(2,  I, S, D)\n+VSRL_VAR(2,  I, S, D)\n+VSRL(4,  I, S, X)\n+VSRL_VAR(4,  I, S, X)\n+VSLL_IMM(2,  I, S, D)\n+VSLL_IMM(4,  I, S, X)\n+VSRA_IMM(2,  I, S, D)\n+VSRA_IMM(4,  I, S, X)\n+VSRL_IMM(2,  I, S, D)\n+VSRL_IMM(4,  I, S, X)\n+VSLL(2,  L, D, X)\n+VSRA(2,  L, D, X)\n+VSRA_VAR(2,  L, D, X)\n+VSRL(2,  L, D, X)\n+VSRL_VAR(2,  L, D, X)\n+VSLL_IMM(2,  L, D, X)\n+VSRA_IMM(2,  L, D, X)\n+VSRL_IMM(2,  L, D, X)\n+VSRAA_IMM(8,  B, B, D)\n+VSRAA_IMM(16, B, B, X)\n+VSRAA_IMM(4,  S, H, D)\n+VSRAA_IMM(8,  S, H, X)\n+VSRAA_IMM(2,  I, S, D)\n+VSRAA_IMM(4,  I, S, X)\n+VSRAA_IMM(2,  L, D, X)\n+VSRLA_IMM(8,  B, B, D)\n+VSRLA_IMM(16, B, B, X)\n+VSRLA_IMM(4,  S, H, D)\n+VSRLA_IMM(8,  S, H, X)\n+VSRLA_IMM(2,  I, S, D)\n+VSRLA_IMM(4,  I, S, X)\n+VSRLA_IMM(2,  L, D, X)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":255,"deletions":181,"binary":false,"changes":436,"status":"modified"},{"patch":"@@ -990,19 +990,27 @@\n-  void hint(int imm) {\n-    system(0b00, 0b011, 0b0010, 0b0000, imm);\n-  }\n-\n-  void nop() {\n-    hint(0);\n-  }\n-\n-  void yield() {\n-    hint(1);\n-  }\n-\n-  void wfe() {\n-    hint(2);\n-  }\n-\n-  void wfi() {\n-    hint(3);\n-  }\n+  \/\/ Hint instructions\n+\n+#define INSN(NAME, crm, op2)               \\\n+  void NAME() {                            \\\n+    system(0b00, 0b011, 0b0010, crm, op2); \\\n+  }\n+\n+  INSN(nop,   0b000, 0b0000);\n+  INSN(yield, 0b000, 0b0001);\n+  INSN(wfe,   0b000, 0b0010);\n+  INSN(wfi,   0b000, 0b0011);\n+  INSN(sev,   0b000, 0b0100);\n+  INSN(sevl,  0b000, 0b0101);\n+\n+  INSN(autia1716, 0b0001, 0b100);\n+  INSN(autiasp,   0b0011, 0b101);\n+  INSN(autiaz,    0b0011, 0b100);\n+  INSN(autib1716, 0b0001, 0b110);\n+  INSN(autibsp,   0b0011, 0b111);\n+  INSN(autibz,    0b0011, 0b110);\n+  INSN(pacia1716, 0b0001, 0b000);\n+  INSN(paciasp,   0b0011, 0b001);\n+  INSN(paciaz,    0b0011, 0b000);\n+  INSN(pacib1716, 0b0001, 0b010);\n+  INSN(pacibsp,   0b0011, 0b011);\n+  INSN(pacibz,    0b0011, 0b010);\n+  INSN(xpaclri,   0b0000, 0b111);\n@@ -1010,7 +1018,1 @@\n-  void sev() {\n-    hint(4);\n-  }\n-\n-  void sevl() {\n-    hint(5);\n-  }\n+#undef INSN\n@@ -1102,1 +1104,2 @@\n-  void branch_reg(Register R, int opc) {\n+\n+  void branch_reg(int OP, int A, int M, Register RN, Register RM) {\n@@ -1105,4 +1108,6 @@\n-    f(opc, 24, 21);\n-    f(0b11111000000, 20, 10);\n-    rf(R, 5);\n-    f(0b00000, 4, 0);\n+    f(OP, 24, 21);\n+    f(0b111110000, 20, 12);\n+    f(A, 11, 11);\n+    f(M, 10, 10);\n+    rf(RN, 5);\n+    rf(RM, 0);\n@@ -1111,3 +1116,3 @@\n-#define INSN(NAME, opc)                         \\\n-  void NAME(Register R) {                       \\\n-    branch_reg(R, opc);                         \\\n+#define INSN(NAME, opc)              \\\n+  void NAME(Register RN) {           \\\n+    branch_reg(opc, 0, 0, RN, r0);    \\\n@@ -1124,3 +1129,3 @@\n-#define INSN(NAME, opc)                         \\\n-  void NAME() {                 \\\n-    branch_reg(dummy_reg, opc);         \\\n+#define INSN(NAME, opc)                     \\\n+  void NAME() {                             \\\n+    branch_reg(opc, 0, 0, dummy_reg, r0);    \\\n@@ -1132,0 +1137,34 @@\n+#undef INSN\n+\n+#define INSN(NAME, M)                                  \\\n+  void NAME() {                                        \\\n+    branch_reg(0b0010, 1, M, dummy_reg, dummy_reg);    \\\n+  }\n+\n+  INSN(retaa, 0);\n+  INSN(retab, 1);\n+\n+#undef INSN\n+\n+#define INSN(NAME, OP, M)                   \\\n+  void NAME(Register rn) {                  \\\n+    branch_reg(OP, 1, M, rn, dummy_reg);    \\\n+  }\n+\n+  INSN(braaz,  0b0000, 0);\n+  INSN(brabz,  0b0000, 1);\n+  INSN(blraaz, 0b0001, 0);\n+  INSN(blrabz, 0b0001, 1);\n+\n+#undef INSN\n+\n+#define INSN(NAME, OP, M)                  \\\n+  void NAME(Register rn, Register rm) {    \\\n+    branch_reg(OP, 1, M, rn, rm);          \\\n+  }\n+\n+  INSN(braa,  0b1000, 0);\n+  INSN(brab,  0b1000, 1);\n+  INSN(blraa, 0b1001, 0);\n+  INSN(blrab, 0b1001, 1);\n+\n@@ -1795,0 +1834,31 @@\n+  \/\/ PAC instructions\n+  INSN(pacia,  0b110, 0b00001, 0b00000);\n+  INSN(pacib,  0b110, 0b00001, 0b00001);\n+  INSN(pacda,  0b110, 0b00001, 0b00010);\n+  INSN(pacdb,  0b110, 0b00001, 0b00011);\n+  INSN(autia,  0b110, 0b00001, 0b00100);\n+  INSN(autib,  0b110, 0b00001, 0b00101);\n+  INSN(autda,  0b110, 0b00001, 0b00110);\n+  INSN(autdb,  0b110, 0b00001, 0b00111);\n+\n+#undef INSN\n+\n+#define INSN(NAME, op29, opcode2, opcode)                       \\\n+  void NAME(Register Rd) {                                      \\\n+    starti;                                                     \\\n+    f(opcode2, 20, 16);                                         \\\n+    data_processing(current_insn, op29, opcode, Rd, dummy_reg); \\\n+  }\n+\n+  \/\/ PAC instructions (with zero modifier)\n+  INSN(paciza,  0b110, 0b00001, 0b01000);\n+  INSN(pacizb,  0b110, 0b00001, 0b01001);\n+  INSN(pacdza,  0b110, 0b00001, 0b01010);\n+  INSN(pacdzb,  0b110, 0b00001, 0b01011);\n+  INSN(autiza,  0b110, 0b00001, 0b01100);\n+  INSN(autizb,  0b110, 0b00001, 0b01101);\n+  INSN(autdza,  0b110, 0b00001, 0b01110);\n+  INSN(autdzb,  0b110, 0b00001, 0b01111);\n+  INSN(xpaci,   0b110, 0b00001, 0b10000);\n+  INSN(xpacd,   0b110, 0b00001, 0b10001);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":107,"deletions":37,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -388,0 +388,1 @@\n+    __ authenticate_return_address(exception_pc, rscratch1);\n@@ -436,0 +437,1 @@\n+  __ protect_return_address(exception_pc, rscratch1);\n@@ -451,0 +453,1 @@\n+  __ protect_return_address(r0, rscratch1);\n@@ -499,0 +502,2 @@\n+  __ mov(r3, lr);\n+  __ protect_return_address();\n@@ -502,1 +507,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), rthread, lr);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), rthread, r3);\n@@ -515,0 +520,1 @@\n+  __ authenticate_return_address();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -131,1 +131,0 @@\n-      sender_pc = (address) this->fp()[return_addr_offset];\n@@ -138,0 +137,1 @@\n+      sender_pc = pauth_strip_verifiable((address) this->fp()[return_addr_offset], (address)saved_fp);\n@@ -154,1 +154,0 @@\n-      sender_pc = (address) *(sender_sp-1);\n@@ -157,0 +156,1 @@\n+      sender_pc = pauth_strip_verifiable((address) *(sender_sp-1), (address)saved_fp);\n@@ -271,0 +271,3 @@\n+  address signing_sp = (((address*) sp())[-2]);\n+  address signed_pc = pauth_sign_return_address(pc, (address)signing_sp);\n+  address pc_old = pauth_strip_verifiable(*pc_addr, (address)signing_sp);\n@@ -272,2 +275,6 @@\n-    tty->print_cr(\"patch_pc at address \" INTPTR_FORMAT \" [\" INTPTR_FORMAT \" -> \" INTPTR_FORMAT \"]\",\n-                  p2i(pc_addr), p2i(*pc_addr), p2i(pc));\n+    tty->print(\"patch_pc at address \" INTPTR_FORMAT \" [\" INTPTR_FORMAT \" -> \" INTPTR_FORMAT \"]\",\n+                  p2i(pc_addr), p2i(pc_old), p2i(pc));\n+    if (VM_Version::use_rop_protection()) {\n+      tty->print(\" [signed \" INTPTR_FORMAT \" -> \" INTPTR_FORMAT \"]\", p2i(*pc_addr), p2i(signed_pc));\n+    }\n+    tty->print_cr(\"\");\n@@ -276,2 +283,0 @@\n-  \/\/ Only generated code frames should be patched, therefore the return address will not be signed.\n-  assert(pauth_ptr_is_raw(*pc_addr), \"cannot be signed\");\n@@ -280,2 +285,2 @@\n-  assert(_pc == *pc_addr || pc == *pc_addr, \"must be\");\n-  *pc_addr = pc;\n+  assert(_pc == pc_old || pc == pc_old, \"must be\");\n+  *pc_addr = signed_pc;\n@@ -458,1 +463,2 @@\n-  \/\/ Use the raw version of pc - the interpreter should not have signed it.\n+  \/\/ For ROP protection, Interpreter will have signed the sender_pc, but there is no requirement to authenticate it here.\n+  address sender_pc = pauth_strip_verifiable(sender_pc_maybe_signed(), (address)link());\n@@ -460,1 +466,1 @@\n-  return frame(sender_sp, unextended_sp, link(), sender_pc_maybe_signed());\n+  return frame(sender_sp, unextended_sp, link(), sender_pc);\n@@ -463,1 +469,0 @@\n-\n@@ -485,1 +490,3 @@\n-  address sender_pc = (address) *(l_sender_sp-1);\n+\n+  \/\/ For ROP protection, C1\/C2 will have signed the sender_pc, but there is no requirement to authenticate it here.\n+  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp-1), (address) *(l_sender_sp-2));\n@@ -533,0 +540,3 @@\n+  \/\/ Native code may or may not have signed the return address, we have no way to be sure or what\n+  \/\/ signing methods they used. Instead, just ensure the stripped value is used.\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,1 +274,1 @@\n-    __ enter(); \/\/ barrier may call runtime\n+    __ enter(\/*strip_ret_addr*\/true); \/\/ barrier may call runtime\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2018, 2022, Red Hat, Inc. All rights reserved.\n@@ -240,1 +240,1 @@\n-  __ enter();\n+  __ enter(\/*strip_ret_addr*\/true);\n@@ -362,1 +362,1 @@\n-    __ enter();\n+    __ enter(\/*strip_ret_addr*\/true);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-  __ enter();\n+  __ enter(\/*strip_ret_addr*\/true);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,3 @@\n-          range(1, 99)\n+          range(1, 99)                                                  \\\n+  product(ccstr, UseBranchProtection, \"none\",                           \\\n+          \"Branch Protection to use: none, standard, pac-ret\")          \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1140,0 +1140,2 @@\n+  strip_return_address(); \/\/ This might happen within a stack frame.\n+  protect_return_address();\n@@ -1153,0 +1155,1 @@\n+  authenticate_return_address();\n@@ -1169,0 +1172,2 @@\n+  strip_return_address(); \/\/ This might happen within a stack frame.\n+  protect_return_address();\n@@ -1189,0 +1194,1 @@\n+  authenticate_return_address();\n@@ -4299,0 +4305,1 @@\n+  protect_return_address();\n@@ -4331,0 +4338,1 @@\n+  authenticate_return_address();\n@@ -4334,2 +4342,2 @@\n-\/\/ This method checks if provided byte array contains byte with highest bit set.\n-address MacroAssembler::has_negatives(Register ary1, Register len, Register result) {\n+\/\/ This method counts leading positive bytes (highest bit not set) in provided byte array\n+address MacroAssembler::count_positives(Register ary1, Register len, Register result) {\n@@ -4342,0 +4350,1 @@\n+    mov(result, len);\n@@ -4343,1 +4352,1 @@\n-    br(LE, SET_RESULT);\n+    br(LE, DONE);\n@@ -4362,1 +4371,1 @@\n-    br(EQ, SET_RESULT);\n+    br(EQ, DONE);\n@@ -4365,5 +4374,6 @@\n-    ldr(result, Address(ary1));\n-    sub(len, zr, len, LSL, 3); \/\/ LSL 3 is to get bits from bytes\n-    lslv(result, result, len);\n-    tst(result, UPPER_BIT_MASK);\n-    b(SET_RESULT);\n+    ldr(rscratch1, Address(ary1));\n+    sub(rscratch2, zr, len, LSL, 3); \/\/ LSL 3 is to get bits from bytes\n+    lslv(rscratch1, rscratch1, rscratch2);\n+    tst(rscratch1, UPPER_BIT_MASK);\n+    br(NE, SET_RESULT);\n+    b(DONE);\n@@ -4372,3 +4382,3 @@\n-    RuntimeAddress has_neg = RuntimeAddress(StubRoutines::aarch64::has_negatives());\n-    assert(has_neg.target() != NULL, \"has_negatives stub has not been generated\");\n-    address tpc1 = trampoline_call(has_neg);\n+    RuntimeAddress count_pos = RuntimeAddress(StubRoutines::aarch64::count_positives());\n+    assert(count_pos.target() != NULL, \"count_positives stub has not been generated\");\n+    address tpc1 = trampoline_call(count_pos);\n@@ -4383,3 +4393,3 @@\n-    RuntimeAddress has_neg_long = RuntimeAddress(StubRoutines::aarch64::has_negatives_long());\n-    assert(has_neg_long.target() != NULL, \"has_negatives stub has not been generated\");\n-    address tpc2 = trampoline_call(has_neg_long);\n+    RuntimeAddress count_pos_long = RuntimeAddress(StubRoutines::aarch64::count_positives_long());\n+    assert(count_pos_long.target() != NULL, \"count_positives_long stub has not been generated\");\n+    address tpc2 = trampoline_call(count_pos_long);\n@@ -4394,1 +4404,3 @@\n-    cset(result, NE); \/\/ set true or false\n+\n+    add(len, len, wordSize);\n+    sub(result, result, len);\n@@ -5172,0 +5184,1 @@\n+  protect_return_address();\n@@ -5181,0 +5194,1 @@\n+  authenticate_return_address();\n@@ -5272,0 +5286,99 @@\n+\n+\/\/ Stack frame creation\/removal\n+\n+void MacroAssembler::enter(bool strip_ret_addr) {\n+  if (strip_ret_addr) {\n+    \/\/ Addresses can only be signed once. If there are multiple nested frames being created\n+    \/\/ in the same function, then the return address needs stripping first.\n+    strip_return_address();\n+  }\n+  protect_return_address();\n+  stp(rfp, lr, Address(pre(sp, -2 * wordSize)));\n+  mov(rfp, sp);\n+}\n+\n+void MacroAssembler::leave() {\n+  mov(sp, rfp);\n+  ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n+  authenticate_return_address();\n+}\n+\n+\/\/ ROP Protection\n+\/\/ Use the AArch64 PAC feature to add ROP protection for generated code. Use whenever creating\/\n+\/\/ destroying stack frames or whenever directly loading\/storing the LR to memory.\n+\/\/ If ROP protection is not set then these functions are no-ops.\n+\/\/ For more details on PAC see pauth_aarch64.hpp.\n+\n+\/\/ Sign the LR. Use during construction of a stack frame, before storing the LR to memory.\n+\/\/ Uses the FP as the modifier.\n+\/\/\n+void MacroAssembler::protect_return_address() {\n+  if (VM_Version::use_rop_protection()) {\n+    check_return_address();\n+    \/\/ The standard convention for C code is to use paciasp, which uses SP as the modifier. This\n+    \/\/ works because in C code, FP and SP match on function entry. In the JDK, SP and FP may not\n+    \/\/ match, so instead explicitly use the FP.\n+    pacia(lr, rfp);\n+  }\n+}\n+\n+\/\/ Sign the return value in the given register. Use before updating the LR in the exisiting stack\n+\/\/ frame for the current function.\n+\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n+\/\/ the current FP.\n+\/\/\n+void MacroAssembler::protect_return_address(Register return_reg, Register temp_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n+    check_return_address(return_reg);\n+    ldr(temp_reg, Address(rfp));\n+    pacia(return_reg, temp_reg);\n+  }\n+}\n+\n+\/\/ Authenticate the LR. Use before function return, after restoring FP and loading LR from memory.\n+\/\/\n+void MacroAssembler::authenticate_return_address(Register return_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    autia(return_reg, rfp);\n+    check_return_address(return_reg);\n+  }\n+}\n+\n+\/\/ Authenticate the return value in the given register. Use before updating the LR in the exisiting\n+\/\/ stack frame for the current function.\n+\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n+\/\/ the current FP.\n+\/\/\n+void MacroAssembler::authenticate_return_address(Register return_reg, Register temp_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n+    ldr(temp_reg, Address(rfp));\n+    autia(return_reg, temp_reg);\n+    check_return_address(return_reg);\n+  }\n+}\n+\n+\/\/ Strip any PAC data from LR without performing any authentication. Use with caution - only if\n+\/\/ there is no guaranteed way of authenticating the LR.\n+\/\/\n+void MacroAssembler::strip_return_address() {\n+  if (VM_Version::use_rop_protection()) {\n+    xpaclri();\n+  }\n+}\n+\n+#ifndef PRODUCT\n+\/\/ PAC failures can be difficult to debug. After an authentication failure, a segfault will only\n+\/\/ occur when the pointer is used - ie when the program returns to the invalid LR. At this point\n+\/\/ it is difficult to debug back to the callee function.\n+\/\/ This function simply loads from the address in the given register.\n+\/\/ Use directly after authentication to catch authentication failures.\n+\/\/ Also use before signing to check that the pointer is valid and hasn't already been signed.\n+\/\/\n+void MacroAssembler::check_return_address(Register return_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    ldr(zr, Address(return_reg));\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":129,"deletions":16,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -691,10 +691,10 @@\n-  void enter()\n-  {\n-    stp(rfp, lr, Address(pre(sp, -2 * wordSize)));\n-    mov(rfp, sp);\n-  }\n-  void leave()\n-  {\n-    mov(sp, rfp);\n-    ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n-  }\n+  void enter(bool strip_ret_addr = false);\n+  void leave();\n+\n+  \/\/ ROP Protection\n+  void protect_return_address();\n+  void protect_return_address(Register return_reg, Register temp_reg);\n+  void authenticate_return_address(Register return_reg = lr);\n+  void authenticate_return_address(Register return_reg, Register temp_reg);\n+  void strip_return_address();\n+  void check_return_address(Register return_reg=lr) PRODUCT_RETURN;\n@@ -1237,1 +1237,1 @@\n-  address has_negatives(Register ary1, Register len, Register result);\n+  address count_positives(Register ary1, Register len, Register result);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -166,0 +166,6 @@\n+  \/\/ Returns pre-selection estimated size of a vector operation.\n+  static int vector_op_pre_select_sz_estimate(int vopc, BasicType ety, int vlen) {\n+    return 0;\n+  }\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n@@ -30,0 +30,39 @@\n+\/\/ Support for ROP Protection in VM code.\n+\/\/ This is provided via the AArch64 PAC feature.\n+\/\/ For more details on PAC see The Arm ARM, section \"Pointer authentication in AArch64 state\".\n+\/\/\n+\/\/ PAC provides a method to sign and authenticate pointer values. Signing combines the register\n+\/\/ being signed, an additional modifier and a per-process secret key, writing the result to unused\n+\/\/ high bits of the signed register. Once signed a register must be authenticated or stripped\n+\/\/ before it can be used.\n+\/\/ Authentication reverses the signing operation, clearing the high bits. If the signed register\n+\/\/ or modifier has changed then authentication will fail and invalid data will be written to the\n+\/\/ high bits and the next time the pointer is used a segfault will be raised.\n+\/\/\n+\/\/ Assume a malicious attacker is able to edit the stack via an exploit. Control flow can be\n+\/\/ changed by re-writing the return values stored on the stack. ROP protection prevents this by\n+\/\/ signing return addresses before saving them on the stack, then authenticating when they are\n+\/\/ loaded back. The scope of this protection is per function (a value is signed and authenticated\n+\/\/ by the same function), therefore it is possible for different functions within the same\n+\/\/ program to use different signing methods.\n+\/\/\n+\/\/ The VM and native code is protected by compiling with the GCC AArch64 branch protection flag.\n+\/\/\n+\/\/ All generated code is protected via the ROP functions provided in macroAssembler.\n+\/\/\n+\/\/ In addition, the VM needs to be aware of PAC whenever viewing or editing the stack. Functions\n+\/\/ are provided here and in the OS specific files. We should assume all stack frames for generated\n+\/\/ code have signed return values. Rewriting the stack should ensure new values are correctly\n+\/\/ signed. However, we cannot make any assumptions about how (or if) native code uses PAC - here\n+\/\/ we should limit access to viewing via stripping.\n+\/\/\n+\n+\n+\/\/ Confirm the given pointer has not been signed - ie none of the high bits are set.\n+\/\/\n+\/\/ Note this can give false positives. The PAC signing can generate a signature with all signing\n+\/\/ bits as zeros, causing this function to return true. Therefore this should only be used for\n+\/\/ assert style checking. In addition, this function should never be used with a \"not\" to confirm\n+\/\/ a pointer is signed, as it will fail the above case. The only safe way to do this is to instead\n+\/\/ authenticate the pointer.\n+\/\/\n@@ -31,1 +70,0 @@\n-  \/\/ Confirm none of the high bits are set in the pointer.\n@@ -35,0 +73,11 @@\n+\/\/ Strip a return value (same as pauth_strip_pointer). When debug is enabled then authenticate\n+\/\/ instead.\n+\/\/\n+inline address pauth_strip_verifiable(address ret_addr, address modifier) {\n+  if (VM_Version::use_rop_protection()) {\n+    DEBUG_ONLY(ret_addr = pauth_authenticate_return_address(ret_addr, modifier);)\n+    NOT_DEBUG(ret_addr = pauth_strip_pointer(ret_addr));\n+  }\n+  return ret_addr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/pauth_aarch64.hpp","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -413,0 +413,1 @@\n+  __ authenticate_return_address(c_rarg1, rscratch1);\n@@ -2181,1 +2182,0 @@\n-\n@@ -2183,0 +2183,1 @@\n+  __ protect_return_address(r3, rscratch1);\n@@ -2290,0 +2291,1 @@\n+  __ authenticate_return_address();\n@@ -2431,0 +2433,1 @@\n+  __ protect_return_address();\n@@ -2505,0 +2508,1 @@\n+  __ authenticate_return_address();\n@@ -2627,0 +2631,5 @@\n+  \/\/ When the signal occured, the LR was either signed and stored on the stack (in which\n+  \/\/ case it will be restored from the stack before being used) or unsigned and not stored\n+  \/\/ on the stack. Stipping ensures we get the right value.\n+  __ strip_return_address();\n+\n@@ -2646,0 +2655,1 @@\n+    __ protect_return_address(r20, rscratch1);\n@@ -2686,0 +2696,1 @@\n+    __ authenticate_return_address(r20, rscratch1);\n@@ -2700,0 +2711,1 @@\n+    __ protect_return_address(r20, rscratch1);\n@@ -2860,0 +2872,1 @@\n+  __ protect_return_address();\n@@ -2913,0 +2926,1 @@\n+  __ authenticate_return_address(r3);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4660,1 +4660,1 @@\n-  address generate_has_negatives(address &has_negatives_long) {\n+  address generate_count_positives(address &count_positives_long) {\n@@ -4669,1 +4669,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"has_negatives\");\n+    StubCodeMark mark(this, \"StubRoutines\", \"count_positives\");\n@@ -4674,0 +4674,2 @@\n+    \/\/ precondition: a copy of len is already in result\n+    \/\/ __ mov(result, len);\n@@ -4675,1 +4677,1 @@\n-  Label RET_TRUE, RET_TRUE_NO_POP, RET_FALSE, ALIGNED, LOOP16, CHECK_16, DONE,\n+  Label RET_ADJUST, RET_ADJUST_16, RET_ADJUST_LONG, RET_NO_POP, RET_LEN, ALIGNED, LOOP16, CHECK_16,\n@@ -4689,1 +4691,1 @@\n-  __ cset(result, Assembler::NE);\n+  __ csel(result, zr, result, Assembler::NE);\n@@ -4696,1 +4698,1 @@\n-  __ br(Assembler::NE, RET_TRUE_NO_POP);\n+  __ br(Assembler::NE, RET_NO_POP);\n@@ -4700,1 +4702,2 @@\n-  __ cset(result, Assembler::NE);\n+  __ bind(RET_NO_POP);\n+  __ csel(result, zr, result, Assembler::NE);\n@@ -4707,1 +4710,1 @@\n-  has_negatives_long = __ pc(); \/\/ 2nd entry point\n+  count_positives_long = __ pc(); \/\/ 2nd entry point\n@@ -4719,1 +4722,0 @@\n-    __ sub(len, len, rscratch1);\n@@ -4722,1 +4724,2 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST);\n+    __ sub(len, len, rscratch1);\n@@ -4737,1 +4740,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST_16);\n@@ -4769,1 +4772,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST_LONG);\n@@ -4782,1 +4785,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST_16);\n@@ -4790,1 +4793,0 @@\n-    __ sub(len, len, 8);\n@@ -4792,1 +4794,2 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST);\n+    __ sub(len, len, 8);\n@@ -4795,1 +4798,1 @@\n-    __ cbz(len, RET_FALSE); \/\/ Can't shift left by 64 when len==0\n+    __ cbz(len, RET_LEN); \/\/ Can't shift left by 64 when len==0\n@@ -4801,1 +4804,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST);\n@@ -4804,1 +4807,1 @@\n-  __ bind(RET_FALSE);\n+  __ bind(RET_LEN);\n@@ -4807,1 +4810,0 @@\n-    __ mov(result, zr);\n@@ -4810,6 +4812,2 @@\n-  __ bind(RET_TRUE);\n-    __ pop(spilled_regs, sp);\n-  __ bind(RET_TRUE_NO_POP);\n-    __ leave();\n-    __ mov(result, 1);\n-    __ ret(lr);\n+    \/\/ difference result - len is the count of guaranteed to be\n+    \/\/ positive bytes\n@@ -4817,1 +4815,5 @@\n-  __ bind(DONE);\n+  __ bind(RET_ADJUST_LONG);\n+    __ add(len, len, (u1)(large_loop_size - 16));\n+  __ bind(RET_ADJUST_16);\n+    __ add(len, len, 16);\n+  __ bind(RET_ADJUST);\n@@ -4820,0 +4822,1 @@\n+    __ sub(result, result, len);\n@@ -4821,0 +4824,1 @@\n+\n@@ -7522,2 +7526,2 @@\n-    \/\/ has negatives stub for large arrays.\n-    StubRoutines::aarch64::_has_negatives = generate_has_negatives(StubRoutines::aarch64::_has_negatives_long);\n+    \/\/ countPositives stub for large arrays.\n+    StubRoutines::aarch64::_count_positives = generate_count_positives(StubRoutines::aarch64::_count_positives_long);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":31,"deletions":27,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-address StubRoutines::aarch64::_has_negatives = NULL;\n-address StubRoutines::aarch64::_has_negatives_long = NULL;\n+address StubRoutines::aarch64::_count_positives = NULL;\n+address StubRoutines::aarch64::_count_positives_long = NULL;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-  static address _has_negatives;\n-  static address _has_negatives_long;\n+  static address _count_positives;\n+  static address _count_positives_long;\n@@ -135,2 +135,2 @@\n-  static address has_negatives() {\n-    return _has_negatives;\n+  static address count_positives() {\n+    return _count_positives;\n@@ -139,2 +139,2 @@\n-  static address has_negatives_long() {\n-      return _has_negatives_long;\n+  static address count_positives_long() {\n+      return _count_positives_long;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -835,0 +835,1 @@\n+  __ protect_return_address();\n@@ -1751,0 +1752,2 @@\n+    \/\/ This is a return address, so requires authenticating for PAC.\n+    __ authenticate_return_address(c_rarg1, rscratch1);\n@@ -1940,0 +1943,1 @@\n+  __ protect_return_address();\n@@ -1950,0 +1954,1 @@\n+  __ authenticate_return_address();\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+bool VM_Version::_rop_protection;\n@@ -412,0 +413,33 @@\n+  if (UseBranchProtection == nullptr || strcmp(UseBranchProtection, \"none\") == 0) {\n+    _rop_protection = false;\n+  } else if (strcmp(UseBranchProtection, \"standard\") == 0) {\n+    _rop_protection = false;\n+    \/\/ Enable PAC if this code has been built with branch-protection and the CPU\/OS supports it.\n+#ifdef __ARM_FEATURE_PAC_DEFAULT\n+    if ((_features & CPU_PACA) != 0) {\n+      _rop_protection = true;\n+    }\n+#endif\n+  } else if (strcmp(UseBranchProtection, \"pac-ret\") == 0) {\n+    _rop_protection = true;\n+#ifdef __ARM_FEATURE_PAC_DEFAULT\n+    if ((_features & CPU_PACA) == 0) {\n+      warning(\"ROP-protection specified, but not supported on this CPU.\");\n+      \/\/ Disable PAC to prevent illegal instruction crashes.\n+      _rop_protection = false;\n+    }\n+#else\n+    warning(\"ROP-protection specified, but this VM was built without ROP-protection support.\");\n+#endif\n+  } else {\n+    vm_exit_during_initialization(err_msg(\"Unsupported UseBranchProtection: %s\", UseBranchProtection));\n+  }\n+\n+  \/\/ The frame pointer must be preserved for ROP protection.\n+  if (_rop_protection == true) {\n+    if (FLAG_IS_DEFAULT(PreserveFramePointer) == false && PreserveFramePointer == false ) {\n+      vm_exit_during_initialization(err_msg(\"PreserveFramePointer cannot be disabled for ROP-protection\"));\n+    }\n+    PreserveFramePointer = true;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+  static bool _rop_protection;\n@@ -117,0 +118,1 @@\n+    decl(PACA,          \"paca\",          30)  \\\n@@ -120,1 +122,1 @@\n-    decl(A53MAC,        \"a53mac\",        30)\n+    decl(A53MAC,        \"a53mac\",        31)\n@@ -159,0 +161,1 @@\n+  static bool use_rop_protection() { return _rop_protection; }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -158,0 +158,5 @@\n+  \/\/ Returns pre-selection estimated cost of a vector operation.\n+  static int vector_op_pre_select_sz_estimate(int vopc, BasicType ety, int vlen) {\n+    return 0;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -568,2 +568,2 @@\n-void C2_MacroAssembler::has_negatives(Register src, Register cnt, Register result,\n-                                      Register tmp1, Register tmp2) {\n+void C2_MacroAssembler::count_positives(Register src, Register cnt, Register result,\n+                                        Register tmp1, Register tmp2) {\n@@ -572,1 +572,1 @@\n-  Label Lfastloop, Lslow, Lloop, Lnoneg, Ldone;\n+  Label Lfastloop, Lslow, Lloop, Ldone;\n@@ -577,1 +577,1 @@\n-  li(result, 1);                  \/\/ Assume there's a negative byte.\n+  mr(result, src);                \/\/ Use result reg to point to the current position.\n@@ -585,2 +585,2 @@\n-  ld(tmp2, 0, src);\n-  ld(tmp0, 8, src);\n+  ld(tmp2, 0, result);\n+  ld(tmp0, 8, result);\n@@ -591,3 +591,2 @@\n-  bne(CCR0, Ldone);               \/\/ Found negative byte.\n-  addi(src, src, 16);\n-\n+  bne(CCR0, Lslow);               \/\/ Found negative byte.\n+  addi(result, result, 16);\n@@ -596,3 +595,4 @@\n-  bind(Lslow);                    \/\/ Fallback to slow version\n-  rldicl_(tmp0, cnt, 0, 64-4);\n-  beq(CCR0, Lnoneg);\n+  bind(Lslow);                    \/\/ Fallback to slow version.\n+  subf(tmp0, src, result);        \/\/ Bytes known positive.\n+  subf_(tmp0, tmp0, cnt);         \/\/ Remaining Bytes.\n+  beq(CCR0, Ldone);\n@@ -601,2 +601,1 @@\n-  lbz(tmp0, 0, src);\n-  addi(src, src, 1);\n+  lbz(tmp0, 0, result);\n@@ -605,0 +604,1 @@\n+  addi(result, result, 1);\n@@ -606,2 +606,0 @@\n-  bind(Lnoneg);\n-  li(result, 0);\n@@ -610,0 +608,1 @@\n+  subf(result, src, result);      \/\/ Result is offset from src.\n@@ -611,1 +610,0 @@\n-\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  void has_negatives(Register src, Register cnt, Register result, Register tmp1, Register tmp2);\n+  void count_positives(Register src, Register cnt, Register result, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,15 +56,1 @@\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default: while (count-- > 0) {\n-             *to++ = *from++;\n-           }\n-           break;\n-  }\n+  shared_disjoint_words_atomic(from, to, count);\n","filename":"src\/hotspot\/cpu\/ppc\/copy_ppc.hpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -167,0 +167,6 @@\n+  \/\/ Returns pre-selection estimated cost of a vector operation.\n+  static int vector_op_pre_select_sz_estimate(int vopc, BasicType ety, int vlen) {\n+    return 0;\n+  }\n+\n+\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -12782,2 +12782,2 @@\n-instruct has_negatives(rarg1RegP ary1, iRegIsrc len, iRegIdst result, iRegLdst tmp1, iRegLdst tmp2,\n-                       regCTR ctr, flagsRegCR0 cr0)\n+instruct count_positives(iRegPsrc ary1, iRegIsrc len, iRegIdst result, iRegLdst tmp1, iRegLdst tmp2,\n+                         regCTR ctr, flagsRegCR0 cr0)\n@@ -12785,2 +12785,2 @@\n-  match(Set result (HasNegatives ary1 len));\n-  effect(TEMP_DEF result, USE_KILL ary1, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0);\n+  match(Set result (CountPositives ary1 len));\n+  effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0);\n@@ -12788,1 +12788,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result \\t\/\/ KILL $tmp1, $tmp2\" %}\n+  format %{ \"count positives byte[] $ary1,$len -> $result \\t\/\/ KILL $tmp1, $tmp2\" %}\n@@ -12790,2 +12790,2 @@\n-    __ has_negatives($ary1$$Register, $len$$Register, $result$$Register,\n-                     $tmp1$$Register, $tmp2$$Register);\n+    __ count_positives($ary1$$Register, $len$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -826,46 +826,58 @@\n-\/\/ Kills src.\n-unsigned int C2_MacroAssembler::has_negatives(Register result, Register src, Register cnt,\n-                                              Register odd_reg, Register even_reg, Register tmp) {\n-  int block_start = offset();\n-  Label Lloop1, Lloop2, Lslow, Lnotfound, Ldone;\n-  const Register addr = src, mask = tmp;\n-\n-  BLOCK_COMMENT(\"has_negatives {\");\n-\n-  z_llgfr(Z_R1, cnt);      \/\/ Number of bytes to read. (Must be a positive simm32.)\n-  z_llilf(mask, 0x80808080);\n-  z_lhi(result, 1);        \/\/ Assume true.\n-  \/\/ Last possible addr for fast loop.\n-  z_lay(odd_reg, -16, Z_R1, src);\n-  z_chi(cnt, 16);\n-  z_brl(Lslow);\n-\n-  \/\/ ind1: index, even_reg: index increment, odd_reg: index limit\n-  z_iihf(mask, 0x80808080);\n-  z_lghi(even_reg, 16);\n-\n-  bind(Lloop1); \/\/ 16 bytes per iteration.\n-  z_lg(Z_R0, Address(addr));\n-  z_lg(Z_R1, Address(addr, 8));\n-  z_ogr(Z_R0, Z_R1);\n-  z_ngr(Z_R0, mask);\n-  z_brne(Ldone);           \/\/ If found return 1.\n-  z_brxlg(addr, even_reg, Lloop1);\n-\n-  bind(Lslow);\n-  z_aghi(odd_reg, 16-1);   \/\/ Last possible addr for slow loop.\n-  z_lghi(even_reg, 1);\n-  z_cgr(addr, odd_reg);\n-  z_brh(Lnotfound);\n-\n-  bind(Lloop2); \/\/ 1 byte per iteration.\n-  z_cli(Address(addr), 0x80);\n-  z_brnl(Ldone);           \/\/ If found return 1.\n-  z_brxlg(addr, even_reg, Lloop2);\n-\n-  bind(Lnotfound);\n-  z_lhi(result, 0);\n-\n-  bind(Ldone);\n-\n-  BLOCK_COMMENT(\"} has_negatives\");\n+\/\/ Returns the number of non-negative bytes (aka US-ASCII characters) found\n+\/\/ before the first negative byte is encountered.\n+unsigned int C2_MacroAssembler::count_positives(Register result, Register src, Register cnt, Register tmp) {\n+  const unsigned int block_start   = offset();\n+  const unsigned int byte_mask     = 0x80;\n+  const unsigned int twobyte_mask  = byte_mask<<8 | byte_mask;\n+  const unsigned int unroll_factor = 16;\n+  const unsigned int log_unroll_factor = exact_log2(unroll_factor);\n+  Register pos  = src;     \/\/ current position in src array, restored at end\n+  Register ctr  = result;  \/\/ loop counter, result value\n+  Register mask = tmp;     \/\/ holds the sign detection mask\n+  Label unrolledLoop, unrolledDone, byteLoop, allDone;\n+\n+  assert_different_registers(result, src, cnt, tmp);\n+\n+  BLOCK_COMMENT(\"count_positives {\");\n+\n+  lgr_if_needed(pos, src);              \/\/ current position in src array\n+  z_srak(ctr, cnt, log_unroll_factor);  \/\/ # iterations of unrolled loop\n+  z_brnh(unrolledDone);                 \/\/ array too short for unrolled loop\n+\n+  z_iilf(mask, twobyte_mask<<16 | twobyte_mask);\n+  z_iihf(mask, twobyte_mask<<16 | twobyte_mask);\n+\n+  bind(unrolledLoop);\n+    z_lmg(Z_R0, Z_R1, 0, pos);\n+    z_ogr(Z_R0, Z_R1);\n+    z_ngr(Z_R0, mask);\n+    z_brne(unrolledDone);               \/\/ There is a negative byte somewhere.\n+                                        \/\/ ctr and pos are not updated yet ->\n+                                        \/\/ delegate finding correct pos to byteLoop.\n+    add2reg(pos, unroll_factor);\n+    z_brct(ctr, unrolledLoop);\n+\n+  \/\/ Once we arrive here, we have to examine at most (unroll_factor - 1) bytes more.\n+  \/\/ We then either have reached the end of the array or we hit a negative byte.\n+  bind(unrolledDone);\n+  z_sll(ctr, log_unroll_factor);        \/\/ calculate # bytes not processed by unrolled loop\n+                                        \/\/ > 0 only if a negative byte was found\n+  z_lr(Z_R0, cnt);                      \/\/ calculate remainder bytes\n+  z_nilf(Z_R0, unroll_factor - 1);\n+  z_ar(ctr, Z_R0);                      \/\/ remaining bytes\n+  z_brnh(allDone);                      \/\/ shortcut if nothing left to do\n+\n+  bind(byteLoop);\n+    z_cli(0, pos, byte_mask);           \/\/ unsigned comparison! byte@pos must be smaller that byte_mask\n+    z_brnl(allDone);                    \/\/ negative byte found.\n+\n+    add2reg(pos, 1);\n+    z_brct(ctr, byteLoop);\n+\n+  bind(allDone);\n+\n+  z_srk(ctr, cnt, ctr);                 \/\/ # bytes actually processed (= cnt or index of first negative byte)\n+  z_sgfr(pos, ctr);                     \/\/ restore src\n+  z_lgfr(result, ctr);                  \/\/ unnecessary. Only there to be sure the high word has a defined state.\n+\n+  BLOCK_COMMENT(\"} count_positives\");\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":58,"deletions":46,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -60,3 +60,1 @@\n-  \/\/ Kills src.\n-  unsigned int has_negatives(Register result, Register src, Register cnt,\n-                             Register odd_reg, Register even_reg, Register tmp);\n+  unsigned int count_positives(Register result, Register src, Register cnt, Register tmp);\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,0 +156,5 @@\n+  \/\/ Returns pre-selection estimated cost of a vector operation.\n+  static int vector_op_pre_select_sz_estimate(int vopc, BasicType ety, int vlen) {\n+    return 0;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -10276,3 +10276,3 @@\n-instruct has_negatives(rarg5RegP ary1, iRegI len, iRegI result, roddRegI oddReg, revenRegI evenReg, iRegI tmp, flagsReg cr) %{\n-  match(Set result (HasNegatives ary1 len));\n-  effect(TEMP_DEF result, USE_KILL ary1, TEMP oddReg, TEMP evenReg, TEMP tmp, KILL cr); \/\/ R0, R1 are killed, too.\n+instruct count_positives(iRegP ary1, iRegI len, iRegI result, iRegI tmp, flagsReg cr) %{\n+  match(Set result (CountPositives ary1 len));\n+  effect(TEMP_DEF result, TEMP tmp, KILL cr); \/\/ R0, R1 are killed, too.\n@@ -10280,1 +10280,1 @@\n-  format %{ \"has negatives byte[] $ary1($len) -> $result\" %}\n+  format %{ \"count positives byte[] $ary1($len) -> $result\" %}\n@@ -10282,2 +10282,1 @@\n-    __ has_negatives($result$$Register, $ary1$$Register, $len$$Register,\n-                     $oddReg$$Register, $evenReg$$Register, $tmp$$Register);\n+    __ count_positives($result$$Register, $ary1$$Register, $len$$Register, $tmp$$Register);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -303,2 +303,1 @@\n-  assert((op1 & 0x01) == 1, \"should be 32bit operation\");\n-  assert((op1 & 0x02) == 0, \"sign-extension bit should not be set\");\n+  assert(op1 == 0x81, \"Unexpected opcode\");\n@@ -309,0 +308,13 @@\n+  } else if (dst == rax) {\n+    switch (op2) {\n+      case 0xD0: emit_int8(0x15); break; \/\/ adc\n+      case 0xC0: emit_int8(0x05); break; \/\/ add\n+      case 0xE0: emit_int8(0x25); break; \/\/ and\n+      case 0xF8: emit_int8(0x3D); break; \/\/ cmp\n+      case 0xC8: emit_int8(0x0D); break; \/\/ or\n+      case 0xD8: emit_int8(0x1D); break; \/\/ sbb\n+      case 0xE8: emit_int8(0x2D); break; \/\/ sub\n+      case 0xF0: emit_int8(0x35); break; \/\/ xor\n+      default: ShouldNotReachHere();\n+    }\n+    emit_int32(imm32);\n@@ -932,0 +944,10 @@\n+  case 0x15: \/\/ adc rax, #32\n+  case 0x05: \/\/ add rax, #32\n+  case 0x25: \/\/ and rax, #32\n+  case 0x3D: \/\/ cmp rax, #32\n+  case 0x0D: \/\/ or  rax, #32\n+  case 0x1D: \/\/ sbb rax, #32\n+  case 0x2D: \/\/ sub rax, #32\n+  case 0x35: \/\/ xor rax, #32\n+    return which == end_pc_operand ? ip + 4 : ip;\n+\n@@ -957,0 +979,5 @@\n+  case 0xA8: \/\/ testb rax, #8\n+    return which == end_pc_operand ? ip + 1 : ip;\n+  case 0xA9: \/\/ testl\/testq rax, #32\n+    return which == end_pc_operand ? ip + 4 : ip;\n+\n@@ -1686,6 +1713,0 @@\n-void Assembler::cmp(Register dst, int32_t imm32) {\n-  prefix(dst);\n-  emit_int8((unsigned char)0x3D);\n-  emit_int32(imm32);\n-}\n-\n@@ -5778,2 +5799,7 @@\n-  (void) prefix_and_encode(dst->encoding(), true);\n-  emit_arith_b(0xF6, 0xC0, dst, imm8);\n+  if (dst == rax) {\n+    emit_int8((unsigned char)0xA8);\n+    emit_int8(imm8);\n+  } else {\n+    (void) prefix_and_encode(dst->encoding(), true);\n+    emit_arith_b(0xF6, 0xC0, dst, imm8);\n+  }\n@@ -5790,0 +5816,11 @@\n+void Assembler::testl(Address dst, int32_t imm32) {\n+  if (imm32 >= 0 && is8bit(imm32)) {\n+    testb(dst, imm32);\n+    return;\n+  }\n+  InstructionMark im(this);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(as_Register(0), dst);\n+  emit_int32(imm32);\n+}\n+\n@@ -5791,0 +5828,4 @@\n+  if (imm32 >= 0 && is8bit(imm32) && dst->has_byte_register()) {\n+    testb(dst, imm32);\n+    return;\n+  }\n@@ -5794,4 +5835,9 @@\n-  int encode = dst->encoding();\n-  encode = prefix_and_encode(encode);\n-  emit_int16((unsigned char)0xF7, (0xC0 | encode));\n-  emit_int32(imm32);\n+  if (dst == rax) {\n+    emit_int8((unsigned char)0xA9);\n+    emit_int32(imm32);\n+  } else {\n+    int encode = dst->encoding();\n+    encode = prefix_and_encode(encode);\n+    emit_int16((unsigned char)0xF7, (0xC0 | encode));\n+    emit_int32(imm32);\n+  }\n@@ -8398,1 +8444,20 @@\n-\/\/ xmm\/mem sourced byte\/word\/dword\/qword replicate\n+void Assembler::vpsadbw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16((unsigned char)0xF6, (0xC0 | encode));\n+}\n+\n+void Assembler::vpunpckhdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x6A, (0xC0 | encode));\n+}\n+\n+void Assembler::vpunpckldq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x62, (0xC0 | encode));\n+}\n@@ -8400,0 +8465,1 @@\n+\/\/ xmm\/mem sourced byte\/word\/dword\/qword replicate\n@@ -9945,1 +10011,1 @@\n-  assert(VM_Version::supports_avx512dq(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -9950,1 +10016,1 @@\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T2, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T4, \/* input_size_in_bits *\/ EVEX_32bit);\n@@ -13147,0 +13213,4 @@\n+  if (imm32 >= 0) {\n+    testl(dst, imm32);\n+    return;\n+  }\n@@ -13154,0 +13224,4 @@\n+  if (imm32 >= 0) {\n+    testl(dst, imm32);\n+    return;\n+  }\n@@ -13157,4 +13231,10 @@\n-  int encode = dst->encoding();\n-  encode = prefixq_and_encode(encode);\n-  emit_int16((unsigned char)0xF7, (0xC0 | encode));\n-  emit_int32(imm32);\n+  if (dst == rax) {\n+    prefix(REX_W);\n+    emit_int8((unsigned char)0xA9);\n+    emit_int32(imm32);\n+  } else {\n+    int encode = dst->encoding();\n+    encode = prefixq_and_encode(encode);\n+    emit_int16((unsigned char)0xF7, (0xC0 | encode));\n+    emit_int32(imm32);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":101,"deletions":21,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -1084,2 +1084,0 @@\n-\n-  void cmp(Register dst, int32_t imm32);\n@@ -1092,1 +1090,0 @@\n-\n@@ -1936,0 +1933,4 @@\n+  void vpunpckldq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+\n+  \/\/ Interleave High Doublewords\n+  void vpunpckhdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n@@ -1940,0 +1941,3 @@\n+  \/\/ Vector sum of absolute difference.\n+  void vpsadbw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+\n@@ -2095,1 +2099,0 @@\n-  void testb(Register dst, int imm8);\n@@ -2097,0 +2100,1 @@\n+  void testb(Register dst, int imm8);\n@@ -2098,0 +2102,1 @@\n+  void testl(Address dst, int32_t imm32);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3377,1 +3377,2 @@\n-\/\/ return true if it has any and false otherwise.\n+\/\/ return the index of the first such character, otherwise the length\n+\/\/ of the array segment searched.\n@@ -3380,1 +3381,1 @@\n-\/\/   private static boolean hasNegatives(byte[] ba, int off, int len) {\n+\/\/   public static int countPositives(byte[] ba, int off, int len) {\n@@ -3383,1 +3384,1 @@\n-\/\/         return true;\n+\/\/         return i - off;\n@@ -3386,1 +3387,1 @@\n-\/\/     return false;\n+\/\/     return len;\n@@ -3388,1 +3389,1 @@\n-void C2_MacroAssembler::has_negatives(Register ary1, Register len,\n+void C2_MacroAssembler::count_positives(Register ary1, Register len,\n@@ -3397,1 +3398,1 @@\n-  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;\n+  Label ADJUST, TAIL_ADJUST, DONE, TAIL_START, CHAR_ADJUST, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;\n@@ -3399,0 +3400,1 @@\n+  movl(result, len); \/\/ copy\n@@ -3401,1 +3403,1 @@\n-  jcc(Assembler::zero, FALSE_LABEL);\n+  jcc(Assembler::zero, DONE);\n@@ -3407,1 +3409,1 @@\n-    Label test_64_loop, test_tail;\n+    Label test_64_loop, test_tail, BREAK_LOOP;\n@@ -3424,1 +3426,1 @@\n-    jcc(Assembler::notZero, TRUE_LABEL);\n+    jcc(Assembler::notZero, BREAK_LOOP);\n@@ -3429,1 +3431,0 @@\n-\n@@ -3433,1 +3434,1 @@\n-    jcc(Assembler::zero, FALSE_LABEL);\n+    jcc(Assembler::zero, DONE);\n@@ -3470,1 +3471,1 @@\n-    jcc(Assembler::notZero, TRUE_LABEL);\n+    jcc(Assembler::zero, DONE);\n@@ -3472,1 +3473,11 @@\n-    jmp(FALSE_LABEL);\n+    bind(BREAK_LOOP);\n+    \/\/ At least one byte in the last 64 bytes is negative.\n+    \/\/ Set up to look at the last 64 bytes as if they were a tail\n+    lea(ary1, Address(ary1, len, Address::times_1));\n+    addptr(result, len);\n+    \/\/ Ignore the very last byte: if all others are positive,\n+    \/\/ it must be negative, so we can skip right to the 2+1 byte\n+    \/\/ end comparison at this point\n+    orl(result, 63);\n+    movl(len, 63);\n+    \/\/ Fallthru to tail compare\n@@ -3474,1 +3485,0 @@\n-    movl(result, len); \/\/ copy\n@@ -3478,1 +3488,1 @@\n-      Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+      Label COMPARE_WIDE_VECTORS, BREAK_LOOP;\n@@ -3481,3 +3491,2 @@\n-      andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n-      andl(len, 0xffffffe0);   \/\/ vector count (in bytes)\n-      jccb(Assembler::zero, COMPARE_TAIL);\n+      testl(len, 0xffffffe0);   \/\/ vector count (in bytes)\n+      jccb(Assembler::zero, TAIL_START);\n@@ -3485,0 +3494,1 @@\n+      andl(len, 0xffffffe0);\n@@ -3495,1 +3505,1 @@\n-      jccb(Assembler::notZero, TRUE_LABEL);\n+      jccb(Assembler::notZero, BREAK_LOOP);\n@@ -3497,1 +3507,1 @@\n-      jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+      jccb(Assembler::notZero, COMPARE_WIDE_VECTORS);\n@@ -3499,2 +3509,2 @@\n-      testl(result, result);\n-      jccb(Assembler::zero, FALSE_LABEL);\n+      testl(result, 0x0000001f);   \/\/ any bytes remaining?\n+      jcc(Assembler::zero, DONE);\n@@ -3502,1 +3512,4 @@\n-      vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n+      \/\/ Quick test using the already prepared vector mask\n+      movl(len, result);\n+      andl(len, 0x0000001f);\n+      vmovdqu(vec1, Address(ary1, len, Address::times_1, -32));\n@@ -3504,2 +3517,3 @@\n-      jccb(Assembler::notZero, TRUE_LABEL);\n-      jmpb(FALSE_LABEL);\n+      jcc(Assembler::zero, DONE);\n+      \/\/ There are zeros, jump to the tail to determine exactly where\n+      jmpb(TAIL_START);\n@@ -3507,2 +3521,10 @@\n-      bind(COMPARE_TAIL); \/\/ len is zero\n-      movl(len, result);\n+      bind(BREAK_LOOP);\n+      \/\/ At least one byte in the last 32-byte vector is negative.\n+      \/\/ Set up to look at the last 32 bytes as if they were a tail\n+      lea(ary1, Address(ary1, len, Address::times_1));\n+      addptr(result, len);\n+      \/\/ Ignore the very last byte: if all others are positive,\n+      \/\/ it must be negative, so we can skip right to the 2+1 byte\n+      \/\/ end comparison at this point\n+      orl(result, 31);\n+      movl(len, 31);\n@@ -3512,1 +3534,1 @@\n-      Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+      Label COMPARE_WIDE_VECTORS, BREAK_LOOP;\n@@ -3515,3 +3537,2 @@\n-      andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n-      andl(len, 0xfffffff0);   \/\/ vector count (in bytes)\n-      jcc(Assembler::zero, COMPARE_TAIL);\n+      testl(len, 0xfffffff0);   \/\/ vector count (in bytes)\n+      jcc(Assembler::zero, TAIL_START);\n@@ -3519,0 +3540,1 @@\n+      andl(len, 0xfffffff0);\n@@ -3529,1 +3551,1 @@\n-      jcc(Assembler::notZero, TRUE_LABEL);\n+      jccb(Assembler::notZero, BREAK_LOOP);\n@@ -3531,1 +3553,1 @@\n-      jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+      jccb(Assembler::notZero, COMPARE_WIDE_VECTORS);\n@@ -3533,2 +3555,2 @@\n-      testl(result, result);\n-      jcc(Assembler::zero, FALSE_LABEL);\n+      testl(result, 0x0000000f); \/\/ len is zero, any bytes remaining?\n+      jcc(Assembler::zero, DONE);\n@@ -3536,1 +3558,4 @@\n-      movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n+      \/\/ Quick test using the already prepared vector mask\n+      movl(len, result);\n+      andl(len, 0x0000000f);   \/\/ tail count (in bytes)\n+      movdqu(vec1, Address(ary1, len, Address::times_1, -16));\n@@ -3538,2 +3563,2 @@\n-      jccb(Assembler::notZero, TRUE_LABEL);\n-      jmpb(FALSE_LABEL);\n+      jcc(Assembler::zero, DONE);\n+      jmpb(TAIL_START);\n@@ -3541,2 +3566,10 @@\n-      bind(COMPARE_TAIL); \/\/ len is zero\n-      movl(len, result);\n+      bind(BREAK_LOOP);\n+      \/\/ At least one byte in the last 16-byte vector is negative.\n+      \/\/ Set up and look at the last 16 bytes as if they were a tail\n+      lea(ary1, Address(ary1, len, Address::times_1));\n+      addptr(result, len);\n+      \/\/ Ignore the very last byte: if all others are positive,\n+      \/\/ it must be negative, so we can skip right to the 2+1 byte\n+      \/\/ end comparison at this point\n+      orl(result, 15);\n+      movl(len, 15);\n@@ -3546,0 +3579,2 @@\n+\n+  bind(TAIL_START);\n@@ -3556,1 +3591,1 @@\n-  jccb(Assembler::notZero, TRUE_LABEL);\n+  jccb(Assembler::notZero, TAIL_ADJUST);\n@@ -3558,1 +3593,1 @@\n-  jcc(Assembler::notZero, COMPARE_VECTORS);\n+  jccb(Assembler::notZero, COMPARE_VECTORS);\n@@ -3560,1 +3595,1 @@\n-  \/\/ Compare trailing char (final 2 bytes), if any\n+  \/\/ Compare trailing char (final 2-3 bytes), if any\n@@ -3562,0 +3597,1 @@\n+\n@@ -3566,2 +3602,1 @@\n-  jccb(Assembler::notZero, TRUE_LABEL);\n-  subptr(result, 2);\n+  jccb(Assembler::notZero, CHAR_ADJUST);\n@@ -3572,1 +3607,1 @@\n-  jccb(Assembler::zero, FALSE_LABEL);\n+  jccb(Assembler::zero, DONE);\n@@ -3574,6 +3609,3 @@\n-  andl(tmp1, 0x00000080);\n-  jccb(Assembler::notEqual, TRUE_LABEL);\n-  jmpb(FALSE_LABEL);\n-\n-  bind(TRUE_LABEL);\n-  movl(result, 1);   \/\/ return true\n+  testl(tmp1, 0x00000080);\n+  jccb(Assembler::zero, DONE);\n+  subptr(result, 1);\n@@ -3582,2 +3614,16 @@\n-  bind(FALSE_LABEL);\n-  xorl(result, result); \/\/ return false\n+  bind(TAIL_ADJUST);\n+  \/\/ there are negative bits in the last 4 byte block.\n+  \/\/ Adjust result and check the next three bytes\n+  addptr(result, len);\n+  orl(result, 3);\n+  lea(ary1, Address(ary1, len, Address::times_1));\n+  jmpb(COMPARE_CHAR);\n+\n+  bind(CHAR_ADJUST);\n+  \/\/ We are looking at a char + optional byte tail, and found that one\n+  \/\/ of the bytes in the char is negative. Adjust the result, check the\n+  \/\/ first byte and readjust if needed.\n+  andl(result, 0xfffffffc);\n+  testl(tmp1, 0x00000080); \/\/ little-endian, so lowest byte comes first\n+  jccb(Assembler::notZero, DONE);\n+  addptr(result, 1);\n@@ -3593,0 +3639,1 @@\n+\n@@ -4389,0 +4436,89 @@\n+\n+\/\/\n+\/\/ Following is lookup table based popcount computation algorithm:-\n+\/\/       Index   Bit set count\n+\/\/     [ 0000 ->   0,\n+\/\/       0001 ->   1,\n+\/\/       0010 ->   1,\n+\/\/       0011 ->   2,\n+\/\/       0100 ->   1,\n+\/\/       0101 ->   2,\n+\/\/       0110 ->   2,\n+\/\/       0111 ->   3,\n+\/\/       1000 ->   1,\n+\/\/       1001 ->   2,\n+\/\/       1010 ->   3,\n+\/\/       1011 ->   3,\n+\/\/       1100 ->   2,\n+\/\/       1101 ->   3,\n+\/\/       1111 ->   4 ]\n+\/\/  a. Count the number of 1s in 4 LSB bits of each byte. These bits are used as\n+\/\/     shuffle indices for lookup table access.\n+\/\/  b. Right shift each byte of vector lane by 4 positions.\n+\/\/  c. Count the number of 1s in 4 MSB bits each byte. These bits are used as\n+\/\/     shuffle indices for lookup table access.\n+\/\/  d. Add the bitset count of upper and lower 4 bits of each byte.\n+\/\/  e. Unpack double words to quad words and compute sum of absolute difference of bitset\n+\/\/     count of all the bytes of a quadword.\n+\/\/  f. Perform step e. for upper 128bit vector lane.\n+\/\/  g. Pack the bitset count of quadwords back to double word.\n+\/\/  h. Unpacking and packing operations are not needed for 64bit vector lane.\n+void C2_MacroAssembler::vector_popcount_int(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n+                                            int vec_enc) {\n+  if (VM_Version::supports_avx512_vpopcntdq()) {\n+    vpopcntd(dst, src, vec_enc);\n+  } else {\n+    assert((vec_enc == Assembler::AVX_512bit && VM_Version::supports_avx512bw()) || VM_Version::supports_avx2(), \"\");\n+    movl(rtmp, 0x0F0F0F0F);\n+    movdl(xtmp1, rtmp);\n+    vpbroadcastd(xtmp1, xtmp1, vec_enc);\n+    if (Assembler::AVX_512bit == vec_enc) {\n+      evmovdqul(xtmp2, k0, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), false, vec_enc, rtmp);\n+    } else {\n+      vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), rtmp);\n+    }\n+    vpand(xtmp3, src, xtmp1, vec_enc);\n+    vpshufb(xtmp3, xtmp2, xtmp3, vec_enc);\n+    vpsrlw(dst, src, 4, vec_enc);\n+    vpand(dst, dst, xtmp1, vec_enc);\n+    vpshufb(dst, xtmp2, dst, vec_enc);\n+    vpaddb(xtmp3, dst, xtmp3, vec_enc);\n+    vpxor(xtmp1, xtmp1, xtmp1, vec_enc);\n+    vpunpckhdq(dst, xtmp3, xtmp1, vec_enc);\n+    vpsadbw(dst, dst, xtmp1, vec_enc);\n+    vpunpckldq(xtmp2, xtmp3, xtmp1, vec_enc);\n+    vpsadbw(xtmp2, xtmp2, xtmp1, vec_enc);\n+    vpackuswb(dst, xtmp2, dst, vec_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_popcount_long(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                             XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc) {\n+  if (VM_Version::supports_avx512_vpopcntdq()) {\n+    vpopcntq(dst, src, vec_enc);\n+  } else if (vec_enc == Assembler::AVX_512bit) {\n+    assert(VM_Version::supports_avx512bw(), \"\");\n+    movl(rtmp, 0x0F0F0F0F);\n+    movdl(xtmp1, rtmp);\n+    vpbroadcastd(xtmp1, xtmp1, vec_enc);\n+    evmovdqul(xtmp2, k0, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), true, vec_enc, rtmp);\n+    vpandq(xtmp3, src, xtmp1, vec_enc);\n+    vpshufb(xtmp3, xtmp2, xtmp3, vec_enc);\n+    vpsrlw(dst, src, 4, vec_enc);\n+    vpandq(dst, dst, xtmp1, vec_enc);\n+    vpshufb(dst, xtmp2, dst, vec_enc);\n+    vpaddb(xtmp3, dst, xtmp3, vec_enc);\n+    vpxorq(xtmp1, xtmp1, xtmp1, vec_enc);\n+    vpsadbw(dst, xtmp3, xtmp1, vec_enc);\n+  } else {\n+    \/\/ We do not see any performance benefit of running\n+    \/\/ above instruction sequence on 256 bit vector which\n+    \/\/ can operate over maximum 4 long elements.\n+    ShouldNotReachHere();\n+  }\n+  if (bt == T_INT) {\n+    evpmovqd(dst, dst, vec_enc);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":190,"deletions":54,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -279,5 +279,4 @@\n-  \/\/ return true if it has any and false otherwise.\n-  void has_negatives(Register ary1, Register len,\n-                     Register result, Register tmp1,\n-                     XMMRegister vec1, XMMRegister vec2, KRegister mask1 = knoreg, KRegister mask2 = knoreg);\n-\n+  \/\/ return index of the first such character, otherwise len.\n+  void count_positives(Register ary1, Register len,\n+                       Register result, Register tmp1,\n+                       XMMRegister vec1, XMMRegister vec2, KRegister mask1 = knoreg, KRegister mask2 = knoreg);\n@@ -325,0 +324,7 @@\n+  void vector_popcount_int(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                           XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n+                           int vec_enc);\n+\n+  void vector_popcount_long(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -151,16 +151,1 @@\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default:\n-    while (count-- > 0) {\n-      *to++ = *from++;\n-    }\n-    break;\n-  }\n+  shared_disjoint_words_atomic(from, to, count);\n","filename":"src\/hotspot\/cpu\/x86\/copy_x86.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -335,15 +335,0 @@\n-\n-void MacroAssembler::pop_callee_saved_registers() {\n-  pop(rcx);\n-  pop(rdx);\n-  pop(rdi);\n-  pop(rsi);\n-}\n-\n-void MacroAssembler::push_callee_saved_registers() {\n-  push(rsi);\n-  push(rdi);\n-  push(rdx);\n-  push(rcx);\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -524,4 +524,0 @@\n-  \/\/ Callee saved registers handling\n-  void push_callee_saved_registers();\n-  void pop_callee_saved_registers();\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,0 +186,9 @@\n+  \/\/ Returns pre-selection estimated cost of a vector operation.\n+  static int vector_op_pre_select_sz_estimate(int vopc, BasicType ety, int vlen) {\n+    switch(vopc) {\n+      default: return 0;\n+      case Op_PopCountVI: return VM_Version::supports_avx512_vpopcntdq() ? 0 : 50;\n+      case Op_PopCountVL: return VM_Version::supports_avx512_vpopcntdq() ? 0 : 40;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,1 +138,1 @@\n-\/\/ The implementation of XMM registers for the IA32 architecture\n+\/\/ The implementation of XMM registers.\n@@ -204,5 +204,1 @@\n-\/\/ Only used by the 32bit stubGenerator. These can't be described by vmreg and hence\n-\/\/ can't be described in oopMaps and therefore can't be used by the compilers (at least\n-\/\/ were deopt might wan't to see them).\n-\n-\/\/ Use XMMRegister as shortcut\n+\/\/ Use KRegister as shortcut\n@@ -216,1 +212,1 @@\n-\/\/ The implementation of XMM registers for the IA32 architecture\n+\/\/ The implementation of AVX-3 (AVX-512) opmask registers.\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -591,0 +591,24 @@\n+  address generate_popcount_avx_lut(const char *stub_name) {\n+    __ align64();\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x02010100, relocInfo::none, 0);\n+    __ emit_data(0x03020201, relocInfo::none, 0);\n+    __ emit_data(0x03020201, relocInfo::none, 0);\n+    __ emit_data(0x04030302, relocInfo::none, 0);\n+    __ emit_data(0x02010100, relocInfo::none, 0);\n+    __ emit_data(0x03020201, relocInfo::none, 0);\n+    __ emit_data(0x03020201, relocInfo::none, 0);\n+    __ emit_data(0x04030302, relocInfo::none, 0);\n+    __ emit_data(0x02010100, relocInfo::none, 0);\n+    __ emit_data(0x03020201, relocInfo::none, 0);\n+    __ emit_data(0x03020201, relocInfo::none, 0);\n+    __ emit_data(0x04030302, relocInfo::none, 0);\n+    __ emit_data(0x02010100, relocInfo::none, 0);\n+    __ emit_data(0x03020201, relocInfo::none, 0);\n+    __ emit_data(0x03020201, relocInfo::none, 0);\n+    __ emit_data(0x04030302, relocInfo::none, 0);\n+    return start;\n+  }\n+\n+\n@@ -4007,0 +4031,5 @@\n+    if (UsePopCountInstruction && VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n+      \/\/ lut implementation influenced by counting 1s algorithm from section 5-1 of Hackers' Delight.\n+      StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut(\"popcount_lut\");\n+    }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -798,0 +798,15 @@\n+  address generate_popcount_avx_lut(const char *stub_name) {\n+    __ align64();\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0302020102010100, relocInfo::none);\n+    __ emit_data64(0x0403030203020201, relocInfo::none);\n+    __ emit_data64(0x0302020102010100, relocInfo::none);\n+    __ emit_data64(0x0403030203020201, relocInfo::none);\n+    __ emit_data64(0x0302020102010100, relocInfo::none);\n+    __ emit_data64(0x0403030203020201, relocInfo::none);\n+    __ emit_data64(0x0302020102010100, relocInfo::none);\n+    __ emit_data64(0x0403030203020201, relocInfo::none);\n+    return start;\n+  }\n+\n@@ -7716,0 +7731,5 @@\n+    if (UsePopCountInstruction && VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n+      \/\/ lut implementation influenced by counting 1s algorithm from section 5-1 of Hackers' Delight.\n+      StubRoutines::x86::_vector_popcount_lut = generate_popcount_avx_lut(\"popcount_lut\");\n+    }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+address StubRoutines::x86::_vector_popcount_lut = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+  static address _vector_popcount_lut;\n@@ -343,0 +344,3 @@\n+  static address vector_popcount_lut() {\n+    return _vector_popcount_lut;\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -758,2 +758,2 @@\n-  \/\/ Record a new watermark, unless the update is above the safe limit.\n-  \/\/ Otherwise, the next time around a check above would pass the safe limit.\n+  \/\/ Record the new watermark, but only if update is above the safe limit.\n+  \/\/ Otherwise, the next time around the check above would pass the safe limit.\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1408,0 +1408,4 @@\n+      if (!UsePopCountInstruction || (UseAVX < 2)) {\n+        return false;\n+      }\n+      break;\n@@ -1409,1 +1413,1 @@\n-      if (!UsePopCountInstruction || !VM_Version::supports_avx512_vpopcntdq()) {\n+      if (!UsePopCountInstruction || (UseAVX <= 2)) {\n@@ -1892,0 +1896,12 @@\n+    case Op_PopCountVI:\n+      if (!VM_Version::supports_avx512_vpopcntdq() &&\n+          (vlen == 16) && !VM_Version::supports_avx512bw()) {\n+        return false;\n+      }\n+      break;\n+    case Op_PopCountVL:\n+      if (!VM_Version::supports_avx512_vpopcntdq() &&\n+          ((vlen <= 4) || ((vlen == 8) && !VM_Version::supports_avx512bw()))) {\n+        return false;\n+      }\n+      break;\n@@ -8602,1 +8618,2 @@\n-instruct vpopcountI(vec dst, vec src) %{\n+instruct vpopcountI_popcntd(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx512_vpopcntdq());\n@@ -8604,1 +8621,1 @@\n-  format %{ \"vpopcntd  $dst,$src\\t! vector popcount packedI\" %}\n+  format %{ \"vector_popcount_int $dst, $src\\t! vector popcount packedI\" %}\n@@ -8607,0 +8624,5 @@\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_popcount_int($dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg, noreg, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -8608,0 +8630,7 @@\n+instruct vpopcountI(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n+  predicate(!VM_Version::supports_avx512_vpopcntdq());\n+  match(Set dst (PopCountVI src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, KILL cc);\n+  format %{ \"vector_popcount_int  $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"not enabled\");\n@@ -8609,1 +8638,2 @@\n-    __ vpopcntd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vector_popcount_int($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                           $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n@@ -8614,1 +8644,2 @@\n-instruct vpopcountL(vec dst, vec src) %{\n+instruct vpopcountL_popcntd(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx512_vpopcntdq());\n@@ -8616,1 +8647,1 @@\n-  format %{ \"vpopcntq  $dst,$src\\t! vector popcount packedL\" %}\n+  format %{ \"vector_popcount_long  $dst, $src\\t! vector popcount packedL\" %}\n@@ -8619,1 +8650,0 @@\n-\n@@ -8622,6 +8652,4 @@\n-    __ vpopcntq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-    if ( bt == T_INT) {\n-      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    } else {\n-      assert(bt == T_LONG, \"\");\n-    }\n+    __ vector_popcount_long(bt, $dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg, noreg, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -8629,0 +8657,11 @@\n+instruct vpopcountL(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n+  predicate(!VM_Version::supports_avx512_vpopcntdq());\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, KILL cc);\n+  format %{ \"vector_popcount_long  $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"not enabled\");\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_popcount_long(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n+                            $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":52,"deletions":13,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -12125,2 +12125,2 @@\n-instruct has_negatives(eSIRegP ary1, eCXRegI len, eAXRegI result,\n-                      regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)\n+instruct count_positives(eSIRegP ary1, eCXRegI len, eAXRegI result,\n+                         regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)\n@@ -12129,1 +12129,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -12132,1 +12132,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -12134,3 +12134,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n@@ -12141,2 +12141,2 @@\n-instruct has_negatives_evex(eSIRegP ary1, eCXRegI len, eAXRegI result,\n-                           regD tmp1, regD tmp2, kReg ktmp1, kReg ktmp2, eBXRegI tmp3, eFlagsReg cr)\n+instruct count_positives_evex(eSIRegP ary1, eCXRegI len, eAXRegI result,\n+                              regD tmp1, regD tmp2, kReg ktmp1, kReg ktmp2, eBXRegI tmp3, eFlagsReg cr)\n@@ -12145,1 +12145,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -12148,1 +12148,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -12150,3 +12150,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1929,1 +1929,1 @@\n-    __ cmp(as_Register(RAX_enc), 0x80000000);\n+    __ cmpl(as_Register(RAX_enc), 0x80000000);\n@@ -11688,2 +11688,2 @@\n-instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n-                       legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr,)\n+instruct count_positives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n+                         legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr,)\n@@ -11692,1 +11692,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -11695,1 +11695,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -11697,3 +11697,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n@@ -11704,2 +11704,2 @@\n-instruct has_negatives_evex(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n-                            legRegD tmp1, legRegD tmp2, kReg ktmp1, kReg ktmp2, rbx_RegI tmp3, rFlagsReg cr,)\n+instruct count_positives_evex(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n+                              legRegD tmp1, legRegD tmp2, kReg ktmp1, kReg ktmp2, rbx_RegI tmp3, rFlagsReg cr,)\n@@ -11708,1 +11708,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -11711,1 +11711,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -11713,3 +11713,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,16 +55,1 @@\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default:\n-    while (count-- > 0) {\n-      *to++ = *from++;\n-    }\n-    break;\n-  }\n+  shared_disjoint_words_atomic(from, to, count);\n","filename":"src\/hotspot\/cpu\/zero\/copy_zero.hpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"runtime\/thread.inline.hpp\"\n-#include \"runtime\/threadCritical.hpp\"\n-\n-\/\/ put OS-includes here\n-# include <pthread.h>\n-\n-\/\/\n-\/\/ See threadCritical.hpp for details of this class.\n-\/\/\n-\n-static pthread_t             tc_owner = 0;\n-static pthread_mutex_t       tc_mutex = PTHREAD_MUTEX_INITIALIZER;\n-static int                   tc_count = 0;\n-\n-ThreadCritical::ThreadCritical() {\n-  pthread_t self = pthread_self();\n-  if (self != tc_owner) {\n-    int ret = pthread_mutex_lock(&tc_mutex);\n-    guarantee(ret == 0, \"fatal error with pthread_mutex_lock()\");\n-    assert(tc_count == 0, \"Lock acquired with illegal reentry count.\");\n-    tc_owner = self;\n-  }\n-  tc_count++;\n-}\n-\n-ThreadCritical::~ThreadCritical() {\n-  assert(tc_owner == pthread_self(), \"must have correct owner\");\n-  assert(tc_count > 0, \"must have correct count\");\n-\n-  tc_count--;\n-  if (tc_count == 0) {\n-    tc_owner = 0;\n-    int ret = pthread_mutex_unlock(&tc_mutex);\n-    guarantee(ret == 0, \"fatal error with pthread_mutex_unlock()\");\n-  }\n-}\n","filename":"src\/hotspot\/os\/bsd\/threadCritical_bsd.cpp","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -498,1 +498,6 @@\n-  int share  = cpu_shares();\n+\n+  \/\/ It's not a good idea to use cpu_shares() to limit the number\n+  \/\/ of CPUs used by the JVM. See JDK-8281181.\n+  \/\/ UseContainerCpuShares and PreferContainerQuotaForCPUCount are\n+  \/\/ deprecated and will be removed in the next JDK release.\n+  int share  = UseContainerCpuShares ? cpu_shares() : -1;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,4 @@\n+  product(bool, UseContainerCpuShares, false,                           \\\n+          \"(Deprecated) Include CPU shares in the CPU availability\"     \\\n+          \" calculation.\")                                              \\\n+                                                                        \\\n@@ -63,3 +67,3 @@\n-          \"Calculate the container CPU availability based on the value\" \\\n-          \" of quotas (if set), when true. Otherwise, use the CPU\"      \\\n-          \" shares value, provided it is less than quota.\")             \\\n+          \"(Deprecated) Calculate the container CPU availability based\" \\\n+          \" on the value of quotas (if set), when true. Otherwise, use\" \\\n+          \" the CPU shares value, provided it is less than quota.\")     \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2015, 2022 SAP SE. All rights reserved.\n@@ -2095,0 +2096,28 @@\n+#ifdef __GLIBC__\n+\/\/ For Glibc, print a one-liner with the malloc tunables.\n+\/\/ Most important and popular is MALLOC_ARENA_MAX, but we are\n+\/\/ thorough and print them all.\n+static void print_glibc_malloc_tunables(outputStream* st) {\n+  static const char* var[] = {\n+      \/\/ the new variant\n+      \"GLIBC_TUNABLES\",\n+      \/\/ legacy variants\n+      \"MALLOC_CHECK_\", \"MALLOC_TOP_PAD_\", \"MALLOC_PERTURB_\",\n+      \"MALLOC_MMAP_THRESHOLD_\", \"MALLOC_TRIM_THRESHOLD_\",\n+      \"MALLOC_MMAP_MAX_\", \"MALLOC_ARENA_TEST\", \"MALLOC_ARENA_MAX\",\n+      NULL};\n+  st->print(\"glibc malloc tunables: \");\n+  bool printed = false;\n+  for (int i = 0; var[i] != NULL; i ++) {\n+    const char* const val = ::getenv(var[i]);\n+    if (val != NULL) {\n+      st->print(\"%s%s=%s\", (printed ? \", \" : \"\"), var[i], val);\n+      printed = true;\n+    }\n+  }\n+  if (!printed) {\n+    st->print(\"(default)\");\n+  }\n+}\n+#endif \/\/ __GLIBC__\n+\n@@ -2117,2 +2146,3 @@\n-  \/\/ Print glibc outstanding allocations.\n-  \/\/ (note: there is no implementation of mallinfo for muslc)\n+  \/\/ glibc only:\n+  \/\/ - Print outstanding allocations using mallinfo\n+  \/\/ - Print glibc tunables\n@@ -2126,3 +2156,4 @@\n-    \/\/ mallinfo is an old API. Member names mean next to nothing and, beyond that, are int.\n-    \/\/ So values may have wrapped around. Still useful enough to see how much glibc thinks\n-    \/\/ we allocated.\n+    \/\/ mallinfo is an old API. Member names mean next to nothing and, beyond that, are 32-bit signed.\n+    \/\/ So for larger footprints the values may have wrapped around. We try to detect this here: if the\n+    \/\/ process whole resident set size is smaller than 4G, malloc footprint has to be less than that\n+    \/\/ and the numbers are reliable.\n@@ -2139,2 +2170,4 @@\n-#endif \/\/ __GLIBC__\n-\n+  \/\/ Tunables\n+  print_glibc_malloc_tunables(st);\n+  st->cr();\n+#endif\n@@ -3942,1 +3975,1 @@\n-static void warn_on_commit_special_failure(char* req_addr, size_t bytes,\n+static void log_on_commit_special_failure(char* req_addr, size_t bytes,\n@@ -3946,13 +3979,4 @@\n-  bool warn_on_failure = UseLargePages &&\n-      (!FLAG_IS_DEFAULT(UseLargePages) ||\n-       !FLAG_IS_DEFAULT(UseHugeTLBFS) ||\n-       !FLAG_IS_DEFAULT(LargePageSizeInBytes));\n-\n-  if (warn_on_failure) {\n-    char msg[128];\n-    jio_snprintf(msg, sizeof(msg), \"Failed to reserve and commit memory. req_addr: \"\n-                                   PTR_FORMAT \" bytes: \" SIZE_FORMAT \" page size: \"\n-                                   SIZE_FORMAT \" (errno = %d).\",\n-                                   req_addr, bytes, page_size, error);\n-    warning(\"%s\", msg);\n-  }\n+  log_info(pagesize)(\"Failed to reserve and commit memory with given page size. req_addr: \" PTR_FORMAT\n+                     \" size: \" SIZE_FORMAT \"%s, page size: \" SIZE_FORMAT \"%s, (errno = %d)\",\n+                     p2i(req_addr), byte_size_in_exact_unit(bytes), exact_unit_for_byte_size(bytes),\n+                     byte_size_in_exact_unit(page_size), exact_unit_for_byte_size(page_size), error);\n@@ -3980,1 +4004,1 @@\n-    warn_on_commit_special_failure(req_addr, bytes, page_size, errno);\n+    log_on_commit_special_failure(req_addr, bytes, page_size, errno);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":46,"deletions":22,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"runtime\/thread.inline.hpp\"\n-#include \"runtime\/threadCritical.hpp\"\n-\n-\/\/ put OS-includes here\n-# include <pthread.h>\n-\n-\/\/\n-\/\/ See threadCritical.hpp for details of this class.\n-\/\/\n-\n-static pthread_t             tc_owner = 0;\n-static pthread_mutex_t       tc_mutex = PTHREAD_MUTEX_INITIALIZER;\n-static int                   tc_count = 0;\n-\n-ThreadCritical::ThreadCritical() {\n-  pthread_t self = pthread_self();\n-  if (self != tc_owner) {\n-    int ret = pthread_mutex_lock(&tc_mutex);\n-    guarantee(ret == 0, \"fatal error with pthread_mutex_lock()\");\n-    assert(tc_count == 0, \"Lock acquired with illegal reentry count.\");\n-    tc_owner = self;\n-  }\n-  tc_count++;\n-}\n-\n-ThreadCritical::~ThreadCritical() {\n-  assert(tc_owner == pthread_self(), \"must have correct owner\");\n-  assert(tc_count > 0, \"must have correct count\");\n-\n-  tc_count--;\n-  if (tc_count == 0) {\n-    tc_owner = 0;\n-    int ret = pthread_mutex_unlock(&tc_mutex);\n-    guarantee(ret == 0, \"fatal error with pthread_mutex_unlock()\");\n-  }\n-}\n","filename":"src\/hotspot\/os\/linux\/threadCritical_linux.cpp","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/os\/posix\/threadCritical_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/hotspot\/os\/aix\/threadCritical_aix.cpp","status":"renamed"},{"patch":"@@ -4461,1 +4461,1 @@\n-static void set_path_prefix(char* buf, LPWSTR* prefix, int* prefix_off, bool* needs_fullpath) {\n+static void set_path_prefix(char* buf, LPCWSTR* prefix, int* prefix_off, bool* needs_fullpath) {\n@@ -4497,1 +4497,1 @@\n-  LPWSTR prefix = NULL;\n+  LPCWSTR prefix = NULL;\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n@@ -28,11 +28,2 @@\n-#ifdef __APPLE__\n-#include <ptrauth.h>\n-#endif\n-\n-\/\/ Only the PAC instructions in the NOP space can be used. This ensures the\n-\/\/ binaries work on systems without PAC. Write these instructions using their\n-\/\/ alternate \"hint\" instructions to ensure older compilers can still be used.\n-\/\/ For Apple, use the provided interface as this may provide additional\n-\/\/ optimization.\n-\n-#define XPACLRI \"hint #0x7;\"\n+\/\/ OS specific Support for ROP Protection in VM code.\n+\/\/ For more details on PAC see pauth_aarch64.hpp.\n@@ -41,7 +32,2 @@\n-#ifdef __APPLE__\n-  return ptrauth_strip(ptr, ptrauth_key_asib);\n-#else\n-  register address result __asm__(\"x30\") = ptr;\n-  asm (XPACLRI : \"+r\"(result));\n-  return result;\n-#endif\n+  \/\/ No PAC support in BSD as of yet.\n+  return ptr;\n@@ -50,1 +36,9 @@\n-#undef XPACLRI\n+inline address pauth_sign_return_address(address ret_addr, address sp) {\n+  \/\/ No PAC support in BSD as of yet.\n+  return ret_addr;\n+}\n+\n+inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+  \/\/ No PAC support in BSD as of yet.\n+  return ret_addr;\n+}\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/pauth_bsd_aarch64.inline.hpp","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n@@ -28,3 +28,2 @@\n-\/\/ Only the PAC instructions in the NOP space can be used. This ensures the\n-\/\/ binaries work on systems without PAC. Write these instructions using their\n-\/\/ alternate \"hint\" instructions to ensure older compilers can still be used.\n+\/\/ OS specific Support for ROP Protection in VM code.\n+\/\/ For more details on PAC see pauth_aarch64.hpp.\n@@ -32,1 +31,1 @@\n-#define XPACLRI \"hint #0x7;\"\n+inline bool pauth_ptr_is_raw(address ptr);\n@@ -34,0 +33,10 @@\n+\/\/ Use only the PAC instructions in the NOP space. This ensures the binaries work on systems\n+\/\/ without PAC. Write these instructions using their alternate \"hint\" instructions to ensure older\n+\/\/ compilers can still be used.\n+#define XPACLRI   \"hint #0x7;\"\n+#define PACIA1716 \"hint #0x8;\"\n+#define AUTIA1716 \"hint #0xc;\"\n+\n+\/\/ Strip an address. Use with caution - only if there is no guaranteed way of authenticating the\n+\/\/ value.\n+\/\/\n@@ -40,0 +49,28 @@\n+\/\/ Sign a return value, using the given modifier.\n+\/\/\n+inline address pauth_sign_return_address(address ret_addr, address sp) {\n+  if (VM_Version::use_rop_protection()) {\n+    \/\/ A pointer cannot be double signed.\n+    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address is already signed\");\n+    register address r17 __asm(\"r17\") = ret_addr;\n+    register address r16 __asm(\"r16\") = sp;\n+    asm (PACIA1716 : \"+r\"(r17) : \"r\"(r16));\n+    ret_addr = r17;\n+  }\n+  return ret_addr;\n+}\n+\n+\/\/ Authenticate a return value, using the given modifier.\n+\/\/\n+inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+  if (VM_Version::use_rop_protection()) {\n+    register address r17 __asm(\"r17\") = ret_addr;\n+    register address r16 __asm(\"r16\") = sp;\n+    asm (AUTIA1716 : \"+r\"(r17) : \"r\"(r16));\n+    ret_addr = r17;\n+    \/\/ Ensure that the pointer authenticated.\n+    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address did not authenticate\");\n+  }\n+  return ret_addr;\n+}\n+\n@@ -41,0 +78,2 @@\n+#undef PACIA1716\n+#undef AUTIA1716\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/pauth_linux_aarch64.inline.hpp","additions":44,"deletions":5,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/\/ Copyright (c) 2015, Red Hat Inc. All rights reserved.\n+\/\/ Copyright (c) 2015, 2022, Red Hat Inc. All rights reserved.\n@@ -32,0 +32,1 @@\n+\thint #0x19      \/\/ paciasp\n@@ -42,0 +43,1 @@\n+\thint #0x1d      \/\/ autiasp\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/threadLS_linux_aarch64.S","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+#ifndef HWCAP_PACA\n+#define HWCAP_PACA (1 << 30)\n+#endif\n+\n@@ -114,0 +118,1 @@\n+  static_assert(CPU_PACA    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n@@ -127,1 +132,2 @@\n-      HWCAP_SVE);\n+      HWCAP_SVE     |\n+      HWCAP_PACA);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,15 +53,1 @@\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default: while (count-- > 0) {\n-             *to++ = *from++;\n-           }\n-           break;\n-  }\n+  shared_disjoint_words_atomic(from, to, count);\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/copy_windows_aarch64.hpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n@@ -28,0 +28,3 @@\n+\/\/ OS specific Support for ROP Protection in VM code.\n+\/\/ For more details on PAC see pauth_aarch64.hpp.\n+\n@@ -33,1 +36,4 @@\n-#endif \/\/ OS_CPU_WINDOWS_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n+inline address pauth_sign_return_address(address ret_addr, address sp) {\n+  \/\/ No PAC support in windows as of yet.\n+  return ret_addr;\n+}\n@@ -35,0 +41,6 @@\n+inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+  \/\/ No PAC support in windows as of yet.\n+  return ret_addr;\n+}\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/pauth_windows_aarch64.inline.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -615,1 +615,1 @@\n-        strcmp(_matrule->_rChild->_opType,\"HasNegatives\" )==0 ||\n+        strcmp(_matrule->_rChild->_opType,\"CountPositives\" )==0 ||\n@@ -905,1 +905,1 @@\n-        strcmp(_matrule->_rChild->_opType,\"HasNegatives\")==0 ||\n+        strcmp(_matrule->_rChild->_opType,\"CountPositives\")==0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-  JavaThread* _thread;\n@@ -563,0 +562,1 @@\n+, _has_irreducible_loops(false)\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  bool               _has_irreducible_loops;\n@@ -138,0 +139,1 @@\n+  bool has_irreducible_loops() const             { return _has_irreducible_loops; }\n@@ -165,0 +167,1 @@\n+  void set_has_irreducible_loops(bool f)         { _has_irreducible_loops = f; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  intArray       _loop_map;            \/\/ caches the information if a block is contained in a loop\n+  GrowableArray<ResourceBitMap> _loop_map; \/\/ caches the information if a block is contained in a loop\n@@ -87,1 +87,1 @@\n-  int  mark_loops(BlockBegin* b, bool in_subroutine);\n+  BitMap& mark_loops(BlockBegin* b, bool in_subroutine);\n@@ -379,1 +379,4 @@\n-  _loop_map = intArray(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), 0);\n+  _loop_map = GrowableArray<ResourceBitMap>(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), ResourceBitMap());\n+  for (int i = 0; i < BlockBegin::number_of_blocks(); i++) {\n+    _loop_map.at(i).initialize(BlockBegin::number_of_blocks());\n+  }\n@@ -383,2 +386,17 @@\n-  \/\/ recursively iterate the control flow graph\n-  mark_loops(_bci2block->at(0), false);\n+  \/\/ The loop detection algorithm works as follows:\n+  \/\/ - We maintain the _loop_map, where for each block we have a bitmap indicating which loops contain this block.\n+  \/\/ - The CFG is recursively traversed (depth-first) and if we detect a loop, we assign the loop a unique number that is stored\n+  \/\/ in the bitmap associated with the loop header block. Until we return back through that loop header the bitmap contains\n+  \/\/ only a single bit corresponding to the loop number.\n+  \/\/ -  The bit is then propagated for all the blocks in the loop after we exit them (post-order). There could be multiple bits\n+  \/\/ of course in case of nested loops.\n+  \/\/ -  When we exit the loop header we remove that single bit and assign the real loop state for it.\n+  \/\/ -  Now, the tricky part here is how we detect irriducible loops. In the algorithm above the loop state bits\n+  \/\/ are propagated to the predecessors. If we encounter an irreducible loop (a loop with multiple heads) we would see\n+  \/\/ a node with some loop bit set that would then propagate back and be never cleared because we would\n+  \/\/ never go back through the original loop header. Therefore if there are any irreducible loops the bits in the states\n+  \/\/ for these loops are going to propagate back to the root.\n+  BitMap& loop_state = mark_loops(_bci2block->at(0), false);\n+  if (!loop_state.is_empty()) {\n+    compilation()->set_has_irreducible_loops(true);\n+  }\n@@ -390,0 +408,1 @@\n+  _loop_map.clear();\n@@ -401,4 +420,3 @@\n-    assert(_loop_map.at(block->block_id()) == 0, \"must not be set yet\");\n-    assert(0 <= _next_loop_index && _next_loop_index < BitsPerInt, \"_next_loop_index is used as a bit-index in integer\");\n-    _loop_map.at_put(block->block_id(), 1 << _next_loop_index);\n-    if (_next_loop_index < 31) _next_loop_index++;\n+    assert(_loop_map.at(block->block_id()).is_empty(), \"must not be set yet\");\n+    assert(0 <= _next_loop_index && _next_loop_index < BlockBegin::number_of_blocks(), \"_next_loop_index is too large\");\n+    _loop_map.at(block->block_id()).set_bit(_next_loop_index++);\n@@ -407,1 +425,1 @@\n-    assert(is_power_of_2((unsigned int)_loop_map.at(block->block_id())), \"exactly one bit must be set\");\n+    assert(_loop_map.at(block->block_id()).count_one_bits() == 1, \"exactly one bit must be set\");\n@@ -411,1 +429,1 @@\n-int BlockListBuilder::mark_loops(BlockBegin* block, bool in_subroutine) {\n+BitMap& BlockListBuilder::mark_loops(BlockBegin* block, bool in_subroutine) {\n@@ -413,1 +431,0 @@\n-\n@@ -431,1 +448,2 @@\n-  intptr_t loop_state = 0;\n+  ResourceMark rm;\n+  ResourceBitMap loop_state(BlockBegin::number_of_blocks());\n@@ -434,1 +452,1 @@\n-    loop_state |= mark_loops(successor_at(block, i), in_subroutine);\n+    loop_state.set_union(mark_loops(successor_at(block, i), in_subroutine));\n@@ -444,1 +462,1 @@\n-  if (loop_state != 0 || in_subroutine ) {\n+  if (!loop_state.is_empty() || in_subroutine ) {\n@@ -451,8 +469,4 @@\n-    int header_loop_state = _loop_map.at(block_id);\n-    assert(is_power_of_2((unsigned)header_loop_state), \"exactly one bit must be set\");\n-\n-    \/\/ If the highest bit is set (i.e. when integer value is negative), the method\n-    \/\/ has 32 or more loops. This bit is never cleared because it is used for multiple loops\n-    if (header_loop_state >= 0) {\n-      clear_bits(loop_state, header_loop_state);\n-    }\n+    BitMap& header_loop_state = _loop_map.at(block_id);\n+    assert(header_loop_state.count_one_bits() == 1, \"exactly one bit must be set\");\n+    \/\/ remove the bit with the loop number for the state (header is outside of the loop)\n+    loop_state.set_difference(header_loop_state);\n@@ -462,2 +476,2 @@\n-  _loop_map.at_put(block_id, loop_state);\n-  return loop_state;\n+  _loop_map.at(block_id).set_from(loop_state);\n+  return _loop_map.at(block_id);\n@@ -2499,1 +2513,1 @@\n-        if (!entry->try_merge(cur_state)) {\n+        if (!entry->try_merge(cur_state, compilation()->has_irreducible_loops())) {\n@@ -2985,1 +2999,1 @@\n-    if (!sux->try_merge(end->state())) BAILOUT_(\"block join failed\", NULL);\n+    if (!sux->try_merge(end->state(), compilation()->has_irreducible_loops())) BAILOUT_(\"block join failed\", NULL);\n@@ -3139,1 +3153,1 @@\n-    base->std_entry()->merge(state);\n+    base->std_entry()->merge(state, compilation()->has_irreducible_loops());\n@@ -3222,1 +3236,1 @@\n-  target->merge(_osr_entry->end()->state());\n+  target->merge(_osr_entry->end()->state(), compilation()->has_irreducible_loops());\n@@ -3281,1 +3295,1 @@\n-  start_block->merge(_initial_state);\n+  start_block->merge(_initial_state, compilation->has_irreducible_loops());\n@@ -4032,1 +4046,1 @@\n-    callee_start_block->merge(callee_state);\n+    callee_start_block->merge(callee_state, compilation()->has_irreducible_loops());\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":45,"deletions":31,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -722,1 +722,1 @@\n-bool BlockBegin::try_merge(ValueStack* new_state) {\n+bool BlockBegin::try_merge(ValueStack* new_state, bool has_irreducible_loops) {\n@@ -763,1 +763,0 @@\n-\n@@ -766,1 +765,1 @@\n-        if (requires_phi || !SelectivePhiFunctions) {\n+        if (requires_phi || !SelectivePhiFunctions || has_irreducible_loops) {\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1782,2 +1782,5 @@\n-  bool try_merge(ValueStack* state);             \/\/ try to merge states at block begin\n-  void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, \"merge failed\"); }\n+  bool try_merge(ValueStack* state, bool has_irreducible_loops);  \/\/ try to merge states at block begin\n+  void merge(ValueStack* state, bool has_irreducible_loops) {\n+    bool b = try_merge(state, has_irreducible_loops);\n+    assert(b, \"merge failed\");\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -525,1 +525,2 @@\n-  } else if (ref->msotype() == MetaspaceObj::MethodDataType) {\n+  } else if (ref->msotype() == MetaspaceObj::MethodDataType ||\n+             ref->msotype() == MetaspaceObj::MethodCountersType) {\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -150,1 +151,1 @@\n-  void append_intptr_t(intptr_t n, bool need_to_mark = false);\n+  void append_intptr_t(intptr_t n, bool need_to_mark = false) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/cdsHeapVerifier.hpp\"\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+\/\/ CDSHeapVerifier is used to check for problems where an archived object references a\n+\/\/ static field that may be reinitialized at runtime. In the following example,\n+\/\/      Foo.get.test()\n+\/\/ correctly returns true when CDS disabled, but incorrectly returns false when CDS is enabled.\n+\/\/\n+\/\/ class Foo {\n+\/\/     final Foo archivedFoo; \/\/ this field is archived by CDS\n+\/\/     Bar bar;\n+\/\/     static {\n+\/\/         CDS.initializeFromArchive(Foo.class);\n+\/\/         if (archivedFoo == null) {\n+\/\/             archivedFoo = new Foo();\n+\/\/             archivedFoo.bar = Bar.bar;\n+\/\/         }\n+\/\/     }\n+\/\/     static Foo get() { return archivedFoo; }\n+\/\/     boolean test() {\n+\/\/         return bar == Bar.bar;\n+\/\/     }\n+\/\/ }\n+\/\/\n+\/\/ class Bar {\n+\/\/     \/\/ this field is initialized in both CDS dump time and runtime.\n+\/\/     static final Bar bar = new Bar();\n+\/\/ }\n+\/\/\n+\/\/ The check itself is simple:\n+\/\/ [1] CDSHeapVerifier::do_klass() collects all static fields\n+\/\/ [2] CDSHeapVerifier::do_entry() checks all the archived objects. None of them\n+\/\/     should be in [1]\n+\/\/\n+\/\/ However, it's legal for *some* static fields to be references. This leads to the\n+\/\/ table of ADD_EXCL below.\n+\/\/\n+\/\/ [A] In most of the cases, the module bootstrap code will update the static field\n+\/\/     to point to part of the archived module graph. E.g.,\n+\/\/     - java\/lang\/System::bootLayer\n+\/\/     - jdk\/internal\/loader\/ClassLoaders::BOOT_LOADER\n+\/\/ [B] A final static String that's explicitly initialized inside <clinit>, but\n+\/\/     its value is deterministic and is always the same string literal.\n+\/\/ [C] A non-final static string that is assigned a string literal during class\n+\/\/     initialization; this string is never changed during -Xshare:dump.\n+\/\/ [D] Simple caches whose value doesn't matter.\n+\/\/ [E] Other cases (see comments in-line below).\n+\n+CDSHeapVerifier::CDSHeapVerifier() : _archived_objs(0), _problems(0)\n+{\n+# define ADD_EXCL(...) { static const char* e[] = {__VA_ARGS__, NULL}; add_exclusion(e); }\n+\n+  \/\/ Unfortunately this needs to be manually maintained. If\n+  \/\/ test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedEnumTest.java fails,\n+  \/\/ you might need to fix the core library code, or fix the ADD_EXCL entries below.\n+  \/\/\n+  \/\/       class                                         field                     type\n+  ADD_EXCL(\"java\/lang\/ClassLoader\",                      \"scl\");                   \/\/ A\n+  ADD_EXCL(\"java\/lang\/invoke\/InvokerBytecodeGenerator\",  \"DONTINLINE_SIG\",         \/\/ B\n+                                                         \"FORCEINLINE_SIG\",        \/\/ B\n+                                                         \"HIDDEN_SIG\",             \/\/ B\n+                                                         \"INJECTEDPROFILE_SIG\",    \/\/ B\n+                                                         \"LF_COMPILED_SIG\");       \/\/ B\n+  ADD_EXCL(\"java\/lang\/Module\",                           \"ALL_UNNAMED_MODULE\",     \/\/ A\n+                                                         \"ALL_UNNAMED_MODULE_SET\", \/\/ A\n+                                                         \"EVERYONE_MODULE\",        \/\/ A\n+                                                         \"EVERYONE_SET\");          \/\/ A\n+  ADD_EXCL(\"java\/lang\/System\",                           \"bootLayer\");             \/\/ A\n+  ADD_EXCL(\"java\/lang\/VersionProps\",                     \"VENDOR_URL_BUG\",         \/\/ C\n+                                                         \"VENDOR_URL_VM_BUG\",      \/\/ C\n+                                                         \"VENDOR_VERSION\");        \/\/ C\n+  ADD_EXCL(\"java\/net\/URL$DefaultFactory\",                \"PREFIX\");                \/\/ B FIXME: JDK-8276561\n+\n+  \/\/ A dummy object used by HashSet. The value doesn't matter and it's never\n+  \/\/ tested for equality.\n+  ADD_EXCL(\"java\/util\/HashSet\",                          \"PRESENT\");               \/\/ E\n+  ADD_EXCL(\"jdk\/internal\/loader\/BuiltinClassLoader\",     \"packageToModule\");       \/\/ A\n+  ADD_EXCL(\"jdk\/internal\/loader\/ClassLoaders\",           \"BOOT_LOADER\",            \/\/ A\n+                                                         \"APP_LOADER\",             \/\/ A\n+                                                         \"PLATFORM_LOADER\");       \/\/ A\n+  ADD_EXCL(\"jdk\/internal\/loader\/URLClassPath\",           \"JAVA_VERSION\");          \/\/ B\n+  ADD_EXCL(\"jdk\/internal\/module\/Builder\",                \"cachedVersion\");         \/\/ D\n+  ADD_EXCL(\"jdk\/internal\/module\/ModuleLoaderMap$Mapper\", \"APP_CLASSLOADER\",        \/\/ A\n+                                                         \"APP_LOADER_INDEX\",       \/\/ A\n+                                                         \"PLATFORM_CLASSLOADER\",   \/\/ A\n+                                                         \"PLATFORM_LOADER_INDEX\"); \/\/ A\n+  ADD_EXCL(\"jdk\/internal\/module\/ServicesCatalog\",        \"CLV\");                   \/\/ A\n+\n+  \/\/ This just points to an empty Map\n+  ADD_EXCL(\"jdk\/internal\/reflect\/Reflection\",            \"methodFilterMap\");       \/\/ E\n+  ADD_EXCL(\"jdk\/internal\/util\/StaticProperty\",           \"FILE_ENCODING\");         \/\/ C\n+\n+  \/\/ Integer for 0 and 1 are in java\/lang\/Integer$IntegerCache and are archived\n+  ADD_EXCL(\"sun\/invoke\/util\/ValueConversions\",           \"ONE_INT\",                \/\/ E\n+                                                         \"ZERO_INT\");              \/\/ E\n+  ADD_EXCL(\"sun\/security\/util\/SecurityConstants\",        \"PROVIDER_VER\");          \/\/ C\n+\n+\n+# undef ADD_EXCL\n+\n+  ClassLoaderDataGraph::classes_do(this);\n+}\n+\n+CDSHeapVerifier::~CDSHeapVerifier() {\n+  if (_problems > 0) {\n+    log_warning(cds, heap)(\"Scanned %d objects. Found %d case(s) where \"\n+                           \"an object points to a static field that may be \"\n+                           \"reinitialized at runtime.\", _archived_objs, _problems);\n+  }\n+}\n+\n+class CDSHeapVerifier::CheckStaticFields : public FieldClosure {\n+  CDSHeapVerifier* _verifier;\n+  InstanceKlass* _ik;\n+  const char** _exclusions;\n+public:\n+  CheckStaticFields(CDSHeapVerifier* verifier, InstanceKlass* ik)\n+    : _verifier(verifier), _ik(ik) {\n+    _exclusions = _verifier->find_exclusion(_ik);\n+  }\n+\n+  void do_field(fieldDescriptor* fd) {\n+    if (fd->field_type() != T_OBJECT) {\n+      return;\n+    }\n+\n+    oop static_obj_field = _ik->java_mirror()->obj_field(fd->offset());\n+    if (static_obj_field != NULL) {\n+      Klass* klass = static_obj_field->klass();\n+      if (_exclusions != NULL) {\n+        for (const char** p = _exclusions; *p != NULL; p++) {\n+          if (fd->name()->equals(*p)) {\n+            return;\n+          }\n+        }\n+      }\n+\n+      if (fd->is_final() && java_lang_String::is_instance(static_obj_field) && fd->has_initial_value()) {\n+        \/\/ This field looks like like this in the Java source:\n+        \/\/    static final SOME_STRING = \"a string literal\";\n+        \/\/ This string literal has been stored in the shared string table, so it's OK\n+        \/\/ for the archived objects to refer to it.\n+        return;\n+      }\n+      if (fd->is_final() && java_lang_Class::is_instance(static_obj_field)) {\n+        \/\/ This field points to an archived mirror.\n+        return;\n+      }\n+      if (klass->has_archived_enum_objs()) {\n+        \/\/ This klass is a subclass of java.lang.Enum. If any instance of this klass\n+        \/\/ has been archived, we will archive all static fields of this klass.\n+        \/\/ See HeapShared::initialize_enum_klass().\n+        return;\n+      }\n+\n+      \/\/ This field *may* be initialized to a different value at runtime. Remember it\n+      \/\/ and check later if it appears in the archived object graph.\n+      _verifier->add_static_obj_field(_ik, static_obj_field, fd->name());\n+    }\n+  }\n+};\n+\n+\/\/ Remember all the static object fields of every class that are currently\n+\/\/ loaded.\n+void CDSHeapVerifier::do_klass(Klass* k) {\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+\n+    if (HeapShared::is_subgraph_root_class(ik)) {\n+      \/\/ ik is inside one of the ArchivableStaticFieldInfo tables\n+      \/\/ in heapShared.cpp. We assume such classes are programmed to\n+      \/\/ update their static fields correctly at runtime.\n+      return;\n+    }\n+\n+    CheckStaticFields csf(this, ik);\n+    ik->do_local_static_fields(&csf);\n+  }\n+}\n+\n+void CDSHeapVerifier::add_static_obj_field(InstanceKlass* ik, oop field, Symbol* name) {\n+  StaticFieldInfo info = {ik, name};\n+  _table.put(field, info);\n+}\n+\n+inline bool CDSHeapVerifier::do_entry(oop& orig_obj, HeapShared::CachedOopInfo& value) {\n+  _archived_objs++;\n+\n+  StaticFieldInfo* info = _table.get(orig_obj);\n+  if (info != NULL) {\n+    ResourceMark rm;\n+    LogStream ls(Log(cds, heap)::warning());\n+    ls.print_cr(\"Archive heap points to a static field that may be reinitialized at runtime:\");\n+    ls.print_cr(\"Field: %s::%s\", info->_holder->name()->as_C_string(), info->_name->as_C_string());\n+    ls.print(\"Value: \");\n+    orig_obj->print_on(&ls);\n+    ls.print_cr(\"--- trace begin ---\");\n+    trace_to_root(orig_obj, NULL, &value);\n+    ls.print_cr(\"--- trace end ---\");\n+    ls.cr();\n+    _problems ++;\n+  }\n+\n+  return true; \/* keep on iterating *\/\n+}\n+\n+class CDSHeapVerifier::TraceFields : public FieldClosure {\n+  oop _orig_obj;\n+  oop _orig_field;\n+  LogStream* _ls;\n+\n+public:\n+  TraceFields(oop orig_obj, oop orig_field, LogStream* ls)\n+    : _orig_obj(orig_obj), _orig_field(orig_field), _ls(ls) {}\n+\n+  void do_field(fieldDescriptor* fd) {\n+    if (fd->field_type() == T_OBJECT || fd->field_type() == T_ARRAY) {\n+      oop obj_field = _orig_obj->obj_field(fd->offset());\n+      if (obj_field == _orig_field) {\n+        _ls->print(\"::%s (offset = %d)\", fd->name()->as_C_string(), fd->offset());\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Hint: to exercise this function, uncomment out one of the ADD_EXCL lines above.\n+int CDSHeapVerifier::trace_to_root(oop orig_obj, oop orig_field, HeapShared::CachedOopInfo* p) {\n+  int level = 0;\n+  LogStream ls(Log(cds, heap)::warning());\n+  if (p->_referrer != NULL) {\n+    HeapShared::CachedOopInfo* ref = HeapShared::archived_object_cache()->get(p->_referrer);\n+    assert(ref != NULL, \"sanity\");\n+    level = trace_to_root(p->_referrer, orig_obj, ref) + 1;\n+  } else if (java_lang_String::is_instance(orig_obj)) {\n+    ls.print_cr(\"[%2d] (shared string table)\", level++);\n+  }\n+  Klass* k = orig_obj->klass();\n+  ResourceMark rm;\n+  ls.print(\"[%2d] \", level);\n+  orig_obj->print_address_on(&ls);\n+  ls.print(\" %s\", k->internal_name());\n+  if (orig_field != NULL) {\n+    if (k->is_instance_klass()) {\n+      TraceFields clo(orig_obj, orig_field, &ls);;\n+      InstanceKlass::cast(k)->do_nonstatic_fields(&clo);\n+    } else {\n+      assert(orig_obj->is_objArray(), \"must be\");\n+      objArrayOop array = (objArrayOop)orig_obj;\n+      for (int i = 0; i < array->length(); i++) {\n+        if (array->obj_at(i) == orig_field) {\n+          ls.print(\" @[%d]\", i);\n+          break;\n+        }\n+      }\n+    }\n+  }\n+  ls.cr();\n+\n+  return level;\n+}\n+\n+#ifdef ASSERT\n+void CDSHeapVerifier::verify() {\n+  CDSHeapVerifier verf;\n+  HeapShared::archived_object_cache()->iterate(&verf);\n+}\n+#endif\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_CDSHEAPVERIFIER_HPP\n+#define SHARED_CDS_CDSHEAPVERIFIER_HPP\n+\n+#include \"cds\/heapShared.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class InstanceKlass;\n+class Symbol;\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+class CDSHeapVerifier : public KlassClosure {\n+  class CheckStaticFields;\n+  class TraceFields;\n+\n+  int _archived_objs;\n+  int _problems;\n+\n+  struct StaticFieldInfo {\n+    InstanceKlass* _holder;\n+    Symbol* _name;\n+  };\n+\n+  ResourceHashtable<oop, StaticFieldInfo,\n+      15889, \/\/ prime number\n+      ResourceObj::C_HEAP,\n+      mtClassShared,\n+      HeapShared::oop_hash> _table;\n+\n+  GrowableArray<const char**> _exclusions;\n+\n+  void add_exclusion(const char** excl) {\n+    _exclusions.append(excl);\n+  }\n+  void add_static_obj_field(InstanceKlass* ik, oop field, Symbol* name);\n+\n+  const char** find_exclusion(InstanceKlass* ik) {\n+    for (int i = 0; i < _exclusions.length(); i++) {\n+      const char** excl = _exclusions.at(i);\n+      if (ik->name()->equals(excl[0])) {\n+        return &excl[1];\n+      }\n+    }\n+    return NULL;\n+  }\n+  int trace_to_root(oop orig_obj, oop orig_field, HeapShared::CachedOopInfo* p);\n+\n+  CDSHeapVerifier();\n+  ~CDSHeapVerifier();\n+\n+public:\n+\n+  \/\/ Overrides KlassClosure::do_klass()\n+  virtual void do_klass(Klass* k);\n+\n+  \/\/ For ResourceHashtable::iterate()\n+  inline bool do_entry(oop& orig_obj, HeapShared::CachedOopInfo& value);\n+\n+  static void verify() NOT_DEBUG_RETURN;\n+};\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+#endif \/\/ SHARED_CDS_CDSHEAPVERIFIER_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.hpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cds\/runTimeClassInfo.hpp\"\n@@ -48,0 +49,1 @@\n+  clone._enum_klass_static_fields = NULL;\n@@ -64,0 +66,1 @@\n+  assert(_enum_klass_static_fields == NULL, \"This should not happen with jcmd VM.cds dumping\");\n@@ -67,0 +70,6 @@\n+size_t DumpTimeClassInfo::runtime_info_bytesize() const {\n+  return RunTimeClassInfo::byte_size(_klass, num_verifier_constraints(),\n+                                     num_loader_constraints(),\n+                                     num_enum_klass_static_fields());\n+}\n+\n@@ -147,0 +156,12 @@\n+void DumpTimeClassInfo::add_enum_klass_static_field(int archived_heap_root_index) {\n+  if (_enum_klass_static_fields == NULL) {\n+    _enum_klass_static_fields = new (ResourceObj::C_HEAP, mtClass) GrowableArray<int>(20, mtClass);\n+  }\n+  _enum_klass_static_fields->append(archived_heap_root_index);\n+}\n+\n+int DumpTimeClassInfo::enum_klass_static_field(int which_field) {\n+  assert(_enum_klass_static_fields != NULL, \"must be\");\n+  return _enum_klass_static_fields->at(which_field);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  GrowableArray<int>*                  _enum_klass_static_fields;\n@@ -95,0 +96,1 @@\n+    _enum_klass_static_fields = NULL;\n@@ -100,1 +102,2 @@\n-\n+  void add_enum_klass_static_field(int archived_heap_root_index);\n+  int  enum_klass_static_field(int which_field);\n@@ -103,4 +106,4 @@\n-  int num_verifier_constraints() {\n-    if (_verifier_constraint_flags != NULL) {\n-      return _verifier_constraint_flags->length();\n-    } else {\n+private:\n+  template <typename T>\n+  static int array_length_or_zero(GrowableArray<T>* array) {\n+    if (array == NULL) {\n@@ -108,0 +111,2 @@\n+    } else {\n+      return array->length();\n@@ -111,6 +116,12 @@\n-  int num_loader_constraints() {\n-    if (_loader_constraints != NULL) {\n-      return _loader_constraints->length();\n-    } else {\n-      return 0;\n-    }\n+public:\n+\n+  int num_verifier_constraints() const {\n+    return array_length_or_zero(_verifier_constraint_flags);\n+  }\n+\n+  int num_loader_constraints() const {\n+    return array_length_or_zero(_loader_constraints);\n+  }\n+\n+  int num_enum_klass_static_fields() const {\n+    return array_length_or_zero(_enum_klass_static_fields);\n@@ -154,0 +165,1 @@\n+\n@@ -155,0 +167,1 @@\n+  size_t runtime_info_bytesize() const;\n@@ -157,2 +170,2 @@\n-\n-inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const& k) {\n+template <typename T>\n+inline unsigned DumpTimeSharedClassTable_hash(T* const& k) {\n@@ -166,1 +179,1 @@\n-    return primitive_hash<InstanceKlass*>(k);\n+    return primitive_hash<T*>(k);\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":27,"deletions":14,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1997,1 +1997,1 @@\n-      log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC or UseSerialGC are required.\");\n+      log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC or UseParallelGC are required.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsHeapVerifier.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"logging\/logMessage.hpp\"\n@@ -146,5 +146,18 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\n-\/\/ Java heap object archiving support\n-\/\/\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+static bool is_subgraph_root_class_of(ArchivableStaticFieldInfo fields[], int num, InstanceKlass* ik) {\n+  for (int i = 0; i < num; i++) {\n+    if (fields[i].klass == ik) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool HeapShared::is_subgraph_root_class(InstanceKlass* ik) {\n+  return is_subgraph_root_class_of(closed_archive_subgraph_entry_fields,\n+                                   num_closed_archive_subgraph_entry_fields, ik) ||\n+         is_subgraph_root_class_of(open_archive_subgraph_entry_fields,\n+                                   num_open_archive_subgraph_entry_fields, ik) ||\n+         is_subgraph_root_class_of(fmg_open_archive_subgraph_entry_fields,\n+                                   num_fmg_open_archive_subgraph_entry_fields, ik);\n+}\n+\n@@ -206,1 +219,1 @@\n-  oop* p = cache->get(obj);\n+  CachedOopInfo* p = cache->get(obj);\n@@ -208,1 +221,1 @@\n-    return *p;\n+    return p->_obj;\n@@ -305,1 +318,2 @@\n-    cache->put(obj, archived_oop);\n+    CachedOopInfo info = make_cached_oop_info(archived_oop);\n+    cache->put(obj, info);\n@@ -339,0 +353,88 @@\n+\/\/ -- Handling of Enum objects\n+\/\/ Java Enum classes have synthetic <clinit> methods that look like this\n+\/\/     enum MyEnum {FOO, BAR}\n+\/\/     MyEnum::<clinint> {\n+\/\/        \/*static final MyEnum*\/ MyEnum::FOO = new MyEnum(\"FOO\");\n+\/\/        \/*static final MyEnum*\/ MyEnum::BAR = new MyEnum(\"BAR\");\n+\/\/     }\n+\/\/\n+\/\/ If MyEnum::FOO object is referenced by any of the archived subgraphs, we must\n+\/\/ ensure the archived value equals (in object address) to the runtime value of\n+\/\/ MyEnum::FOO.\n+\/\/\n+\/\/ However, since MyEnum::<clinint> is synthetically generated by javac, there's\n+\/\/ no way of programatically handling this inside the Java code (as you would handle\n+\/\/ ModuleLayer::EMPTY_LAYER, for example).\n+\/\/\n+\/\/ Instead, we archive all static field of such Enum classes. At runtime,\n+\/\/ HeapShared::initialize_enum_klass() will skip the <clinit> method and pull\n+\/\/ the static fields out of the archived heap.\n+void HeapShared::check_enum_obj(int level,\n+                                KlassSubGraphInfo* subgraph_info,\n+                                oop orig_obj,\n+                                bool is_closed_archive) {\n+  Klass* k = orig_obj->klass();\n+  Klass* relocated_k = ArchiveBuilder::get_relocated_klass(k);\n+  if (!k->is_instance_klass()) {\n+    return;\n+  }\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  if (ik->java_super() == vmClasses::Enum_klass() && !ik->has_archived_enum_objs()) {\n+    ResourceMark rm;\n+    ik->set_has_archived_enum_objs();\n+    relocated_k->set_has_archived_enum_objs();\n+    oop mirror = ik->java_mirror();\n+\n+    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        if (fd.field_type() != T_OBJECT && fd.field_type() != T_ARRAY) {\n+          guarantee(false, \"static field %s::%s must be T_OBJECT or T_ARRAY\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        }\n+        oop oop_field = mirror->obj_field(fd.offset());\n+        if (oop_field == NULL) {\n+          guarantee(false, \"static field %s::%s must not be null\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        } else if (oop_field->klass() != ik && oop_field->klass() != ik->array_klass_or_null()) {\n+          guarantee(false, \"static field %s::%s is of the wrong type\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        }\n+        oop archived_oop_field = archive_reachable_objects_from(level, subgraph_info, oop_field, is_closed_archive);\n+        int root_index = append_root(archived_oop_field);\n+        log_info(cds, heap)(\"Archived enum obj @%d %s::%s (\" INTPTR_FORMAT \" -> \" INTPTR_FORMAT \")\",\n+                            root_index, ik->external_name(), fd.name()->as_C_string(),\n+                            p2i((oopDesc*)oop_field), p2i((oopDesc*)archived_oop_field));\n+        SystemDictionaryShared::add_enum_klass_static_field(ik, root_index);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ See comments in HeapShared::check_enum_obj()\n+bool HeapShared::initialize_enum_klass(InstanceKlass* k, TRAPS) {\n+  if (!is_fully_available()) {\n+    return false;\n+  }\n+\n+  RunTimeClassInfo* info = RunTimeClassInfo::get_for(k);\n+  assert(info != NULL, \"sanity\");\n+\n+  if (log_is_enabled(Info, cds, heap)) {\n+    ResourceMark rm;\n+    log_info(cds, heap)(\"Initializing Enum class: %s\", k->external_name());\n+  }\n+\n+  oop mirror = k->java_mirror();\n+  int i = 0;\n+  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      int root_index = info->enum_klass_static_field_root_index_at(i++);\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      assert(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY, \"must be\");\n+      mirror->obj_field_put(fd.offset(), get_root(root_index, \/*clear=*\/true));\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -380,0 +482,1 @@\n+    CDSHeapVerifier::verify();\n@@ -474,1 +577,1 @@\n-    _dump_time_subgraph_info_table->put_if_absent(relocated_k, KlassSubGraphInfo(relocated_k, is_full_module_graph),\n+    _dump_time_subgraph_info_table->put_if_absent(k, KlassSubGraphInfo(relocated_k, is_full_module_graph),\n@@ -482,2 +585,1 @@\n-  Klass* relocated_k = ArchiveBuilder::get_relocated_klass(k);\n-  KlassSubGraphInfo* info = _dump_time_subgraph_info_table->get(relocated_k);\n+  KlassSubGraphInfo* info = _dump_time_subgraph_info_table->get(k);\n@@ -644,1 +746,2 @@\n-      unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary((address)klass);\n+      Klass* relocated_k = ArchiveBuilder::get_relocated_klass(klass);\n+      unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary((address)relocated_k);\n@@ -906,0 +1009,5 @@\n+\n+  \/\/ The following are for maintaining a stack for determining\n+  \/\/ CachedOopInfo::_referrer\n+  static WalkOopAndArchiveClosure* _current;\n+  WalkOopAndArchiveClosure* _last;\n@@ -915,1 +1023,7 @@\n-    _orig_referencing_obj(orig), _archived_referencing_obj(archived) {}\n+    _orig_referencing_obj(orig), _archived_referencing_obj(archived) {\n+    _last = _current;\n+    _current = this;\n+  }\n+  ~WalkOopAndArchiveClosure() {\n+    _current = _last;\n+  }\n@@ -952,0 +1066,5 @@\n+\n+ public:\n+  static WalkOopAndArchiveClosure* current()  { return _current;              }\n+  oop orig_referencing_obj()                  { return _orig_referencing_obj; }\n+  KlassSubGraphInfo* subgraph_info()          { return _subgraph_info;        }\n@@ -954,0 +1073,13 @@\n+WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = NULL;\n+\n+HeapShared::CachedOopInfo HeapShared::make_cached_oop_info(oop orig_obj) {\n+  CachedOopInfo info;\n+  WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n+\n+  info._subgraph_info = (walker == NULL) ? NULL : walker->subgraph_info();\n+  info._referrer = (walker == NULL) ? NULL : walker->orig_referencing_obj();\n+  info._obj = orig_obj;\n+\n+  return info;\n+}\n+\n@@ -1079,0 +1211,2 @@\n+\n+  check_enum_obj(level + 1, subgraph_info, orig_obj, is_closed_archive);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":148,"deletions":14,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/dumpTimeClassInfo.hpp\"\n@@ -46,0 +47,1 @@\n+class KlassSubGraphInfo;\n@@ -196,1 +198,1 @@\n-\n+  static bool is_subgraph_root_class(InstanceKlass* ik);\n@@ -231,0 +233,7 @@\n+  struct CachedOopInfo {\n+    KlassSubGraphInfo* _subgraph_info;\n+    oop _referrer;\n+    oop _obj;\n+    CachedOopInfo() :_subgraph_info(), _referrer(), _obj() {}\n+  };\n+\n@@ -232,0 +241,4 @@\n+  static void check_enum_obj(int level,\n+                             KlassSubGraphInfo* subgraph_info,\n+                             oop orig_obj,\n+                             bool is_closed_archive);\n@@ -236,1 +249,1 @@\n-  typedef ResourceHashtable<oop, oop,\n+  typedef ResourceHashtable<oop, CachedOopInfo,\n@@ -243,5 +256,0 @@\n-  static unsigned klass_hash(Klass* const& klass) {\n-    \/\/ Generate deterministic hashcode even if SharedBaseAddress is changed due to ASLR.\n-    return primitive_hash<address>(address(klass) - SharedBaseAddress);\n-  }\n-\n@@ -253,1 +261,1 @@\n-                               HeapShared::klass_hash> {\n+                               DumpTimeSharedClassTable_hash> {\n@@ -275,1 +283,1 @@\n-\n+  static CachedOopInfo make_cached_oop_info(oop orig_obj);\n@@ -485,0 +493,1 @@\n+  static bool initialize_enum_klass(InstanceKlass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -3,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +66,9 @@\n+  if (_klass->has_archived_enum_objs()) {\n+    int num = info.num_enum_klass_static_fields();\n+    set_num_enum_klass_static_fields(num);\n+    for (int i = 0; i < num; i++) {\n+      int root_index = info.enum_klass_static_field(i);\n+      set_enum_klass_static_field_root_index_at(i, root_index);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -3,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +66,4 @@\n+  struct RTEnumKlassStaticFields {\n+    int _num;\n+    int _root_indices[1];\n+  };\n@@ -72,5 +75,6 @@\n-  \/\/ optional CrcInfo              _crc;  (only for UNREGISTERED classes)\n-  \/\/ optional InstanceKlass*       _nest_host\n-  \/\/ optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]\n-  \/\/ optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]\n-  \/\/ optional char                 _verifier_constraint_flags[_num_verifier_constraints]\n+  \/\/ optional CrcInfo                 _crc;  (only for UNREGISTERED classes)\n+  \/\/ optional InstanceKlass*          _nest_host\n+  \/\/ optional RTLoaderConstraint      _loader_constraint_types[_num_loader_constraints]\n+  \/\/ optional RTVerifierConstraint    _verifier_constraints[_num_verifier_constraints]\n+  \/\/ optional char                    _verifier_constraint_flags[_num_verifier_constraints]\n+  \/\/ optional RTEnumKlassStaticFields _enum_klass_static_fields;\n@@ -80,1 +84,1 @@\n-    return sizeof(RunTimeClassInfo);\n+    return align_up(sizeof(RunTimeClassInfo), wordSize);\n@@ -83,1 +87,1 @@\n-    return sizeof(RTVerifierConstraint) * num_verifier_constraints;\n+    return align_up(sizeof(RTVerifierConstraint) * num_verifier_constraints, wordSize);\n@@ -86,1 +90,1 @@\n-    return sizeof(char) * num_verifier_constraints;\n+    return align_up(sizeof(char) * num_verifier_constraints, wordSize);\n@@ -89,1 +93,1 @@\n-    return sizeof(RTLoaderConstraint) * num_loader_constraints;\n+    return align_up(sizeof(RTLoaderConstraint) * num_loader_constraints, wordSize);\n@@ -91,0 +95,5 @@\n+  static size_t enum_klass_static_fields_size(int num_fields) {\n+    size_t size = num_fields <= 0 ? 0 : sizeof(RTEnumKlassStaticFields) + (num_fields - 1) * sizeof(int);\n+    return align_up(size, wordSize);\n+  }\n+\n@@ -101,1 +110,2 @@\n-  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {\n+  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints,\n+                          int num_enum_klass_static_fields) {\n@@ -107,1 +117,2 @@\n-           verifier_constraint_flags_size(num_verifier_constraints);\n+           verifier_constraint_flags_size(num_verifier_constraints) +\n+           enum_klass_static_fields_size(num_enum_klass_static_fields);\n@@ -116,1 +127,1 @@\n-      return crc_offset() + crc_size(_klass);\n+    return crc_offset() + crc_size(_klass);\n@@ -128,0 +139,3 @@\n+  size_t enum_klass_static_fields_offset() const {\n+    return verifier_constraint_flags_offset() + verifier_constraint_flags_size(_num_verifier_constraints);\n+  }\n@@ -137,0 +151,5 @@\n+  RTEnumKlassStaticFields* enum_klass_static_fields_addr() const {\n+    assert(_klass->has_archived_enum_objs(), \"sanity\");\n+    return (RTEnumKlassStaticFields*)(address(this) + enum_klass_static_fields_offset());\n+  }\n+\n@@ -190,0 +209,17 @@\n+  int num_enum_klass_static_fields(int i) const {\n+    return enum_klass_static_fields_addr()->_num;\n+  }\n+\n+  void set_num_enum_klass_static_fields(int num) {\n+    enum_klass_static_fields_addr()->_num = num;\n+  }\n+\n+  int enum_klass_static_field_root_index_at(int i) const {\n+    assert(0 <= i && i < enum_klass_static_fields_addr()->_num, \"must be\");\n+    return enum_klass_static_fields_addr()->_root_indices[i];\n+  }\n+\n+  void set_enum_klass_static_field_root_index_at(int i, int root_index) {\n+    assert(0 <= i && i < enum_klass_static_fields_addr()->_num, \"must be\");\n+    enum_klass_static_fields_addr()->_root_indices[i] = root_index;\n+  }\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":50,"deletions":14,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -2744,0 +2744,1 @@\n+                                     _cp->symbol_at(name_index),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -903,1 +903,1 @@\n-                               mt, CHECK_NULL);\n+                               mt, name, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1562,2 +1562,2 @@\n-\/\/ Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Compile_lock\n-\/\/ is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in\n+\/\/ Update hierarchy. This is done before the new klass has been added to the SystemDictionary. The Compile_lock\n+\/\/ is held, to ensure that the compiler is not using the class hierarchy, and that deoptimization will kick in\n@@ -1577,1 +1577,1 @@\n-  \/\/ Link into hierachy.\n+  \/\/ Link into hierarchy.\n@@ -1727,1 +1727,1 @@\n-\/\/ Update class loader data dictionary - done after check_constraint and add_to_hierachy\n+\/\/ Update class loader data dictionary - done after check_constraint and add_to_hierarchy\n@@ -2017,1 +2017,1 @@\n-    if (!Arguments::is_interpreter_only()) {\n+    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n@@ -2019,0 +2019,1 @@\n+      \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -796,0 +796,7 @@\n+void SystemDictionaryShared::add_enum_klass_static_field(InstanceKlass* ik, int root_index) {\n+  assert(DumpSharedSpaces, \"static dump only\");\n+  DumpTimeClassInfo* info = SystemDictionaryShared::find_or_allocate_info_for_locked(ik);\n+  assert(info != NULL, \"must be\");\n+  info->add_enum_klass_static_field(root_index);\n+}\n+\n@@ -1177,1 +1184,1 @@\n-      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      size_t byte_size = info.runtime_info_bytesize();\n@@ -1286,1 +1293,1 @@\n-      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      size_t byte_size = info.runtime_info_bytesize();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,0 +196,3 @@\n+  static bool has_archived_enum_objs(InstanceKlass* ik);\n+  static void set_has_archived_enum_objs(InstanceKlass* ik);\n+\n@@ -246,0 +249,1 @@\n+  static void add_enum_klass_static_field(InstanceKlass* ik, int root_index);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,0 +139,1 @@\n+  do_klass(Enum_klass,                                  java_lang_Enum                                        ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-    case vmIntrinsics::_hasNegatives:\n+    case vmIntrinsics::_countPositives:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -357,3 +357,3 @@\n-  do_intrinsic(_hasNegatives,             java_lang_StringCoding, hasNegatives_name, hasNegatives_signature,     F_S)   \\\n-   do_name(     hasNegatives_name,                               \"hasNegatives\")                                        \\\n-   do_signature(hasNegatives_signature,                          \"([BII)Z\")                                             \\\n+  do_intrinsic(_countPositives,     java_lang_StringCoding, countPositives_name, countPositives_signature, F_S)         \\\n+   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n+   do_signature(countPositives_signature,                  \"([BII)I\")                                                   \\\n@@ -462,1 +462,1 @@\n-  do_intrinsic(_digestBase_implCompressMB, sun_security_provider_digestbase, implCompressMB_name, implCompressMB_signature, F_R)   \\\n+  do_intrinsic(_digestBase_implCompressMB, sun_security_provider_digestbase, implCompressMB_name, countPositives_signature, F_R)   \\\n@@ -464,1 +464,0 @@\n-   do_signature(implCompressMB_signature,                          \"([BII)I\")                                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -703,0 +703,1 @@\n+  template(java_lang_Enum,                                  \"java\/lang\/Enum\")                                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,16 +104,31 @@\n-  int total()                                    { return total_size; }\n-  bool is_empty()                                { return count == 0; }\n-\n-  void print(const char* title) {\n-    tty->print_cr(\" #%d %s = %dK (hdr %d%%,  loc %d%%, code %d%%, stub %d%%, [oops %d%%, metadata %d%%, data %d%%, pcs %d%%])\",\n-                  count,\n-                  title,\n-                  (int)(total() \/ K),\n-                  header_size             * 100 \/ total_size,\n-                  relocation_size         * 100 \/ total_size,\n-                  code_size               * 100 \/ total_size,\n-                  stub_size               * 100 \/ total_size,\n-                  scopes_oop_size         * 100 \/ total_size,\n-                  scopes_metadata_size    * 100 \/ total_size,\n-                  scopes_data_size        * 100 \/ total_size,\n-                  scopes_pcs_size         * 100 \/ total_size);\n+  int total() const                              { return total_size; }\n+  bool is_empty() const                          { return count == 0; }\n+\n+  void print(const char* title) const {\n+    if (is_empty()) {\n+      tty->print_cr(\" #%d %s = %dK\",\n+                    count,\n+                    title,\n+                    total()                 \/ (int)K);\n+    } else {\n+      tty->print_cr(\" #%d %s = %dK (hdr %dK %d%%, loc %dK %d%%, code %dK %d%%, stub %dK %d%%, [oops %dK %d%%, metadata %dK %d%%, data %dK %d%%, pcs %dK %d%%])\",\n+                    count,\n+                    title,\n+                    total()                 \/ (int)K,\n+                    header_size             \/ (int)K,\n+                    header_size             * 100 \/ total_size,\n+                    relocation_size         \/ (int)K,\n+                    relocation_size         * 100 \/ total_size,\n+                    code_size               \/ (int)K,\n+                    code_size               * 100 \/ total_size,\n+                    stub_size               \/ (int)K,\n+                    stub_size               * 100 \/ total_size,\n+                    scopes_oop_size         \/ (int)K,\n+                    scopes_oop_size         * 100 \/ total_size,\n+                    scopes_metadata_size    \/ (int)K,\n+                    scopes_metadata_size    * 100 \/ total_size,\n+                    scopes_data_size        \/ (int)K,\n+                    scopes_data_size        * 100 \/ total_size,\n+                    scopes_pcs_size         \/ (int)K,\n+                    scopes_pcs_size         * 100 \/ total_size);\n+    }\n@@ -356,1 +371,1 @@\n-  } else if (Arguments::is_interpreter_only()) {\n+  } else if (CompilerConfig::is_interpreter_only()) {\n@@ -1226,1 +1241,1 @@\n-  heap->report_full();\n+  int full_count = heap->report_full();\n@@ -1228,1 +1243,1 @@\n-  if ((heap->full_count() == 1) || print) {\n+  if ((full_count == 1) || print) {\n@@ -1265,1 +1280,1 @@\n-    if (heap->full_count() == 1) {\n+    if (full_count == 1) {\n@@ -1430,2 +1445,8 @@\n-  CodeBlob_sizes live;\n-  CodeBlob_sizes dead;\n+  CodeBlob_sizes live[CompLevel_full_optimization + 1];\n+  CodeBlob_sizes dead[CompLevel_full_optimization + 1];\n+  CodeBlob_sizes runtimeStub;\n+  CodeBlob_sizes uncommonTrapStub;\n+  CodeBlob_sizes deoptimizationStub;\n+  CodeBlob_sizes adapter;\n+  CodeBlob_sizes bufferBlob;\n+  CodeBlob_sizes other;\n@@ -1435,2 +1456,18 @@\n-      if (!cb->is_alive()) {\n-        dead.add(cb);\n+      if (cb->is_nmethod()) {\n+        const int level = cb->as_nmethod()->comp_level();\n+        assert(0 <= level && level <= CompLevel_full_optimization, \"Invalid compilation level\");\n+        if (!cb->is_alive()) {\n+          dead[level].add(cb);\n+        } else {\n+          live[level].add(cb);\n+        }\n+      } else if (cb->is_runtime_stub()) {\n+        runtimeStub.add(cb);\n+      } else if (cb->is_deoptimization_stub()) {\n+        deoptimizationStub.add(cb);\n+      } else if (cb->is_uncommon_trap_stub()) {\n+        uncommonTrapStub.add(cb);\n+      } else if (cb->is_adapter_blob()) {\n+        adapter.add(cb);\n+      } else if (cb->is_buffer_blob()) {\n+        bufferBlob.add(cb);\n@@ -1438,1 +1475,1 @@\n-        live.add(cb);\n+        other.add(cb);\n@@ -1443,1 +1480,0 @@\n-  tty->print_cr(\"CodeCache:\");\n@@ -1446,5 +1482,30 @@\n-  if (!live.is_empty()) {\n-    live.print(\"live\");\n-  }\n-  if (!dead.is_empty()) {\n-    dead.print(\"dead\");\n+  tty->print_cr(\"nmethod blobs per compilation level:\");\n+  for (int i = 0; i <= CompLevel_full_optimization; i++) {\n+    const char *level_name;\n+    switch (i) {\n+    case CompLevel_none:              level_name = \"none\";              break;\n+    case CompLevel_simple:            level_name = \"simple\";            break;\n+    case CompLevel_limited_profile:   level_name = \"limited profile\";   break;\n+    case CompLevel_full_profile:      level_name = \"full profile\";      break;\n+    case CompLevel_full_optimization: level_name = \"full optimization\"; break;\n+    default: assert(false, \"invalid compilation level\");\n+    }\n+    tty->print_cr(\"%s:\", level_name);\n+    live[i].print(\"live\");\n+    dead[i].print(\"dead\");\n+  }\n+\n+  struct {\n+    const char* name;\n+    const CodeBlob_sizes* sizes;\n+  } non_nmethod_blobs[] = {\n+    { \"runtime\",        &runtimeStub },\n+    { \"uncommon trap\",  &uncommonTrapStub },\n+    { \"deoptimization\", &deoptimizationStub },\n+    { \"adapter\",        &adapter },\n+    { \"buffer blob\",    &bufferBlob },\n+    { \"other\",          &other },\n+  };\n+  tty->print_cr(\"Non-nmethod blobs:\");\n+  for (auto& blob: non_nmethod_blobs) {\n+    blob.sizes->print(blob.name);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":92,"deletions":31,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -228,0 +228,2 @@\n+    \/\/ Note: This method can be called from non-Java\/compiler threads to\n+    \/\/ log the global metaspace failure that might affect profiling.\n@@ -232,1 +234,1 @@\n-    log(JavaThread::current(), \"%s\", (const char*)lm);\n+    log(Thread::current(), \"%s\", (const char*)lm);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -313,1 +313,0 @@\n-\n@@ -512,0 +511,4 @@\n+    if (SegmentedCodeCache) {\n+      warning(\"SegmentedCodeCache has no meaningful effect with -Xint\");\n+      FLAG_SET_DEFAULT(SegmentedCodeCache, false);\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+NOT_PRODUCT(cflags(TraceEscapeAnalysis, bool, false, TraceEscapeAnalysis)) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+NOT_PRODUCT(option(TraceEscapeAnalysis, \"TraceEscapeAnalysis\", Bool)) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/g1\/g1FromCardCache.hpp\"\n@@ -31,0 +30,2 @@\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"runtime\/mutex.hpp\"\n@@ -38,6 +38,0 @@\n-#include \"utilities\/lockFreeStack.hpp\"\n-#include \"utilities\/spinYield.hpp\"\n-\n-#include \"gc\/shared\/gcLogPrecious.hpp\"\n-#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n-#include \"runtime\/java.hpp\"\n@@ -45,1 +39,1 @@\n-G1CardSet::CardSetPtr G1CardSet::FullCardSet = (G1CardSet::CardSetPtr)-1;\n+G1CardSet::ContainerPtr G1CardSet::FullCardSet = (G1CardSet::ContainerPtr)-1;\n@@ -47,1 +41,1 @@\n-static uint default_log2_card_region_per_region() {\n+static uint default_log2_card_regions_per_region() {\n@@ -65,1 +59,1 @@\n-                         default_log2_card_region_per_region())                     \/* log2_card_region_per_region *\/\n+                         default_log2_card_regions_per_region())                    \/* log2_card_regions_per_region *\/\n@@ -76,1 +70,1 @@\n-                                               uint log2_card_region_per_region) :\n+                                               uint log2_card_regions_per_region) :\n@@ -85,1 +79,1 @@\n-                         log2_card_region_per_region)\n+                         log2_card_regions_per_region)\n@@ -200,1 +194,1 @@\n-  using CardSetPtr = G1CardSet::CardSetPtr;\n+  using ContainerPtr = G1CardSet::ContainerPtr;\n@@ -234,1 +228,1 @@\n-    G1CardSet::CardSetPtrClosure* _scan_f;\n+    G1CardSet::ContainerPtrClosure* _scan_f;\n@@ -236,1 +230,1 @@\n-    explicit G1CardSetHashTableScan(G1CardSet::CardSetPtrClosure* f) : _scan_f(f) { }\n+    explicit G1CardSetHashTableScan(G1CardSet::ContainerPtrClosure* f) : _scan_f(f) { }\n@@ -239,1 +233,1 @@\n-      _scan_f->do_cardsetptr(value->_region_idx, value->_num_occupied, value->_card_set);\n+      _scan_f->do_containerptr(value->_region_idx, value->_num_occupied, value->_container);\n@@ -287,1 +281,1 @@\n-  void iterate_safepoint(G1CardSet::CardSetPtrClosure* cl2) {\n+  void iterate_safepoint(G1CardSet::ContainerPtrClosure* cl2) {\n@@ -292,1 +286,1 @@\n-  void iterate(G1CardSet::CardSetPtrClosure* cl2) {\n+  void iterate(G1CardSet::ContainerPtrClosure* cl2) {\n@@ -299,1 +293,1 @@\n-       _table.unsafe_reset(InitialLogTableSize);\n+      _table.unsafe_reset(InitialLogTableSize);\n@@ -346,4 +340,4 @@\n-uint G1CardSet::card_set_type_to_mem_object_type(uintptr_t type) const {\n-  assert(type == G1CardSet::CardSetArrayOfCards ||\n-         type == G1CardSet::CardSetBitMap ||\n-         type == G1CardSet::CardSetHowl, \"should not allocate card set type %zu\", type);\n+uint G1CardSet::container_type_to_mem_object_type(uintptr_t type) const {\n+  assert(type == G1CardSet::ContainerArrayOfCards ||\n+         type == G1CardSet::ContainerBitMap ||\n+         type == G1CardSet::ContainerHowl, \"should not allocate container type %zu\", type);\n@@ -355,1 +349,1 @@\n-  return _mm->allocate(card_set_type_to_mem_object_type(type));\n+  return _mm->allocate(container_type_to_mem_object_type(type));\n@@ -358,3 +352,3 @@\n-void G1CardSet::free_mem_object(CardSetPtr card_set) {\n-  assert(card_set != G1CardSet::FreeCardSet, \"should not free Free card set\");\n-  assert(card_set != G1CardSet::FullCardSet, \"should not free Full card set\");\n+void G1CardSet::free_mem_object(ContainerPtr container) {\n+  assert(container != G1CardSet::FreeCardSet, \"should not free container FreeCardSet\");\n+  assert(container != G1CardSet::FullCardSet, \"should not free container FullCardSet\");\n@@ -362,2 +356,2 @@\n-  uintptr_t type = card_set_type(card_set);\n-  void* value = strip_card_set_type(card_set);\n+  uintptr_t type = container_type(container);\n+  void* value = strip_container_type(container);\n@@ -365,3 +359,3 @@\n-  assert(type == G1CardSet::CardSetArrayOfCards ||\n-         type == G1CardSet::CardSetBitMap ||\n-         type == G1CardSet::CardSetHowl, \"should not free card set type %zu\", type);\n+  assert(type == G1CardSet::ContainerArrayOfCards ||\n+         type == G1CardSet::ContainerBitMap ||\n+         type == G1CardSet::ContainerHowl, \"should not free card set type %zu\", type);\n@@ -370,1 +364,1 @@\n-  _mm->free(card_set_type_to_mem_object_type(type), value);\n+  _mm->free(container_type_to_mem_object_type(type), value);\n@@ -373,1 +367,1 @@\n-G1CardSet::CardSetPtr G1CardSet::acquire_card_set(CardSetPtr volatile* card_set_addr) {\n+G1CardSet::ContainerPtr G1CardSet::acquire_container(ContainerPtr volatile* container_addr) {\n@@ -379,5 +373,5 @@\n-    \/\/ Get cardsetptr and increment refcount atomically wrt to memory reuse.\n-    CardSetPtr card_set = Atomic::load_acquire(card_set_addr);\n-    uint cs_type = card_set_type(card_set);\n-    if (card_set == FullCardSet || cs_type == CardSetInlinePtr) {\n-      return card_set;\n+    \/\/ Get ContainerPtr and increment refcount atomically wrt to memory reuse.\n+    ContainerPtr container = Atomic::load_acquire(container_addr);\n+    uint cs_type = container_type(container);\n+    if (container == FullCardSet || cs_type == ContainerInlinePtr) {\n+      return container;\n@@ -386,1 +380,1 @@\n-    G1CardSetContainer* card_set_on_heap = (G1CardSetContainer*)strip_card_set_type(card_set);\n+    G1CardSetContainer* container_on_heap = (G1CardSetContainer*)strip_container_type(container);\n@@ -388,3 +382,3 @@\n-    if (card_set_on_heap->try_increment_refcount()) {\n-      assert(card_set_on_heap->refcount() >= 3, \"Smallest value is 3\");\n-      return card_set;\n+    if (container_on_heap->try_increment_refcount()) {\n+      assert(container_on_heap->refcount() >= 3, \"Smallest value is 3\");\n+      return container;\n@@ -395,3 +389,3 @@\n-bool G1CardSet::release_card_set(CardSetPtr card_set) {\n-  uint cs_type = card_set_type(card_set);\n-  if (card_set == FullCardSet || cs_type == CardSetInlinePtr) {\n+bool G1CardSet::release_container(ContainerPtr container) {\n+  uint cs_type = container_type(container);\n+  if (container == FullCardSet || cs_type == ContainerInlinePtr) {\n@@ -401,2 +395,2 @@\n-  G1CardSetContainer* card_set_on_heap = (G1CardSetContainer*)strip_card_set_type(card_set);\n-  return card_set_on_heap->decrement_refcount() == 1;\n+  G1CardSetContainer* container_on_heap = (G1CardSetContainer*)strip_container_type(container);\n+  return container_on_heap->decrement_refcount() == 1;\n@@ -405,3 +399,3 @@\n-void G1CardSet::release_and_maybe_free_card_set(CardSetPtr card_set) {\n-  if (release_card_set(card_set)) {\n-    free_mem_object(card_set);\n+void G1CardSet::release_and_maybe_free_container(ContainerPtr container) {\n+  if (release_container(container)) {\n+    free_mem_object(container);\n@@ -411,2 +405,2 @@\n-void G1CardSet::release_and_must_free_card_set(CardSetPtr card_set) {\n-  bool should_free = release_card_set(card_set);\n+void G1CardSet::release_and_must_free_container(ContainerPtr container) {\n+  bool should_free = release_container(container);\n@@ -414,1 +408,1 @@\n-  free_mem_object(card_set);\n+  free_mem_object(container);\n@@ -419,1 +413,1 @@\n-  using CardSetPtr = G1CardSet::CardSetPtr;\n+  using ContainerPtr = G1CardSet::ContainerPtr;\n@@ -421,1 +415,1 @@\n-  void coarsen_to_full(CardSetPtr* card_set_addr) {\n+  void coarsen_to_full(ContainerPtr* container_addr) {\n@@ -423,3 +417,3 @@\n-      CardSetPtr cur_card_set = Atomic::load_acquire(card_set_addr);\n-      uint cs_type = G1CardSet::card_set_type(cur_card_set);\n-      if (cur_card_set == G1CardSet::FullCardSet) {\n+      ContainerPtr cur_container = Atomic::load_acquire(container_addr);\n+      uint cs_type = G1CardSet::container_type(cur_container);\n+      if (cur_container == G1CardSet::FullCardSet) {\n@@ -429,1 +423,1 @@\n-      CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, G1CardSet::FullCardSet);\n+      ContainerPtr old_value = Atomic::cmpxchg(container_addr, cur_container, G1CardSet::FullCardSet);\n@@ -431,2 +425,2 @@\n-      if (old_value == cur_card_set) {\n-        _card_set->release_and_maybe_free_card_set(cur_card_set);\n+      if (old_value == cur_container) {\n+        _card_set->release_and_maybe_free_container(cur_container);\n@@ -441,2 +435,2 @@\n-  void operator ()(CardSetPtr* card_set_addr) {\n-    coarsen_to_full(card_set_addr);\n+  void operator ()(ContainerPtr* container_addr) {\n+    coarsen_to_full(container_addr);\n@@ -446,2 +440,2 @@\n-G1AddCardResult G1CardSet::add_to_array(CardSetPtr card_set, uint card_in_region) {\n-  G1CardSetArray* array = card_set_ptr<G1CardSetArray>(card_set);\n+G1AddCardResult G1CardSet::add_to_array(ContainerPtr container, uint card_in_region) {\n+  G1CardSetArray* array = container_ptr<G1CardSetArray>(container);\n@@ -451,5 +445,5 @@\n-G1AddCardResult G1CardSet::add_to_howl(CardSetPtr parent_card_set,\n-                                                uint card_region,\n-                                                uint card_in_region,\n-                                                bool increment_total) {\n-  G1CardSetHowl* howl = card_set_ptr<G1CardSetHowl>(parent_card_set);\n+G1AddCardResult G1CardSet::add_to_howl(ContainerPtr parent_container,\n+                                       uint card_region,\n+                                       uint card_in_region,\n+                                       bool increment_total) {\n+  G1CardSetHowl* howl = container_ptr<G1CardSetHowl>(parent_container);\n@@ -458,2 +452,2 @@\n-  CardSetPtr to_transfer = nullptr;\n-  CardSetPtr card_set;\n+  ContainerPtr to_transfer = nullptr;\n+  ContainerPtr container;\n@@ -462,1 +456,1 @@\n-  volatile CardSetPtr* bucket_entry = howl->get_card_set_addr(bucket);\n+  ContainerPtr volatile* bucket_entry = howl->get_container_addr(bucket);\n@@ -469,2 +463,2 @@\n-    card_set = acquire_card_set(bucket_entry);\n-    add_result = add_to_card_set(bucket_entry, card_set, card_region, card_in_region);\n+    container = acquire_container(bucket_entry);\n+    add_result = add_to_container(bucket_entry, container, card_region, card_in_region);\n@@ -475,3 +469,3 @@\n-    \/\/ Card set has overflown. Coarsen or retry.\n-    bool coarsened = coarsen_card_set(bucket_entry, card_set, card_in_region, true \/* within_howl *\/);\n-    _coarsen_stats.record_coarsening(card_set_type(card_set) + G1CardSetCoarsenStats::CoarsenHowlOffset, !coarsened);\n+    \/\/ Card set container has overflown. Coarsen or retry.\n+    bool coarsened = coarsen_container(bucket_entry, container, card_in_region, true \/* within_howl *\/);\n+    _coarsen_stats.record_coarsening(container_type(container) + G1CardSetCoarsenStats::CoarsenHowlOffset, !coarsened);\n@@ -479,1 +473,1 @@\n-      \/\/ We have been the one coarsening this card set (and in the process added that card).\n+      \/\/ We successful coarsened this card set container (and in the process added the card).\n@@ -481,1 +475,1 @@\n-      to_transfer = card_set;\n+      to_transfer = container;\n@@ -485,1 +479,1 @@\n-    release_and_maybe_free_card_set(card_set);\n+    release_and_maybe_free_container(container);\n@@ -493,1 +487,1 @@\n-    transfer_cards_in_howl(parent_card_set, to_transfer, card_region);\n+    transfer_cards_in_howl(parent_container, to_transfer, card_region);\n@@ -496,1 +490,1 @@\n-  release_and_maybe_free_card_set(card_set);\n+  release_and_maybe_free_container(container);\n@@ -500,2 +494,2 @@\n-G1AddCardResult G1CardSet::add_to_bitmap(CardSetPtr card_set, uint card_in_region) {\n-  G1CardSetBitMap* bitmap = card_set_ptr<G1CardSetBitMap>(card_set);\n+G1AddCardResult G1CardSet::add_to_bitmap(ContainerPtr container, uint card_in_region) {\n+  G1CardSetBitMap* bitmap = container_ptr<G1CardSetBitMap>(container);\n@@ -506,2 +500,2 @@\n-G1AddCardResult G1CardSet::add_to_inline_ptr(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_in_region) {\n-  G1CardSetInlinePtr value(card_set_addr, card_set);\n+G1AddCardResult G1CardSet::add_to_inline_ptr(ContainerPtr volatile* container_addr, ContainerPtr container, uint card_in_region) {\n+  G1CardSetInlinePtr value(container_addr, container);\n@@ -511,1 +505,1 @@\n-G1CardSet::CardSetPtr G1CardSet::create_coarsened_array_of_cards(uint card_in_region, bool within_howl) {\n+G1CardSet::ContainerPtr G1CardSet::create_coarsened_array_of_cards(uint card_in_region, bool within_howl) {\n@@ -513,1 +507,1 @@\n-  CardSetPtr new_card_set;\n+  ContainerPtr new_container;\n@@ -516,4 +510,4 @@\n-    uint card_offset = _config->howl_bitmap_offset(card_in_region);\n-    data = allocate_mem_object(CardSetBitMap);\n-    new (data) G1CardSetBitMap(card_offset, size_in_bits);\n-    new_card_set = make_card_set_ptr(data, CardSetBitMap);\n+    uint container_offset = _config->howl_bitmap_offset(card_in_region);\n+    data = allocate_mem_object(ContainerBitMap);\n+    new (data) G1CardSetBitMap(container_offset, size_in_bits);\n+    new_container = make_container_ptr(data, ContainerBitMap);\n@@ -521,1 +515,1 @@\n-    data = allocate_mem_object(CardSetHowl);\n+    data = allocate_mem_object(ContainerHowl);\n@@ -523,1 +517,1 @@\n-    new_card_set = make_card_set_ptr(data, CardSetHowl);\n+    new_container = make_container_ptr(data, ContainerHowl);\n@@ -525,1 +519,1 @@\n-  return new_card_set;\n+  return new_container;\n@@ -528,5 +522,5 @@\n-bool G1CardSet::coarsen_card_set(volatile CardSetPtr* card_set_addr,\n-                                 CardSetPtr cur_card_set,\n-                                 uint card_in_region,\n-                                 bool within_howl) {\n-  CardSetPtr new_card_set = nullptr;\n+bool G1CardSet::coarsen_container(ContainerPtr volatile* container_addr,\n+                                  ContainerPtr cur_container,\n+                                  uint card_in_region,\n+                                  bool within_howl) {\n+  ContainerPtr new_container = nullptr;\n@@ -534,3 +528,3 @@\n-  switch (card_set_type(cur_card_set)) {\n-    case CardSetArrayOfCards : {\n-      new_card_set = create_coarsened_array_of_cards(card_in_region, within_howl);\n+  switch (container_type(cur_container)) {\n+    case ContainerArrayOfCards: {\n+      new_container = create_coarsened_array_of_cards(card_in_region, within_howl);\n@@ -539,2 +533,2 @@\n-    case CardSetBitMap: {\n-      new_card_set = FullCardSet;\n+    case ContainerBitMap: {\n+      new_container = FullCardSet;\n@@ -543,1 +537,1 @@\n-    case CardSetInlinePtr: {\n+    case ContainerInlinePtr: {\n@@ -545,1 +539,1 @@\n-      uint8_t* data = allocate_mem_object(CardSetArrayOfCards);\n+      uint8_t* data = allocate_mem_object(ContainerArrayOfCards);\n@@ -547,1 +541,1 @@\n-      new_card_set = make_card_set_ptr(data, CardSetArrayOfCards);\n+      new_container = make_container_ptr(data, ContainerArrayOfCards);\n@@ -550,2 +544,2 @@\n-    case CardSetHowl: {\n-      new_card_set = FullCardSet; \/\/ anything will do at this point.\n+    case ContainerHowl: {\n+      new_container = FullCardSet; \/\/ anything will do at this point.\n@@ -558,2 +552,2 @@\n-  CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, new_card_set); \/\/ Memory order?\n-  if (old_value == cur_card_set) {\n+  ContainerPtr old_value = Atomic::cmpxchg(container_addr, cur_container, new_container); \/\/ Memory order?\n+  if (old_value == cur_container) {\n@@ -565,1 +559,1 @@\n-    bool should_free = release_card_set(cur_card_set);\n+    bool should_free = release_container(cur_container);\n@@ -567,2 +561,2 @@\n-    \/\/ Free containers if cur_card_set is CardSetHowl\n-    if (card_set_type(cur_card_set) == CardSetHowl) {\n+    \/\/ Free containers if cur_container is ContainerHowl\n+    if (container_type(cur_container) == ContainerHowl) {\n@@ -570,1 +564,1 @@\n-      card_set_ptr<G1CardSetHowl>(cur_card_set)->iterate(rel, _config->num_buckets_in_howl());\n+      container_ptr<G1CardSetHowl>(cur_container)->iterate(rel, _config->num_buckets_in_howl());\n@@ -575,3 +569,3 @@\n-    if (new_card_set != FullCardSet) {\n-      assert(new_card_set != nullptr, \"must not be\");\n-      release_and_must_free_card_set(new_card_set);\n+    if (new_container != FullCardSet) {\n+      assert(new_container != nullptr, \"must not be\");\n+      release_and_must_free_container(new_container);\n@@ -594,5 +588,5 @@\n-void G1CardSet::transfer_cards(G1CardSetHashTableValue* table_entry, CardSetPtr source_card_set, uint card_region) {\n-  assert(source_card_set != FullCardSet, \"Should not need to transfer from full\");\n-  \/\/ Need to transfer old entries unless there is a Full card set in place now, i.e.\n-  \/\/ the old type has been CardSetBitMap. \"Full\" contains all elements anyway.\n-  if (card_set_type(source_card_set) != CardSetHowl) {\n+void G1CardSet::transfer_cards(G1CardSetHashTableValue* table_entry, ContainerPtr source_container, uint card_region) {\n+  assert(source_container != FullCardSet, \"Should not need to transfer from FullCardSet\");\n+  \/\/ Need to transfer old entries unless there is a Full card set container in place now, i.e.\n+  \/\/ the old type has been ContainerBitMap. \"Full\" contains all elements anyway.\n+  if (container_type(source_container) != ContainerHowl) {\n@@ -600,1 +594,1 @@\n-    iterate_cards_during_transfer(source_card_set, iter);\n+    iterate_cards_during_transfer(source_container, iter);\n@@ -602,1 +596,1 @@\n-    assert(card_set_type(source_card_set) == CardSetHowl, \"must be\");\n+    assert(container_type(source_container) == ContainerHowl, \"must be\");\n@@ -609,5 +603,5 @@\n-void G1CardSet::transfer_cards_in_howl(CardSetPtr parent_card_set,\n-                                                     CardSetPtr source_card_set,\n-                                                     uint card_region) {\n-  assert(card_set_type(parent_card_set) == CardSetHowl, \"must be\");\n-  assert(source_card_set != FullCardSet, \"Should not need to transfer from full\");\n+void G1CardSet::transfer_cards_in_howl(ContainerPtr parent_container,\n+                                       ContainerPtr source_container,\n+                                       uint card_region) {\n+  assert(container_type(parent_container) == ContainerHowl, \"must be\");\n+  assert(source_container != FullCardSet, \"Should not need to transfer from full\");\n@@ -615,3 +609,3 @@\n-  \/\/ the old type has been CardSetBitMap.\n-  if (card_set_type(source_card_set) != CardSetBitMap) {\n-    \/\/ We only need to transfer from anything below CardSetBitMap.\n+  \/\/ the old type has been ContainerBitMap.\n+  if (container_type(source_container) != ContainerBitMap) {\n+    \/\/ We only need to transfer from anything below ContainerBitMap.\n@@ -619,1 +613,1 @@\n-    iterate_cards_during_transfer(source_card_set, iter);\n+    iterate_cards_during_transfer(source_container, iter);\n@@ -621,1 +615,1 @@\n-    uint diff = _config->max_cards_in_howl_bitmap() - card_set_ptr<G1CardSetBitMap>(source_card_set)->num_bits_set();\n+    uint diff = _config->max_cards_in_howl_bitmap() - container_ptr<G1CardSetBitMap>(source_container)->num_bits_set();\n@@ -630,1 +624,1 @@\n-    G1CardSetHowl* howling_array = card_set_ptr<G1CardSetHowl>(parent_card_set);\n+    G1CardSetHowl* howling_array = container_ptr<G1CardSetHowl>(parent_container);\n@@ -633,1 +627,1 @@\n-    G1CardSetHashTableValue* table_entry = get_card_set(card_region);\n+    G1CardSetHashTableValue* table_entry = get_container(card_region);\n@@ -642,2 +636,6 @@\n-G1AddCardResult G1CardSet::add_to_card_set(volatile CardSetPtr* card_set_addr, CardSetPtr card_set,  uint card_region, uint card_in_region, bool increment_total) {\n-  assert(card_set_addr != nullptr, \"Cannot add to empty cardset\");\n+G1AddCardResult G1CardSet::add_to_container(ContainerPtr volatile* container_addr,\n+                                            ContainerPtr container,\n+                                            uint card_region,\n+                                            uint card_in_region,\n+                                            bool increment_total) {\n+  assert(container_addr != nullptr, \"must be\");\n@@ -647,3 +645,3 @@\n-  switch (card_set_type(card_set)) {\n-    case CardSetInlinePtr: {\n-      add_result = add_to_inline_ptr(card_set_addr, card_set, card_in_region);\n+  switch (container_type(container)) {\n+    case ContainerInlinePtr: {\n+      add_result = add_to_inline_ptr(container_addr, container, card_in_region);\n@@ -652,2 +650,2 @@\n-    case CardSetArrayOfCards : {\n-      add_result = add_to_array(card_set, card_in_region);\n+    case ContainerArrayOfCards: {\n+      add_result = add_to_array(container, card_in_region);\n@@ -656,2 +654,2 @@\n-    case CardSetBitMap: {\n-      add_result = add_to_bitmap(card_set, card_in_region);\n+    case ContainerBitMap: {\n+      add_result = add_to_bitmap(container, card_in_region);\n@@ -660,3 +658,3 @@\n-    case CardSetHowl: {\n-      assert(CardSetHowl == card_set_type(FullCardSet), \"must be\");\n-      if (card_set == FullCardSet) {\n+    case ContainerHowl: {\n+      assert(ContainerHowl == container_type(FullCardSet), \"must be\");\n+      if (container == FullCardSet) {\n@@ -665,1 +663,1 @@\n-      add_result = add_to_howl(card_set, card_region, card_in_region, increment_total);\n+      add_result = add_to_howl(container, card_region, card_in_region, increment_total);\n@@ -671,1 +669,0 @@\n-\n@@ -675,1 +672,1 @@\n-G1CardSetHashTableValue* G1CardSet::get_or_add_card_set(uint card_region, bool* should_grow_table) {\n+G1CardSetHashTableValue* G1CardSet::get_or_add_container(uint card_region, bool* should_grow_table) {\n@@ -679,1 +676,1 @@\n-G1CardSetHashTableValue* G1CardSet::get_card_set(uint card_region) {\n+G1CardSetHashTableValue* G1CardSet::get_container(uint card_region) {\n@@ -685,2 +682,2 @@\n-  CardSetPtr to_transfer = nullptr;\n-  CardSetPtr card_set;\n+  ContainerPtr to_transfer = nullptr;\n+  ContainerPtr container;\n@@ -689,1 +686,1 @@\n-  G1CardSetHashTableValue* table_entry = get_or_add_card_set(card_region, &should_grow_table);\n+  G1CardSetHashTableValue* table_entry = get_or_add_container(card_region, &should_grow_table);\n@@ -691,2 +688,2 @@\n-    card_set = acquire_card_set(&table_entry->_card_set);\n-    add_result = add_to_card_set(&table_entry->_card_set, card_set, card_region, card_in_region, increment_total);\n+    container = acquire_container(&table_entry->_container);\n+    add_result = add_to_container(&table_entry->_container, container, card_region, card_in_region, increment_total);\n@@ -698,2 +695,2 @@\n-    bool coarsened = coarsen_card_set(&table_entry->_card_set, card_set, card_in_region);\n-    _coarsen_stats.record_coarsening(card_set_type(card_set), !coarsened);\n+    bool coarsened = coarsen_container(&table_entry->_container, container, card_in_region);\n+    _coarsen_stats.record_coarsening(container_type(container), !coarsened);\n@@ -701,1 +698,1 @@\n-      \/\/ We have been the one coarsening this card set (and in the process added that card).\n+      \/\/ We successful coarsened this card set container (and in the process added the card).\n@@ -703,1 +700,1 @@\n-      to_transfer = card_set;\n+      to_transfer = container;\n@@ -707,1 +704,1 @@\n-    release_and_maybe_free_card_set(card_set);\n+    release_and_maybe_free_container(container);\n@@ -721,1 +718,1 @@\n-  release_and_maybe_free_card_set(card_set);\n+  release_and_maybe_free_container(container);\n@@ -730,1 +727,1 @@\n-  \/\/ Protect the card set from reclamation.\n+  \/\/ Protect the card set container from reclamation.\n@@ -732,1 +729,1 @@\n-  G1CardSetHashTableValue* table_entry = get_card_set(card_region);\n+  G1CardSetHashTableValue* table_entry = get_container(card_region);\n@@ -737,2 +734,2 @@\n-  CardSetPtr card_set = table_entry->_card_set;\n-  if (card_set == FullCardSet) {\n+  ContainerPtr container = table_entry->_container;\n+  if (container == FullCardSet) {\n@@ -744,3 +741,3 @@\n-  switch (card_set_type(card_set)) {\n-    case CardSetInlinePtr: {\n-      G1CardSetInlinePtr ptr(card_set);\n+  switch (container_type(container)) {\n+    case ContainerInlinePtr: {\n+      G1CardSetInlinePtr ptr(container);\n@@ -749,4 +746,4 @@\n-    case CardSetArrayOfCards :  return card_set_ptr<G1CardSetArray>(card_set)->contains(card_in_region);\n-    case CardSetBitMap: return card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_in_region, _config->max_cards_in_howl_bitmap());\n-    case CardSetHowl: {\n-      G1CardSetHowl* howling_array = card_set_ptr<G1CardSetHowl>(card_set);\n+    case ContainerArrayOfCards: return container_ptr<G1CardSetArray>(container)->contains(card_in_region);\n+    case ContainerBitMap: return container_ptr<G1CardSetBitMap>(container)->contains(card_in_region, _config->max_cards_in_howl_bitmap());\n+    case ContainerHowl: {\n+      G1CardSetHowl* howling_array = container_ptr<G1CardSetHowl>(container);\n@@ -762,1 +759,1 @@\n-  G1CardSetHashTableValue* table_entry = get_card_set(card_region);\n+  G1CardSetHashTableValue* table_entry = get_container(card_region);\n@@ -768,2 +765,2 @@\n-  CardSetPtr card_set = table_entry->_card_set;\n-  if (card_set == FullCardSet) {\n+  ContainerPtr container = table_entry->_container;\n+  if (container == FullCardSet) {\n@@ -773,2 +770,2 @@\n-  switch (card_set_type(card_set)) {\n-    case CardSetInlinePtr: {\n+  switch (container_type(container)) {\n+    case ContainerInlinePtr: {\n@@ -778,1 +775,1 @@\n-    case CardSetArrayOfCards :  {\n+    case ContainerArrayOfCards: {\n@@ -782,1 +779,1 @@\n-    case CardSetBitMap: {\n+    case ContainerBitMap: {\n@@ -786,2 +783,2 @@\n-    case CardSetHowl: {\n-      st->print(\"CardSetHowl not containing %u\", card_in_region);\n+    case ContainerHowl: {\n+      st->print(\"ContainerHowl not containing %u\", card_in_region);\n@@ -790,1 +787,1 @@\n-    default: st->print(\"Unknown card set type %u\", card_set_type(card_set)); ShouldNotReachHere(); break;\n+    default: st->print(\"Unknown card set container type %u\", container_type(container)); ShouldNotReachHere(); break;\n@@ -795,3 +792,3 @@\n-void G1CardSet::iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& cl) {\n-  uint type = card_set_type(card_set);\n-  assert(type == CardSetInlinePtr || type == CardSetArrayOfCards,\n+void G1CardSet::iterate_cards_during_transfer(ContainerPtr const container, CardVisitor& cl) {\n+  uint type = container_type(container);\n+  assert(type == ContainerInlinePtr || type == ContainerArrayOfCards,\n@@ -799,1 +796,1 @@\n-         card_set_type(card_set));\n+         container_type(container));\n@@ -802,2 +799,2 @@\n-    case CardSetInlinePtr: {\n-      G1CardSetInlinePtr ptr(card_set);\n+    case ContainerInlinePtr: {\n+      G1CardSetInlinePtr ptr(container);\n@@ -807,2 +804,2 @@\n-    case CardSetArrayOfCards : {\n-      card_set_ptr<G1CardSetArray>(card_set)->iterate(cl);\n+    case ContainerArrayOfCards: {\n+      container_ptr<G1CardSetArray>(container)->iterate(cl);\n@@ -816,1 +813,1 @@\n-void G1CardSet::iterate_containers(CardSetPtrClosure* cl, bool at_safepoint) {\n+void G1CardSet::iterate_containers(ContainerPtrClosure* cl, bool at_safepoint) {\n@@ -847,1 +844,1 @@\n-class G1CardSetContainersClosure : public G1CardSet::CardSetPtrClosure {\n+class G1CardSetContainersClosure : public G1CardSet::ContainerPtrClosure {\n@@ -858,1 +855,1 @@\n-  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+  void do_containerptr(uint region_idx, size_t num_occupied, G1CardSet::ContainerPtr container) override {\n@@ -860,1 +857,1 @@\n-    _card_set->iterate_cards_or_ranges_in_container(card_set, cl);\n+    _card_set->iterate_cards_or_ranges_in_container(container, cl);\n@@ -882,1 +879,1 @@\n-  class GetNumberOfContainers : public CardSetPtrClosure {\n+  class GetNumberOfContainers : public ContainerPtrClosure {\n@@ -886,1 +883,1 @@\n-    GetNumberOfContainers() : CardSetPtrClosure(), _count(0) { }\n+    GetNumberOfContainers() : ContainerPtrClosure(), _count(0) { }\n@@ -888,1 +885,1 @@\n-    void do_cardsetptr(uint region_idx, size_t num_occupied, CardSetPtr card_set) override {\n+    void do_containerptr(uint region_idx, size_t num_occupied, ContainerPtr container) override {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":201,"deletions":204,"binary":false,"changes":405,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#include \"memory\/padded.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n@@ -32,1 +30,0 @@\n-#include \"utilities\/lockFreeStack.hpp\"\n@@ -150,2 +147,2 @@\n-  \/\/ cardset of the coarsening, this is the total number of combinations of\n-  \/\/ card sets - 1.\n+  \/\/ container of the coarsening, this is the total number of combinations of\n+  \/\/ card set containers - 1.\n@@ -153,1 +150,1 @@\n-  \/\/ Coarsening statistics for the possible CardSetPtr in the Howl card set\n+  \/\/ Coarsening statistics for the possible ContainerPtr in the Howl card set\n@@ -176,1 +173,1 @@\n-\/\/ Sparse set of card indexes comprising a remembered set on the Java heap. Card\n+\/\/ Set of card indexes comprising a remembered set on the Java heap. Card\n@@ -183,1 +180,1 @@\n-\/\/ node as CardSetPtr. A CardSetPtr may cover the whole region or just a part of\n+\/\/ node as ContainerPtr. A ContainerPtr may cover the whole region or just a part of\n@@ -197,2 +194,2 @@\n-  \/\/ Two lower bits are used to encode the card storage types\n-  static const uintptr_t CardSetPtrHeaderSize = 2;\n+  \/\/ Two lower bits are used to encode the card set container types\n+  static const uintptr_t ContainerPtrHeaderSize = 2;\n@@ -200,2 +197,2 @@\n-  \/\/ CardSetPtr represents the card storage type of a given covered area. It encodes\n-  \/\/ a type in the LSBs, in addition to having a few significant values.\n+  \/\/ ContainerPtr represents the card set container  type of a given covered area.\n+  \/\/ It encodes a type in the LSBs, in addition to having a few significant values.\n@@ -206,2 +203,2 @@\n-  \/\/ 1...11111 full               All card indexes in the whole area this CardSetPtr covers are part of this container.\n-  \/\/ X...XXX00 inline-ptr-cards   A handful of card indexes covered by this CardSetPtr are encoded within the CardSetPtr.\n+  \/\/ 1...11111 full               All card indexes in the whole area this ContainerPtr covers are part of this container.\n+  \/\/ X...XXX00 inline-ptr-cards   A handful of card indexes covered by this ContainerPtr are encoded within the ContainerPtr.\n@@ -210,1 +207,1 @@\n-  \/\/ X...XXX11 howl               This is a card set container containing an array of CardSetPtr, with each CardSetPtr\n+  \/\/ X...XXX11 howl               This is a card set container containing an array of ContainerPtr, with each ContainerPtr\n@@ -213,1 +210,1 @@\n-  typedef void* CardSetPtr;\n+  using ContainerPtr = void*;\n@@ -215,7 +212,7 @@\n-  \/\/ CardSetInlinePtr -> CardSetArrayOfCards -> CardSetHowl -> Full\n-  \/\/ Corsening of containers inside the CardSetHowl happens in the order:\n-  \/\/ CardSetInlinePtr -> CardSetArrayOfCards -> CardSetBitMap -> Full\n-  static const uintptr_t CardSetInlinePtr      = 0x0;\n-  static const uintptr_t CardSetArrayOfCards   = 0x1;\n-  static const uintptr_t CardSetBitMap         = 0x2;\n-  static const uintptr_t CardSetHowl           = 0x3;\n+  \/\/ ContainerInlinePtr -> ContainerArrayOfCards -> ContainerHowl -> Full\n+  \/\/ Corsening of containers inside the ContainerHowl happens in the order:\n+  \/\/ ContainerInlinePtr -> ContainerArrayOfCards -> ContainerBitMap -> Full\n+  static const uintptr_t ContainerInlinePtr      = 0x0;\n+  static const uintptr_t ContainerArrayOfCards   = 0x1;\n+  static const uintptr_t ContainerBitMap         = 0x2;\n+  static const uintptr_t ContainerHowl           = 0x3;\n@@ -224,2 +221,2 @@\n-  static constexpr CardSetPtr FreeCardSet = nullptr;\n-  \/\/ Unfortunately we can't make (G1CardSet::CardSetPtr)-1 constexpr because\n+  static constexpr ContainerPtr FreeCardSet = nullptr;\n+  \/\/ Unfortunately we can't make (G1CardSet::ContainerPtr)-1 constexpr because\n@@ -227,1 +224,1 @@\n-  static CardSetPtr FullCardSet;\n+  static ContainerPtr FullCardSet;\n@@ -229,1 +226,1 @@\n-  static const uintptr_t CardSetPtrTypeMask    = ((uintptr_t)1 << CardSetPtrHeaderSize) - 1;\n+  static const uintptr_t ContainerPtrTypeMask = ((uintptr_t)1 << ContainerPtrHeaderSize) - 1;\n@@ -231,1 +228,1 @@\n-  static CardSetPtr strip_card_set_type(CardSetPtr ptr) { return (CardSetPtr)((uintptr_t)ptr & ~CardSetPtrTypeMask); }\n+  static ContainerPtr strip_container_type(ContainerPtr ptr) { return (ContainerPtr)((uintptr_t)ptr & ~ContainerPtrTypeMask); }\n@@ -233,1 +230,1 @@\n-  static uint card_set_type(CardSetPtr ptr) { return (uintptr_t)ptr & CardSetPtrTypeMask; }\n+  static uint container_type(ContainerPtr ptr) { return (uintptr_t)ptr & ContainerPtrTypeMask; }\n@@ -236,1 +233,1 @@\n-  static T* card_set_ptr(CardSetPtr ptr);\n+  static T* container_ptr(ContainerPtr ptr);\n@@ -248,1 +245,1 @@\n-  CardSetPtr make_card_set_ptr(void* value, uintptr_t type);\n+  ContainerPtr make_container_ptr(void* value, uintptr_t type);\n@@ -250,3 +247,3 @@\n-  CardSetPtr acquire_card_set(CardSetPtr volatile* card_set_addr);\n-  \/\/ Returns true if the card set should be released\n-  bool release_card_set(CardSetPtr card_set);\n+  ContainerPtr acquire_container(ContainerPtr volatile* container_addr);\n+  \/\/ Returns true if the card set container should be released\n+  bool release_container(ContainerPtr container);\n@@ -254,1 +251,1 @@\n-  void release_and_maybe_free_card_set(CardSetPtr card_set);\n+  void release_and_maybe_free_container(ContainerPtr container);\n@@ -256,1 +253,1 @@\n-  void release_and_must_free_card_set(CardSetPtr card_set);\n+  void release_and_must_free_container(ContainerPtr container);\n@@ -258,8 +255,8 @@\n-  \/\/ Coarsens the CardSet cur_card_set to the next level; tries to replace the\n-  \/\/ previous CardSet with a new one which includes the given card_in_region.\n-  \/\/ coarsen_card_set does not transfer cards from cur_card_set\n-  \/\/ to the new card_set. Transfer is achieved by transfer_cards.\n-  \/\/ Returns true if this was the thread that coarsened the CardSet (and added the card).\n-  bool coarsen_card_set(CardSetPtr volatile* card_set_addr,\n-                        CardSetPtr cur_card_set,\n-                        uint card_in_region, bool within_howl = false);\n+  \/\/ Coarsens the card set container cur_container to the next level; tries to replace the\n+  \/\/ previous ContainerPtr with a new one which includes the given card_in_region.\n+  \/\/ coarsen_container does not transfer cards from cur_container\n+  \/\/ to the new container. Transfer is achieved by transfer_cards.\n+  \/\/ Returns true if this was the thread that coarsened the container (and added the card).\n+  bool coarsen_container(ContainerPtr volatile* container_addr,\n+                         ContainerPtr cur_container,\n+                         uint card_in_region, bool within_howl = false);\n@@ -267,1 +264,1 @@\n-  CardSetPtr create_coarsened_array_of_cards(uint card_in_region, bool within_howl);\n+  ContainerPtr create_coarsened_array_of_cards(uint card_in_region, bool within_howl);\n@@ -270,1 +267,1 @@\n-  \/\/ We only need to transfer anything finer than CardSetBitMap. \"Full\" contains\n+  \/\/ We only need to transfer anything finer than ContainerBitMap. \"Full\" contains\n@@ -272,2 +269,2 @@\n-  void transfer_cards(G1CardSetHashTableValue* table_entry, CardSetPtr source_card_set, uint card_region);\n-  void transfer_cards_in_howl(CardSetPtr parent_card_set, CardSetPtr source_card_set, uint card_region);\n+  void transfer_cards(G1CardSetHashTableValue* table_entry, ContainerPtr source_container, uint card_region);\n+  void transfer_cards_in_howl(ContainerPtr parent_container, ContainerPtr source_container, uint card_region);\n@@ -275,1 +272,1 @@\n-  G1AddCardResult add_to_card_set(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_region, uint card, bool increment_total = true);\n+  G1AddCardResult add_to_container(ContainerPtr volatile* container_addr, ContainerPtr container, uint card_region, uint card, bool increment_total = true);\n@@ -277,4 +274,4 @@\n-  G1AddCardResult add_to_inline_ptr(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_in_region);\n-  G1AddCardResult add_to_array(CardSetPtr card_set, uint card_in_region);\n-  G1AddCardResult add_to_bitmap(CardSetPtr card_set, uint card_in_region);\n-  G1AddCardResult add_to_howl(CardSetPtr parent_card_set, uint card_region, uint card_in_region, bool increment_total = true);\n+  G1AddCardResult add_to_inline_ptr(ContainerPtr volatile* container_addr, ContainerPtr container, uint card_in_region);\n+  G1AddCardResult add_to_array(ContainerPtr container, uint card_in_region);\n+  G1AddCardResult add_to_bitmap(ContainerPtr container, uint card_in_region);\n+  G1AddCardResult add_to_howl(ContainerPtr parent_container, uint card_region, uint card_in_region, bool increment_total = true);\n@@ -282,2 +279,2 @@\n-  G1CardSetHashTableValue* get_or_add_card_set(uint card_region, bool* should_grow_table);\n-  G1CardSetHashTableValue* get_card_set(uint card_region);\n+  G1CardSetHashTableValue* get_or_add_container(uint card_region, bool* should_grow_table);\n+  G1CardSetHashTableValue* get_container(uint card_region);\n@@ -292,1 +289,1 @@\n-  void iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& vl);\n+  void iterate_cards_during_transfer(ContainerPtr const container, CardVisitor& vl);\n@@ -294,1 +291,1 @@\n-  uint card_set_type_to_mem_object_type(uintptr_t type) const;\n+  uint container_type_to_mem_object_type(uintptr_t type) const;\n@@ -296,1 +293,1 @@\n-  void free_mem_object(CardSetPtr card_set);\n+  void free_mem_object(ContainerPtr container);\n@@ -305,2 +302,2 @@\n-  \/\/ Adds the given card to this set, returning an appropriate result. If added,\n-  \/\/ updates the total count.\n+  \/\/ Adds the given card to this set, returning an appropriate result.\n+  \/\/ If incremental_count is true and the card has been added, updates the total count.\n@@ -354,1 +351,1 @@\n-  void iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& cl);\n+  void iterate_cards_or_ranges_in_container(ContainerPtr const container, CardOrRangeVisitor& cl);\n@@ -356,1 +353,1 @@\n-  class CardSetPtrClosure {\n+  class ContainerPtrClosure {\n@@ -358,1 +355,1 @@\n-    virtual void do_cardsetptr(uint region_idx, size_t num_occupied, CardSetPtr card_set) = 0;\n+    virtual void do_containerptr(uint region_idx, size_t num_occupied, ContainerPtr container) = 0;\n@@ -361,1 +358,1 @@\n-  void iterate_containers(CardSetPtrClosure* cl, bool safepoint = false);\n+  void iterate_containers(ContainerPtrClosure* cl, bool safepoint = false);\n@@ -373,1 +370,1 @@\n-  using CardSetPtr = G1CardSet::CardSetPtr;\n+  using ContainerPtr = G1CardSet::ContainerPtr;\n@@ -377,1 +374,1 @@\n-  CardSetPtr volatile _card_set;\n+  ContainerPtr volatile _container;\n@@ -379,1 +376,1 @@\n-  G1CardSetHashTableValue(uint region_idx, CardSetPtr card_set) : _region_idx(region_idx), _num_occupied(0), _card_set(card_set) { }\n+  G1CardSetHashTableValue(uint region_idx, ContainerPtr container) : _region_idx(region_idx), _num_occupied(0), _container(container) { }\n@@ -394,1 +391,1 @@\n-typedef ConcurrentHashTable<G1CardSetHashTableConfig, mtGCCardSet> CardSetHash;\n+using CardSetHash = ConcurrentHashTable<G1CardSetHashTableConfig, mtGCCardSet>;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":65,"deletions":68,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -35,2 +34,2 @@\n-inline T* G1CardSet::card_set_ptr(CardSetPtr ptr) {\n-  return (T*)strip_card_set_type(ptr);\n+inline T* G1CardSet::container_ptr(ContainerPtr ptr) {\n+  return (T*)strip_container_type(ptr);\n@@ -39,3 +38,3 @@\n-inline G1CardSet::CardSetPtr G1CardSet::make_card_set_ptr(void* value, uintptr_t type) {\n-  assert(card_set_type(value) == 0, \"Given ptr \" PTR_FORMAT \" already has type bits set\", p2i(value));\n-  return (CardSetPtr)((uintptr_t)value | type);\n+inline G1CardSet::ContainerPtr G1CardSet::make_container_ptr(void* value, uintptr_t type) {\n+  assert(container_type(value) == 0, \"Given ptr \" PTR_FORMAT \" already has type bits set\", p2i(value));\n+  return (ContainerPtr)((uintptr_t)value | type);\n@@ -45,3 +44,3 @@\n-inline void G1CardSet::iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& cl) {\n-  switch (card_set_type(card_set)) {\n-    case CardSetInlinePtr: {\n+inline void G1CardSet::iterate_cards_or_ranges_in_container(ContainerPtr const container, CardOrRangeVisitor& cl) {\n+  switch (container_type(container)) {\n+    case ContainerInlinePtr: {\n@@ -49,1 +48,1 @@\n-        G1CardSetInlinePtr ptr(card_set);\n+        G1CardSetInlinePtr ptr(container);\n@@ -54,1 +53,1 @@\n-    case CardSetArrayOfCards : {\n+    case ContainerArrayOfCards: {\n@@ -56,1 +55,1 @@\n-        card_set_ptr<G1CardSetArray>(card_set)->iterate(cl);\n+        container_ptr<G1CardSetArray>(container)->iterate(cl);\n@@ -60,1 +59,1 @@\n-    case CardSetBitMap: {\n+    case ContainerBitMap: {\n@@ -65,3 +64,3 @@\n-    case CardSetHowl: {\n-      assert(card_set_type(FullCardSet) == CardSetHowl, \"Must be\");\n-      if (card_set == FullCardSet) {\n+    case ContainerHowl: {\n+      assert(container_type(FullCardSet) == ContainerHowl, \"Must be\");\n+      if (container == FullCardSet) {\n@@ -74,1 +73,1 @@\n-        card_set_ptr<G1CardSetHowl>(card_set)->iterate(cl, _config);\n+        container_ptr<G1CardSetHowl>(container)->iterate(cl, _config);\n@@ -79,1 +78,1 @@\n-  log_error(gc)(\"Unkown card set type %u\", card_set_type(card_set));\n+  log_error(gc)(\"Unkown card set container type %u\", container_type(container));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.inline.hpp","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/bitMap.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"utilities\/spinYield.hpp\"\n@@ -35,5 +34,1 @@\n-#include \"logging\/log.hpp\"\n-\n-#include \"runtime\/thread.inline.hpp\"\n-\n-\/\/ A helper class to encode a few card indexes within a CardSetPtr.\n+\/\/ A helper class to encode a few card indexes within a ContainerPtr.\n@@ -73,1 +68,1 @@\n-  typedef G1CardSet::CardSetPtr CardSetPtr;\n+  using ContainerPtr = G1CardSet::ContainerPtr;\n@@ -75,2 +70,2 @@\n-  CardSetPtr volatile * _value_addr;\n-  CardSetPtr _value;\n+  ContainerPtr volatile * _value_addr;\n+  ContainerPtr _value;\n@@ -80,1 +75,1 @@\n-  static const uint HeaderSize = G1CardSet::CardSetPtrHeaderSize + SizeFieldLen;\n+  static const uint HeaderSize = G1CardSet::ContainerPtrHeaderSize + SizeFieldLen;\n@@ -82,1 +77,1 @@\n-  static const uint BitsInValue = sizeof(CardSetPtr) * BitsPerByte;\n+  static const uint BitsInValue = sizeof(ContainerPtr) * BitsPerByte;\n@@ -90,1 +85,1 @@\n-  static CardSetPtr merge(CardSetPtr orig_value, uint card_in_region, uint idx, uint bits_per_card);\n+  static ContainerPtr merge(ContainerPtr orig_value, uint card_in_region, uint idx, uint bits_per_card);\n@@ -92,1 +87,1 @@\n-  static uint card_at(CardSetPtr value, uint const idx, uint const bits_per_card) {\n+  static uint card_at(ContainerPtr value, uint const idx, uint const bits_per_card) {\n@@ -101,1 +96,1 @@\n-  G1CardSetInlinePtr() : _value_addr(nullptr), _value((CardSetPtr)G1CardSet::CardSetInlinePtr) { }\n+  G1CardSetInlinePtr() : _value_addr(nullptr), _value((ContainerPtr)G1CardSet::ContainerInlinePtr) { }\n@@ -103,2 +98,2 @@\n-  G1CardSetInlinePtr(CardSetPtr value) : _value_addr(nullptr), _value(value) {\n-    assert(G1CardSet::card_set_type(_value) == G1CardSet::CardSetInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInPtr.\", p2i(_value));\n+  G1CardSetInlinePtr(ContainerPtr value) : _value_addr(nullptr), _value(value) {\n+    assert(G1CardSet::container_type(_value) == G1CardSet::ContainerInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInlinePtr.\", p2i(_value));\n@@ -107,2 +102,2 @@\n-  G1CardSetInlinePtr(CardSetPtr volatile* value_addr, CardSetPtr value) : _value_addr(value_addr), _value(value) {\n-    assert(G1CardSet::card_set_type(_value) == G1CardSet::CardSetInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInPtr.\", p2i(_value));\n+  G1CardSetInlinePtr(ContainerPtr volatile* value_addr, ContainerPtr value) : _value_addr(value_addr), _value(value) {\n+    assert(G1CardSet::container_type(_value) == G1CardSet::ContainerInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInlinePtr.\", p2i(_value));\n@@ -118,1 +113,1 @@\n-  operator CardSetPtr () { return _value; }\n+  operator ContainerPtr () { return _value; }\n@@ -124,1 +119,1 @@\n-  static uint num_cards_in(CardSetPtr value) {\n+  static uint num_cards_in(ContainerPtr value) {\n@@ -146,3 +141,0 @@\n-\/\/ When such an object is on a free list, we reuse the same field for linking\n-\/\/ together those free objects.\n-\/\/\n@@ -150,1 +142,1 @@\n-\/\/ directly in the CardSetPtr of the ConcurrentHashTable node.\n+\/\/ directly in the ContainerPtr of the ConcurrentHashTable node.\n@@ -152,6 +144,3 @@\n-private:\n-  union {\n-    G1CardSetContainer* _next;\n-    uintptr_t _ref_count;\n-  };\n-\n+  uintptr_t _ref_count;\n+protected:\n+  ~G1CardSetContainer() = default;\n@@ -169,12 +158,0 @@\n-  G1CardSetContainer* next() {\n-    return _next;\n-  }\n-\n-  G1CardSetContainer** next_addr() {\n-    return &_next;\n-  }\n-\n-  void set_next(G1CardSetContainer* next) {\n-    _next = next;\n-  }\n-\n@@ -189,1 +166,1 @@\n-  using CardSetPtr = G1CardSet::CardSetPtr;\n+  using ContainerPtr = G1CardSet::ContainerPtr;\n@@ -243,1 +220,1 @@\n-  using CardSetPtr = G1CardSet::CardSetPtr;\n+  using ContainerPtr = G1CardSet::ContainerPtr;\n@@ -278,1 +255,1 @@\n-  using CardSetPtr = G1CardSet::CardSetPtr;\n+  using ContainerPtr = G1CardSet::ContainerPtr;\n@@ -281,1 +258,1 @@\n-  CardSetPtr _buckets[2];\n+  ContainerPtr _buckets[2];\n@@ -289,1 +266,1 @@\n-  \/\/ Iterates over the given CardSetPtr with at index in this Howl card set,\n+  \/\/ Iterates over the given ContainerPtr with at index in this Howl card set,\n@@ -292,1 +269,1 @@\n-  void iterate_cardset(CardSetPtr const card_set, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config);\n+  void iterate_cardset(ContainerPtr const container, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config);\n@@ -297,1 +274,1 @@\n-  CardSetPtr* get_card_set_addr(EntryCountType index) {\n+  ContainerPtr* get_container_addr(EntryCountType index) {\n@@ -303,1 +280,1 @@\n-  \/\/ Iterates over all CardSetPtrs in this Howl card set, applying a CardOrRangeVisitor\n+  \/\/ Iterates over all ContainerPtrs in this Howl card set, applying a CardOrRangeVisitor\n@@ -308,1 +285,1 @@\n-  \/\/ Iterates over all CardSetPtrs in this Howl card set. Calls\n+  \/\/ Iterates over all ContainerPtrs in this Howl card set. Calls\n@@ -310,1 +287,1 @@\n-  \/\/   void operator ()(CardSetPtr* card_set_addr);\n+  \/\/   void operator ()(ContainerPtr* card_set_addr);\n@@ -313,2 +290,2 @@\n-  template <class CardSetPtrVisitor>\n-  void iterate(CardSetPtrVisitor& found, uint num_card_sets);\n+  template <class ContainerPtrVisitor>\n+  void iterate(ContainerPtrVisitor& found, uint num_card_sets);\n@@ -326,1 +303,1 @@\n-    return header_size_in_bytes() + sizeof(CardSetPtr) * num_arrays;\n+    return header_size_in_bytes() + sizeof(ContainerPtr) * num_arrays;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":33,"deletions":56,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"utilities\/spinYield.hpp\"\n@@ -32,1 +34,1 @@\n-inline G1CardSetInlinePtr::CardSetPtr G1CardSetInlinePtr::merge(CardSetPtr orig_value, uint card_in_region, uint idx, uint bits_per_card) {\n+inline G1CardSetInlinePtr::ContainerPtr G1CardSetInlinePtr::merge(ContainerPtr orig_value, uint card_in_region, uint idx, uint bits_per_card) {\n@@ -45,1 +47,1 @@\n-  return (CardSetPtr)res;\n+  return (ContainerPtr)res;\n@@ -65,2 +67,2 @@\n-    CardSetPtr new_value = merge(_value, card_idx, num_cards, bits_per_card);\n-    CardSetPtr old_value = Atomic::cmpxchg(_value_addr, _value, new_value, memory_order_relaxed);\n+    ContainerPtr new_value = merge(_value, card_idx, num_cards, bits_per_card);\n+    ContainerPtr old_value = Atomic::cmpxchg(_value_addr, _value, new_value, memory_order_relaxed);\n@@ -74,1 +76,1 @@\n-    if (G1CardSet::card_set_type(_value) != G1CardSet::CardSetInlinePtr) {\n+    if (G1CardSet::container_type(_value) != G1CardSet::ContainerInlinePtr) {\n@@ -269,2 +271,2 @@\n-  CardSetPtr* array_entry = get_card_set_addr(bucket);\n-  CardSetPtr card_set = Atomic::load_acquire(array_entry);\n+  ContainerPtr* array_entry = get_container_addr(bucket);\n+  ContainerPtr container = Atomic::load_acquire(array_entry);\n@@ -272,3 +274,3 @@\n-  switch (G1CardSet::card_set_type(card_set)) {\n-    case G1CardSet::CardSetArrayOfCards : {\n-      return G1CardSet::card_set_ptr<G1CardSetArray>(card_set)->contains(card_idx);\n+  switch (G1CardSet::container_type(container)) {\n+    case G1CardSet::ContainerArrayOfCards: {\n+      return G1CardSet::container_ptr<G1CardSetArray>(container)->contains(card_idx);\n@@ -276,1 +278,1 @@\n-    case G1CardSet::CardSetBitMap: {\n+    case G1CardSet::ContainerBitMap: {\n@@ -278,1 +280,1 @@\n-      return G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_offset, config->max_cards_in_howl_bitmap());\n+      return G1CardSet::container_ptr<G1CardSetBitMap>(container)->contains(card_offset, config->max_cards_in_howl_bitmap());\n@@ -280,2 +282,2 @@\n-    case G1CardSet::CardSetInlinePtr: {\n-      G1CardSetInlinePtr ptr(card_set);\n+    case G1CardSet::ContainerInlinePtr: {\n+      G1CardSetInlinePtr ptr(container);\n@@ -284,2 +286,2 @@\n-    case G1CardSet::CardSetHowl: {\/\/ Fullcard set entry\n-      assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n+    case G1CardSet::ContainerHowl: {\/\/ Fullcard set entry\n+      assert(container == G1CardSet::FullCardSet, \"Must be\");\n@@ -299,2 +301,2 @@\n-template <class CardSetPtrVisitor>\n-inline void G1CardSetHowl::iterate(CardSetPtrVisitor& found, uint num_card_sets) {\n+template <class ContainerPtrVisitor>\n+inline void G1CardSetHowl::iterate(ContainerPtrVisitor& found, uint num_card_sets) {\n@@ -307,3 +309,3 @@\n-inline void G1CardSetHowl::iterate_cardset(CardSetPtr const card_set, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config) {\n-  switch (G1CardSet::card_set_type(card_set)) {\n-    case G1CardSet::CardSetInlinePtr: {\n+inline void G1CardSetHowl::iterate_cardset(ContainerPtr const container, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config) {\n+  switch (G1CardSet::container_type(container)) {\n+    case G1CardSet::ContainerInlinePtr: {\n@@ -311,1 +313,1 @@\n-        G1CardSetInlinePtr ptr(card_set);\n+        G1CardSetInlinePtr ptr(container);\n@@ -316,1 +318,1 @@\n-    case G1CardSet::CardSetArrayOfCards : {\n+    case G1CardSet::ContainerArrayOfCards: {\n@@ -318,1 +320,1 @@\n-        G1CardSet::card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+        G1CardSet::container_ptr<G1CardSetArray>(container)->iterate(found);\n@@ -322,1 +324,1 @@\n-    case G1CardSet::CardSetBitMap: {\n+    case G1CardSet::ContainerBitMap: {\n@@ -325,1 +327,1 @@\n-        G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->iterate(found, config->max_cards_in_howl_bitmap(), offset);\n+        G1CardSet::container_ptr<G1CardSetBitMap>(container)->iterate(found, config->max_cards_in_howl_bitmap(), offset);\n@@ -329,2 +331,2 @@\n-    case G1CardSet::CardSetHowl: { \/\/ actually FullCardSet\n-      assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n+    case G1CardSet::ContainerHowl: { \/\/ actually FullCardSet\n+      assert(container == G1CardSet::FullCardSet, \"Must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":30,"deletions":28,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,4 +33,3 @@\n-template <class Slot>\n-G1CardSetAllocator<Slot>::G1CardSetAllocator(const char* name,\n-                                             const G1CardSetAllocOptions* alloc_options,\n-                                             G1CardSetFreeList* free_segment_list) :\n+G1CardSetAllocator::G1CardSetAllocator(const char* name,\n+                                       const G1CardSetAllocOptions* alloc_options,\n+                                       G1CardSetFreeList* free_segment_list) :\n@@ -38,5 +37,1 @@\n-  _transfer_lock(false),\n-  _free_slots_list(),\n-  _pending_slots_list(),\n-  _num_pending_slots(0),\n-  _num_free_slots(0)\n+  _free_slots_list(name, &_segmented_array)\n@@ -48,2 +43,1 @@\n-template <class Slot>\n-G1CardSetAllocator<Slot>::~G1CardSetAllocator() {\n+G1CardSetAllocator::~G1CardSetAllocator() {\n@@ -53,38 +47,1 @@\n-template <class Slot>\n-bool G1CardSetAllocator<Slot>::try_transfer_pending() {\n-  \/\/ Attempt to claim the lock.\n-  if (Atomic::load_acquire(&_transfer_lock) || \/\/ Skip CAS if likely to fail.\n-      Atomic::cmpxchg(&_transfer_lock, false, true)) {\n-    return false;\n-  }\n-  \/\/ Have the lock; perform the transfer.\n-\n-  \/\/ Claim all the pending slots.\n-  G1CardSetContainer* first = _pending_slots_list.pop_all();\n-\n-  if (first != nullptr) {\n-    \/\/ Prepare to add the claimed slots, and update _num_pending_slots.\n-    G1CardSetContainer* last = first;\n-    Atomic::load_acquire(&_num_pending_slots);\n-\n-    uint count = 1;\n-    for (G1CardSetContainer* next = first->next(); next != nullptr; next = next->next()) {\n-      last = next;\n-      ++count;\n-    }\n-\n-    Atomic::sub(&_num_pending_slots, count);\n-\n-    \/\/ Wait for any in-progress pops to avoid ABA for them.\n-    GlobalCounter::write_synchronize();\n-    \/\/ Add synchronized slots to _free_slots_list.\n-    \/\/ Update count first so there can be no underflow in allocate().\n-    Atomic::add(&_num_free_slots, count);\n-    _free_slots_list.prepend(*first, *last);\n-  }\n-  Atomic::release_store(&_transfer_lock, false);\n-  return true;\n-}\n-\n-template <class Slot>\n-void G1CardSetAllocator<Slot>::free(Slot* slot) {\n+void G1CardSetAllocator::free(void* slot) {\n@@ -92,12 +49,2 @@\n-  \/\/ Desired minimum transfer batch size.  There is relatively little\n-  \/\/ importance to the specific number.  It shouldn't be too big, else\n-  \/\/ we're wasting space when the release rate is low.  If the release\n-  \/\/ rate is high, we might accumulate more than this before being\n-  \/\/ able to start a new transfer, but that's okay.  Also note that\n-  \/\/ the allocation rate and the release rate are going to be fairly\n-  \/\/ similar, due to how the slots are used. - kbarret\n-  uint const trigger_transfer = 10;\n-\n-  uint pending_count = Atomic::add(&_num_pending_slots, 1u, memory_order_relaxed);\n-\n-  G1CardSetContainer* container =  reinterpret_cast<G1CardSetContainer*>(reinterpret_cast<char*>(slot));\n+  _free_slots_list.release(slot);\n+}\n@@ -105,2 +52,4 @@\n-  container->set_next(nullptr);\n-  assert(container->next() == nullptr, \"precondition\");\n+void G1CardSetAllocator::drop_all() {\n+  _free_slots_list.reset();\n+  _segmented_array.drop_all();\n+}\n@@ -108,1 +57,5 @@\n-  _pending_slots_list.push(*container);\n+size_t G1CardSetAllocator::mem_size() const {\n+  return sizeof(*this) +\n+         _segmented_array.num_segments() * sizeof(G1CardSetSegment) +\n+         _segmented_array.num_available_slots() * _segmented_array.slot_size();\n+}\n@@ -110,3 +63,5 @@\n-  if (pending_count > trigger_transfer) {\n-    try_transfer_pending();\n-  }\n+size_t G1CardSetAllocator::wasted_mem_size() const {\n+  uint num_wasted_slots = _segmented_array.num_available_slots() -\n+                          _segmented_array.num_allocated_slots() -\n+                          (uint)_free_slots_list.pending_count();\n+  return num_wasted_slots * _segmented_array.slot_size();\n@@ -115,7 +70,2 @@\n-template <class Slot>\n-void G1CardSetAllocator<Slot>::drop_all() {\n-  _free_slots_list.pop_all();\n-  _pending_slots_list.pop_all();\n-  _num_pending_slots = 0;\n-  _num_free_slots = 0;\n-  _segmented_array.drop_all();\n+uint G1CardSetAllocator::num_segments() const {\n+  return _segmented_array.num_segments();\n@@ -124,2 +74,1 @@\n-template <class Slot>\n-void G1CardSetAllocator<Slot>::print(outputStream* os) {\n+void G1CardSetAllocator::print(outputStream* os) {\n@@ -132,0 +81,1 @@\n+  uint num_pending_slots = (uint)_free_slots_list.pending_count();\n@@ -134,1 +84,1 @@\n-            _num_pending_slots,\n+            num_pending_slots,\n@@ -137,1 +87,1 @@\n-            percent_of(num_allocated_slots - _num_pending_slots, num_available_slots),\n+            percent_of(num_allocated_slots - num_pending_slots, num_available_slots),\n@@ -146,1 +96,1 @@\n-  _allocators = NEW_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainer>,\n+  _allocators = NEW_C_HEAP_ARRAY(G1CardSetAllocator,\n@@ -150,3 +100,3 @@\n-    new (&_allocators[i]) G1CardSetAllocator<G1CardSetContainer>(_config->mem_object_type_name_str(i),\n-                                                                 _config->mem_object_alloc_options(i),\n-                                                                 free_list_pool->free_list(i));\n+    new (&_allocators[i]) G1CardSetAllocator(_config->mem_object_type_name_str(i),\n+                                             _config->mem_object_alloc_options(i),\n+                                             free_list_pool->free_list(i));\n@@ -170,1 +120,1 @@\n-  _allocators[type].free((G1CardSetContainer*)value);\n+  _allocators[type].free(value);\n@@ -191,3 +141,2 @@\n-  return sizeof(*this) -\n-    (sizeof(G1CardSetAllocator<G1CardSetContainer>) * num_mem_object_types()) +\n-    result;\n+  return sizeof(*this) + result -\n+    (sizeof(G1CardSetAllocator) * num_mem_object_types());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":36,"deletions":87,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/freeListAllocator.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"utilities\/lockFreeStack.hpp\"\n@@ -65,1 +65,1 @@\n-\/\/ Arena-like allocator for (card set) heap memory objects (Slot slots).\n+\/\/ Arena-like allocator for (card set) heap memory objects.\n@@ -67,21 +67,2 @@\n-\/\/ Allocation and deallocation in the first phase on G1CardSetContainer basis\n-\/\/ may occur by multiple threads at once.\n-\/\/\n-\/\/ Allocation occurs from an internal free list of G1CardSetContainers first,\n-\/\/ only then trying to bump-allocate from the current G1CardSetSegment. If there is\n-\/\/ none, this class allocates a new G1CardSetSegment (allocated from the C heap,\n-\/\/ asking the G1CardSetAllocOptions instance about sizes etc) and uses that one.\n-\/\/\n-\/\/ The SegmentStack free list is a linked list of G1CardSetContainers\n-\/\/ within all G1CardSetSegment instances allocated so far. It uses a separate\n-\/\/ pending list and global synchronization to avoid the ABA problem when the\n-\/\/ user frees a memory object.\n-\/\/\n-\/\/ The class also manages a few counters for statistics using atomic operations.\n-\/\/ Their values are only consistent within each other with extra global\n-\/\/ synchronization.\n-\/\/\n-\/\/ Since it is expected that every CardSet (and in extension each region) has its\n-\/\/ own set of allocators, there is intentionally no padding between them to save\n-\/\/ memory.\n-template <class Slot>\n+\/\/ Allocation occurs from an internal free list of objects first. If the free list is\n+\/\/ empty then tries to allocate from the G1SegmentedArray.\n@@ -89,22 +70,2 @@\n-  \/\/ G1CardSetSegment management.\n-\n-  typedef G1SegmentedArray<Slot, mtGCCardSet> SegmentedArray;\n-  \/\/ G1CardSetContainer slot management within the G1CardSetSegments allocated\n-  \/\/ by this allocator.\n-  static G1CardSetContainer* volatile* next_ptr(G1CardSetContainer& slot);\n-  typedef LockFreeStack<G1CardSetContainer, &G1CardSetAllocator::next_ptr> SlotStack;\n-\n-  SegmentedArray _segmented_array;\n-  volatile bool _transfer_lock;\n-  SlotStack _free_slots_list;\n-  SlotStack _pending_slots_list;\n-\n-  volatile uint _num_pending_slots;   \/\/ Number of slots in the pending list.\n-  volatile uint _num_free_slots;      \/\/ Number of slots in the free list.\n-\n-  \/\/ Try to transfer slots from _pending_slots_list to _free_slots_list, with a\n-  \/\/ synchronization delay for any in-progress pops from the _free_slots_list\n-  \/\/ to solve ABA here.\n-  bool try_transfer_pending();\n-\n-  uint num_free_slots() const;\n+  G1SegmentedArray<mtGCCardSet> _segmented_array;\n+  FreeListAllocator _free_slots_list;\n@@ -118,2 +79,2 @@\n-  Slot* allocate();\n-  void free(Slot* slot);\n+  void* allocate();\n+  void free(void* slot);\n@@ -125,5 +86,1 @@\n-  size_t mem_size() const {\n-    return sizeof(*this) +\n-      _segmented_array.num_segments() * sizeof(G1CardSetSegment) + _segmented_array.num_available_slots() *\n-                                                                   _segmented_array.slot_size();\n-  }\n+  size_t mem_size() const;\n@@ -131,4 +88,1 @@\n-  size_t wasted_mem_size() const {\n-    return (_segmented_array.num_available_slots() - (_segmented_array.num_allocated_slots() - _num_pending_slots)) *\n-           _segmented_array.slot_size();\n-  }\n+  size_t wasted_mem_size() const;\n@@ -136,1 +90,1 @@\n-  inline uint num_segments() { return _segmented_array.num_segments(); }\n+  uint num_segments() const;\n@@ -146,1 +100,1 @@\n-  G1CardSetAllocator<G1CardSetContainer>* _allocators;\n+  G1CardSetAllocator* _allocators;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":13,"deletions":59,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,0 @@\n-#include \"gc\/g1\/g1CardSetContainers.hpp\"\n-#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-\n@@ -34,0 +30,1 @@\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n@@ -35,0 +32,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -36,24 +34,2 @@\n-template <class Slot>\n-G1CardSetContainer* volatile* G1CardSetAllocator<Slot>::next_ptr(G1CardSetContainer& slot) {\n-  return slot.next_addr();\n-}\n-\n-template <class Slot>\n-Slot* G1CardSetAllocator<Slot>::allocate() {\n-  assert(_segmented_array.slot_size() > 0, \"instance size not set.\");\n-\n-  if (num_free_slots() > 0) {\n-    \/\/ Pop under critical section to deal with ABA problem\n-    \/\/ Other solutions to the same problem are more complicated (ref counting, HP)\n-    GlobalCounter::CriticalSection cs(Thread::current());\n-\n-    G1CardSetContainer* container = _free_slots_list.pop();\n-    if (container != nullptr) {\n-      Slot* slot = reinterpret_cast<Slot*>(reinterpret_cast<char*>(container));\n-      Atomic::sub(&_num_free_slots, 1u);\n-      guarantee(is_aligned(slot, 8), \"result \" PTR_FORMAT \" not aligned\", p2i(slot));\n-      return slot;\n-    }\n-  }\n-\n-  Slot* slot = _segmented_array.allocate();\n+inline void* G1CardSetAllocator::allocate() {\n+  void* slot = _free_slots_list.allocate();\n@@ -77,5 +53,0 @@\n-template <class Slot>\n-inline uint G1CardSetAllocator<Slot>::num_free_slots() const {\n-  return Atomic::load(&_num_free_slots);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.inline.hpp","additions":5,"deletions":34,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -3316,0 +3316,7 @@\n+void G1CollectedHeap::mark_evac_failure_object(const oop obj, uint worker_id) const {\n+  \/\/ All objects failing evacuation are live. What we'll do is\n+  \/\/ that we'll update the prev marking info so that they are\n+  \/\/ all under PTAMS and explicitly marked.\n+  _cm->par_mark_in_prev_bitmap(obj);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n@@ -1181,1 +1182,1 @@\n-  inline bool is_in_young(const oop obj);\n+  inline bool is_in_young(const oop obj) const;\n@@ -1251,1 +1252,1 @@\n-  inline void mark_evac_failure_object(const oop obj, uint worker_id) const;\n+  void mark_evac_failure_object(const oop obj, uint worker_id) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n@@ -211,1 +210,1 @@\n-inline bool G1CollectedHeap::is_in_young(const oop obj) {\n+inline bool G1CollectedHeap::is_in_young(const oop obj) const {\n@@ -237,7 +236,0 @@\n-inline void G1CollectedHeap::mark_evac_failure_object(const oop obj, uint worker_id) const {\n-    \/\/ All objects failing evacuation are live. What we'll do is\n-    \/\/ that we'll update the prev marking info so that they are\n-    \/\/ all under PTAMS and explicitly marked.\n-    _cm->par_mark_in_prev_bitmap(obj);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1316,1 +1316,0 @@\n-  double predicted_old_time_ms = 0.0;\n@@ -1347,1 +1346,1 @@\n-      predicted_old_time_ms += predicted_time_ms;\n+      predicted_initial_time_ms += predicted_time_ms;\n@@ -1361,1 +1360,1 @@\n-        predicted_old_time_ms += predicted_time_ms;\n+        predicted_initial_time_ms += predicted_time_ms;\n@@ -1385,1 +1384,1 @@\n-                            \"predicted old time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f\",\n+                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, time remaining: %1.2f\",\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/freeListAllocator.hpp\"\n@@ -183,2 +184,2 @@\n-template <class Slot, MEMFLAGS flag>\n-class G1SegmentedArray {\n+template <MEMFLAGS flag>\n+class G1SegmentedArray : public FreeListConfig  {\n@@ -225,1 +226,4 @@\n-  inline Slot* allocate();\n+  inline void* allocate() override;\n+\n+  \/\/ We do not deallocate individual slots\n+  inline void deallocate(void* node) override { ShouldNotReachHere(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-template <class Slot, MEMFLAGS flag>\n-G1SegmentedArraySegment<flag>* G1SegmentedArray<Slot, flag>::create_new_segment(G1SegmentedArraySegment<flag>* const prev) {\n+template <MEMFLAGS flag>\n+G1SegmentedArraySegment<flag>* G1SegmentedArray<flag>::create_new_segment(G1SegmentedArraySegment<flag>* const prev) {\n@@ -128,1 +128,1 @@\n-           \"Mismatch %d != %d Slot %zu\", slot_size(), next->slot_size(), sizeof(Slot));\n+           \"Mismatch %d != %d\", slot_size(), next->slot_size());\n@@ -151,2 +151,2 @@\n-template <class Slot, MEMFLAGS flag>\n-uint G1SegmentedArray<Slot, flag>::slot_size() const {\n+template <MEMFLAGS flag>\n+uint G1SegmentedArray<flag>::slot_size() const {\n@@ -156,3 +156,3 @@\n-template <class Slot, MEMFLAGS flag>\n-G1SegmentedArray<Slot, flag>::G1SegmentedArray(const G1SegmentedArrayAllocOptions* alloc_options,\n-                                               G1SegmentedArrayFreeList<flag>* free_segment_list) :\n+template <MEMFLAGS flag>\n+G1SegmentedArray<flag>::G1SegmentedArray(const G1SegmentedArrayAllocOptions* alloc_options,\n+                                         G1SegmentedArrayFreeList<flag>* free_segment_list) :\n@@ -170,2 +170,2 @@\n-template <class Slot, MEMFLAGS flag>\n-G1SegmentedArray<Slot, flag>::~G1SegmentedArray() {\n+template <MEMFLAGS flag>\n+G1SegmentedArray<flag>::~G1SegmentedArray() {\n@@ -175,2 +175,2 @@\n-template <class Slot, MEMFLAGS flag>\n-void G1SegmentedArray<Slot, flag>::drop_all() {\n+template <MEMFLAGS flag>\n+void G1SegmentedArray<flag>::drop_all() {\n@@ -212,2 +212,2 @@\n-template <class Slot, MEMFLAGS flag>\n-Slot* G1SegmentedArray<Slot, flag>::allocate() {\n+template <MEMFLAGS flag>\n+void* G1SegmentedArray<flag>::allocate() {\n@@ -222,1 +222,1 @@\n-    Slot* slot = (Slot*)cur->get_new_slot();\n+    void* slot = cur->get_new_slot();\n@@ -235,2 +235,2 @@\n-template <class Slot, MEMFLAGS flag>\n-inline uint G1SegmentedArray<Slot, flag>::num_segments() const {\n+template <MEMFLAGS flag>\n+inline uint G1SegmentedArray<flag>::num_segments() const {\n@@ -254,2 +254,2 @@\n-template <class Slot, MEMFLAGS flag>\n-uint G1SegmentedArray<Slot, flag>::calculate_length() const {\n+template <MEMFLAGS flag>\n+uint G1SegmentedArray<flag>::calculate_length() const {\n@@ -262,1 +262,1 @@\n-template <class Slot, MEMFLAGS flag>\n+template <MEMFLAGS flag>\n@@ -264,1 +264,1 @@\n-void G1SegmentedArray<Slot, flag>::iterate_segments(SegmentClosure& closure) const {\n+void G1SegmentedArray<flag>::iterate_segments(SegmentClosure& closure) const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.inline.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-class G1HeapRegionRemSetMergeCardClosure : public G1CardSet::CardSetPtrClosure {\n+class G1HeapRegionRemSetMergeCardClosure : public G1CardSet::ContainerPtrClosure {\n@@ -101,1 +101,1 @@\n-  void do_cardsetptr(uint card_region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+  void do_containerptr(uint card_region_idx, size_t num_occupied, G1CardSet::ContainerPtr container) override {\n@@ -105,1 +105,1 @@\n-    _card_set->iterate_cards_or_ranges_in_container(card_set, cl);\n+    _card_set->iterate_cards_or_ranges_in_container(container, cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -801,0 +801,10 @@\n+HeapWord* ParallelScavengeHeap::allocate_loaded_archive_space(size_t size) {\n+  return _old_gen->allocate(size);\n+}\n+\n+void ParallelScavengeHeap::complete_loaded_archive_space(MemRegion archive_space) {\n+  assert(_old_gen->object_space()->used_region().contains(archive_space),\n+         \"Archive space not contained in old gen\");\n+  _old_gen->complete_loaded_archive_space(archive_space);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -187,2 +187,1 @@\n-  bool is_in_young(oop p);  \/\/ reserved part\n-  bool is_in_old(oop p);    \/\/ reserved part\n+  bool is_in_young(const oop p) const;\n@@ -276,0 +275,5 @@\n+\n+  \/\/ Support for loading objects from CDS archive into the heap\n+  bool can_load_archived_objects() const { return UseCompressedOops; }\n+  HeapWord* allocate_loaded_archive_space(size_t size);\n+  void complete_loaded_archive_space(MemRegion archive_space);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-inline bool ParallelScavengeHeap::is_in_young(oop p) {\n+inline bool ParallelScavengeHeap::is_in_young(const oop p) const {\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,0 +120,72 @@\n+static void prefetch_write(void *p) {\n+  if (PrefetchScanIntervalInBytes >= 0) {\n+    Prefetch::write(p, PrefetchScanIntervalInBytes);\n+  }\n+}\n+\n+\/\/ postcondition: ret is a dirty card or end_card\n+CardTable::CardValue* PSCardTable::find_first_dirty_card(CardValue* const start_card,\n+                                                         CardValue* const end_card) {\n+  for (CardValue* i_card = start_card; i_card < end_card; ++i_card) {\n+    if (*i_card != PSCardTable::clean_card_val()) {\n+      return i_card;\n+    }\n+  }\n+  return end_card;\n+}\n+\n+\/\/ postcondition: ret is a clean card or end_card\n+\/\/ Note: if a part of an object is on a dirty card, all cards this object\n+\/\/ resides on are considered dirty.\n+CardTable::CardValue* PSCardTable::find_first_clean_card(ObjectStartArray* const start_array,\n+                                                         CardValue* const start_card,\n+                                                         CardValue* const end_card) {\n+  assert(start_card == end_card ||\n+         *start_card != PSCardTable::clean_card_val(), \"precondition\");\n+  \/\/ Skip the first dirty card.\n+  CardValue* i_card = start_card + 1;\n+  while (i_card < end_card) {\n+    if (*i_card != PSCardTable::clean_card_val()) {\n+      i_card++;\n+      continue;\n+    }\n+    assert(i_card - 1 >= start_card, \"inv\");\n+    assert(*(i_card - 1) != PSCardTable::clean_card_val(), \"prev card must be dirty\");\n+    \/\/ Find the final obj on the prev dirty card.\n+    HeapWord* obj_addr = start_array->object_start(addr_for(i_card)-1);\n+    HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n+    CardValue* final_card_by_obj = byte_for(obj_end_addr - 1);\n+    assert(final_card_by_obj < end_card, \"inv\");\n+    if (final_card_by_obj <= i_card) {\n+      return i_card;\n+    }\n+    \/\/ This final obj extends beyond i_card, check if this new card is dirty.\n+    if (*final_card_by_obj == PSCardTable::clean_card_val()) {\n+      return final_card_by_obj;\n+    }\n+    \/\/ This new card is dirty, continuing the search...\n+    i_card = final_card_by_obj + 1;\n+  }\n+  return end_card;\n+}\n+\n+void PSCardTable::clear_cards(CardValue* const start, CardValue* const end) {\n+  for (CardValue* i_card = start; i_card < end; ++i_card) {\n+    *i_card = clean_card;\n+  }\n+}\n+\n+void PSCardTable::scan_objects_in_range(PSPromotionManager* pm,\n+                                        HeapWord* start,\n+                                        HeapWord* end) {\n+  HeapWord* obj_addr = start;\n+  while (obj_addr < end) {\n+    oop obj = cast_to_oop(obj_addr);\n+    assert(oopDesc::is_oop(obj), \"inv\");\n+    prefetch_write(obj_addr);\n+    pm->push_contents(obj);\n+    obj_addr += obj->size();\n+  }\n+  pm->drain_stacks_cond_depth();\n+}\n+\n@@ -125,3 +197,1 @@\n-\/\/ do no work.  If this method needs to be called\n-\/\/ when the space is empty, fix the calculation of\n-\/\/ end_card to allow sp_top == sp->bottom().\n+\/\/ do no work. This method is just a no-op if space_top == sp->bottom().\n@@ -131,1 +201,1 @@\n-\/\/ a stripe is a constant, ssize.\n+\/\/ a stripe is a constant, num_cards_in_stripe.\n@@ -155,5 +225,4 @@\n-\/\/ the next slice is calculated based on the number of stripes.  The next\n-\/\/ stripe is at ssize * number_of_stripes (= slice_stride)..  So after\n-\/\/ finishing stripe 0 in slice 0, the thread finds the stripe 0 in slice1 by\n-\/\/ adding slice_stride to the start of stripe 0 in slice 0 to get to the start\n-\/\/ of stride 0 in slice 1.\n+\/\/ the next slice is calculated based on the number of stripes. After finishing\n+\/\/ stripe 0 in slice 0, the thread finds the stripe 0 in slice 1 by adding\n+\/\/ slice_size_in_words to the start of stripe 0 in slice 0 to get to the start\n+\/\/ of stripe 0 in slice 1.\n@@ -165,34 +234,15 @@\n-                                             uint stripe_number,\n-                                             uint stripe_total) {\n-  int ssize = 128; \/\/ Naked constant!  Work unit = 64k.\n-\n-  \/\/ It is a waste to get here if empty.\n-  assert(sp->bottom() < sp->top(), \"Should not be called if empty\");\n-  oop* sp_top = (oop*)space_top;\n-  CardValue* start_card = byte_for(sp->bottom());\n-  CardValue* end_card   = byte_for(sp_top - 1) + 1;\n-  oop* last_scanned = NULL; \/\/ Prevent scanning objects more than once\n-  \/\/ The width of the stripe ssize*stripe_total must be\n-  \/\/ consistent with the number of stripes so that the complete slice\n-  \/\/ is covered.\n-  size_t slice_width = ssize * stripe_total;\n-  for (CardValue* slice = start_card; slice < end_card; slice += slice_width) {\n-    CardValue* worker_start_card = slice + stripe_number * ssize;\n-    if (worker_start_card >= end_card)\n-      return; \/\/ We're done.\n-\n-    CardValue* worker_end_card = worker_start_card + ssize;\n-    if (worker_end_card > end_card)\n-      worker_end_card = end_card;\n-\n-    \/\/ We do not want to scan objects more than once. In order to accomplish\n-    \/\/ this, we assert that any object with an object head inside our 'slice'\n-    \/\/ belongs to us. We may need to extend the range of scanned cards if the\n-    \/\/ last object continues into the next 'slice'.\n-    \/\/\n-    \/\/ Note! ending cards are exclusive!\n-    HeapWord* slice_start = addr_for(worker_start_card);\n-    HeapWord* slice_end = MIN2((HeapWord*) sp_top, addr_for(worker_end_card));\n-\n-    \/\/ If there are not objects starting within the chunk, skip it.\n-    if (!start_array->object_starts_in_range(slice_start, slice_end)) {\n+                                             uint stripe_index,\n+                                             uint n_stripes) {\n+  const size_t num_cards_in_stripe = 128;\n+  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n+  const size_t slice_size_in_words = stripe_size_in_words * n_stripes;\n+\n+  HeapWord* cur_stripe_addr = sp->bottom() + stripe_index * stripe_size_in_words;\n+\n+  for (\/* empty *\/; cur_stripe_addr < space_top; cur_stripe_addr += slice_size_in_words) {\n+    \/\/ exclusive\n+    HeapWord* const cur_stripe_end_addr = MIN2(cur_stripe_addr + stripe_size_in_words,\n+                                               space_top);\n+\n+    \/\/ Process a stripe iff it contains any obj-start\n+    if (!start_array->object_starts_in_range(cur_stripe_addr, cur_stripe_end_addr)) {\n@@ -201,7 +251,21 @@\n-    \/\/ Update our beginning addr\n-    HeapWord* first_object = start_array->object_start(slice_start);\n-    debug_only(oop* first_object_within_slice = (oop*) first_object;)\n-    if (first_object < slice_start) {\n-      last_scanned = (oop*)(first_object + cast_to_oop(first_object)->size());\n-      debug_only(first_object_within_slice = last_scanned;)\n-      worker_start_card = byte_for(last_scanned);\n+\n+    \/\/ Constraints:\n+    \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n+    \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n+    \/\/ 3. range of objs (obj-start) can be scanned: [first_obj_addr, cur_stripe_end_addr)\n+\n+    CardValue* iter_limit_l;\n+    CardValue* iter_limit_r;\n+    CardValue* clear_limit_l;\n+    CardValue* clear_limit_r;\n+\n+    \/\/ Identify left ends and the first obj-start inside this stripe.\n+    HeapWord* first_obj_addr = start_array->object_start(cur_stripe_addr);\n+    if (first_obj_addr < cur_stripe_addr) {\n+      \/\/ this obj belongs to previous stripe; can't clear any cards it occupies\n+      first_obj_addr += cast_to_oop(first_obj_addr)->size();\n+      clear_limit_l = byte_for(first_obj_addr - 1) + 1;\n+      iter_limit_l = byte_for(first_obj_addr);\n+    } else {\n+      assert(first_obj_addr == cur_stripe_addr, \"inv\");\n+      iter_limit_l = clear_limit_l = byte_for(cur_stripe_addr);\n@@ -210,11 +274,10 @@\n-    \/\/ Update the ending addr\n-    if (slice_end < (HeapWord*)sp_top) {\n-      \/\/ The subtraction is important! An object may start precisely at slice_end.\n-      HeapWord* last_object = start_array->object_start(slice_end - 1);\n-      slice_end = last_object + cast_to_oop(last_object)->size();\n-      \/\/ worker_end_card is exclusive, so bump it one past the end of last_object's\n-      \/\/ covered span.\n-      worker_end_card = byte_for(slice_end) + 1;\n-\n-      if (worker_end_card > end_card)\n-        worker_end_card = end_card;\n+    assert(cur_stripe_addr <= first_obj_addr, \"inside this stripe\");\n+    assert(first_obj_addr <= cur_stripe_end_addr, \"can be empty\");\n+\n+    {\n+      \/\/ Identify right ends.\n+      HeapWord* obj_addr = start_array->object_start(cur_stripe_end_addr - 1);\n+      HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n+      assert(obj_end_addr >= cur_stripe_end_addr, \"inv\");\n+      clear_limit_r = byte_for(obj_end_addr);\n+      iter_limit_r = byte_for(obj_end_addr - 1) + 1;\n@@ -223,13 +286,17 @@\n-    assert(slice_end <= (HeapWord*)sp_top, \"Last object in slice crosses space boundary\");\n-    assert(is_valid_card_address(worker_start_card), \"Invalid worker start card\");\n-    assert(is_valid_card_address(worker_end_card), \"Invalid worker end card\");\n-    \/\/ Note that worker_start_card >= worker_end_card is legal, and happens when\n-    \/\/ an object spans an entire slice.\n-    assert(worker_start_card <= end_card, \"worker start card beyond end card\");\n-    assert(worker_end_card <= end_card, \"worker end card beyond end card\");\n-\n-    CardValue* current_card = worker_start_card;\n-    while (current_card < worker_end_card) {\n-      \/\/ Find an unclean card.\n-      while (current_card < worker_end_card && card_is_clean(*current_card)) {\n-        current_card++;\n+    assert(iter_limit_l <= clear_limit_l &&\n+           clear_limit_r <= iter_limit_r, \"clear cards only if we iterate over them\");\n+\n+    \/\/ Process dirty chunks, i.e. consecutive dirty cards [dirty_l, dirty_r),\n+    \/\/ chunk by chunk inside [iter_limit_l, iter_limit_r).\n+    CardValue* dirty_l;\n+    CardValue* dirty_r;\n+\n+    for (CardValue* cur_card = iter_limit_l; cur_card < iter_limit_r; cur_card = dirty_r + 1) {\n+      dirty_l = find_first_dirty_card(cur_card, iter_limit_r);\n+      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r);\n+      assert(dirty_l <= dirty_r, \"inv\");\n+\n+      \/\/ empty\n+      if (dirty_l == dirty_r) {\n+        assert(dirty_r == iter_limit_r, \"no more dirty cards in this stripe\");\n+        break;\n@@ -237,25 +304,10 @@\n-      CardValue* first_unclean_card = current_card;\n-\n-      \/\/ Find the end of a run of contiguous unclean cards\n-      while (current_card < worker_end_card && !card_is_clean(*current_card)) {\n-        while (current_card < worker_end_card && !card_is_clean(*current_card)) {\n-          current_card++;\n-        }\n-\n-        if (current_card < worker_end_card) {\n-          \/\/ Some objects may be large enough to span several cards. If such\n-          \/\/ an object has more than one dirty card, separated by a clean card,\n-          \/\/ we will attempt to scan it twice. The test against \"last_scanned\"\n-          \/\/ prevents the redundant object scan, but it does not prevent newly\n-          \/\/ marked cards from being cleaned.\n-          HeapWord* last_object_in_dirty_region = start_array->object_start(addr_for(current_card)-1);\n-          size_t size_of_last_object = cast_to_oop(last_object_in_dirty_region)->size();\n-          HeapWord* end_of_last_object = last_object_in_dirty_region + size_of_last_object;\n-          CardValue* ending_card_of_last_object = byte_for(end_of_last_object);\n-          assert(ending_card_of_last_object <= worker_end_card, \"ending_card_of_last_object is greater than worker_end_card\");\n-          if (ending_card_of_last_object > current_card) {\n-            \/\/ This means the object spans the next complete card.\n-            \/\/ We need to bump the current_card to ending_card_of_last_object\n-            current_card = ending_card_of_last_object;\n-          }\n-        }\n+\n+      assert(*dirty_l != clean_card, \"inv\");\n+      assert(*dirty_r == clean_card || dirty_r >= clear_limit_r,\n+             \"clean card or belonging to next stripe\");\n+\n+      \/\/ Process this non-empty dirty chunk in two steps:\n+      {\n+        \/\/ 1. Clear card in [dirty_l, dirty_r) subject to [clear_limit_l, clear_limit_r) constraint\n+        clear_cards(MAX2(dirty_l, clear_limit_l),\n+                    MIN2(dirty_r, clear_limit_r));\n@@ -263,61 +315,10 @@\n-      CardValue* following_clean_card = current_card;\n-\n-      if (first_unclean_card < worker_end_card) {\n-        oop* p = (oop*) start_array->object_start(addr_for(first_unclean_card));\n-        assert((HeapWord*)p <= addr_for(first_unclean_card), \"checking\");\n-        \/\/ \"p\" should always be >= \"last_scanned\" because newly GC dirtied\n-        \/\/ cards are no longer scanned again (see comment at end\n-        \/\/ of loop on the increment of \"current_card\").  Test that\n-        \/\/ hypothesis before removing this code.\n-        \/\/ If this code is removed, deal with the first time through\n-        \/\/ the loop when the last_scanned is the object starting in\n-        \/\/ the previous slice.\n-        assert((p >= last_scanned) ||\n-               (last_scanned == first_object_within_slice),\n-               \"Should no longer be possible\");\n-        if (p < last_scanned) {\n-          \/\/ Avoid scanning more than once; this can happen because\n-          \/\/ newgen cards set by GC may a different set than the\n-          \/\/ originally dirty set\n-          p = last_scanned;\n-        }\n-        oop* to = (oop*)addr_for(following_clean_card);\n-\n-        \/\/ Test slice_end first!\n-        if ((HeapWord*)to > slice_end) {\n-          to = (oop*)slice_end;\n-        } else if (to > sp_top) {\n-          to = sp_top;\n-        }\n-\n-        \/\/ we know which cards to scan, now clear them\n-        if (first_unclean_card <= worker_start_card+1)\n-          first_unclean_card = worker_start_card+1;\n-        if (following_clean_card >= worker_end_card-1)\n-          following_clean_card = worker_end_card-1;\n-\n-        while (first_unclean_card < following_clean_card) {\n-          *first_unclean_card++ = clean_card;\n-        }\n-\n-        const int interval = PrefetchScanIntervalInBytes;\n-        \/\/ scan all objects in the range\n-        if (interval != 0) {\n-          while (p < to) {\n-            Prefetch::write(p, interval);\n-            oop m = cast_to_oop(p);\n-            assert(oopDesc::is_oop_or_null(m), \"Expected an oop or NULL for header field at \" PTR_FORMAT, p2i(m));\n-            pm->push_contents(m);\n-            p += m->size();\n-          }\n-          pm->drain_stacks_cond_depth();\n-        } else {\n-          while (p < to) {\n-            oop m = cast_to_oop(p);\n-            assert(oopDesc::is_oop_or_null(m), \"Expected an oop or NULL for header field at \" PTR_FORMAT, p2i(m));\n-            pm->push_contents(m);\n-            p += m->size();\n-          }\n-          pm->drain_stacks_cond_depth();\n-        }\n-        last_scanned = p;\n+\n+      {\n+        \/\/ 2. Scan objs in [dirty_l, dirty_r) subject to [first_obj_addr, cur_stripe_end_addr) constraint\n+        HeapWord* obj_l = MAX2(start_array->object_start(addr_for(dirty_l)),\n+                               first_obj_addr);\n+\n+        HeapWord* obj_r = MIN2(addr_for(dirty_r),\n+                               cur_stripe_end_addr);\n+\n+        scan_objects_in_range(pm, obj_l, obj_r);\n@@ -325,12 +326,0 @@\n-      \/\/ \"current_card\" is still the \"following_clean_card\" or\n-      \/\/ the current_card is >= the worker_end_card so the\n-      \/\/ loop will not execute again.\n-      assert((current_card == following_clean_card) ||\n-             (current_card >= worker_end_card),\n-        \"current_card should only be incremented if it still equals \"\n-        \"following_clean_card\");\n-      \/\/ Increment current_card so that it is not processed again.\n-      \/\/ It may now be dirty because a old-to-young pointer was\n-      \/\/ found on it an updated.  If it is now dirty, it cannot be\n-      \/\/ be safely cleaned in the next iteration.\n-      current_card++;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":161,"deletions":172,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -45,0 +45,13 @@\n+  CardValue* find_first_dirty_card(CardValue* const start_card,\n+                                   CardValue* const end_card);\n+\n+  CardValue* find_first_clean_card(ObjectStartArray* start_array,\n+                                   CardValue* const start_card,\n+                                   CardValue* const end_card);\n+\n+  void clear_cards(CardValue* const start, CardValue* const end);\n+\n+  void scan_objects_in_range(PSPromotionManager* pm,\n+                             HeapWord* start,\n+                             HeapWord* end);\n+\n@@ -56,2 +69,2 @@\n-                                  uint stripe_number,\n-                                  uint stripe_total);\n+                                  uint stripe_index,\n+                                  uint n_stripes);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -286,0 +286,9 @@\n+void PSOldGen::complete_loaded_archive_space(MemRegion archive_space) {\n+  HeapWord* cur = archive_space.start();\n+  while (cur < archive_space.end()) {\n+    _start_array.allocate_block(cur);\n+    size_t word_size = cast_to_oop(cur)->size();\n+    cur += word_size;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -136,0 +136,2 @@\n+  void complete_loaded_archive_space(MemRegion archive_space);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -848,28 +848,0 @@\n-class PCReferenceProcessor: public ReferenceProcessor {\n-public:\n-  PCReferenceProcessor(\n-    BoolObjectClosure* is_subject_to_discovery,\n-    BoolObjectClosure* is_alive_non_header) :\n-      ReferenceProcessor(is_subject_to_discovery,\n-      ParallelGCThreads,   \/\/ mt processing degree\n-      ParallelGCThreads,   \/\/ mt discovery degree\n-      true,                \/\/ atomic_discovery\n-      is_alive_non_header) {\n-  }\n-\n-  template<typename T> bool discover(oop obj, ReferenceType type) {\n-    T* referent_addr = (T*) java_lang_ref_Reference::referent_addr_raw(obj);\n-    T heap_oop = RawAccess<>::oop_load(referent_addr);\n-    oop referent = CompressedOops::decode_not_null(heap_oop);\n-    return PSParallelCompact::mark_bitmap()->is_unmarked(referent)\n-        && ReferenceProcessor::discover_reference(obj, type);\n-  }\n-  virtual bool discover_reference(oop obj, ReferenceType type) {\n-    if (UseCompressedOops) {\n-      return discover<narrowOop>(obj, type);\n-    } else {\n-      return discover<oop>(obj, type);\n-    }\n-  }\n-};\n-\n@@ -880,2 +852,5 @@\n-    new PCReferenceProcessor(&_span_based_discoverer,\n-                             &_is_alive_closure); \/\/ non-header is alive closure\n+    new ReferenceProcessor(&_span_based_discoverer,\n+                           ParallelGCThreads,   \/\/ mt processing degree\n+                           ParallelGCThreads,   \/\/ mt discovery degree\n+                           false,               \/\/ concurrent_discovery\n+                           &_is_alive_closure); \/\/ non-header is alive closure\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":5,"deletions":30,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -183,2 +183,1 @@\n-  _totally_drain = (ParallelGCThreads == 1) || (GCDrainStackTargetSize == 0);\n-  if (_totally_drain) {\n+  if (ParallelGCThreads == 1) {\n@@ -230,1 +229,1 @@\n-  totally_drain = totally_drain || _totally_drain;\n+  totally_drain = totally_drain || (_target_stack_size == 0);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-  bool                                _totally_drain;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/frame.inline.hpp\"\n@@ -57,0 +58,1 @@\n+  AARCH64_PORT_ONLY(return_address = pauth_strip_pointer(return_address));\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -251,4 +251,0 @@\n-\/\/ Action_mark - update the BOT for the block [blk_start, blk_end).\n-\/\/               Current typical use is for splitting a block.\n-\/\/ Action_single - udpate the BOT for an allocation.\n-\/\/ Action_verify - BOT verification.\n@@ -258,1 +254,1 @@\n-                                    Action action, bool reducing) {\n+                                    bool reducing) {\n@@ -287,27 +283,7 @@\n-    switch (action) {\n-      case Action_mark: {\n-        if (init_to_zero()) {\n-          _array->set_offset_array(start_index, boundary, blk_start, reducing);\n-          break;\n-        } \/\/ Else fall through to the next case\n-      }\n-      case Action_single: {\n-        _array->set_offset_array(start_index, boundary, blk_start, reducing);\n-        \/\/ We have finished marking the \"offset card\". We need to now\n-        \/\/ mark the subsequent cards that this blk spans.\n-        if (start_index < end_index) {\n-          HeapWord* rem_st = _array->address_for_index(start_index) + BOTConstants::card_size_in_words();\n-          HeapWord* rem_end = _array->address_for_index(end_index) + BOTConstants::card_size_in_words();\n-          set_remainder_to_point_to_start(rem_st, rem_end, reducing);\n-        }\n-        break;\n-      }\n-      case Action_check: {\n-        _array->check_offset_array(start_index, boundary, blk_start);\n-        \/\/ We have finished checking the \"offset card\". We need to now\n-        \/\/ check the subsequent cards that this blk spans.\n-        check_all_cards(start_index + 1, end_index);\n-        break;\n-      }\n-      default:\n-        ShouldNotReachHere();\n+    _array->set_offset_array(start_index, boundary, blk_start, reducing);\n+    \/\/ We have finished marking the \"offset card\". We need to now\n+    \/\/ mark the subsequent cards that this blk spans.\n+    if (start_index < end_index) {\n+      HeapWord* rem_st = _array->address_for_index(start_index) + BOTConstants::card_size_in_words();\n+      HeapWord* rem_end = _array->address_for_index(end_index) + BOTConstants::card_size_in_words();\n+      set_remainder_to_point_to_start(rem_st, rem_end, reducing);\n@@ -325,1 +301,1 @@\n-  do_block_internal(blk_start, blk_end, Action_single);\n+  do_block_internal(blk_start, blk_end);\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.cpp","additions":9,"deletions":33,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -282,8 +282,0 @@\n-  \/\/ The following enums are used by do_block_internal() below\n-  enum Action {\n-    Action_single,      \/\/ BOT records a single block (see single_block())\n-    Action_mark,        \/\/ BOT marks the start of a block (see mark_block())\n-    Action_check        \/\/ Check that BOT records block correctly\n-                        \/\/ (see verify_single_block()).\n-  };\n-\n@@ -318,1 +310,1 @@\n-  void do_block_internal(HeapWord* blk_start, HeapWord* blk_end, Action action, bool reducing = false);\n+  void do_block_internal(HeapWord* blk_start, HeapWord* blk_end, bool reducing = false);\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -388,26 +388,0 @@\n-\/\/ Unlike several other card table methods, dirty_card_iterate()\n-\/\/ iterates over dirty cards ranges in increasing address order.\n-void CardTable::dirty_card_iterate(MemRegion mr, MemRegionClosure* cl) {\n-  for (int i = 0; i < _cur_covered_regions; i++) {\n-    MemRegion mri = mr.intersection(_covered[i]);\n-    if (!mri.is_empty()) {\n-      CardValue *cur_entry, *next_entry, *limit;\n-      for (cur_entry = byte_for(mri.start()), limit = byte_for(mri.last());\n-           cur_entry <= limit;\n-           cur_entry  = next_entry) {\n-        next_entry = cur_entry + 1;\n-        if (*cur_entry == dirty_card) {\n-          size_t dirty_cards;\n-          \/\/ Accumulate maximal dirty card range, starting at cur_entry\n-          for (dirty_cards = 1;\n-               next_entry <= limit && *next_entry == dirty_card;\n-               dirty_cards++, next_entry++);\n-          MemRegion cur_cards(addr_for(cur_entry),\n-                              dirty_cards*_card_size_in_words);\n-          cl->do_MemRegion(cur_cards);\n-        }\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -221,4 +221,0 @@\n-  \/\/ Apply closure \"cl\" to the dirty cards containing some part of\n-  \/\/ MemRegion \"mr\".\n-  void dirty_card_iterate(MemRegion mr, MemRegionClosure* cl);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -420,0 +420,5 @@\n+void CollectedHeap::zap_filler_array_with(HeapWord* start, size_t words, juint value) {\n+  Copy::fill_to_words(start + filler_array_hdr_size(),\n+                      words - filler_array_hdr_size(), value);\n+}\n+\n@@ -430,2 +435,1 @@\n-    Copy::fill_to_words(start + filler_array_hdr_size(),\n-                        words - filler_array_hdr_size(), 0XDEAFBABE);\n+    zap_filler_array_with(start, words, 0XDEAFBABE);\n@@ -448,1 +452,7 @@\n-  DEBUG_ONLY(zap_filler_array(start, words, zap);)\n+  if (DumpSharedSpaces) {\n+    \/\/ This array is written into the CDS archive. Make sure it\n+    \/\/ has deterministic contents.\n+    zap_filler_array_with(start, words, 0);\n+  } else {\n+    DEBUG_ONLY(zap_filler_array(start, words, zap);)\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+  static inline void zap_filler_array_with(HeapWord* start, size_t words, juint value);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/freeListAllocator.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"utilities\/globalCounter.inline.hpp\"\n+\n+FreeListAllocator::NodeList::NodeList() :\n+  _head(nullptr), _tail(nullptr), _entry_count(0) {}\n+\n+FreeListAllocator::NodeList::NodeList(FreeNode* head, FreeNode* tail, size_t entry_count) :\n+  _head(head), _tail(tail), _entry_count(entry_count)\n+{\n+  assert((_head == nullptr) == (_tail == nullptr), \"invariant\");\n+  assert((_head == nullptr) == (_entry_count == 0), \"invariant\");\n+}\n+\n+FreeListAllocator::PendingList::PendingList() :\n+  _tail(nullptr), _head(nullptr), _count(0) {}\n+\n+size_t FreeListAllocator::PendingList::add(FreeNode* node) {\n+  assert(node->next() == nullptr, \"precondition\");\n+  FreeNode* old_head = Atomic::xchg(&_head, node);\n+  if (old_head != nullptr) {\n+    node->set_next(old_head);\n+  } else {\n+    assert(_tail == nullptr, \"invariant\");\n+    _tail = node;\n+  }\n+  return Atomic::add(&_count, size_t(1));\n+}\n+\n+typename FreeListAllocator::NodeList FreeListAllocator::PendingList::take_all() {\n+  NodeList result{Atomic::load(&_head), _tail, Atomic::load(&_count)};\n+  Atomic::store(&_head, (FreeNode*)nullptr);\n+  _tail = nullptr;\n+  Atomic::store(&_count, size_t(0));\n+  return result;\n+}\n+\n+size_t FreeListAllocator::PendingList::count() const {\n+  return  Atomic::load(&_count);\n+}\n+\n+FreeListAllocator::FreeListAllocator(const char* name, FreeListConfig* config) :\n+  _config(config),\n+  _free_count(0),\n+  _free_list(),\n+  _transfer_lock(false),\n+  _active_pending_list(0),\n+  _pending_lists()\n+{\n+  strncpy(_name, name, sizeof(_name) - 1);\n+  _name[sizeof(_name) - 1] = '\\0';\n+}\n+\n+void FreeListAllocator::delete_list(FreeNode* list) {\n+  while (list != nullptr) {\n+    FreeNode* next = list->next();\n+    list->~FreeNode();\n+    _config->deallocate(list);\n+    list = next;\n+  }\n+}\n+\n+FreeListAllocator::~FreeListAllocator() {\n+  uint index = Atomic::load(&_active_pending_list);\n+  NodeList pending_list = _pending_lists[index].take_all();\n+  delete_list(Atomic::load(&pending_list._head));\n+  delete_list(_free_list.pop_all());\n+}\n+\n+\/\/ Drop existing nodes and reset all counters\n+void FreeListAllocator::reset() {\n+  uint index = Atomic::load(&_active_pending_list);\n+  _pending_lists[index].take_all();\n+  _free_list.pop_all();\n+  _free_count = 0;\n+}\n+\n+size_t FreeListAllocator::free_count() const {\n+  return Atomic::load(&_free_count);\n+}\n+\n+size_t FreeListAllocator::pending_count() const {\n+  uint index = Atomic::load(&_active_pending_list);\n+  return _pending_lists[index].count();;\n+}\n+\n+\/\/ To solve the ABA problem, popping a node from the _free_list is performed within\n+\/\/ a GlobalCounter critical section, and pushing nodes onto the _free_list is done\n+\/\/ after a GlobalCounter synchronization associated with the nodes to be pushed.\n+void* FreeListAllocator::allocate() {\n+  FreeNode* node = nullptr;\n+  if (free_count() > 0) {\n+    \/\/ Protect against ABA; see release().\n+    GlobalCounter::CriticalSection cs(Thread::current());\n+    node = _free_list.pop();\n+  }\n+\n+  if (node != nullptr) {\n+    node->~FreeNode();\n+    \/\/ Decrement count after getting buffer from free list.  This, along\n+    \/\/ with incrementing count before adding to free list, ensures count\n+    \/\/ never underflows.\n+    size_t count = Atomic::sub(&_free_count, 1u);\n+    assert((count + 1) != 0, \"_free_count underflow\");\n+    return node;\n+  } else {\n+    return _config->allocate();\n+  }\n+}\n+\n+\/\/ The release synchronizes on the critical sections before adding to\n+\/\/ the _free_list. But we don't want to make every release have to do a\n+\/\/ synchronize. Instead, we initially place released nodes on the pending list,\n+\/\/ and transfer them to the _free_list in batches. Only one transfer at a time is\n+\/\/ permitted, with a lock bit to control access to that phase. While a transfer\n+\/\/ is in progress, other threads might be adding other nodes to the pending list,\n+\/\/ to be dealt with by some later transfer.\n+void FreeListAllocator::release(void* free_node) {\n+  assert(free_node != nullptr, \"precondition\");\n+  assert(is_aligned(free_node, sizeof(FreeNode)), \"Unaligned addr \" PTR_FORMAT, p2i(free_node));\n+  FreeNode* node = ::new (free_node) FreeNode();\n+\n+  \/\/ The pending list is double-buffered.  Add node to the currently active\n+  \/\/ pending list, within a critical section so a transfer will wait until\n+  \/\/ we're done with what might be the pending list to be transferred.\n+  {\n+    GlobalCounter::CriticalSection cs(Thread::current());\n+    uint index = Atomic::load_acquire(&_active_pending_list);\n+    size_t count = _pending_lists[index].add(node);\n+    if (count <= _config->transfer_threshold()) return;\n+  }\n+  \/\/ Attempt transfer when number pending exceeds the transfer threshold.\n+  try_transfer_pending();\n+}\n+\n+\/\/ Try to transfer nodes from the pending list to _free_list, with a\n+\/\/ synchronization delay for any in-progress pops from the _free_list,\n+\/\/ to solve ABA there.  Return true if performed a (possibly empty)\n+\/\/ transfer, false if blocked from doing so by some other thread's\n+\/\/ in-progress transfer.\n+bool FreeListAllocator::try_transfer_pending() {\n+  \/\/ Attempt to claim the lock.\n+  if (Atomic::load(&_transfer_lock) || \/\/ Skip CAS if likely to fail.\n+      Atomic::cmpxchg(&_transfer_lock, false, true)) {\n+    return false;\n+  }\n+  \/\/ Have the lock; perform the transfer.\n+\n+  \/\/ Change which pending list is active.  Don't need an atomic RMW since\n+  \/\/ we have the lock and we're the only writer.\n+  uint index = Atomic::load(&_active_pending_list);\n+  uint new_active = (index + 1) % ARRAY_SIZE(_pending_lists);\n+  Atomic::release_store(&_active_pending_list, new_active);\n+\n+  \/\/ Wait for all critical sections in the buffer life-cycle to complete.\n+  \/\/ This includes _free_list pops and adding to the now inactive pending\n+  \/\/ list.\n+  GlobalCounter::write_synchronize();\n+\n+  \/\/ Transfer the inactive pending list to _free_list.\n+  NodeList transfer_list = _pending_lists[index].take_all();\n+  size_t count = transfer_list._entry_count;\n+  if (count > 0) {\n+    \/\/ Update count first so no underflow in allocate().\n+    Atomic::add(&_free_count, count);\n+    _free_list.prepend(*transfer_list._head, *transfer_list._tail);\n+    log_trace(gc, freelist)\n+             (\"Transferred %s pending to free: %zu\", name(), count);\n+  }\n+  Atomic::release_store(&_transfer_lock, false);\n+  return true;\n+}\n+\n+size_t FreeListAllocator::reduce_free_list(size_t remove_goal) {\n+  try_transfer_pending();\n+  size_t removed = 0;\n+  for ( ; removed < remove_goal; ++removed) {\n+    FreeNode* node = _free_list.pop();\n+    if (node == nullptr) break;\n+    node->~FreeNode();\n+    _config->deallocate(node);\n+  }\n+  size_t new_count = Atomic::sub(&_free_count, removed);\n+  log_debug(gc, freelist)\n+           (\"Reduced %s free list by \" SIZE_FORMAT \" to \" SIZE_FORMAT,\n+            name(), removed, new_count);\n+  return removed;\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/freeListAllocator.cpp","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_FREELISTALLOCATOR_HPP\n+#define SHARE_GC_SHARED_FREELISTALLOCATOR_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/padded.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+\n+class FreeListConfig {\n+  \/\/ Desired minimum transfer batch size.  There is relatively little\n+  \/\/ importance to the specific number.  It shouldn't be too big, else\n+  \/\/ we're wasting space when the release rate is low.  If the release\n+  \/\/ rate is high, we might accumulate more than this before being\n+  \/\/ able to start a new transfer, but that's okay.\n+  const size_t _transfer_threshold;\n+protected:\n+  ~FreeListConfig() = default;\n+public:\n+  explicit FreeListConfig(size_t threshold = 10) : _transfer_threshold(threshold) {}\n+\n+  size_t transfer_threshold() { return _transfer_threshold; }\n+\n+  virtual void* allocate() = 0;\n+\n+  virtual  void deallocate(void* node) = 0;\n+};\n+\n+\/\/ Allocation is based on a lock-free list of nodes. To reduce synchronization\n+\/\/ overhead on the free list between allocation and release calls, the released\n+\/\/ nodes are first placed on a pending list, then transferred to the free list in\n+\/\/ batches. While on the pending list, the nodes are not available for allocation.\n+\/\/ The allocator uses allocation options specified by an instance of\n+\/\/ FreeListConfig. The FreeListConfig includes an allocation method to use in case\n+\/\/ the free list is empty and a deallocation method used to deallocate nodes in\n+\/\/ the free list. Additionally, the FreeListConfig configures the threshold used\n+\/\/ as a minimum batch size for transferring released nodes from the pending list\n+\/\/ to the free list making them available for re-allocation.\n+class FreeListAllocator {\n+  struct FreeNode {\n+    FreeNode* volatile _next;\n+\n+    FreeNode() : _next (nullptr) { }\n+\n+    FreeNode* next() { return Atomic::load(&_next); }\n+\n+    FreeNode* volatile* next_addr() { return &_next; }\n+\n+    void set_next(FreeNode* next) { Atomic::store(&_next, next); }\n+  };\n+\n+  struct NodeList {\n+    FreeNode* _head;     \/\/ First node in list or nullptr if empty.\n+    FreeNode* _tail;     \/\/ Last node in list or nullptr if empty.\n+    size_t _entry_count; \/\/ Sum of entries in nodes in list.\n+\n+    NodeList();\n+\n+    NodeList(FreeNode* head, FreeNode* tail, size_t entry_count);\n+  };\n+\n+  class PendingList {\n+    FreeNode* _tail;\n+    FreeNode* volatile _head;\n+    volatile size_t _count;\n+\n+    NONCOPYABLE(PendingList);\n+\n+  public:\n+    PendingList();\n+    ~PendingList() = default;\n+\n+    \/\/ Add node to the list.  Returns the number of nodes in the list.\n+    \/\/ Thread-safe against concurrent add operations.\n+    size_t add(FreeNode* node);\n+\n+    size_t count() const;\n+\n+    \/\/ Return the nodes in the list, leaving the list empty.\n+    \/\/ Not thread-safe.\n+    NodeList take_all();\n+  };\n+\n+  static FreeNode* volatile* next_ptr(FreeNode& node) { return node.next_addr(); }\n+  typedef LockFreeStack<FreeNode, &next_ptr> Stack;\n+\n+  FreeListConfig* _config;\n+  char _name[DEFAULT_CACHE_LINE_SIZE - sizeof(FreeListConfig*)];  \/\/ Use name as padding.\n+\n+#define DECLARE_PADDED_MEMBER(Id, Type, Name) \\\n+  Type Name; DEFINE_PAD_MINUS_SIZE(Id, DEFAULT_CACHE_LINE_SIZE, sizeof(Type))\n+  DECLARE_PADDED_MEMBER(1, volatile size_t, _free_count);\n+  DECLARE_PADDED_MEMBER(2, Stack, _free_list);\n+  DECLARE_PADDED_MEMBER(3, volatile bool, _transfer_lock);\n+#undef DECLARE_PADDED_MEMBER\n+\n+  volatile uint _active_pending_list;\n+  PendingList _pending_lists[2];\n+\n+  void delete_list(FreeNode* list);\n+\n+  NONCOPYABLE(FreeListAllocator);\n+\n+public:\n+  FreeListAllocator(const char* name, FreeListConfig* config);\n+\n+  const char* name() const { return _name; }\n+\n+  ~FreeListAllocator();\n+\n+  size_t free_count() const;\n+  size_t pending_count() const;\n+\n+  void* allocate();\n+  void release(void* node);\n+\n+  \/\/ Free nodes in the allocator could have been allocated out of an arena.\n+  \/\/ Therefore, the nodes can be freed at once when entire arena is discarded\n+  \/\/ without running destructors for the individual nodes. In such cases, reset\n+  \/\/ method should be called before the ~FreeListAllocator(). Calling the reset\n+  \/\/ method on nodes not managed by an arena will leak the memory by just dropping\n+  \/\/ the nodes to the floor.\n+  void reset();\n+  bool try_transfer_pending();\n+\n+  size_t mem_size() const {\n+    return sizeof(*this);\n+  }\n+\n+  \/\/ Deallocate some of the available nodes in the free_list.\n+  \/\/ remove_goal is the target number to remove.  Returns the number\n+  \/\/ actually deallocated, which may be less than the goal if there\n+  \/\/ were fewer available.\n+  size_t reduce_free_list(size_t remove_goal);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_FREELISTALLOCATOR_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/freeListAllocator.hpp","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -27,2 +27,0 @@\n-#include \"logging\/log.hpp\"\n-#include \"memory\/allocation.hpp\"\n@@ -30,5 +28,0 @@\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"runtime\/thread.inline.hpp\"\n-#include \"utilities\/globalCounter.inline.hpp\"\n@@ -48,13 +41,1 @@\n-BufferNode* BufferNode::allocate(size_t size) {\n-  size_t byte_size = size * sizeof(void*);\n-  void* data = NEW_C_HEAP_ARRAY(char, buffer_offset() + byte_size, mtGC);\n-  return new (data) BufferNode;\n-}\n-\n-void BufferNode::deallocate(BufferNode* node) {\n-  node->~BufferNode();\n-  FREE_C_HEAP_ARRAY(char, node);\n-}\n-\n-BufferNode::Allocator::PendingList::PendingList() :\n-  _tail(nullptr), _head(nullptr), _count(0) {}\n+BufferNode::AllocatorConfig::AllocatorConfig(size_t size) : _buffer_size(size) {}\n@@ -62,2 +43,3 @@\n-BufferNode::Allocator::PendingList::~PendingList() {\n-  delete_list(Atomic::load(&_head));\n+void* BufferNode::AllocatorConfig::allocate() {\n+  size_t byte_size = _buffer_size * sizeof(void*);\n+  return NEW_C_HEAP_ARRAY(char, buffer_offset() + byte_size, mtGC);\n@@ -66,18 +48,3 @@\n-size_t BufferNode::Allocator::PendingList::add(BufferNode* node) {\n-  assert(node->next() == nullptr, \"precondition\");\n-  BufferNode* old_head = Atomic::xchg(&_head, node);\n-  if (old_head != nullptr) {\n-    node->set_next(old_head);\n-  } else {\n-    assert(_tail == nullptr, \"invariant\");\n-    _tail = node;\n-  }\n-  return Atomic::add(&_count, size_t(1));\n-}\n-\n-BufferNodeList BufferNode::Allocator::PendingList::take_all() {\n-  BufferNodeList result{Atomic::load(&_head), _tail, Atomic::load(&_count)};\n-  Atomic::store(&_head, (BufferNode*)nullptr);\n-  _tail = nullptr;\n-  Atomic::store(&_count, size_t(0));\n-  return result;\n+void BufferNode::AllocatorConfig::deallocate(void* node) {\n+  assert(node != nullptr, \"precondition\");\n+  FREE_C_HEAP_ARRAY(char, node);\n@@ -87,6 +54,2 @@\n-  _buffer_size(buffer_size),\n-  _pending_lists(),\n-  _active_pending_list(0),\n-  _free_list(),\n-  _free_count(0),\n-  _transfer_lock(false)\n+  _config(buffer_size),\n+  _free_list(name, &_config)\n@@ -94,7 +57,0 @@\n-  strncpy(_name, name, sizeof(_name) - 1);\n-  _name[sizeof(_name) - 1] = '\\0';\n-}\n-\n-BufferNode::Allocator::~Allocator() {\n-  delete_list(_free_list.pop_all());\n-}\n@@ -102,7 +58,0 @@\n-void BufferNode::Allocator::delete_list(BufferNode* list) {\n-  while (list != NULL) {\n-    BufferNode* next = list->next();\n-    DEBUG_ONLY(list->set_next(NULL);)\n-    BufferNode::deallocate(list);\n-    list = next;\n-  }\n@@ -112,1 +61,1 @@\n-  return Atomic::load(&_free_count);\n+  return _free_list.free_count();\n@@ -116,16 +65,1 @@\n-  BufferNode* node;\n-  {\n-    \/\/ Protect against ABA; see release().\n-    GlobalCounter::CriticalSection cs(Thread::current());\n-    node = _free_list.pop();\n-  }\n-  if (node == NULL) {\n-    node = BufferNode::allocate(_buffer_size);\n-  } else {\n-    \/\/ Decrement count after getting buffer from free list.  This, along\n-    \/\/ with incrementing count before adding to free list, ensures count\n-    \/\/ never underflows.\n-    size_t count = Atomic::sub(&_free_count, 1u);\n-    assert((count + 1) != 0, \"_free_count underflow\");\n-  }\n-  return node;\n+  return ::new (_free_list.allocate()) BufferNode();\n@@ -134,9 +68,0 @@\n-\/\/ To solve the ABA problem for lock-free stack pop, allocate does the\n-\/\/ pop inside a critical section, and release synchronizes on the\n-\/\/ critical sections before adding to the _free_list.  But we don't\n-\/\/ want to make every release have to do a synchronize.  Instead, we\n-\/\/ initially place released nodes on the pending list, and transfer\n-\/\/ them to the _free_list in batches.  Only one transfer at a time is\n-\/\/ permitted, with a lock bit to control access to that phase.  While\n-\/\/ a transfer is in progress, other threads might be adding other nodes\n-\/\/ to the pending list, to be dealt with by some later transfer.\n@@ -146,59 +71,2 @@\n-\n-  \/\/ Desired minimum transfer batch size.  There is relatively little\n-  \/\/ importance to the specific number.  It shouldn't be too big, else\n-  \/\/ we're wasting space when the release rate is low.  If the release\n-  \/\/ rate is high, we might accumulate more than this before being\n-  \/\/ able to start a new transfer, but that's okay.  Also note that\n-  \/\/ the allocation rate and the release rate are going to be fairly\n-  \/\/ similar, due to how the buffers are used.\n-  const size_t trigger_transfer = 10;\n-\n-  \/\/ The pending list is double-buffered.  Add node to the currently active\n-  \/\/ pending list, within a critical section so a transfer will wait until\n-  \/\/ we're done with what might be the pending list to be transferred.\n-  {\n-    GlobalCounter::CriticalSection cs(Thread::current());\n-    uint index = Atomic::load_acquire(&_active_pending_list);\n-    size_t count = _pending_lists[index].add(node);\n-    if (count <= trigger_transfer) return;\n-  }\n-  \/\/ Attempt transfer when number pending exceeds the transfer threshold.\n-  try_transfer_pending();\n-}\n-\n-\/\/ Try to transfer nodes from the pending list to _free_list, with a\n-\/\/ synchronization delay for any in-progress pops from the _free_list,\n-\/\/ to solve ABA there.  Return true if performed a (possibly empty)\n-\/\/ transfer, false if blocked from doing so by some other thread's\n-\/\/ in-progress transfer.\n-bool BufferNode::Allocator::try_transfer_pending() {\n-  \/\/ Attempt to claim the lock.\n-  if (Atomic::load(&_transfer_lock) || \/\/ Skip CAS if likely to fail.\n-      Atomic::cmpxchg(&_transfer_lock, false, true)) {\n-    return false;\n-  }\n-  \/\/ Have the lock; perform the transfer.\n-\n-  \/\/ Change which pending list is active.  Don't need an atomic RMW since\n-  \/\/ we have the lock and we're the only writer.\n-  uint index = Atomic::load(&_active_pending_list);\n-  uint new_active = (index + 1) % ARRAY_SIZE(_pending_lists);\n-  Atomic::release_store(&_active_pending_list, new_active);\n-\n-  \/\/ Wait for all critical sections in the buffer life-cycle to complete.\n-  \/\/ This includes _free_list pops and adding to the now inactive pending\n-  \/\/ list.\n-  GlobalCounter::write_synchronize();\n-\n-  \/\/ Transfer the inactive pending list to _free_list.\n-  BufferNodeList transfer_list = _pending_lists[index].take_all();\n-  size_t count = transfer_list._entry_count;\n-  if (count > 0) {\n-    \/\/ Update count first so no underflow in allocate().\n-    Atomic::add(&_free_count, count);\n-    _free_list.prepend(*transfer_list._head, *transfer_list._tail);\n-    log_trace(gc, ptrqueue, freelist)\n-             (\"Transferred %s pending to free: %zu\", name(), count);\n-  }\n-  Atomic::release_store(&_transfer_lock, false);\n-  return true;\n+  node->~BufferNode();\n+  _free_list.release(node);\n@@ -208,12 +76,1 @@\n-  try_transfer_pending();\n-  size_t removed = 0;\n-  for ( ; removed < remove_goal; ++removed) {\n-    BufferNode* node = _free_list.pop();\n-    if (node == NULL) break;\n-    BufferNode::deallocate(node);\n-  }\n-  size_t new_count = Atomic::sub(&_free_count, removed);\n-  log_debug(gc, ptrqueue, freelist)\n-           (\"Reduced %s free list by \" SIZE_FORMAT \" to \" SIZE_FORMAT,\n-            name(), removed, new_count);\n-  return removed;\n+  return _free_list.reduce_free_list(remove_goal);\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.cpp","additions":14,"deletions":157,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/bufferNodeList.hpp\"\n+#include \"gc\/shared\/freeListAllocator.hpp\"\n@@ -135,6 +135,0 @@\n-  \/\/ Allocate a new BufferNode with the \"buffer\" having size elements.\n-  static BufferNode* allocate(size_t size);\n-\n-  \/\/ Free a BufferNode.\n-  static void deallocate(BufferNode* node);\n-\n@@ -166,0 +160,1 @@\n+  class AllocatorConfig;\n@@ -170,21 +165,6 @@\n-\/\/ Allocation is based on a lock-free free list of nodes, linked through\n-\/\/ BufferNode::_next (see BufferNode::Stack).  To solve the ABA problem,\n-\/\/ popping a node from the free list is performed within a GlobalCounter\n-\/\/ critical section, and pushing nodes onto the free list is done after\n-\/\/ a GlobalCounter synchronization associated with the nodes to be pushed.\n-\/\/ This is documented behavior so that other parts of the node life-cycle\n-\/\/ can depend on and make use of it too.\n-class BufferNode::Allocator {\n-  friend class TestSupport;\n-\n-  \/\/ Since we don't expect many instances, and measured >15% speedup\n-  \/\/ on stress gtest, padding seems like a good tradeoff here.\n-#define DECLARE_PADDED_MEMBER(Id, Type, Name) \\\n-  Type Name; DEFINE_PAD_MINUS_SIZE(Id, DEFAULT_CACHE_LINE_SIZE, sizeof(Type))\n-\n-  class PendingList {\n-    BufferNode* _tail;\n-    DECLARE_PADDED_MEMBER(1, BufferNode* volatile, _head);\n-    DECLARE_PADDED_MEMBER(2, volatile size_t, _count);\n-\n-    NONCOPYABLE(PendingList);\n+\/\/ We use BufferNode::AllocatorConfig to set the allocation options for the\n+\/\/ FreeListAllocator.\n+class BufferNode::AllocatorConfig : public FreeListConfig {\n+  const size_t _buffer_size;\n+public:\n+  explicit AllocatorConfig(size_t size);\n@@ -192,3 +172,1 @@\n-  public:\n-    PendingList();\n-    ~PendingList();\n+  ~AllocatorConfig() = default;\n@@ -196,3 +174,1 @@\n-    \/\/ Add node to the list.  Returns the number of nodes in the list.\n-    \/\/ Thread-safe against concurrent add operations.\n-    size_t add(BufferNode* node);\n+  void* allocate() override;\n@@ -200,4 +176,1 @@\n-    \/\/ Return the nodes in the list, leaving the list empty.\n-    \/\/ Not thread-safe.\n-    BufferNodeList take_all();\n-  };\n+  void deallocate(void* node) override;\n@@ -205,7 +178,2 @@\n-  const size_t _buffer_size;\n-  char _name[DEFAULT_CACHE_LINE_SIZE - sizeof(size_t)]; \/\/ Use name as padding.\n-  PendingList _pending_lists[2];\n-  DECLARE_PADDED_MEMBER(1, volatile uint, _active_pending_list);\n-  DECLARE_PADDED_MEMBER(2, Stack, _free_list);\n-  DECLARE_PADDED_MEMBER(3, volatile size_t, _free_count);\n-  DECLARE_PADDED_MEMBER(4, volatile bool, _transfer_lock);\n+  size_t buffer_size() const { return _buffer_size; }\n+};\n@@ -213,1 +181,2 @@\n-#undef DECLARE_PADDED_MEMBER\n+class BufferNode::Allocator {\n+  friend class TestSupport;\n@@ -215,2 +184,2 @@\n-  static void delete_list(BufferNode* list);\n-  bool try_transfer_pending();\n+  AllocatorConfig _config;\n+  FreeListAllocator _free_list;\n@@ -222,1 +191,1 @@\n-  ~Allocator();\n+  ~Allocator() = default;\n@@ -224,2 +193,1 @@\n-  const char* name() const { return _name; }\n-  size_t buffer_size() const { return _buffer_size; }\n+  size_t buffer_size() const { return _config.buffer_size(); }\n@@ -230,0 +198,4 @@\n+  \/\/ If _free_list has items buffered in the pending list, transfer\n+  \/\/ these to make them available for re-allocation.\n+  bool flush_free_list() { return _free_list.try_transfer_pending(); }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.hpp","additions":23,"deletions":51,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -583,1 +583,0 @@\n-  PartialArrayScanTask() : _src() {}\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-        Op_HasNegatives,\n+        Op_CountPositives,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -557,1 +557,0 @@\n-\n@@ -559,3 +558,6 @@\n-  const char* const error_msg = c_str(errorMsg, t);\n-  if (error_msg != NULL) {\n-    log_error(jfr, system)(\"%s\",error_msg);\n+  abort(c_str(errorMsg, t));\n+}\n+\n+void JfrJavaSupport::abort(const char* error_msg, bool dump_core \/* true *\/) {\n+  if (error_msg != nullptr) {\n+    log_error(jfr, system)(\"%s\", error_msg);\n@@ -564,1 +566,1 @@\n-  vm_abort();\n+  vm_abort(dump_core);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,0 +104,1 @@\n+  static void abort(const char* error_msg, bool dump_core = true);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+\n@@ -87,1 +88,2 @@\n-  }  else {\n+    _reference_stack[_depth] = reference;\n+  } else {\n@@ -91,0 +93,6 @@\n+    _mark_bits->mark_obj(pointee);\n+    _reference_stack[_depth] = reference;\n+    \/\/ is the pointee a sample object?\n+    if (pointee->mark().is_marked()) {\n+      add_chain();\n+    }\n@@ -92,9 +100,0 @@\n-  _reference_stack[_depth] = reference;\n-  _mark_bits->mark_obj(pointee);\n-  assert(_mark_bits->is_marked(pointee), \"invariant\");\n-\n-  \/\/ is the pointee a sample object?\n-  if (pointee->mark().is_marked()) {\n-    add_chain();\n-  }\n-\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -237,1 +237,9 @@\n-  return leak_context_edge_idx(sample) != 0;\n+  const int idx = leak_context_edge_idx(sample);\n+  if (idx == 0) {\n+    return false;\n+  }\n+  assert(idx > 0, \"invariant\");\n+  assert(_leak_context_edges != nullptr, \"invariant\");\n+  assert(idx < _leak_context_edges->length(), \"invariant\");\n+  assert(_leak_context_edges->at(idx) != nullptr, \"invariant\");\n+  return true;\n@@ -246,1 +254,4 @@\n-      return _leak_context_edges->at(idx);\n+      assert(idx < _leak_context_edges->length(), \"invariant\");\n+      const StoredEdge* const edge =_leak_context_edges->at(idx);\n+      assert(edge != nullptr, \"invariant\");\n+      return edge;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n@@ -29,1 +30,0 @@\n-\n@@ -80,0 +80,3 @@\n+    if (errno == ENOSPC) {\n+      JfrJavaSupport::abort(\"Failed to write to jfr stream because no space left on device\", false);\n+    }\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrStreamWriterHost.inline.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -745,2 +745,3 @@\n-  static_field(StubRoutines::aarch64, _has_negatives, address)          \\\n-  static_field(StubRoutines::aarch64, _has_negatives_long, address)     \\\n+  static_field(StubRoutines::aarch64, _count_positives, address)        \\\n+  static_field(StubRoutines::aarch64, _count_positives_long, address)   \\\n+  static_field(VM_Version, _rop_protection, bool)                       \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -219,1 +220,1 @@\n-  void        report_full()                      {        _full_count++; }\n+  int         report_full()                      { return Atomic::add(&_full_count, 1); }\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1251,0 +1251,1 @@\n+      _fullgc_alot_dummy_array = OopHandle(); \/\/ NULL out OopStorage pointer.\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -142,0 +142,13 @@\n+static void log_on_large_pages_failure(char* req_addr, size_t bytes) {\n+  if (large_pages_requested()) {\n+    \/\/ Compressed oops logging.\n+    log_debug(gc, heap, coops)(\"Reserve regular memory without large pages\");\n+    \/\/ JVM style warning that we did not succeed in using large pages.\n+    char msg[128];\n+    jio_snprintf(msg, sizeof(msg), \"Failed to reserve and commit memory using large pages. \"\n+                                   \"req_addr: \" PTR_FORMAT \" bytes: \" SIZE_FORMAT,\n+                                   req_addr, bytes);\n+    warning(\"%s\", msg);\n+  }\n+}\n+\n@@ -186,4 +199,0 @@\n-  } else {\n-    if (large_pages_requested()) {\n-      log_debug(gc, heap, coops)(\"Reserve regular memory without large pages\");\n-    }\n@@ -238,0 +247,10 @@\n+    size_t used_page_size = page_size;\n+    char* base = NULL;\n+\n+    do {\n+      base = reserve_memory_special(requested_address, size, alignment, used_page_size, executable);\n+      if (base != NULL) {\n+        break;\n+      }\n+      used_page_size = os::page_sizes().next_smaller(used_page_size);\n+    } while (used_page_size > (size_t) os::vm_page_size());\n@@ -239,1 +258,0 @@\n-    char* base = reserve_memory_special(requested_address, size, alignment, page_size, executable);\n@@ -242,1 +260,1 @@\n-      initialize_members(base, size, alignment, page_size, true, executable);\n+      initialize_members(base, size, alignment, used_page_size, true, executable);\n@@ -245,1 +263,3 @@\n-    \/\/ Failed to reserve explicit large pages, fall back to normal reservation.\n+    \/\/ Failed to reserve explicit large pages, do proper logging.\n+    log_on_large_pages_failure(requested_address, size);\n+    \/\/ Now fall back to normal reservation.\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -1506,0 +1507,11 @@\n+#if INCLUDE_CDS\n+  \/\/ This is needed to ensure the consistency of the archived heap objects.\n+  if (has_archived_enum_objs()) {\n+    assert(is_shared(), \"must be\");\n+    bool initialized = HeapShared::initialize_enum_klass(this, CHECK);\n+    if (initialized) {\n+      return;\n+    }\n+  }\n+#endif\n+\n@@ -2065,0 +2077,46 @@\n+PrintClassClosure::PrintClassClosure(outputStream* st, bool verbose)\n+  :_st(st), _verbose(verbose) {\n+  ResourceMark rm;\n+  _st->print(\"%-18s  \", \"KlassAddr\");\n+  _st->print(\"%-4s  \", \"Size\");\n+  _st->print(\"%-20s  \", \"State\");\n+  _st->print(\"%-7s  \", \"Flags\");\n+  _st->print(\"%-5s  \", \"ClassName\");\n+  _st->cr();\n+}\n+\n+void PrintClassClosure::do_klass(Klass* k)  {\n+  ResourceMark rm;\n+  \/\/ klass pointer\n+  _st->print(INTPTR_FORMAT \"  \", p2i(k));\n+  \/\/ klass size\n+  _st->print(\"%4d  \", k->size());\n+  \/\/ initialization state\n+  if (k->is_instance_klass()) {\n+    _st->print(\"%-20s  \",InstanceKlass::cast(k)->init_state_name());\n+  } else {\n+    _st->print(\"%-20s  \",\"\");\n+  }\n+  \/\/ misc flags(Changes should synced with ClassesDCmd::ClassesDCmd help doc)\n+  char buf[10];\n+  int i = 0;\n+  if (k->has_finalizer()) buf[i++] = 'F';\n+  if (k->has_final_method()) buf[i++] = 'f';\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->is_rewritten()) buf[i++] = 'W';\n+    if (ik->is_contended()) buf[i++] = 'C';\n+    if (ik->has_been_redefined()) buf[i++] = 'R';\n+    if (ik->is_shared()) buf[i++] = 'S';\n+  }\n+  buf[i++] = '\\0';\n+  _st->print(\"%-7s  \", buf);\n+  \/\/ klass name\n+  _st->print(\"%-5s  \", k->external_name());\n+  \/\/ end\n+  _st->cr();\n+  if (_verbose) {\n+    k->print_on(_st);\n+  }\n+}\n+\n@@ -3384,0 +3442,4 @@\n+const char* InstanceKlass::init_state_name() const {\n+  return state_names[_init_state];\n+}\n+\n@@ -3391,1 +3453,1 @@\n-  st->print(BULLET\"state:             \"); st->print_cr(\"%s\", state_names[_init_state]);\n+  st->print(BULLET\"state:             \"); st->print_cr(\"%s\", init_state_name());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -550,0 +550,1 @@\n+  const char* init_state_name() const;\n@@ -1280,0 +1281,9 @@\n+class PrintClassClosure : public KlassClosure {\n+private:\n+  outputStream* _st;\n+  bool _verbose;\n+public:\n+  PrintClassClosure(outputStream* st, bool verbose);\n+\n+  void do_klass(Klass* k);\n+};\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,4 +176,5 @@\n-    _archived_lambda_proxy_is_available = 2,\n-    _has_value_based_class_annotation = 4,\n-    _verified_at_dump_time = 8,\n-    _regenerated = 16\n+    _archived_lambda_proxy_is_available    = 1 << 1,\n+    _has_value_based_class_annotation      = 1 << 2,\n+    _verified_at_dump_time                 = 1 << 3,\n+    _has_archived_enum_objs                = 1 << 4,\n+    _regenerated                           = 1 << 5\n@@ -343,0 +344,8 @@\n+  void set_has_archived_enum_objs() {\n+    CDS_ONLY(_shared_class_flags |= _has_archived_enum_objs;)\n+  }\n+  bool has_archived_enum_objs() const {\n+    CDS_ONLY(return (_shared_class_flags & _has_archived_enum_objs) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+                         Symbol* name,\n@@ -95,1 +96,1 @@\n-  return new (loader_data, size, MetaspaceObj::MethodType, THREAD) Method(cm, access_flags);\n+  return new (loader_data, size, MetaspaceObj::MethodType, THREAD) Method(cm, access_flags, name);\n@@ -98,1 +99,1 @@\n-Method::Method(ConstMethod* xconst, AccessFlags access_flags) {\n+Method::Method(ConstMethod* xconst, AccessFlags access_flags, Symbol* name) {\n@@ -122,0 +123,2 @@\n+  \/\/ Name is very useful for debugging.\n+  NOT_PRODUCT(_name = name;)\n@@ -396,0 +399,1 @@\n+  NOT_PRODUCT(it->push(&_name);)\n@@ -1449,1 +1453,3 @@\n-                                     ConstMethod::NORMAL, CHECK_(empty));\n+                                     ConstMethod::NORMAL,\n+                                     name,\n+                                     CHECK_(empty));\n@@ -1529,0 +1535,1 @@\n+                                      m->name(),\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,1 @@\n+ friend class MethodTest;\n@@ -101,0 +102,2 @@\n+\n+  Symbol* _name;\n@@ -116,1 +119,1 @@\n-  Method(ConstMethod* xconst, AccessFlags access_flags);\n+  Method(ConstMethod* xconst, AccessFlags access_flags, Symbol* name);\n@@ -124,0 +127,1 @@\n+                          Symbol* name,\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -237,2 +237,2 @@\n-  case vmIntrinsics::_hasNegatives:\n-    if (!Matcher::match_rule_supported(Op_HasNegatives))  return false;\n+  case vmIntrinsics::_countPositives:\n+    if (!Matcher::match_rule_supported(Op_CountPositives))  return false;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -529,0 +529,4 @@\n+    if (C->print_inlining() || C->print_intrinsics()) {\n+      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(),\n+                        \"late call devirtualization failed (receiver may be null)\");\n+    }\n@@ -535,0 +539,4 @@\n+    if (C->print_inlining() || C->print_intrinsics()) {\n+      C->print_inlining(method(), jvms->depth()-1, call_node()->jvms()->bci(),\n+                        \"late call devirtualization failed (interface call)\");\n+    }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -197,0 +197,34 @@\n+  if (res == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  assert(res->isa_int(), \"res must be int\");\n+\n+  \/\/ Similar to ConvI2LNode::Value() for the same reasons\n+  \/\/ see if we can remove type assertion after loop opts\n+  \/\/ But here we have to pay extra attention:\n+  \/\/ Do not narrow the type of range check dependent CastIINodes to\n+  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n+  \/\/ the corresponding range check is not removed.\n+  if (!_range_check_dependency && phase->C->post_loop_opts_phase()) {\n+    const TypeInt* this_type = res->is_int();\n+    const TypeInt* in_type = phase->type(in(1))->isa_int();\n+    if (in_type != NULL &&\n+        (in_type->_lo != this_type->_lo ||\n+         in_type->_hi != this_type->_hi)) {\n+      jint lo1 = this_type->_lo;\n+      jint hi1 = this_type->_hi;\n+      int w1 = this_type->_widen;\n+      if (lo1 >= 0) {\n+        \/\/ Keep a range assertion of >=0.\n+        lo1 = 0;        hi1 = max_jint;\n+      } else if (hi1 < 0) {\n+        \/\/ Keep a range assertion of <0.\n+        lo1 = min_jint; hi1 = -1;\n+      } else {\n+        lo1 = min_jint; hi1 = max_jint;\n+      }\n+      res = TypeInt::make(MAX2(in_type->_lo, lo1),\n+                          MIN2(in_type->_hi, hi1),\n+                          MAX2((int)in_type->_widen, w1));\n+    }\n+  }\n@@ -251,1 +285,0 @@\n-\n@@ -277,2 +310,5 @@\n-\n-  PhaseIterGVN *igvn = phase->is_IterGVN();\n+  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -303,37 +339,0 @@\n-\n-  \/\/ Similar to ConvI2LNode::Ideal() for the same reasons\n-  \/\/ Do not narrow the type of range check dependent CastIINodes to\n-  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n-  \/\/ the corresponding range check is not removed.\n-  if (can_reshape && !_range_check_dependency) {\n-    if (phase->C->post_loop_opts_phase()) {\n-      const TypeInt* this_type = this->type()->is_int();\n-      const TypeInt* in_type = phase->type(in(1))->isa_int();\n-      if (in_type != NULL && this_type != NULL &&\n-          (in_type->_lo != this_type->_lo ||\n-           in_type->_hi != this_type->_hi)) {\n-        jint lo1 = this_type->_lo;\n-        jint hi1 = this_type->_hi;\n-        int w1  = this_type->_widen;\n-\n-        if (lo1 >= 0) {\n-          \/\/ Keep a range assertion of >=0.\n-          lo1 = 0;        hi1 = max_jint;\n-        } else if (hi1 < 0) {\n-          \/\/ Keep a range assertion of <0.\n-          lo1 = min_jint; hi1 = -1;\n-        } else {\n-          lo1 = min_jint; hi1 = max_jint;\n-        }\n-        const TypeInt* wtype = TypeInt::make(MAX2(in_type->_lo, lo1),\n-                                             MIN2(in_type->_hi, hi1),\n-                                             MAX2((int)in_type->_widen, w1));\n-        if (wtype != type()) {\n-          set_type(wtype);\n-          return this;\n-        }\n-      }\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":39,"deletions":40,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-macro(HasNegatives)\n+macro(CountPositives)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4836,1 +4836,1 @@\n-  ss.print_raw(CompilerPhaseTypeHelper::to_name(cpt));\n+  ss.print_raw(CompilerPhaseTypeHelper::to_description(cpt));\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -255,1 +255,3 @@\n-  if( t == Type::TOP ) return Type::TOP;\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -260,1 +262,34 @@\n-  return tl;\n+  if (!tl->isa_long()) {\n+    return tl;\n+  }\n+  const TypeLong* this_type = tl->is_long();\n+  \/\/ Do NOT remove this node's type assertion until no more loop ops can happen.\n+  if (phase->C->post_loop_opts_phase()) {\n+    const TypeInt* in_type = phase->type(in(1))->isa_int();\n+    if (in_type != NULL &&\n+        (in_type->_lo != this_type->_lo ||\n+         in_type->_hi != this_type->_hi)) {\n+      \/\/ Although this WORSENS the type, it increases GVN opportunities,\n+      \/\/ because I2L nodes with the same input will common up, regardless\n+      \/\/ of slightly differing type assertions.  Such slight differences\n+      \/\/ arise routinely as a result of loop unrolling, so this is a\n+      \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n+      \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n+      jlong lo1 = this_type->_lo;\n+      jlong hi1 = this_type->_hi;\n+      int   w1  = this_type->_widen;\n+      if (lo1 >= 0) {\n+        \/\/ Keep a range assertion of >=0.\n+        lo1 = 0;        hi1 = max_jint;\n+      } else if (hi1 < 0) {\n+        \/\/ Keep a range assertion of <0.\n+        lo1 = min_jint; hi1 = -1;\n+      } else {\n+        lo1 = min_jint; hi1 = max_jint;\n+      }\n+      return TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n+                            MIN2((jlong)in_type->_hi, hi1),\n+                            MAX2((int)in_type->_widen, w1));\n+    }\n+  }\n+  return this_type;\n@@ -362,1 +397,0 @@\n-  PhaseIterGVN *igvn = phase->is_IterGVN();\n@@ -364,44 +398,3 @@\n-  Node* this_changed = NULL;\n-\n-  if (igvn != NULL) {\n-    \/\/ Do NOT remove this node's type assertion until no more loop ops can happen.\n-    if (phase->C->post_loop_opts_phase()) {\n-      const TypeInt* in_type = phase->type(in(1))->isa_int();\n-      if (in_type != NULL && this_type != NULL &&\n-          (in_type->_lo != this_type->_lo ||\n-           in_type->_hi != this_type->_hi)) {\n-        \/\/ Although this WORSENS the type, it increases GVN opportunities,\n-        \/\/ because I2L nodes with the same input will common up, regardless\n-        \/\/ of slightly differing type assertions.  Such slight differences\n-        \/\/ arise routinely as a result of loop unrolling, so this is a\n-        \/\/ post-unrolling graph cleanup.  Choose a type which depends only\n-        \/\/ on my input.  (Exception:  Keep a range assertion of >=0 or <0.)\n-        jlong lo1 = this_type->_lo;\n-        jlong hi1 = this_type->_hi;\n-        int   w1  = this_type->_widen;\n-        if (lo1 != (jint)lo1 ||\n-            hi1 != (jint)hi1 ||\n-            lo1 > hi1) {\n-          \/\/ Overflow leads to wraparound, wraparound leads to range saturation.\n-          lo1 = min_jint; hi1 = max_jint;\n-        } else if (lo1 >= 0) {\n-          \/\/ Keep a range assertion of >=0.\n-          lo1 = 0;        hi1 = max_jint;\n-        } else if (hi1 < 0) {\n-          \/\/ Keep a range assertion of <0.\n-          lo1 = min_jint; hi1 = -1;\n-        } else {\n-          lo1 = min_jint; hi1 = max_jint;\n-        }\n-        const TypeLong* wtype = TypeLong::make(MAX2((jlong)in_type->_lo, lo1),\n-                                               MIN2((jlong)in_type->_hi, hi1),\n-                                               MAX2((int)in_type->_widen, w1));\n-        if (wtype != type()) {\n-          set_type(wtype);\n-          \/\/ Note: this_type still has old type value, for the logic below.\n-          this_changed = this;\n-        }\n-      }\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n+  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    phase->C->record_for_post_loop_opts_igvn(this);\n@@ -431,1 +424,1 @@\n-\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -440,1 +433,1 @@\n-      return this_changed;\n+      return NULL;\n@@ -456,1 +449,1 @@\n-  return this_changed;\n+  return NULL;\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":43,"deletions":50,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -220,0 +220,14 @@\n+\n+#ifndef PRODUCT\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    tty->print(\"+++++ Initial worklist for \");\n+    _compile->method()->print_name();\n+    tty->print_cr(\" (ea_inv=%d)\", _invocation);\n+    for (int i = 0; i < ptnodes_worklist.length(); i++) {\n+      PointsToNode* ptn = ptnodes_worklist.at(i);\n+      ptn->dump();\n+    }\n+    tty->print_cr(\"+++++ Calculating escape states and scalar replaceability\");\n+  }\n+#endif\n+\n@@ -624,1 +638,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n@@ -762,1 +776,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n@@ -868,1 +882,1 @@\n-    set_escape_state(ptn, PointsToNode::GlobalEscape);\n+    set_escape_state(ptn, PointsToNode::GlobalEscape NOT_PRODUCT(COMMA \"stored at raw address\"));\n@@ -895,0 +909,1 @@\n+    NOT_PRODUCT(const char* nsr_reason = \"\");\n@@ -900,2 +915,2 @@\n-        if (length < 0 || length > EliminateAllocationArraySizeLimit) {\n-          \/\/ Not scalar replaceable if the length is not constant or too big.\n+        if (length < 0) {\n+          \/\/ Not scalar replaceable if the length is not constant.\n@@ -903,0 +918,5 @@\n+          NOT_PRODUCT(nsr_reason = \"has a non-constant length\");\n+        } else if (length > EliminateAllocationArraySizeLimit) {\n+          \/\/ Not scalar replaceable if the length is too big.\n+          scalar_replaceable = false;\n+          NOT_PRODUCT(nsr_reason = \"has a length that is too big\");\n@@ -917,0 +937,1 @@\n+          NOT_PRODUCT(nsr_reason = \"has too many fields\");\n@@ -923,1 +944,1 @@\n-      ptn->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(ptn NOT_PRODUCT(COMMA nsr_reason));\n@@ -954,1 +975,1 @@\n-      ptnode_adr(call_idx)->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(ptnode_adr(call_idx) NOT_PRODUCT(COMMA \"is result of multinewarray\"));\n@@ -976,1 +997,1 @@\n-        ptnode_adr(call_idx)->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(ptnode_adr(call_idx) NOT_PRODUCT(COMMA \"is result of call\"));\n@@ -1131,1 +1152,1 @@\n-          set_escape_state(arg_ptn, es);\n+          set_escape_state(arg_ptn, es NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1186,1 +1207,1 @@\n-              set_escape_state(arg_ptn, PointsToNode::GlobalEscape);\n+              set_escape_state(arg_ptn, PointsToNode::GlobalEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1188,1 +1209,1 @@\n-              set_escape_state(arg_ptn, PointsToNode::ArgEscape);\n+              set_escape_state(arg_ptn, PointsToNode::ArgEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1191,1 +1212,1 @@\n-                set_fields_escape_state(arg_ptn, PointsToNode::GlobalEscape);\n+                set_fields_escape_state(arg_ptn, PointsToNode::GlobalEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1220,1 +1241,1 @@\n-          set_escape_state(ptnode_adr(arg->_idx), PointsToNode::GlobalEscape);\n+          set_escape_state(ptnode_adr(arg->_idx), PointsToNode::GlobalEscape NOT_PRODUCT(COMMA trace_arg_escape_message(call)));\n@@ -1404,1 +1425,1 @@\n-          set_fields_escape_state(e, field_es);\n+          set_fields_escape_state(e, field_es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1410,1 +1431,1 @@\n-          set_escape_state(e, es);\n+          set_escape_state(e, es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1417,1 +1438,1 @@\n-          set_fields_escape_state(e, field_es);\n+          set_fields_escape_state(e, field_es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1424,1 +1445,1 @@\n-          set_escape_state(e, field_es);\n+          set_escape_state(e, field_es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1427,1 +1448,1 @@\n-          set_escape_state(e, es);\n+          set_escape_state(e, es NOT_PRODUCT(COMMA trace_propagate_message(ptn)));\n@@ -1793,1 +1814,1 @@\n-        jobj->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is stored at unknown offset\"));\n@@ -1802,1 +1823,1 @@\n-            jobj->set_scalar_replaceable(false);\n+            set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is stored into field with potentially null base\"));\n@@ -1814,2 +1835,2 @@\n-        jobj->set_scalar_replaceable(false);\n-         ptn->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA trace_merged_message(ptn)));\n+        set_not_scalar_replaceable(ptn NOT_PRODUCT(COMMA trace_merged_message(jobj)));\n@@ -1835,1 +1856,1 @@\n-      jobj->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"has field with unknown offset\"));\n@@ -1850,1 +1871,1 @@\n-      jobj->set_scalar_replaceable(false);\n+      set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is used as base of mixed unsafe access\"));\n@@ -1857,1 +1878,1 @@\n-        jobj->set_scalar_replaceable(false);\n+        set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is used in LoadStore or mismatched access\"));\n@@ -1886,2 +1907,2 @@\n-          jobj->set_scalar_replaceable(false);\n-          base->set_scalar_replaceable(false);\n+          set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"may point to more than one object\"));\n+          set_not_scalar_replaceable(base NOT_PRODUCT(COMMA \"may point to more than one object\"));\n@@ -3152,1 +3173,1 @@\n-      set_escape_state(ptnode_adr(n->_idx), es); \/\/ CheckCastPP escape state\n+      set_escape_state(ptnode_adr(n->_idx), es NOT_PRODUCT(COMMA trace_propagate_message(ptn))); \/\/ CheckCastPP escape state\n@@ -3326,1 +3347,2 @@\n-              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||\n+              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp ||\n+              op == Op_CountPositives ||\n@@ -3457,1 +3479,1 @@\n-              op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||\n+              op == Op_AryEq || op == Op_StrComp || op == Op_CountPositives ||\n@@ -3627,1 +3649,1 @@\n-void PointsToNode::dump(bool print_state) const {\n+void PointsToNode::dump_header(bool print_state, outputStream* out) const {\n@@ -3629,1 +3651,1 @@\n-  tty->print(\"%s \", node_type_names[(int) nt]);\n+  out->print(\"%s(%d) \", node_type_names[(int) nt], _pidx);\n@@ -3633,1 +3655,1 @@\n-    tty->print(\"%s(%s) \", esc_names[(int)es], esc_names[(int)fields_es]);\n+    out->print(\"%s(%s) \", esc_names[(int)es], esc_names[(int)fields_es]);\n@@ -3635,1 +3657,1 @@\n-      tty->print(\"NSR \");\n+      out->print(\"NSR \");\n@@ -3638,0 +3660,4 @@\n+}\n+\n+void PointsToNode::dump(bool print_state, outputStream* out, bool newline) const {\n+  dump_header(print_state, out);\n@@ -3641,1 +3667,1 @@\n-      tty->print(\"oop \");\n+      out->print(\"oop \");\n@@ -3644,1 +3670,1 @@\n-      tty->print(\"+%d \", f->offset());\n+      out->print(\"+%d \", f->offset());\n@@ -3646,1 +3672,1 @@\n-    tty->print(\"(\");\n+    out->print(\"(\");\n@@ -3649,1 +3675,1 @@\n-      tty->print(\" %d%s\", b->idx(),(b->is_JavaObject() ? \"P\" : \"\"));\n+      out->print(\" %d%s\", b->idx(),(b->is_JavaObject() ? \"P\" : \"\"));\n@@ -3651,1 +3677,1 @@\n-    tty->print(\" )\");\n+    out->print(\" )\");\n@@ -3653,1 +3679,1 @@\n-  tty->print(\"[\");\n+  out->print(\"[\");\n@@ -3656,1 +3682,1 @@\n-    tty->print(\" %d%s%s\", e->idx(),(e->is_JavaObject() ? \"P\" : (e->is_Field() ? \"F\" : \"\")), e->is_Arraycopy() ? \"cp\" : \"\");\n+    out->print(\" %d%s%s\", e->idx(),(e->is_JavaObject() ? \"P\" : (e->is_Field() ? \"F\" : \"\")), e->is_Arraycopy() ? \"cp\" : \"\");\n@@ -3658,1 +3684,1 @@\n-  tty->print(\" [\");\n+  out->print(\" [\");\n@@ -3666,1 +3692,1 @@\n-    tty->print(\" %d%s%s\", u->idx(), is_base ? \"b\" : \"\", u->is_Arraycopy() ? \"cp\" : \"\");\n+    out->print(\" %d%s%s\", u->idx(), is_base ? \"b\" : \"\", u->is_Arraycopy() ? \"cp\" : \"\");\n@@ -3668,1 +3694,1 @@\n-  tty->print(\" ]]  \");\n+  out->print(\" ]]  \");\n@@ -3670,1 +3696,1 @@\n-    tty->print_cr(\"<null>\");\n+    out->print(\"<null>%s\", newline ? \"\\n\" : \"\");\n@@ -3672,1 +3698,1 @@\n-    _node->dump();\n+    _node->dump(newline ? \"\\n\" : \"\", false, out);\n@@ -3715,0 +3741,45 @@\n+\n+void ConnectionGraph::trace_es_update_helper(PointsToNode* ptn, PointsToNode::EscapeState es, bool fields, const char* reason) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    assert(ptn != nullptr, \"should not be null\");\n+    assert(reason != nullptr, \"should not be null\");\n+    ptn->dump_header(true);\n+    PointsToNode::EscapeState new_es = fields ? ptn->escape_state() : es;\n+    PointsToNode::EscapeState new_fields_es = fields ? es : ptn->fields_escape_state();\n+    tty->print_cr(\"-> %s(%s) %s\", esc_names[(int)new_es], esc_names[(int)new_fields_es], reason);\n+  }\n+}\n+\n+const char* ConnectionGraph::trace_propagate_message(PointsToNode* from) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    stringStream ss;\n+    ss.print(\"propagated from: \");\n+    from->dump(true, &ss, false);\n+    return ss.as_string();\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+const char* ConnectionGraph::trace_arg_escape_message(CallNode* call) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    stringStream ss;\n+    ss.print(\"escapes as arg to:\");\n+    call->dump(\"\", false, &ss);\n+    return ss.as_string();\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n+const char* ConnectionGraph::trace_merged_message(PointsToNode* other) const {\n+  if (_compile->directive()->TraceEscapeAnalysisOption) {\n+    stringStream ss;\n+    ss.print(\"is merged with other object: \");\n+    other->dump_header(true, &ss);\n+    return ss.as_string();\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":117,"deletions":46,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -235,1 +235,2 @@\n-  void dump(bool print_state=true) const;\n+  void dump(bool print_state=true, outputStream* out=tty, bool newline=true) const;\n+  void dump_header(bool print_state=true, outputStream* out=tty) const;\n@@ -432,1 +433,2 @@\n-  void set_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc) {\n+  void set_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc\n+                        NOT_PRODUCT(COMMA const char* reason)) {\n@@ -436,0 +438,1 @@\n+        NOT_PRODUCT(trace_es_update_helper(ptn, esc, false, reason));\n@@ -439,0 +442,1 @@\n+        NOT_PRODUCT(trace_es_update_helper(ptn, esc, true, reason));\n@@ -443,1 +447,2 @@\n-  void set_fields_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc) {\n+  void set_fields_escape_state(PointsToNode* ptn, PointsToNode::EscapeState esc\n+                               NOT_PRODUCT(COMMA const char* reason)) {\n@@ -447,0 +452,1 @@\n+        NOT_PRODUCT(trace_es_update_helper(ptn, esc, true, reason));\n@@ -572,0 +578,18 @@\n+  void set_not_scalar_replaceable(PointsToNode* ptn NOT_PRODUCT(COMMA const char* reason)) const {\n+#ifndef PRODUCT\n+    if (_compile->directive()->TraceEscapeAnalysisOption) {\n+      assert(ptn != nullptr, \"should not be null\");\n+      ptn->dump_header(true);\n+      tty->print_cr(\"is NSR. %s\", reason);\n+    }\n+#endif\n+    ptn->set_scalar_replaceable(false);\n+  }\n+\n+#ifndef PRODUCT\n+  void trace_es_update_helper(PointsToNode* ptn, PointsToNode::EscapeState es, bool fields, const char* reason) const;\n+  const char* trace_propagate_message(PointsToNode* from) const;\n+  const char* trace_arg_escape_message(CallNode* call) const;\n+  const char* trace_merged_message(PointsToNode* other) const;\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+#include <fenv.h>\n+\n@@ -787,1 +789,1 @@\n-    assert(lrg._area >= 0.0, \"negative spill area\" );\n+    assert(lrg._area >= 0.0, \"unexpected spill area value %g (rounding mode %x)\", lrg._area, fegetround());\n@@ -898,1 +900,1 @@\n-          assert(lrg._area >= 0.0, \"negative spill area\" );\n+          assert(lrg._area >= 0.0, \"unexpected spill area value %g (rounding mode %x)\", lrg._area, fegetround());\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -160,2 +160,2 @@\n-\/\/------------------------------HasNegatives---------------------------------\n-class HasNegativesNode: public StrIntrinsicNode {\n+\/\/------------------------------CountPositives------------------------------\n+class CountPositivesNode: public StrIntrinsicNode {\n@@ -163,1 +163,1 @@\n-  HasNegativesNode(Node* control, Node* char_array_mem, Node* s1, Node* c1):\n+  CountPositivesNode(Node* control, Node* char_array_mem, Node* s1, Node* c1):\n@@ -166,1 +166,1 @@\n-  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual const Type* bottom_type() const { return TypeInt::POS; }\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -620,2 +620,2 @@\n-  case vmIntrinsics::_hasNegatives:\n-    return inline_hasNegatives();\n+  case vmIntrinsics::_countPositives:\n+    return inline_countPositives();\n@@ -1016,2 +1016,2 @@\n-\/\/------------------------------inline_hasNegatives------------------------------\n-bool LibraryCallKit::inline_hasNegatives() {\n+\/\/------------------------------inline_countPositives------------------------------\n+bool LibraryCallKit::inline_countPositives() {\n@@ -1022,1 +1022,1 @@\n-  assert(callee()->signature()->size() == 3, \"hasNegatives has 3 parameters\");\n+  assert(callee()->signature()->size() == 3, \"countPositives has 3 parameters\");\n@@ -1036,1 +1036,1 @@\n-  Node* result = new HasNegativesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);\n+  Node* result = new CountPositivesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);\n@@ -1097,1 +1097,0 @@\n-  clear_upper_avx();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-  bool inline_hasNegatives();\n+  bool inline_countPositives();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -762,1 +762,1 @@\n-  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, &scale, &offset, bt)) {\n+  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, bt, &scale, &offset)) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -831,1 +831,1 @@\n-      case Op_HasNegatives: {\n+      case Op_CountPositives: {\n@@ -959,0 +959,2 @@\n+  \/\/ Rudimentary cost model to estimate loop unrolling\n+  \/\/ factor.\n@@ -971,0 +973,5 @@\n+      case Op_PopCountVI:\n+      case Op_PopCountVL: {\n+        const TypeVect* vt = n->bottom_type()->is_vect();\n+        body_size += Matcher::vector_op_pre_select_sz_estimate(n->Opcode(), vt->element_basic_type(), vt->length());\n+      } break;\n@@ -977,1 +984,1 @@\n-      case Op_HasNegatives: {\n+      case Op_CountPositives: {\n@@ -1124,2 +1131,0 @@\n-      Node *rc_exp = cmp->in(1);\n-      Node *limit = cmp->in(2);\n@@ -1131,2 +1136,2 @@\n-        if (!phase->is_scaled_iv_plus_offset(cmp->in(1), trip_counter, NULL, NULL, bt) &&\n-            !phase->is_scaled_iv_plus_offset(cmp->in(2), trip_counter, NULL, NULL, bt)) {\n+        if (!phase->is_scaled_iv_plus_offset(cmp->in(1), trip_counter, bt, NULL, NULL) &&\n+            !phase->is_scaled_iv_plus_offset(cmp->in(2), trip_counter, bt, NULL, NULL)) {\n@@ -1136,0 +1141,2 @@\n+        Node *rc_exp = cmp->in(1);\n+        Node *limit = cmp->in(2);\n@@ -1150,1 +1157,1 @@\n-        if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL, bt)) {\n+        if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, bt, NULL, NULL)) {\n@@ -2525,0 +2532,4 @@\n+\/\/----------------------------------is_iv------------------------------------\n+\/\/ Return true if exp is the value (of type bt) of the given induction var.\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/    VIV[iv] = iv | (CastXX VIV[iv]) | (ConvI2X VIV[iv])\n@@ -2526,1 +2537,2 @@\n-  if (exp == iv) {\n+  exp = exp->uncast();\n+  if (exp == iv && iv->bottom_type()->isa_integer(bt)) {\n@@ -2530,1 +2542,1 @@\n-  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L && exp->in(1) == iv) {\n+  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L && exp->in(1)->uncast() == iv) {\n@@ -2537,5 +2549,17 @@\n-\/\/ Return true if exp is a constant times an induction var\n-bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt, bool* converted) {\n-  exp = exp->uncast();\n-  assert(bt == T_INT || bt == T_LONG, \"unexpected int type\");\n-  if (is_iv(exp, iv, bt)) {\n+\/\/ Return true if exp is a constant times the given induction var (of type bt).\n+\/\/ The multiplication is either done in full precision (exactly of type bt),\n+\/\/ or else bt is T_LONG but iv is scaled using 32-bit arithmetic followed by a ConvI2L.\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/    SIV[iv] = VIV[iv] | (CastXX SIV[iv])\n+\/\/            | (MulX VIV[iv] ConX) | (MulX ConX VIV[iv])\n+\/\/            | (LShiftX VIV[iv] ConI)\n+\/\/            | (ConvI2L SIV[iv])  -- a \"short-scale\" can occur here; note recursion\n+\/\/            | (SubX 0 SIV[iv])  -- same as MulX(iv, -scale); note recursion\n+\/\/    VIV[iv] = [either iv or its value converted; see is_iv() above]\n+\/\/ On success, the constant scale value is stored back to *p_scale.\n+\/\/ The value (*p_short_scale) reports if such a ConvI2L conversion was present.\n+bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, BasicType bt, jlong* p_scale, bool* p_short_scale, int depth) {\n+  BasicType exp_bt = bt;\n+  exp = exp->uncast();  \/\/strip casts\n+  assert(exp_bt == T_INT || exp_bt == T_LONG, \"unexpected int type\");\n+  if (is_iv(exp, iv, exp_bt)) {\n@@ -2545,0 +2569,3 @@\n+    if (p_short_scale != NULL) {\n+      *p_short_scale = false;\n+    }\n@@ -2547,1 +2574,1 @@\n-  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n+  if (exp_bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n@@ -2549,4 +2576,1 @@\n-    bt = T_INT;\n-    if (converted != NULL) {\n-      *converted = true;\n-    }\n+    exp_bt = T_INT;\n@@ -2555,0 +2579,1 @@\n+  int which = 0;  \/\/ this is which subexpression we find the iv in\n@@ -2556,2 +2581,8 @@\n-  if (opc == Op_Mul(bt)) {\n-    if (is_iv(exp->in(1)->uncast(), iv, bt) && exp->in(2)->is_Con()) {\n+  if (opc == Op_Mul(exp_bt)) {\n+    if ((is_iv(exp->in(which = 1), iv, exp_bt) && exp->in(2)->is_Con()) ||\n+        (is_iv(exp->in(which = 2), iv, exp_bt) && exp->in(1)->is_Con())) {\n+      Node* factor = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      jlong scale = factor->find_integer_as_long(exp_bt, 0);\n+      if (scale == 0) {\n+        return false;  \/\/ might be top\n+      }\n@@ -2559,1 +2590,5 @@\n-        *p_scale = exp->in(2)->get_integer_as_long(bt);\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = (exp_bt != bt && scale != 1);\n@@ -2563,1 +2598,12 @@\n-    if (is_iv(exp->in(2)->uncast(), iv, bt) && exp->in(1)->is_Con()) {\n+  } else if (opc == Op_LShift(exp_bt)) {\n+    if (is_iv(exp->in(1), iv, exp_bt) && exp->in(2)->is_Con()) {\n+      jint shift_amount = exp->in(2)->find_int_con(min_jint);\n+      if (shift_amount == min_jint) {\n+        return false;  \/\/ might be top\n+      }\n+      jlong scale;\n+      if (exp_bt == T_INT) {\n+        scale = java_shift_left((jint)1, (juint)shift_amount);\n+      } else if (exp_bt == T_LONG) {\n+        scale = java_shift_left((jlong)1, (julong)shift_amount);\n+      }\n@@ -2565,1 +2611,5 @@\n-        *p_scale = exp->in(1)->get_integer_as_long(bt);\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = (exp_bt != bt && scale != 1);\n@@ -2569,2 +2619,10 @@\n-  } else if (opc == Op_LShift(bt)) {\n-    if (is_iv(exp->in(1)->uncast(), iv, bt) && exp->in(2)->is_Con()) {\n+  } else if (opc == Op_Sub(exp_bt) &&\n+             exp->in(1)->find_integer_as_long(exp_bt, -1) == 0) {\n+    jlong scale = 0;\n+    if (depth == 0 && is_scaled_iv(exp->in(2), iv, exp_bt, &scale, p_short_scale, depth + 1)) {\n+      \/\/ SubX(0, iv*K) => iv*(-K)\n+      if (scale == min_signed_integer(exp_bt)) {\n+        \/\/ This should work even if -K overflows, but let's not.\n+        return false;\n+      }\n+      scale = java_multiply(scale, (jlong)-1);\n@@ -2572,6 +2630,5 @@\n-        jint shift_amount = exp->in(2)->get_int();\n-        if (bt == T_INT) {\n-          *p_scale = java_shift_left((jint)1, (juint)shift_amount);\n-        } else if (bt == T_LONG) {\n-          *p_scale = java_shift_left((jlong)1, (julong)shift_amount);\n-        }\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = *p_short_scale || (exp_bt != bt && scale != 1);\n@@ -2582,0 +2639,1 @@\n+  \/\/ We could also recognize (iv*K1)*K2, even with overflow, but let's not.\n@@ -2585,3 +2643,17 @@\n-\/\/-----------------------------is_scaled_iv_plus_offset------------------------------\n-\/\/ Return true if exp is a simple induction variable expression: k1*iv + (invar + k2)\n-bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* converted, int depth) {\n+\/\/-------------------------is_scaled_iv_plus_offset--------------------------\n+\/\/ Return true if exp is a simple linear transform of the given induction var.\n+\/\/ The scale must be constant and the addition tree (if any) must be simple.\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/\n+\/\/    OIV[iv] = SIV[iv] | (CastXX OIV[iv])\n+\/\/            | (AddX SIV[iv] E) | (AddX E SIV[iv])\n+\/\/            | (SubX SIV[iv] E) | (SubX E SIV[iv])\n+\/\/    SSIV[iv] = (ConvI2X SIV[iv])  -- a \"short scale\" might occur here\n+\/\/    SIV[iv] = [a possibly scaled value of iv; see is_scaled_iv() above]\n+\/\/\n+\/\/ On success, the constant scale value is stored back to *p_scale unless null.\n+\/\/ Likewise, the addend (perhaps a synthetic AddX node) is stored to *p_offset.\n+\/\/ Also, (*p_short_scale) reports if a ConvI2L conversion was seen after a MulI,\n+\/\/ meaning bt is T_LONG but iv was scaled using 32-bit arithmetic.\n+\/\/ To avoid looping, the match is depth-limited, and so may fail to match the grammar to complex expressions.\n+bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale, int depth) {\n@@ -2589,1 +2661,7 @@\n-  if (is_scaled_iv(exp, iv, p_scale, bt, converted)) {\n+  jlong scale = 0;  \/\/ to catch result from is_scaled_iv()\n+  BasicType exp_bt = bt;\n+  exp = exp->uncast();\n+  if (is_scaled_iv(exp, iv, exp_bt, &scale, p_short_scale)) {\n+    if (p_scale != NULL) {\n+      *p_scale = scale;\n+    }\n@@ -2591,1 +2669,1 @@\n-      Node *zero = _igvn.integercon(0, bt);\n+      Node *zero = _igvn.zerocon(bt);\n@@ -2597,1 +2675,7 @@\n-  exp = exp->uncast();\n+  if (exp_bt != bt) {\n+    \/\/ We would now be matching inputs like (ConvI2L exp:(AddI (MulI iv S) E)).\n+    \/\/ It's hard to make 32-bit arithmetic linear if it overflows.  Although we do\n+    \/\/ cope with overflowing multiplication by S, it would be even more work to\n+    \/\/ handle overflowing addition of E.  So we bail out here on ConvI2L input.\n+    return false;\n+  }\n@@ -2599,2 +2683,10 @@\n-  if (opc == Op_Add(bt)) {\n-    if (is_scaled_iv(exp->in(1), iv, p_scale, bt, converted)) {\n+  int which = 0;  \/\/ this is which subexpression we find the iv in\n+  Node* offset = NULL;\n+  if (opc == Op_Add(exp_bt)) {\n+    \/\/ Check for a scaled IV in (AddX (MulX iv S) E) or (AddX E (MulX iv S)).\n+    if (is_scaled_iv(exp->in(which = 1), iv, bt, &scale, p_short_scale) ||\n+        is_scaled_iv(exp->in(which = 2), iv, bt, &scale, p_short_scale)) {\n+      offset = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      if (p_scale != NULL) {\n+        *p_scale = scale;\n+      }\n@@ -2602,1 +2694,1 @@\n-        *p_offset = exp->in(2);\n+        *p_offset = offset;\n@@ -2606,4 +2698,3 @@\n-    if (is_scaled_iv(exp->in(2), iv, p_scale, bt, converted)) {\n-      if (p_offset != NULL) {\n-        *p_offset = exp->in(1);\n-      }\n+    \/\/ Check for more addends, like (AddX (AddX (MulX iv S) E1) E2), etc.\n+    if (is_scaled_iv_plus_extra_offset(exp->in(1), exp->in(2), iv, bt, p_scale, p_offset, p_short_scale, depth) ||\n+        is_scaled_iv_plus_extra_offset(exp->in(2), exp->in(1), iv, bt, p_scale, p_offset, p_short_scale, depth)) {\n@@ -2612,10 +2703,10 @@\n-    if (exp->in(2)->is_Con()) {\n-      Node* offset2 = NULL;\n-      if (depth < 2 &&\n-          is_scaled_iv_plus_offset(exp->in(1), iv, p_scale,\n-                                   p_offset != NULL ? &offset2 : NULL, bt, converted, depth+1)) {\n-        if (p_offset != NULL) {\n-          Node *ctrl_off2 = get_ctrl(offset2);\n-          Node* offset = AddNode::make(offset2, exp->in(2), bt);\n-          register_new_node(offset, ctrl_off2);\n-          *p_offset = offset;\n+  } else if (opc == Op_Sub(exp_bt)) {\n+    if (is_scaled_iv(exp->in(which = 1), iv, bt, &scale, p_short_scale) ||\n+        is_scaled_iv(exp->in(which = 2), iv, bt, &scale, p_short_scale)) {\n+      \/\/ Match (SubX SIV[iv] E) as if (AddX SIV[iv] (SubX 0 E)), and\n+      \/\/ match (SubX E SIV[iv]) as if (AddX E (SubX 0 SIV[iv])).\n+      offset = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      if (which == 2) {\n+        \/\/ We can't handle a scale of min_jint (or min_jlong) here as -1 * min_jint = min_jint\n+        if (scale == min_signed_integer(bt)) {\n+          return false;   \/\/ cannot negate the scale of the iv\n@@ -2623,1 +2714,1 @@\n-        return true;\n+        scale = java_multiply(scale, (jlong)-1);\n@@ -2625,10 +2716,2 @@\n-    }\n-  } else if (opc == Op_Sub(bt)) {\n-    if (is_scaled_iv(exp->in(1), iv, p_scale, bt, converted)) {\n-      if (p_offset != NULL) {\n-        Node *zero = _igvn.integercon(0, bt);\n-        set_ctrl(zero, C->root());\n-        Node *ctrl_off = get_ctrl(exp->in(2));\n-        Node* offset = SubNode::make(zero, exp->in(2), bt);\n-        register_new_node(offset, ctrl_off);\n-        *p_offset = offset;\n+      if (p_scale != NULL) {\n+        *p_scale = scale;\n@@ -2636,3 +2719,0 @@\n-      return true;\n-    }\n-    if (is_scaled_iv(exp->in(2), iv, p_scale, bt, converted)) {\n@@ -2640,3 +2720,6 @@\n-        \/\/ We can't handle a scale of min_jint (or min_jlong) here as -1 * min_jint = min_jint\n-        if (*p_scale == min_signed_integer(bt)) {\n-          return false;\n+        if (which == 1) {  \/\/ must negate the extracted offset\n+          Node *zero = _igvn.integercon(0, exp_bt);\n+          set_ctrl(zero, C->root());\n+          Node *ctrl_off = get_ctrl(offset);\n+          offset = SubNode::make(zero, offset, exp_bt);\n+          register_new_node(offset, ctrl_off);\n@@ -2644,2 +2727,1 @@\n-        *p_scale *= -1;\n-        *p_offset = exp->in(1);\n+        *p_offset = offset;\n@@ -2653,0 +2735,27 @@\n+\/\/ Helper for is_scaled_iv_plus_offset(), not called separately.\n+\/\/ The caller encountered (AddX exp1 offset3) or (AddX offset3 exp1).\n+\/\/ Here, exp1 is inspected to see if it is a simple linear transform of iv.\n+\/\/ If so, the offset3 is combined with any other offset2 from inside exp1.\n+bool PhaseIdealLoop::is_scaled_iv_plus_extra_offset(Node* exp1, Node* offset3, Node* iv,\n+                                                    BasicType bt,\n+                                                    jlong* p_scale, Node** p_offset,\n+                                                    bool* p_short_scale, int depth) {\n+  \/\/ By the time we reach here, it is unlikely that exp1 is a simple iv*K.\n+  \/\/ If is a linear iv transform, it is probably an add or subtract.\n+  \/\/ Let's collect the internal offset2 from it.\n+  Node* offset2 = NULL;\n+  if (offset3->is_Con() &&\n+      depth < 2 &&\n+      is_scaled_iv_plus_offset(exp1, iv, bt, p_scale,\n+                               &offset2, p_short_scale, depth+1)) {\n+    if (p_offset != NULL) {\n+      Node* ctrl_off2 = get_ctrl(offset2);\n+      Node* offset = AddNode::make(offset2, offset3, bt);\n+      register_new_node(offset, ctrl_off2);\n+      *p_offset = offset;\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":183,"deletions":74,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -693,2 +693,1 @@\n-    \/\/ We can only use that safepoint if there's not side effect\n-    \/\/ between the backedge and the safepoint.\n+    \/\/ We can only use that safepoint if there's no side effect between the backedge and the safepoint.\n@@ -856,1 +855,4 @@\n-    strip_mined_nest_back_to_counted_loop(loop, head, back_control, exit_test, safepoint);\n+    OuterStripMinedLoopNode* outer_loop = head->as_CountedLoop()->outer_loop();\n+    safepoint = outer_loop->outer_safepoint();\n+    outer_loop->transform_to_counted_loop(&_igvn, this);\n+    exit_test = head->loopexit();\n@@ -1062,62 +1064,0 @@\n-\/\/ Convert the strip mined loop nest back to a single loop with the safepoint right before the loop exit test\n-void PhaseIdealLoop::strip_mined_nest_back_to_counted_loop(IdealLoopTree* loop, const BaseCountedLoopNode* head,\n-                                                           Node* back_control, IfNode*& exit_test,\n-                                                           SafePointNode*& safepoint) {\n-  CountedLoopNode* cl = head->as_CountedLoop();\n-  cl->verify_strip_mined(1);\n-  safepoint = cl->outer_safepoint();\n-  CountedLoopEndNode* cle = cl->loopexit();\n-  OuterStripMinedLoopNode* outer_head = cl->outer_loop();\n-  OuterStripMinedLoopEndNode* outer_end = cl->outer_loop_end();\n-\n-  cl->clear_strip_mined();\n-\n-  _igvn.replace_input_of(cl, LoopNode::EntryControl, outer_head->in(LoopNode::EntryControl));\n-  _igvn.replace_input_of(outer_head, LoopNode::EntryControl, C->top());\n-  set_idom(cl, cl->in(LoopNode::EntryControl), dom_depth(cl));\n-\n-  Node* exit_bol = cle->in(1);\n-  Node *zero = _igvn.intcon(0);\n-  set_ctrl(zero, C->root());\n-  _igvn.replace_input_of(cle, 1, zero);\n-\n-  _igvn.replace_input_of(outer_end, 1, exit_bol);\n-\n-  assert(outer_head->in(LoopNode::LoopBackControl)->in(0) == outer_end, \"\");\n-  _igvn.replace_input_of(outer_head->in(LoopNode::LoopBackControl), 0, C->top());\n-  _igvn.replace_input_of(back_control, 0, outer_end);\n-  set_idom(back_control, outer_end, dom_depth(outer_end) + 1);\n-\n-  Unique_Node_List wq;\n-  wq.push(safepoint);\n-\n-  IdealLoopTree* outer_loop_ilt = get_loop(outer_head);\n-\n-  for (uint i = 0; i < wq.size(); i++) {\n-    Node* n = wq.at(i);\n-    for (uint j = 0; j < n->req(); ++j) {\n-      Node* in = n->in(j);\n-      if (in == NULL || in->is_CFG()) {\n-        continue;\n-      }\n-      if (get_loop(get_ctrl(in)) != outer_loop_ilt) {\n-        continue;\n-      }\n-      assert(!loop->_body.contains(in), \"\");\n-      loop->_body.push(in);\n-      wq.push(in);\n-    }\n-  }\n-\n-  set_loop(outer_end, loop);\n-  loop->_body.push(outer_end);\n-  set_loop(safepoint, loop);\n-  loop->_body.push(safepoint);\n-  set_loop(safepoint->in(0), loop);\n-  loop->_body.push(safepoint->in(0));\n-\n-  exit_test = outer_end;\n-\n-  outer_loop_ilt->_tail = C->top();\n-}\n-\n@@ -1126,3 +1066,0 @@\n-  if (stride_con < 0) { \/\/ only for stride_con > 0 && scale > 0 for now\n-    return iters_limit;\n-  }\n@@ -1143,1 +1080,0 @@\n-            scale > 0 && \/\/ only for stride_con > 0 && scale > 0 for now\n@@ -1158,2 +1094,1 @@\n-\/\/ i is never Z.  It will be B=Z-1 if S=1, or B=Z+1 if S=-1.  If |S|>1 the formula for the last value requires a floor\n-\/\/ operation, specifically B=floor((Z-sgn(S)-A)\/S)*S+A.  Thus i ranges as i:[A,B] or i:[A,Z) or i:[A,Z-U) for some U<S.\n+\/\/ i is never Z.  It will be B=Z-1 if S=1, or B=Z+1 if S=-1.\n@@ -1161,3 +1096,3 @@\n-\/\/ N.B. We handle only the case of positive S currently, so comments about S<0 are not operative at present.  Also,\n-\/\/ we only support positive index scale value (K > 0) to simplify the logic for clamping 32-bit bounds (L_2, R_2).\n-\/\/ For restrictions on S and K, see the guards in extract_long_range_checks.\n+\/\/ If |S|>1 the formula for the last value B would require a floor operation, specifically B=floor((Z-sgn(S)-A)\/S)*S+A,\n+\/\/ which is B=Z-sgn(S)U for some U in [1,|S|].  So when S>0, i ranges as i:[A,Z) or i:[A,B=Z-U], or else (in reverse)\n+\/\/ as i:(Z,A] or i:[B=Z+U,A].  It will become important to reason about this inclusive range [A,B] or [B,A].\n@@ -1167,1 +1102,1 @@\n-\/\/ Because R is never negative, this check can always be simplified to an unsigned check i*K+L <u R.\n+\/\/ Because R is never negative (see below), this check can always be simplified to an unsigned check i*K+L <u R.\n@@ -1170,3 +1105,3 @@\n-\/\/ variable j (inner_iv), j ranges over a shorter interval j:[0,Z_2), where the limit is chosen to prevent various cases\n-\/\/ of 32-bit overflow (including multiplications j*K below).  In the sub-loop the logical value i is offset from j by a\n-\/\/ 64-bit constant C, so i ranges in i:C+[0,Z_2).\n+\/\/ variable j (inner_iv), j ranges over a shorter interval j:[0,B_2] or [0,Z_2) (assuming S > 0), where the limit is\n+\/\/ chosen to prevent various cases of 32-bit overflow (including multiplications j*K below).  In the sub-loop the\n+\/\/ logical value i is offset from j by a 64-bit constant C, so i ranges in i:C+[0,Z_2).\n@@ -1174,3 +1109,2 @@\n-\/\/ The union of all the C+[0,Z_2) ranges from the sub-loops must be identical to the whole range [A,B].  Assuming S>0,\n-\/\/ the first C must be A itself, and the next C value is the previous C+Z_2.  In each sub-loop, j counts up from zero\n-\/\/ and exits just before i=C+Z_2.\n+\/\/ For S<0, j ranges (in reverse!) through j:[-|B_2|,0] or (-|Z_2|,0].  For either sign of S, we can say i=j+C and j\n+\/\/ ranges through 32-bit ranges [A_2,B_2] or [B_2,A_2] (A_2=0 of course).\n@@ -1178,1 +1112,5 @@\n-\/\/ (N.B. If S<0 the formulas are different, because all the loops count downward.)\n+\/\/ The disjoint union of all the C+[A_2,B_2] ranges from the sub-loops must be identical to the whole range [A,B].\n+\/\/ Assuming S>0, the first C must be A itself, and the next C value is the previous C+B_2, plus S.  If |S|=1, the next\n+\/\/ C value is also the previous C+Z_2.  In each sub-loop, j counts from j=A_2=0 and i counts from C+0 and exits at\n+\/\/ j=B_2 (i=C+B_2), just before it gets to i=C+Z_2.  Both i and j count up (from C and 0) if S>0; otherwise they count\n+\/\/ down (from C and 0 again).\n@@ -1198,4 +1136,3 @@\n-\/\/ For each R.C. j*K+Q <u32 R, the range of mathematical values of j*K+Q in the sub-loop is [Q_min, Q_max), where\n-\/\/ Q_min=Q and Q_max=Z_2*K+Q.  Making the upper limit Q_max be exclusive helps it integrate correctly with the strict\n-\/\/ comparisons against R and R_2.  Sometimes a very high R will be replaced by an R_2 derived from the more moderate\n-\/\/ Q_max, and replacing one exclusive limit by another exclusive limit avoids off-by-one complexities.\n+\/\/ For each R.C. j*K+Q <u32 R, the range of mathematical values of j*K+Q in the sub-loop is [Q_min, Q_max], where\n+\/\/ Q_min=Q and Q_max=B_2*K+Q (if S>0 and K>0), Q_min=A_2*K+Q and Q_max=Q (if S<0 and K>0),\n+\/\/ Q_min=B_2*K+Q and Q_max=Q if (S>0 and K<0), Q_min=Q and Q_max=A_2*K+Q (if S<0 and K<0)\n@@ -1203,2 +1140,3 @@\n-\/\/ N.B. If (S*K)<0 then the formulas for Q_min and Q_max may differ; the values may need to be swapped and adjusted to\n-\/\/ the correct type of bound (inclusive or exclusive).\n+\/\/ Note that the first R.C. value is always Q=(S*K>0 ? Q_min : Q_max).  Also Q_{min,max} = Q + {min,max}(A_2*K,B_2*K).\n+\/\/ If S*K>0 then, as the loop iterations progress, each R.C. value i*K+L = j*K+Q goes up from Q=Q_min towards Q_max.\n+\/\/ If S*K<0 then j*K+Q starts at Q=Q_max and goes down towards Q_min.\n@@ -1210,0 +1148,1 @@\n+\/\/ |    .     .    .    .    R=0  R<   R<   R<    R<   |  (against R values)\n@@ -1211,0 +1150,1 @@\n+\/\/ |    .     .    .    .    R    R    R<   R<    R<   |  (against R values)\n@@ -1212,2 +1152,7 @@\n-\/\/ if Q_min <s64 0, then use this test:\n-\/\/ j*K + s32_trunc(Q_min) <u32 clamp(R, 0, Q_max)\n+\/\/ R values which are out of range (>Q_max+1) are reduced to max(0,Q_max+1).  They are marked on the number line as R<.\n+\/\/\n+\/\/ So, if Q_min <s64 0, then use this test:\n+\/\/ j*K + s32_trunc(Q_min) <u32 clamp(R, 0, Q_max+1) if S*K>0 (R.C.E. steps upward)\n+\/\/ j*K + s32_trunc(Q_max) <u32 clamp(R, 0, Q_max+1) if S*K<0 (R.C.E. steps downward)\n+\/\/ Both formulas reduce to adding j*K to the 32-bit truncated value of the first R.C. expression value, Q:\n+\/\/ j*K + s32_trunc(Q) <u32 clamp(R, 0, Q_max+1) for all S,K\n@@ -1215,1 +1160,1 @@\n-\/\/ If the 32-bit truncation loses information, no harm is done, since certainly the clamp also returns R_2=zero.\n+\/\/ If the 32-bit truncation loses information, no harm is done, since certainly the clamp also will return R_2=zero.\n@@ -1221,0 +1166,1 @@\n+\/\/ |    .     .    .    .    R>   R    R    R<    R<   |  (against R values)\n@@ -1222,0 +1168,4 @@\n+\/\/ |    .     .    .    .    R>   R>   R    R     R<   |  (against R values)\n+\/\/\n+\/\/ R values which are out of range (<Q_min or >Q_max+1) are reduced as marked: R> up to Q_min, R< down to Q_max+1.\n+\/\/ Then the whole comparison is shifted left by Q_min, so it can take place at zero, which is a nice 32-bit value.\n@@ -1223,4 +1173,4 @@\n-\/\/ if both Q_min, Q_max >=s64 0, then use this test:\n-\/\/ j*K + 0 <u32 clamp(R, Q_min, Q_max) - Q_min\n-\/\/ or equivalently:\n-\/\/ j*K + 0 <u32 clamp(R - Q_min, 0, Q_max - Q_min)\n+\/\/ So, if both Q_min, Q_max+1 >=s64 0, then use this test:\n+\/\/ j*K + 0         <u32 clamp(R, Q_min, Q_max+1) - Q_min if S*K>0\n+\/\/ More generally:\n+\/\/ j*K + Q - Q_min <u32 clamp(R, Q_min, Q_max+1) - Q_min for all S,K\n@@ -1231,0 +1181,1 @@\n+\/\/ |    .     .    .    .    R>   R>   R>   R>    R    |  (against R values)\n@@ -1232,6 +1183,3 @@\n-\/\/ if Q_min >=s64 0 but Q_max <s64 0, then use this test:\n-\/\/ j*K + 0 <u32 clamp(R, Q_min, R) - Q_min\n-\/\/ or equivalently:\n-\/\/ j*K + 0 <u32 clamp(R - Q_min, 0, R - Q_min)\n-\/\/ or also equivalently:\n-\/\/ j*K + 0 <u32 max(0, R - Q_min)\n+\/\/ In this case, Q_min >s64 Q_max+1, even though the mathematical values of Q_min and Q_max+1 are correctly ordered.\n+\/\/ The formulas from the previous case can be used, except that the bad upper bound Q_max is replaced by max_jlong.\n+\/\/ (In fact, we could use any replacement bound from R to max_jlong inclusive, as the input to the clamp function.)\n@@ -1239,2 +1187,10 @@\n-\/\/ Here the clamp function is a simple 64-bit min\/max:\n-\/\/ clamp(X, L, H) := max(L, min(X, H))\n+\/\/ So if Q_min >=s64 0 but Q_max+1 <s64 0, use this test:\n+\/\/ j*K + 0         <u32 clamp(R, Q_min, max_jlong) - Q_min if S*K>0\n+\/\/ More generally:\n+\/\/ j*K + Q - Q_min <u32 clamp(R, Q_min, max_jlong) - Q_min for all S,K\n+\/\/\n+\/\/ Dropping the bad bound means only Q_min is used to reduce the range of R:\n+\/\/ j*K + Q - Q_min <u32 max(Q_min, R) - Q_min for all S,K\n+\/\/\n+\/\/ Here the clamp function is a 64-bit min\/max that reduces the dynamic range of its R operand to the required [L,H]:\n+\/\/     clamp(X, L, H) := max(L, min(X, H))\n@@ -1243,6 +1199,23 @@\n-\/\/ Tests above can be merged into a single one:\n-\/\/ L_clamp = Q_min < 0 ? 0 : Q_min\n-\/\/ H_clamp = Q_max < Q_min ? R : Q_max\n-\/\/ j*K + Q_min - L_clamp <u32 clamp(R, L_clamp, H_clamp) - L_clamp\n-\/\/ or equivalently:\n-\/\/ j*K + Q_min - L_clamp <u32 clamp(R - L_clamp, 0, H_clamp - L_clamp)\n+\/\/ All of the formulas above can be merged into a single one:\n+\/\/     L_clamp = Q_min < 0 ? 0 : Q_min        --whether and how far to left-shift\n+\/\/     H_clamp = Q_max+1 < Q_min ? max_jlong : Q_max+1\n+\/\/             = Q_max+1 < 0 && Q_min >= 0 ? max_jlong : Q_max+1\n+\/\/     Q_first = Q = (S*K>0 ? Q_min : Q_max) = (C*K+L)\n+\/\/     R_clamp = clamp(R, L_clamp, H_clamp)   --reduced dynamic range\n+\/\/     replacement R.C.:\n+\/\/       j*K + Q_first - L_clamp <u32 R_clamp - L_clamp\n+\/\/     or equivalently:\n+\/\/       j*K + L_2 <u32 R_2\n+\/\/     where\n+\/\/       L_2 = Q_first - L_clamp\n+\/\/       R_2 = R_clamp - L_clamp\n+\/\/\n+\/\/ Note on why R is never negative:\n+\/\/\n+\/\/ Various details of this transformation would break badly if R could be negative, so this transformation only\n+\/\/ operates after obtaining hard evidence that R<0 is impossible.  For example, if R comes from a LoadRange node, we\n+\/\/ know R cannot be negative.  For explicit checks (of both int and long) a proof is constructed in\n+\/\/ inline_preconditions_checkIndex, which triggers an uncommon trap if R<0, then wraps R in a ConstraintCastNode with a\n+\/\/ non-negative type.  Later on, when IdealLoopTree::is_range_check_if looks for an optimizable R.C., it checks that\n+\/\/ the type of that R node is non-negative.  Any \"wild\" R node that could be negative is not treated as an optimizable\n+\/\/ R.C., but R values from a.length and inside checkIndex are good to go.\n@@ -1250,2 +1223,0 @@\n-\/\/ Readers may find the equivalent forms easier to reason about, but the forms given first generate better code.\n-\n@@ -1257,0 +1228,6 @@\n+  Node* int_zero = _igvn.intcon(0);\n+  set_ctrl(int_zero, this->C->root());\n+  Node* long_one = _igvn.longcon(1);\n+  set_ctrl(long_one, this->C->root());\n+  Node* int_stride = _igvn.intcon(checked_cast<int>(stride_con));\n+  set_ctrl(int_stride, this->C->root());\n@@ -1270,2 +1247,2 @@\n-    bool converted = false;\n-    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, &scale, &offset, T_LONG, &converted);\n+    bool short_scale = false;\n+    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, T_LONG, &scale, &offset, &short_scale);\n@@ -1283,1 +1260,1 @@\n-    if (converted) {\n+    if (short_scale) {\n@@ -1285,1 +1262,1 @@\n-      \/\/ i*K + L <u64 R\n+      \/\/ (int)i*K + L <u64 R\n@@ -1288,1 +1265,1 @@\n-      \/\/ to protect against an overflow of i*K\n+      \/\/ to protect against an overflow of (int)i*K\n@@ -1290,7 +1267,6 @@\n-      \/\/ Because if i*K overflows, there are K,L where:\n-      \/\/ i*K + L <u64 R is false\n-      \/\/ when\n-      \/\/ i*(long)K is > (long)max_jint and < R\n-      \/\/ and so i*(long)K + L <u64 R is true\n-      \/\/ As a consequence simply converting:\n-      \/\/ i*K + L <u64 R to i*(long)K + L <u64 R could cause incorrect execution\n+      \/\/ Because if (int)i*K overflows, there are K,L where:\n+      \/\/ (int)i*K + L <u64 R is false because (int)i*K+L overflows to a negative which becomes a huge u64 value.\n+      \/\/ But if i*(long)K + L is >u64 (long)max_jint and still is <u64 R, then\n+      \/\/ i*(long)K + L <u64 R is true.\n+      \/\/\n+      \/\/ As a consequence simply converting i*K + L <u64 R to i*(long)K + L <u64 R could cause incorrect execution.\n@@ -1299,2 +1275,2 @@\n-      \/\/ i*K <u64 (long)max_jint + 1\n-      \/\/ which implies i*K + L <u64 (long)max_jint + 1 + L\n+      \/\/ (int)i*K <u64 (long)max_jint + 1\n+      \/\/ which implies (int)i*K + L <u64 (long)max_jint + 1 + L\n@@ -1305,1 +1281,1 @@\n-      \/\/ Note, there are K,L where i*K overflows and\n+      \/\/ Note, there are also K,L where i*K overflows and\n@@ -1309,1 +1285,2 @@\n-      \/\/ (but not incorrect execution) for unlikely corner cases with overflow\n+      \/\/ (but not incorrect execution) for unlikely corner cases with overflow.\n+      \/\/ If this causes problems in practice, we could maybe direct excution to a post-loop, instead of deoptimizing.\n@@ -1319,2 +1296,0 @@\n-    Node* Z_2 = new ConvI2LNode(inner_iters_actual_int, TypeLong::LONG);\n-    register_new_node(Z_2, entry_control);\n@@ -1325,10 +1300,19 @@\n-    \/\/   j*K + L_2 <u64 R    where L_2 = C*K+L\n-    Node* L_2 = new MulLNode(C, K);\n-    register_new_node(L_2, entry_control);\n-    L_2 = new AddLNode(L_2, L);\n-    register_new_node(L_2, entry_control);\n-\n-    \/\/ Compute endpoints of the range of values j*K.\n-    \/\/  Q_min = (j=0)*K + L_2;  Q_max = (j=Z_2)*K + L_2\n-    Node* Q_min = L_2;\n-    Node* Q_max = new MulLNode(Z_2, K);\n+    \/\/   j*K + Q <u64 R    where Q = Q_first = C*K+L\n+    Node* Q_first = new MulLNode(C, K);\n+    register_new_node(Q_first, entry_control);\n+    Q_first = new AddLNode(Q_first, L);\n+    register_new_node(Q_first, entry_control);\n+\n+    \/\/ Compute endpoints of the range of values j*K + Q.\n+    \/\/  Q_min = (j=0)*K + Q;  Q_max = (j=B_2)*K + Q\n+    Node* Q_min = Q_first;\n+\n+    \/\/ Compute the exact ending value B_2 (which is really A_2 if S < 0)\n+    Node* B_2 = new LoopLimitNode(this->C, int_zero, inner_iters_actual_int, int_stride);\n+    register_new_node(B_2, entry_control);\n+    B_2 = new SubINode(B_2, int_stride);\n+    register_new_node(B_2, entry_control);\n+    B_2 = new ConvI2LNode(B_2);\n+    register_new_node(B_2, entry_control);\n+\n+    Node* Q_max = new MulLNode(B_2, K);\n@@ -1336,1 +1320,1 @@\n-    Q_max = new AddLNode(Q_max, L_2);\n+    Q_max = new AddLNode(Q_max, Q_first);\n@@ -1339,0 +1323,5 @@\n+    if (scale * stride_con < 0) {\n+      swap(Q_min, Q_max);\n+    }\n+    \/\/ Now, mathematically, Q_max > Q_min, and they are close enough so that (Q_max-Q_min) fits in 32 bits.\n+\n@@ -1346,0 +1335,1 @@\n+    \/\/ (This could also be coded bitwise as L_clamp = Q_min & ~(Q_min>>63).)\n@@ -1347,2 +1337,8 @@\n-    \/\/ H_clamp = Q_max < Q_min ? R : Q_max\n-    Node* Q_max_cmp = new CmpLNode(Q_max, Q_min);\n+    Node* Q_max_plus_one = new AddLNode(Q_max, long_one);\n+    register_new_node(Q_max_plus_one, entry_control);\n+\n+    \/\/ H_clamp = Q_max+1 < Q_min ? max_jlong : Q_max+1\n+    \/\/ (Because Q_min and Q_max are close, the overflow check could also be encoded as Q_max+1 < 0 & Q_min >= 0.)\n+    Node* max_jlong_long = _igvn.longcon(max_jlong);\n+    set_ctrl(max_jlong_long, this->C->root());\n+    Node* Q_max_cmp = new CmpLNode(Q_max_plus_one, Q_min);\n@@ -1352,1 +1348,1 @@\n-    Node* H_clamp = new CMoveLNode(Q_max_bool, Q_max, R, TypeLong::LONG);\n+    Node* H_clamp = new CMoveLNode(Q_max_bool, Q_max_plus_one, max_jlong_long, TypeLong::LONG);\n@@ -1354,0 +1350,1 @@\n+    \/\/ (This could also be coded bitwise as H_clamp = ((Q_max+1)<<1 | M)>>>1 where M = (Q_max+1)>>63 & ~Q_min>>63.)\n@@ -1356,2 +1353,4 @@\n-    \/\/ that is: R_2 = clamp(R, L_clamp, H_clamp) if Q_min < 0\n-    \/\/ or:      R_2 = clamp(R, L_clamp, H_clamp) - Q_min if Q_min > 0\n+    \/\/ that is:  R_2 = clamp(R, L_clamp=0, H_clamp=Q_max)      if Q_min < 0\n+    \/\/ or else:  R_2 = clamp(R, L_clamp,   H_clamp) - Q_min    if Q_min >= 0\n+    \/\/ and also: R_2 = clamp(R, L_clamp,   Q_max+1) - L_clamp  if Q_min < Q_max+1 (no overflow)\n+    \/\/ or else:  R_2 = clamp(R, L_clamp, *no limit*)- L_clamp  if Q_max+1 < Q_min (overflow)\n@@ -1364,7 +1363,8 @@\n-    \/\/ Q = Q_min - L_clamp\n-    \/\/ that is: Q = Q_min - 0 if Q_min < 0\n-    \/\/ or:      Q = Q_min - Q_min = 0 if Q_min > 0\n-    Node* Q = new SubLNode(Q_min, L_clamp);\n-    register_new_node(Q, entry_control);\n-    Q = new ConvL2INode(Q, TypeInt::INT);\n-    register_new_node(Q, entry_control);\n+    \/\/ L_2 = Q_first - L_clamp\n+    \/\/ We are subtracting L_clamp from both sides of the <u32 comparison.\n+    \/\/ If S*K>0, then Q_first == 0 and the R.C. expression at -L_clamp and steps upward to Q_max-L_clamp.\n+    \/\/ If S*K<0, then Q_first != 0 and the R.C. expression starts high and steps downward to Q_min-L_clamp.\n+    Node* L_2 = new SubLNode(Q_first, L_clamp);\n+    register_new_node(L_2, entry_control);\n+    L_2 = new ConvL2INode(L_2, TypeInt::INT);\n+    register_new_node(L_2, entry_control);\n@@ -1372,1 +1372,5 @@\n-    \/\/ Transform the range check\n+    \/\/ Transform the range check using the computed values L_2\/R_2\n+    \/\/ from:   i*K + L   <u64 R\n+    \/\/ to:     j*K + L_2 <u32 R_2\n+    \/\/ that is:\n+    \/\/   (j*K + Q_first) - L_clamp <u32 clamp(R, L_clamp, H_clamp) - L_clamp\n@@ -1377,1 +1381,1 @@\n-    Node* scaled_iv_plus_offset = scaled_iv_plus_offset = new AddINode(scaled_iv, Q);\n+    Node* scaled_iv_plus_offset = scaled_iv_plus_offset = new AddINode(scaled_iv, L_2);\n@@ -1624,10 +1628,0 @@\n-  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint &&\n-          ((iv_bt == T_INT && LoopStripMiningIter != 0) ||\n-           iv_bt == T_LONG)) {\n-    \/\/ Leaving the safepoint on the backedge and creating a\n-    \/\/ CountedLoop will confuse optimizations. We can't move the\n-    \/\/ safepoint around because its jvm state wouldn't match a new\n-    \/\/ location. Give up on that loop.\n-    return false;\n-  }\n-\n@@ -1862,0 +1856,31 @@\n+  Node* sfpt = NULL;\n+  if (loop->_child == NULL) {\n+    sfpt = find_safepoint(back_control, x, loop);\n+  } else {\n+    sfpt = iff->in(0);\n+    if (sfpt->Opcode() != Op_SafePoint) {\n+      sfpt = NULL;\n+    }\n+  }\n+\n+  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n+    Node* backedge_sfpt = x->in(LoopNode::LoopBackControl);\n+    if (((iv_bt == T_INT && LoopStripMiningIter != 0) ||\n+         iv_bt == T_LONG) &&\n+        sfpt == NULL) {\n+      \/\/ Leaving the safepoint on the backedge and creating a\n+      \/\/ CountedLoop will confuse optimizations. We can't move the\n+      \/\/ safepoint around because its jvm state wouldn't match a new\n+      \/\/ location. Give up on that loop.\n+      return false;\n+    }\n+    if (is_deleteable_safept(backedge_sfpt)) {\n+      lazy_replace(backedge_sfpt, iftrue);\n+      if (loop->_safepts != NULL) {\n+        loop->_safepts->yank(backedge_sfpt);\n+      }\n+      loop->_tail = iftrue;\n+    }\n+  }\n+\n+\n@@ -1900,12 +1925,0 @@\n-  if (iv_bt == T_INT && LoopStripMiningIter == 0) {\n-    \/\/ Check for SafePoint on backedge and remove\n-    Node *sfpt = x->in(LoopNode::LoopBackControl);\n-    if (sfpt->Opcode() == Op_SafePoint && is_deleteable_safept(sfpt)) {\n-      lazy_replace( sfpt, iftrue );\n-      if (loop->_safepts != NULL) {\n-        loop->_safepts->yank(sfpt);\n-      }\n-      loop->_tail = iftrue;\n-    }\n-  }\n-\n@@ -1983,2 +1996,0 @@\n-  Node *sfpt2 = le->in(0);\n-\n@@ -1987,1 +1998,0 @@\n-                         LoopStripMiningIter > 1 &&\n@@ -1989,1 +1999,1 @@\n-                         sfpt2->Opcode() == Op_SafePoint &&\n+                         sfpt != NULL &&\n@@ -2015,1 +2025,1 @@\n-    if (sfpt2->Opcode() == Op_SafePoint && (LoopStripMiningIter != 0 || is_deleteable_safept(sfpt2))) {\n+    if (sfpt != NULL && (strip_mine_loop || is_deleteable_safept(sfpt))) {\n@@ -2018,3 +2028,3 @@\n-        Node* sfpt = sfpt2->clone();\n-        sfpt->set_req(0, iffalse);\n-        outer_le->set_req(0, sfpt);\n+        Node* sfpt_clone = sfpt->clone();\n+        sfpt_clone->set_req(0, iffalse);\n+        outer_le->set_req(0, sfpt_clone);\n@@ -2022,1 +2032,1 @@\n-        Node* polladdr = sfpt->in(TypeFunc::Parms);\n+        Node* polladdr = sfpt_clone->in(TypeFunc::Parms);\n@@ -2029,1 +2039,1 @@\n-          sfpt->set_req(TypeFunc::Parms, new_polladdr);\n+          sfpt_clone->set_req(TypeFunc::Parms, new_polladdr);\n@@ -2033,2 +2043,2 @@\n-        register_control(sfpt, outer_ilt, iffalse, body_populated);\n-        set_idom(outer_le, sfpt, dom_depth(sfpt));\n+        register_control(sfpt_clone, outer_ilt, iffalse, body_populated);\n+        set_idom(outer_le, sfpt_clone, dom_depth(sfpt_clone));\n@@ -2036,1 +2046,1 @@\n-      lazy_replace( sfpt2, sfpt2->in(TypeFunc::Control));\n+      lazy_replace(sfpt, sfpt->in(TypeFunc::Control));\n@@ -2038,1 +2048,1 @@\n-        loop->_safepts->yank(sfpt2);\n+        loop->_safepts->yank(sfpt);\n@@ -2557,0 +2567,117 @@\n+void OuterStripMinedLoopNode::fix_sunk_stores(CountedLoopEndNode* inner_cle, LoopNode* inner_cl, PhaseIterGVN* igvn,\n+                                              PhaseIdealLoop* iloop) {\n+  Node* cle_out = inner_cle->proj_out(false);\n+  Node* cle_tail = inner_cle->proj_out(true);\n+  if (cle_out->outcnt() > 1) {\n+    \/\/ Look for chains of stores that were sunk\n+    \/\/ out of the inner loop and are in the outer loop\n+    for (DUIterator_Fast imax, i = cle_out->fast_outs(imax); i < imax; i++) {\n+      Node* u = cle_out->fast_out(i);\n+      if (u->is_Store()) {\n+        int alias_idx = igvn->C->get_alias_index(u->adr_type());\n+        Node* first = u;\n+        for (;;) {\n+          Node* next = first->in(MemNode::Memory);\n+          if (!next->is_Store() || next->in(0) != cle_out) {\n+            break;\n+          }\n+          assert(igvn->C->get_alias_index(next->adr_type()) == alias_idx, \"\");\n+          first = next;\n+        }\n+        Node* last = u;\n+        for (;;) {\n+          Node* next = NULL;\n+          for (DUIterator_Fast jmax, j = last->fast_outs(jmax); j < jmax; j++) {\n+            Node* uu = last->fast_out(j);\n+            if (uu->is_Store() && uu->in(0) == cle_out) {\n+              assert(next == NULL, \"only one in the outer loop\");\n+              next = uu;\n+              assert(igvn->C->get_alias_index(next->adr_type()) == alias_idx, \"\");\n+            }\n+          }\n+          if (next == NULL) {\n+            break;\n+          }\n+          last = next;\n+        }\n+        Node* phi = NULL;\n+        for (DUIterator_Fast jmax, j = inner_cl->fast_outs(jmax); j < jmax; j++) {\n+          Node* uu = inner_cl->fast_out(j);\n+          if (uu->is_Phi()) {\n+            Node* be = uu->in(LoopNode::LoopBackControl);\n+            if (be->is_Store() && be->in(0) == inner_cl->in(LoopNode::LoopBackControl)) {\n+              assert(igvn->C->get_alias_index(uu->adr_type()) != alias_idx && igvn->C->get_alias_index(uu->adr_type()) != Compile::AliasIdxBot, \"unexpected store\");\n+            }\n+            if (be == last || be == first->in(MemNode::Memory)) {\n+              assert(igvn->C->get_alias_index(uu->adr_type()) == alias_idx || igvn->C->get_alias_index(uu->adr_type()) == Compile::AliasIdxBot, \"unexpected alias\");\n+              assert(phi == NULL, \"only one phi\");\n+              phi = uu;\n+            }\n+          }\n+        }\n+#ifdef ASSERT\n+        for (DUIterator_Fast jmax, j = inner_cl->fast_outs(jmax); j < jmax; j++) {\n+          Node* uu = inner_cl->fast_out(j);\n+          if (uu->is_Phi() && uu->bottom_type() == Type::MEMORY) {\n+            if (uu->adr_type() == igvn->C->get_adr_type(igvn->C->get_alias_index(u->adr_type()))) {\n+              assert(phi == uu, \"what's that phi?\");\n+            } else if (uu->adr_type() == TypePtr::BOTTOM) {\n+              Node* n = uu->in(LoopNode::LoopBackControl);\n+              uint limit = igvn->C->live_nodes();\n+              uint i = 0;\n+              while (n != uu) {\n+                i++;\n+                assert(i < limit, \"infinite loop\");\n+                if (n->is_Proj()) {\n+                  n = n->in(0);\n+                } else if (n->is_SafePoint() || n->is_MemBar()) {\n+                  n = n->in(TypeFunc::Memory);\n+                } else if (n->is_Phi()) {\n+                  n = n->in(1);\n+                } else if (n->is_MergeMem()) {\n+                  n = n->as_MergeMem()->memory_at(igvn->C->get_alias_index(u->adr_type()));\n+                } else if (n->is_Store() || n->is_LoadStore() || n->is_ClearArray()) {\n+                  n = n->in(MemNode::Memory);\n+                } else {\n+                  n->dump();\n+                  ShouldNotReachHere();\n+                }\n+              }\n+            }\n+          }\n+        }\n+#endif\n+        if (phi == NULL) {\n+          \/\/ If an entire chains was sunk, the\n+          \/\/ inner loop has no phi for that memory\n+          \/\/ slice, create one for the outer loop\n+          phi = PhiNode::make(inner_cl, first->in(MemNode::Memory), Type::MEMORY,\n+                              igvn->C->get_adr_type(igvn->C->get_alias_index(u->adr_type())));\n+          phi->set_req(LoopNode::LoopBackControl, last);\n+          phi = register_new_node(phi, inner_cl, igvn, iloop);\n+          igvn->replace_input_of(first, MemNode::Memory, phi);\n+        } else {\n+          \/\/ Or fix the outer loop fix to include\n+          \/\/ that chain of stores.\n+          Node* be = phi->in(LoopNode::LoopBackControl);\n+          assert(!(be->is_Store() && be->in(0) == inner_cl->in(LoopNode::LoopBackControl)), \"store on the backedge + sunk stores: unsupported\");\n+          if (be == first->in(MemNode::Memory)) {\n+            if (be == phi->in(LoopNode::LoopBackControl)) {\n+              igvn->replace_input_of(phi, LoopNode::LoopBackControl, last);\n+            } else {\n+              igvn->replace_input_of(be, MemNode::Memory, last);\n+            }\n+          } else {\n+#ifdef ASSERT\n+            if (be == phi->in(LoopNode::LoopBackControl)) {\n+              assert(phi->in(LoopNode::LoopBackControl) == last, \"\");\n+            } else {\n+              assert(be->in(MemNode::Memory) == last, \"\");\n+            }\n+#endif\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n@@ -2564,0 +2691,8 @@\n+  if (LoopStripMiningIter == 0) {\n+    remove_outer_loop_and_safepoint(igvn);\n+    return;\n+  }\n+  if (LoopStripMiningIter == 1) {\n+    transform_to_counted_loop(igvn, NULL);\n+    return;\n+  }\n@@ -2583,5 +2718,1 @@\n-    Node* outer_sfpt = outer_safepoint();\n-    Node* outer_out = outer_loop_exit();\n-    igvn->replace_node(outer_out, outer_sfpt->in(0));\n-    igvn->replace_input_of(outer_sfpt, 0, igvn->C->top());\n-    inner_cl->clear_strip_mined();\n+    remove_outer_loop_and_safepoint(igvn);\n@@ -2668,115 +2799,0 @@\n-  Node* cle_out = inner_cle->proj_out(false);\n-  if (cle_out->outcnt() > 1) {\n-    \/\/ Look for chains of stores that were sunk\n-    \/\/ out of the inner loop and are in the outer loop\n-    for (DUIterator_Fast imax, i = cle_out->fast_outs(imax); i < imax; i++) {\n-      Node* u = cle_out->fast_out(i);\n-      if (u->is_Store()) {\n-        Node* first = u;\n-        for(;;) {\n-          Node* next = first->in(MemNode::Memory);\n-          if (!next->is_Store() || next->in(0) != cle_out) {\n-            break;\n-          }\n-          first = next;\n-        }\n-        Node* last = u;\n-        for(;;) {\n-          Node* next = NULL;\n-          for (DUIterator_Fast jmax, j = last->fast_outs(jmax); j < jmax; j++) {\n-            Node* uu = last->fast_out(j);\n-            if (uu->is_Store() && uu->in(0) == cle_out) {\n-              assert(next == NULL, \"only one in the outer loop\");\n-              next = uu;\n-            }\n-          }\n-          if (next == NULL) {\n-            break;\n-          }\n-          last = next;\n-        }\n-        Node* phi = NULL;\n-        for (DUIterator_Fast jmax, j = fast_outs(jmax); j < jmax; j++) {\n-          Node* uu = fast_out(j);\n-          if (uu->is_Phi()) {\n-            Node* be = uu->in(LoopNode::LoopBackControl);\n-            if (be->is_Store() && old_new[be->_idx] != NULL) {\n-              assert(false, \"store on the backedge + sunk stores: unsupported\");\n-              \/\/ drop outer loop\n-              IfNode* outer_le = outer_loop_end();\n-              Node* iff = igvn->transform(new IfNode(outer_le->in(0), outer_le->in(1), outer_le->_prob, outer_le->_fcnt));\n-              igvn->replace_node(outer_le, iff);\n-              inner_cl->clear_strip_mined();\n-              return;\n-            }\n-            if (be == last || be == first->in(MemNode::Memory)) {\n-              assert(phi == NULL, \"only one phi\");\n-              phi = uu;\n-            }\n-          }\n-        }\n-#ifdef ASSERT\n-        for (DUIterator_Fast jmax, j = fast_outs(jmax); j < jmax; j++) {\n-          Node* uu = fast_out(j);\n-          if (uu->is_Phi() && uu->bottom_type() == Type::MEMORY) {\n-            if (uu->adr_type() == igvn->C->get_adr_type(igvn->C->get_alias_index(u->adr_type()))) {\n-              assert(phi == uu, \"what's that phi?\");\n-            } else if (uu->adr_type() == TypePtr::BOTTOM) {\n-              Node* n = uu->in(LoopNode::LoopBackControl);\n-              uint limit = igvn->C->live_nodes();\n-              uint i = 0;\n-              while (n != uu) {\n-                i++;\n-                assert(i < limit, \"infinite loop\");\n-                if (n->is_Proj()) {\n-                  n = n->in(0);\n-                } else if (n->is_SafePoint() || n->is_MemBar()) {\n-                  n = n->in(TypeFunc::Memory);\n-                } else if (n->is_Phi()) {\n-                  n = n->in(1);\n-                } else if (n->is_MergeMem()) {\n-                  n = n->as_MergeMem()->memory_at(igvn->C->get_alias_index(u->adr_type()));\n-                } else if (n->is_Store() || n->is_LoadStore() || n->is_ClearArray()) {\n-                  n = n->in(MemNode::Memory);\n-                } else {\n-                  n->dump();\n-                  ShouldNotReachHere();\n-                }\n-              }\n-            }\n-          }\n-        }\n-#endif\n-        if (phi == NULL) {\n-          \/\/ If the an entire chains was sunk, the\n-          \/\/ inner loop has no phi for that memory\n-          \/\/ slice, create one for the outer loop\n-          phi = PhiNode::make(this, first->in(MemNode::Memory), Type::MEMORY,\n-                              igvn->C->get_adr_type(igvn->C->get_alias_index(u->adr_type())));\n-          phi->set_req(LoopNode::LoopBackControl, last);\n-          phi = igvn->transform(phi);\n-          igvn->replace_input_of(first, MemNode::Memory, phi);\n-        } else {\n-          \/\/ Or fix the outer loop fix to include\n-          \/\/ that chain of stores.\n-          Node* be = phi->in(LoopNode::LoopBackControl);\n-          assert(!(be->is_Store() && old_new[be->_idx] != NULL), \"store on the backedge + sunk stores: unsupported\");\n-          if (be == first->in(MemNode::Memory)) {\n-            if (be == phi->in(LoopNode::LoopBackControl)) {\n-              igvn->replace_input_of(phi, LoopNode::LoopBackControl, last);\n-            } else {\n-              igvn->replace_input_of(be, MemNode::Memory, last);\n-            }\n-          } else {\n-#ifdef ASSERT\n-            if (be == phi->in(LoopNode::LoopBackControl)) {\n-              assert(phi->in(LoopNode::LoopBackControl) == last, \"\");\n-            } else {\n-              assert(be->in(MemNode::Memory) == last, \"\");\n-            }\n-#endif\n-          }\n-        }\n-      }\n-    }\n-  }\n@@ -2831,0 +2847,90 @@\n+void OuterStripMinedLoopNode::transform_to_counted_loop(PhaseIterGVN* igvn, PhaseIdealLoop* iloop) {\n+  CountedLoopNode* inner_cl = unique_ctrl_out()->as_CountedLoop();\n+  CountedLoopEndNode* cle = inner_cl->loopexit();\n+  Node* inner_test = cle->in(1);\n+  IfNode* outer_le = outer_loop_end();\n+  CountedLoopEndNode* inner_cle = inner_cl->loopexit();\n+  Node* safepoint = outer_safepoint();\n+\n+  fix_sunk_stores(inner_cle, inner_cl, igvn, iloop);\n+\n+  \/\/ make counted loop exit test always fail\n+  ConINode* zero = igvn->intcon(0);\n+  if (iloop != NULL) {\n+    iloop->set_ctrl(zero, igvn->C->root());\n+  }\n+  igvn->replace_input_of(cle, 1, zero);\n+  \/\/ replace outer loop end with CountedLoopEndNode with formers' CLE's exit test\n+  Node* new_end = new CountedLoopEndNode(outer_le->in(0), inner_test, cle->_prob, cle->_fcnt);\n+  register_control(new_end, inner_cl, outer_le->in(0), igvn, iloop);\n+  if (iloop == NULL) {\n+    igvn->replace_node(outer_le, new_end);\n+  } else {\n+    iloop->lazy_replace(outer_le, new_end);\n+  }\n+  \/\/ the backedge of the inner loop must be rewired to the new loop end\n+  Node* backedge = cle->proj_out(true);\n+  igvn->replace_input_of(backedge, 0, new_end);\n+  if (iloop != NULL) {\n+    iloop->set_idom(backedge, new_end, iloop->dom_depth(new_end) + 1);\n+  }\n+  \/\/ make the outer loop go away\n+  igvn->replace_input_of(in(LoopBackControl), 0, igvn->C->top());\n+  igvn->replace_input_of(this, LoopBackControl, igvn->C->top());\n+  inner_cl->clear_strip_mined();\n+  if (iloop != NULL) {\n+    Unique_Node_List wq;\n+    wq.push(safepoint);\n+\n+    IdealLoopTree* outer_loop_ilt = iloop->get_loop(this);\n+    IdealLoopTree* loop = iloop->get_loop(inner_cl);\n+\n+    for (uint i = 0; i < wq.size(); i++) {\n+      Node* n = wq.at(i);\n+      for (uint j = 0; j < n->req(); ++j) {\n+        Node* in = n->in(j);\n+        if (in == NULL || in->is_CFG()) {\n+          continue;\n+        }\n+        if (iloop->get_loop(iloop->get_ctrl(in)) != outer_loop_ilt) {\n+          continue;\n+        }\n+        assert(!loop->_body.contains(in), \"\");\n+        loop->_body.push(in);\n+        wq.push(in);\n+      }\n+    }\n+    iloop->set_loop(safepoint, loop);\n+    loop->_body.push(safepoint);\n+    iloop->set_loop(safepoint->in(0), loop);\n+    loop->_body.push(safepoint->in(0));\n+    outer_loop_ilt->_tail = igvn->C->top();\n+  }\n+}\n+\n+void OuterStripMinedLoopNode::remove_outer_loop_and_safepoint(PhaseIterGVN* igvn) const {\n+  CountedLoopNode* inner_cl = unique_ctrl_out()->as_CountedLoop();\n+  Node* outer_sfpt = outer_safepoint();\n+  Node* outer_out = outer_loop_exit();\n+  igvn->replace_node(outer_out, outer_sfpt->in(0));\n+  igvn->replace_input_of(outer_sfpt, 0, igvn->C->top());\n+  inner_cl->clear_strip_mined();\n+}\n+\n+Node* OuterStripMinedLoopNode::register_new_node(Node* node, LoopNode* ctrl, PhaseIterGVN* igvn, PhaseIdealLoop* iloop) {\n+  if (iloop == NULL) {\n+    return igvn->transform(node);\n+  }\n+  iloop->register_new_node(node, ctrl);\n+  return node;\n+}\n+\n+Node* OuterStripMinedLoopNode::register_control(Node* node, Node* loop, Node* idom, PhaseIterGVN* igvn,\n+                                                PhaseIdealLoop* iloop) {\n+  if (iloop == NULL) {\n+    return igvn->transform(node);\n+  }\n+  iloop->register_control(node, iloop->get_loop(loop), idom);\n+  return node;\n+}\n+\n@@ -3666,1 +3772,1 @@\n-    if (LoopStripMiningIter == 0 || (LoopStripMiningIter > 1 && _child == NULL)) {\n+    if (LoopStripMiningIter == 0 || _head->as_CountedLoop()->is_strip_mined()) {\n@@ -4092,1 +4198,1 @@\n-void PhaseIdealLoop::build_and_optimize(LoopOptsMode mode) {\n+void PhaseIdealLoop::build_and_optimize() {\n@@ -4095,2 +4201,2 @@\n-  bool do_split_ifs = (mode == LoopOptsDefault);\n-  bool skip_loop_opts = (mode == LoopOptsNone);\n+  bool do_split_ifs = (_mode == LoopOptsDefault);\n+  bool skip_loop_opts = (_mode == LoopOptsNone);\n@@ -4167,1 +4273,1 @@\n-    !bs->is_gc_specific_loop_opts_pass(mode);\n+    !bs->is_gc_specific_loop_opts_pass(_mode);\n@@ -4169,1 +4275,1 @@\n-  bool strip_mined_loops_expanded = bs->strip_mined_loops_expanded(mode);\n+  bool strip_mined_loops_expanded = bs->strip_mined_loops_expanded(_mode);\n@@ -4261,1 +4367,1 @@\n-    assert(C->unique() == unique, \"verification mode made Nodes? ? ?\");\n+    assert(C->unique() == unique, \"verification _mode made Nodes? ? ?\");\n@@ -4291,2 +4397,2 @@\n-    \/\/ Check to see if the verify mode is broken\n-    assert(C->unique() == unique, \"non-optimize mode made Nodes? ? ?\");\n+    \/\/ Check to see if the verify _mode is broken\n+    assert(C->unique() == unique, \"non-optimize _mode made Nodes? ? ?\");\n@@ -4306,1 +4412,1 @@\n-  if (mode == LoopOptsMaxUnroll) {\n+  if (_mode == LoopOptsMaxUnroll) {\n@@ -4327,1 +4433,1 @@\n-  if (bs->optimize_loops(this, mode, visited, nstack, worklist)) {\n+  if (bs->optimize_loops(this, _mode, visited, nstack, worklist)) {\n@@ -5672,1 +5778,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n@@ -5758,1 +5864,1 @@\n-  if (least != early) {\n+  if (least != early && !BarrierSet::barrier_set()->barrier_set_c2()->is_gc_specific_loop_opts_pass(_mode)) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":429,"deletions":323,"binary":false,"changes":752,"status":"modified"},{"patch":"@@ -549,1 +549,2 @@\n-  CountedLoopNode* inner_loop() const;\n+  static void fix_sunk_stores(CountedLoopEndNode* inner_cle, LoopNode* inner_cl, PhaseIterGVN* igvn, PhaseIdealLoop* iloop);\n+\n@@ -565,0 +566,9 @@\n+\n+  void remove_outer_loop_and_safepoint(PhaseIterGVN* igvn) const;\n+\n+  void transform_to_counted_loop(PhaseIterGVN* igvn, PhaseIdealLoop* iloop);\n+\n+  static Node* register_new_node(Node* node, LoopNode* ctrl, PhaseIterGVN* igvn, PhaseIdealLoop* iloop);\n+\n+  Node* register_control(Node* node, Node* loop, Node* idom, PhaseIterGVN* igvn,\n+                         PhaseIdealLoop* iloop);\n@@ -1045,0 +1055,1 @@\n+  LoopOptsMode _mode;\n@@ -1047,1 +1058,1 @@\n-  void build_and_optimize(LoopOptsMode mode);\n+  void build_and_optimize();\n@@ -1058,0 +1069,1 @@\n+    _mode(mode),\n@@ -1060,1 +1072,1 @@\n-    build_and_optimize(mode);\n+    build_and_optimize();\n@@ -1071,0 +1083,1 @@\n+    _mode(LoopOptsVerify),\n@@ -1072,1 +1085,1 @@\n-    build_and_optimize(LoopOptsVerify);\n+    build_and_optimize();\n@@ -1265,1 +1278,1 @@\n-  bool is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt, bool* converted);\n+  bool is_scaled_iv(Node* exp, Node* iv, BasicType bt, jlong* p_scale, bool* p_short_scale, int depth = 0);\n@@ -1270,1 +1283,1 @@\n-  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* converted = NULL, int depth = 0);\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale = NULL, int depth = 0);\n@@ -1273,1 +1286,1 @@\n-    if (is_scaled_iv_plus_offset(exp, iv, &long_scale, p_offset, T_INT)) {\n+    if (is_scaled_iv_plus_offset(exp, iv, T_INT, &long_scale, p_offset)) {\n@@ -1282,0 +1295,6 @@\n+  \/\/ Helper for finding more complex matches to is_scaled_iv_plus_offset.\n+  bool is_scaled_iv_plus_extra_offset(Node* exp1, Node* offset2, Node* iv,\n+                                      BasicType bt,\n+                                      jlong* p_scale, Node** p_offset,\n+                                      bool* p_short_scale, int depth);\n+\n@@ -1656,2 +1675,0 @@\n-  void strip_mined_nest_back_to_counted_loop(IdealLoopTree* loop, const BaseCountedLoopNode* head, Node* back_control,\n-                                             IfNode*&exit_test, SafePointNode*&safepoint);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1069,1 +1069,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n@@ -2255,1 +2255,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1165,1 +1165,6 @@\n-    guarantee(t != NULL, \"must be con\");\n+    guarantee(t != NULL && t->is_con(), \"must be con\");\n+    return t->get_con_as_long(bt);\n+  }\n+  jlong find_integer_as_long(BasicType bt, jlong value_if_unknown) const {\n+    const TypeInteger* t = find_integer_type(bt);\n+    if (t == NULL || !t->is_con())  return value_if_unknown;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1468,0 +1468,6 @@\n+  \/\/ ret_pc will have been loaded from the stack, so for AArch64 will be signed.\n+  \/\/ This needs authenticating, but to do that here requires the fp of the previous frame.\n+  \/\/ A better way of doing it would be authenticate in the caller by adding a\n+  \/\/ AuthPAuthNode and using it in GraphKit::gen_stub. For now, just strip it.\n+  AARCH64_PORT_ONLY(ret_pc = pauth_strip_pointer(ret_pc));\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  if (in(1)->Opcode() == Op_AddI) {\n+  if (in(1)->Opcode() == Op_AddI || in(1)->Opcode() == Op_AddL) {\n@@ -420,0 +420,4 @@\n+  \/\/ Convert \"(x-y) - x\" into \"-y\"\n+  if (op1 == Op_SubL && in1->in(1) == in2) {\n+    return new SubLNode(phase->makecon(TypeLong::ZERO), in1->in(2));\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -565,0 +565,1 @@\n+\n@@ -568,3 +569,1 @@\n-    (thread = JavaThread::thread_from_jni_environment(trace->env_id)) == NULL ||\n-    thread->is_exiting()) {\n-\n+      (thread = JavaThread::thread_from_jni_environment(trace->env_id))->is_exiting()) {\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-JVM_ENTRY_NO_ENV(jboolean, JVM_IsUseContainerSupport(void))\n+JVM_LEAF(jboolean, JVM_IsUseContainerSupport(void))\n@@ -693,1 +693,1 @@\n-JVM_ENTRY(jboolean, JVM_IsFinalizationEnabled(JNIEnv * env))\n+JVM_LEAF(jboolean, JVM_IsFinalizationEnabled(JNIEnv * env))\n@@ -2868,0 +2868,20 @@\n+#if INCLUDE_CDS\n+  if (DumpSharedSpaces) {\n+    \/\/ During java -Xshare:dump, if we allow multiple Java threads to\n+    \/\/ execute in parallel, symbols and classes may be loaded in\n+    \/\/ random orders which will make the resulting CDS archive\n+    \/\/ non-deterministic.\n+    \/\/\n+    \/\/ Lucikly, during java -Xshare:dump, it's important to run only\n+    \/\/ the code in the main Java thread (which is NOT started here) that\n+    \/\/ creates the module graph, etc. It's safe to not start the other\n+    \/\/ threads which are launched by class static initializers\n+    \/\/ (ReferenceHandler, FinalizerThread and CleanerImpl).\n+    if (log_is_enabled(Info, cds)) {\n+      ResourceMark rm;\n+      oop t = JNIHandles::resolve_non_null(jthread);\n+      log_info(cds)(\"JVM_StartThread() ignored: %s\", t->klass()->external_name());\n+    }\n+    return;\n+  }\n+#endif\n@@ -3038,1 +3058,1 @@\n-JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))\n+JVM_LEAF(void, JVM_Yield(JNIEnv *env, jclass threadClass))\n@@ -3646,1 +3666,1 @@\n-JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))\n+JVM_LEAF(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))\n@@ -3650,1 +3670,1 @@\n-JVM_ENTRY(jboolean, JVM_IsSharingEnabled(JNIEnv* env))\n+JVM_LEAF(jboolean, JVM_IsSharingEnabled(JNIEnv* env))\n@@ -3676,1 +3696,1 @@\n-JVM_ENTRY(jboolean, JVM_IsDumpingClassList(JNIEnv *env))\n+JVM_LEAF(jboolean, JVM_IsDumpingClassList(JNIEnv *env))\n@@ -3785,1 +3805,1 @@\n-JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))\n+JVM_LEAF(void*, JVM_GetManagement(jint version))\n@@ -3874,1 +3894,1 @@\n-JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))\n+JVM_LEAF(jint, JVM_FindSignal(const char *name))\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,5 +201,1 @@\n-      #if _MSC_VER == 1600\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 10.0 (VS2010)\"\n-      #elif _MSC_VER == 1700\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 11.0 (VS2012)\"\n-      #elif _MSC_VER == 1800\n+      #if _MSC_VER == 1800\n@@ -241,0 +237,4 @@\n+      #elif _MSC_VER == 1930\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.0 (VS2022)\"\n+      #elif _MSC_VER == 1931\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.1 (VS2022)\"\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -59,0 +60,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -66,0 +68,1 @@\n+#include <limits>\n@@ -541,0 +544,2 @@\n+  { \"UseContainerCpuShares\",        JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n+  { \"PreferContainerQuotaForCPUCount\", JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n@@ -745,3 +750,13 @@\n-\/\/ Parses a size specification string.\n-bool Arguments::atojulong(const char *s, julong* result) {\n-  julong n = 0;\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ signed 32-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  \/\/ Don't use strtol -- on 64-bit builds, \"long\" could be either 32- or 64-bits\n+  \/\/ so the range tests could be tautological and might cause compiler warnings.\n+  STATIC_ASSERT(sizeof(long long) >= 8); \/\/ C++ specification\n+  errno = 0; \/\/ errno is thread safe\n+  long long v = strtoll(s, endptr, base);\n+  if (errno != 0 || v < min_jint || v > max_jint) {\n+    return false;\n+  }\n+  *result = static_cast<T>(v);\n+  return true;\n+}\n@@ -749,2 +764,3 @@\n-  \/\/ First char must be a digit. Don't allow negative numbers or leading spaces.\n-  if (!isdigit(*s)) {\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ unsigned 32-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  if (s[0] == '-') {\n@@ -753,0 +769,10 @@\n+  \/\/ Don't use strtoul -- same reason as above.\n+  STATIC_ASSERT(sizeof(unsigned long long) >= 8); \/\/ C++ specification\n+  errno = 0; \/\/ errno is thread safe\n+  unsigned long long v = strtoull(s, endptr, base);\n+  if (errno != 0 || v > max_juint) {\n+    return false;\n+  }\n+  *result = static_cast<T>(v);\n+  return true;\n+}\n@@ -754,1 +780,45 @@\n-  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'));\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ signed 64-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  errno = 0; \/\/ errno is thread safe\n+  *result = strtoll(s, endptr, base);\n+  return errno == 0;\n+}\n+\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ unsigned 64-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  if (s[0] == '-') {\n+    return false;\n+  }\n+  errno = 0; \/\/ errno is thread safe\n+  *result = strtoull(s, endptr, base);\n+  return errno == 0;\n+}\n+\n+template<typename T>\n+static bool multiply_by_1k(T& n) {\n+  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n+      n <= std::numeric_limits<T>::max() \/ 1024) {\n+    n *= 1024;\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ All of the integral types that can be used for command line options:\n+\/\/   int, uint, intx, uintx, uint64_t, size_t\n+\/\/\n+\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n+\/\/    {signed, unsigned} x {32-bit, 64-bit}\n+\/\/\n+\/\/ We use SFINAE to pick the correct parse_integer_impl() function\n+template<typename T>\n+static bool parse_integer(const char *s, T* result) {\n+  if (!isdigit(s[0]) && s[0] != '-') {\n+    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n+    return false;\n+  }\n+\n+  T n = 0;\n+  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n+                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n@@ -756,3 +826,2 @@\n-  errno = 0;\n-  n = strtoull(s, &remainder, (is_hex ? 16 : 10));\n-  if (errno != 0) {\n+\n+  if (!parse_integer_impl(s, &remainder, (is_hex ? 16 : 10), &n)) {\n@@ -769,4 +838,2 @@\n-      *result = n * G * K;\n-      \/\/ Check for overflow.\n-      if (*result\/((julong)G * K) != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n@@ -774,3 +841,2 @@\n-      *result = n * G;\n-      if (*result\/G != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n@@ -778,3 +844,2 @@\n-      *result = n * M;\n-      if (*result\/M != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n@@ -782,3 +847,2 @@\n-      *result = n * K;\n-      if (*result\/K != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      break;\n@@ -786,2 +850,1 @@\n-      *result = n;\n-      return true;\n+      break;\n@@ -791,0 +854,7 @@\n+\n+  *result = n;\n+  return true;\n+}\n+\n+bool Arguments::atojulong(const char *s, julong* result) {\n+  return parse_integer(s, result);\n@@ -839,6 +909,1 @@\n-static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n-  julong v;\n-  int int_v;\n-  intx intx_v;\n-  bool is_neg = false;\n-\n+static JVMFlag::Error set_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n@@ -846,1 +911,1 @@\n-    return false;\n+    return JVMFlag::INVALID_FLAG;\n@@ -849,11 +914,0 @@\n-  \/\/ Check the sign first since atojulong() parses only unsigned values.\n-  if (*value == '-') {\n-    if (!flag->is_intx() && !flag->is_int()) {\n-      return false;\n-    }\n-    value++;\n-    is_neg = true;\n-  }\n-  if (!Arguments::atojulong(value, &v)) {\n-    return false;\n-  }\n@@ -861,3 +915,3 @@\n-    int_v = (int) v;\n-    if (is_neg) {\n-      int_v = -int_v;\n+    int v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_int(flag, &v, origin);\n@@ -865,1 +919,0 @@\n-    return JVMFlagAccess::set_int(flag, &int_v, origin) == JVMFlag::SUCCESS;\n@@ -867,2 +920,4 @@\n-    uint uint_v = (uint) v;\n-    return JVMFlagAccess::set_uint(flag, &uint_v, origin) == JVMFlag::SUCCESS;\n+    uint v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_uint(flag, &v, origin);\n+    }\n@@ -870,3 +925,3 @@\n-    intx_v = (intx) v;\n-    if (is_neg) {\n-      intx_v = -intx_v;\n+    intx v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_intx(flag, &v, origin);\n@@ -874,1 +929,0 @@\n-    return JVMFlagAccess::set_intx(flag, &intx_v, origin) == JVMFlag::SUCCESS;\n@@ -876,2 +930,4 @@\n-    uintx uintx_v = (uintx) v;\n-    return JVMFlagAccess::set_uintx(flag, &uintx_v, origin) == JVMFlag::SUCCESS;\n+    uintx v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_uintx(flag, &v, origin);\n+    }\n@@ -879,2 +935,4 @@\n-    uint64_t uint64_t_v = (uint64_t) v;\n-    return JVMFlagAccess::set_uint64_t(flag, &uint64_t_v, origin) == JVMFlag::SUCCESS;\n+    uint64_t v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_uint64_t(flag, &v, origin);\n+    }\n@@ -882,2 +940,4 @@\n-    size_t size_t_v = (size_t) v;\n-    return JVMFlagAccess::set_size_t(flag, &size_t_v, origin) == JVMFlag::SUCCESS;\n+    size_t v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_size_t(flag, &v, origin);\n+    }\n@@ -885,4 +945,12 @@\n-    double double_v = (double) v;\n-    return JVMFlagAccess::set_double(flag, &double_v, origin) == JVMFlag::SUCCESS;\n-  } else {\n-    return false;\n+    \/\/ This function parses only input strings without a decimal\n+    \/\/ point character (.)\n+    \/\/ If a string looks like a FP number, it would be parsed by\n+    \/\/ set_fp_numeric_flag(). See Arguments::parse_argument().\n+    jlong v;\n+    if (parse_integer(value, &v)) {\n+      double double_v = (double) v;\n+      if (value[0] == '-' && v == 0) { \/\/ special case: 0.0 is different than -0.0.\n+        double_v = -0.0;\n+      }\n+      return JVMFlagAccess::set_double(flag, &double_v, origin);\n+    }\n@@ -890,0 +958,2 @@\n+\n+  return JVMFlag::WRONG_FORMAT;\n@@ -1051,1 +1121,1 @@\n-    return set_numeric_flag(flag, value, origin);\n+    return set_numeric_flag(flag, value, origin) == JVMFlag::SUCCESS;\n@@ -2068,16 +2138,9 @@\n-\n-  \/\/ Check the sign first since atojulong() parses only unsigned values.\n-  bool value_is_positive = !(*value == '-');\n-\n-  if (value_is_positive) {\n-    julong n;\n-    bool good_return = atojulong(value, &n);\n-    if (good_return) {\n-      bool above_minimum = n >= min_size;\n-      bool value_is_too_large = n > max_uintx;\n-\n-      if (above_minimum && !value_is_too_large) {\n-        *uintx_arg = n;\n-        return true;\n-      }\n-    }\n+  uintx n;\n+  if (!parse_integer(value, &n)) {\n+    return false;\n+  }\n+  if (n >= min_size) {\n+    *uintx_arg = n;\n+    return true;\n+  } else {\n+    return false;\n@@ -2085,1 +2148,0 @@\n-  return false;\n@@ -2136,1 +2198,1 @@\n-  if (!atojulong(s, long_arg)) return arg_unreadable;\n+  if (!parse_integer(s, long_arg)) return arg_unreadable;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":143,"deletions":81,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -240,0 +240,1 @@\n+  friend class LargeOptionsTest;\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,23 @@\n+  product(bool, TestFlagFor_bool, false,                                    \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(int, TestFlagFor_int, 0,                                          \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(uint, TestFlagFor_uint, 0,                                        \\\n+           \"Used by VM internal regression tests only\")                     \\\n+                                                                            \\\n+  product(intx, TestFlagFor_intx, 0,                                        \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(uintx, TestFlagFor_uintx, 0,                                      \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(uint64_t, TestFlagFor_uint64_t, 0,                                \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(size_t, TestFlagFor_size_t, 0,                                    \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(double, TestFlagFor_double, 0.0,                                  \\\n+          \"Used by VM internal regression tests only\")                      \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/debug_globals.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1113,0 +1113,5 @@\n+#ifdef TARGET_ARCH_aarch64\n+  if (!pauth_ptr_is_raw(x)) {\n+    return false;\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -637,0 +637,2 @@\n+    \/\/ No need to fill with 0 because DumpSharedSpaces doesn't use these\n+    \/\/ early allocations.\n@@ -652,3 +654,1 @@\n-  const NMT_TrackingLevel level = MemTracker::tracking_level();\n-  const size_t nmt_overhead =\n-      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n+  const size_t outer_size = size + MemTracker::overhead_per_malloc();\n@@ -656,3 +656,1 @@\n-  const size_t outer_size = size + nmt_overhead;\n-\n-  void* const outer_ptr = (u_char*)::malloc(outer_size);\n+  void* const outer_ptr = ::malloc(outer_size);\n@@ -663,1 +661,1 @@\n-  void* inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, memflags, stack, level);\n+  void* const inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, memflags, stack);\n@@ -665,1 +663,6 @@\n-  DEBUG_ONLY(::memset(inner_ptr, uninitBlockPad, size);)\n+  if (DumpSharedSpaces) {\n+    \/\/ Need to deterministically fill all the alignment gaps in C++ structures.\n+    ::memset(inner_ptr, 0, size);\n+  } else {\n+    DEBUG_ONLY(::memset(inner_ptr, uninitBlockPad, size);)\n+  }\n@@ -667,1 +670,0 @@\n-\n@@ -699,5 +701,1 @@\n-  const NMT_TrackingLevel level = MemTracker::tracking_level();\n-  const size_t nmt_overhead =\n-      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n-\n-  const size_t new_outer_size = size + nmt_overhead;\n+  const size_t new_outer_size = size + MemTracker::overhead_per_malloc();\n@@ -706,1 +704,1 @@\n-  void* const old_outer_ptr = MemTracker::record_free(memblock, level);\n+  void* const old_outer_ptr = MemTracker::record_free(memblock);\n@@ -709,0 +707,3 @@\n+  if (new_outer_ptr == NULL) {\n+    return NULL;\n+  }\n@@ -710,2 +711,1 @@\n-  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n-  void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack, level);\n+  void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack);\n@@ -731,2 +731,0 @@\n-  const NMT_TrackingLevel level = MemTracker::tracking_level();\n-\n@@ -734,1 +732,2 @@\n-  void* const old_outer_ptr = MemTracker::record_free(memblock, level);\n+  void* const old_outer_ptr = MemTracker::record_free(memblock);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1950,0 +1950,2 @@\n+  AARCH64_PORT_ONLY(assert(pauth_ptr_is_raw(caller_pc), \"should be raw\"));\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -218,1 +218,4 @@\n-    _code1 = BufferBlob::create(\"StubRoutines (1)\", code_size1);\n+    \/\/ Add extra space for large CodeEntryAlignment\n+    int max_aligned_stubs = 10;\n+    int size = code_size1 + CodeEntryAlignment * max_aligned_stubs;\n+    _code1 = BufferBlob::create(\"StubRoutines (1)\", size);\n@@ -272,1 +275,4 @@\n-    _code2 = BufferBlob::create(\"StubRoutines (2)\", code_size2);\n+    \/\/ Add extra space for large CodeEntryAlignment\n+    int max_aligned_stubs = 100;\n+    int size = code_size2 + CodeEntryAlignment * max_aligned_stubs;\n+    _code2 = BufferBlob::create(\"StubRoutines (2)\", size);\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1326,2 +1326,4 @@\n-    \/\/ We can't get here in a thread that has completed its execution and so\n-    \/\/ \"is_terminated\", but a thread is also considered terminated if the VM\n+    \/\/ We can't normally get here in a thread that has completed its\n+    \/\/ execution and so \"is_terminated\", except when the call is from\n+    \/\/ AsyncGetCallTrace, which can be triggered by a signal at any point in\n+    \/\/ a thread's lifecycle. A thread is also considered terminated if the VM\n@@ -1333,1 +1335,0 @@\n-      ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  template(PrintClasses)                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -105,0 +106,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassesDCmd>(full_export, true, false));\n@@ -957,0 +959,35 @@\n+ClassesDCmd::ClassesDCmd(outputStream* output, bool heap) :\n+                                     DCmdWithParser(output, heap),\n+  _verbose(\"-verbose\",\n+           \"Dump the detailed content of a Java class. \"\n+           \"Some classes are annotated with flags: \"\n+           \"F = has, or inherits, a non-empty finalize method, \"\n+           \"f = has final method, \"\n+           \"W = methods rewritten, \"\n+           \"C = marked with @Contended annotation, \"\n+           \"R = has been redefined, \"\n+           \"S = is shared class\",\n+           \"BOOLEAN\", false, \"false\") {\n+  _dcmdparser.add_dcmd_option(&_verbose);\n+}\n+\n+class VM_PrintClasses : public VM_Operation {\n+private:\n+  outputStream* _out;\n+  bool _verbose;\n+public:\n+  VM_PrintClasses(outputStream* out, bool verbose) : _out(out), _verbose(verbose) {}\n+\n+  virtual VMOp_Type type() const { return VMOp_PrintClasses; }\n+\n+  virtual void doit() {\n+    PrintClassClosure closure(_out, _verbose);\n+    ClassLoaderDataGraph::classes_do(&closure);\n+  }\n+};\n+\n+void ClassesDCmd::execute(DCmdSource source, TRAPS) {\n+  VM_PrintClasses vmop(output(), _verbose.is_set());\n+  VMThread::execute(&vmop);\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -861,0 +861,22 @@\n+class ClassesDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _verbose;\n+public:\n+  ClassesDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"VM.classes\";\n+  }\n+  static const char* description() {\n+    return \"Print all loaded classes\";\n+  }\n+  static const char* impact() {\n+      return \"Medium: Depends on number of loaded classes.\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -109,2 +109,1 @@\n-MallocSite* MallocSiteTable::lookup_or_add(const NativeCallStack& key, size_t* bucket_idx,\n-  size_t* pos_idx, MEMFLAGS flags) {\n+MallocSite* MallocSiteTable::lookup_or_add(const NativeCallStack& key, uint32_t* marker, MEMFLAGS flags) {\n@@ -114,2 +113,1 @@\n-  *bucket_idx = (size_t)index;\n-  *pos_idx = 0;\n+  *marker = 0;\n@@ -125,0 +123,1 @@\n+      *marker = build_marker(index, 0);\n@@ -131,0 +130,1 @@\n+  unsigned pos_idx = 0;\n@@ -132,1 +132,1 @@\n-  while (head != NULL && (*pos_idx) <= MAX_BUCKET_LENGTH) {\n+  while (head != NULL && pos_idx < MAX_BUCKET_LENGTH) {\n@@ -136,0 +136,1 @@\n+        *marker = build_marker(index, pos_idx);\n@@ -140,1 +141,1 @@\n-    if (head->next() == NULL && (*pos_idx) < MAX_BUCKET_LENGTH) {\n+    if (head->next() == NULL && pos_idx < (MAX_BUCKET_LENGTH - 1)) {\n@@ -145,1 +146,2 @@\n-        (*pos_idx) ++;\n+        pos_idx ++;\n+        *marker = build_marker(index, pos_idx);\n@@ -152,1 +154,1 @@\n-    (*pos_idx) ++;\n+    pos_idx ++;\n@@ -158,1 +160,2 @@\n-MallocSite* MallocSiteTable::malloc_site(size_t bucket_idx, size_t pos_idx) {\n+MallocSite* MallocSiteTable::malloc_site(uint32_t marker) {\n+  uint16_t bucket_idx = bucket_idx_from_marker(marker);\n@@ -160,0 +163,1 @@\n+  const uint16_t pos_idx = pos_idx_from_marker(marker);\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -114,2 +114,5 @@\n-  \/\/ The table must not be wider than the maximum value the bucket_idx field\n-  \/\/ in the malloc header can hold.\n+  \/\/ Table cannot be wider than a 16bit bucket idx can hold\n+#define MAX_MALLOCSITE_TABLE_SIZE (USHRT_MAX - 1)\n+  \/\/ Each bucket chain cannot be longer than what a 16 bit pos idx can hold (hopefully way shorter)\n+#define MAX_BUCKET_LENGTH         (USHRT_MAX - 1)\n+\n@@ -118,0 +121,7 @@\n+  static uint32_t build_marker(unsigned bucket_idx, unsigned pos_idx) {\n+    assert(bucket_idx <= MAX_MALLOCSITE_TABLE_SIZE && pos_idx < MAX_BUCKET_LENGTH, \"overflow\");\n+    return (uint32_t)bucket_idx << 16 | pos_idx;\n+  }\n+  static uint16_t bucket_idx_from_marker(uint32_t marker) { return marker >> 16; }\n+  static uint16_t pos_idx_from_marker(uint32_t marker) { return marker & 0xFFFF; }\n+\n@@ -119,0 +129,1 @@\n+\n@@ -126,3 +137,2 @@\n-  static inline bool access_stack(NativeCallStack& stack, size_t bucket_idx,\n-    size_t pos_idx) {\n-    MallocSite* site = malloc_site(bucket_idx, pos_idx);\n+  static inline bool access_stack(NativeCallStack& stack, uint32_t marker) {\n+    MallocSite* site = malloc_site(marker);\n@@ -137,3 +147,2 @@\n-  \/\/ Return true if the allocation is recorded successfully, bucket_idx\n-  \/\/ and pos_idx are also updated to indicate the entry where the allocation\n-  \/\/ information was recorded.\n+  \/\/ Return true if the allocation is recorded successfully and updates marker\n+  \/\/ to indicate the entry where the allocation information was recorded.\n@@ -144,2 +153,2 @@\n-    size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags) {\n-    MallocSite* site = lookup_or_add(stack, bucket_idx, pos_idx, flags);\n+      uint32_t* marker, MEMFLAGS flags) {\n+    MallocSite* site = lookup_or_add(stack, marker, flags);\n@@ -150,1 +159,1 @@\n-  \/\/ Record memory deallocation. bucket_idx and pos_idx indicate where the allocation\n+  \/\/ Record memory deallocation. marker indicates where the allocation\n@@ -152,2 +161,2 @@\n-  static inline bool deallocation_at(size_t size, size_t bucket_idx, size_t pos_idx) {\n-    MallocSite* site = malloc_site(bucket_idx, pos_idx);\n+  static inline bool deallocation_at(size_t size, uint32_t marker) {\n+    MallocSite* site = malloc_site(marker);\n@@ -173,2 +182,2 @@\n-  static MallocSite* lookup_or_add(const NativeCallStack& key, size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags);\n-  static MallocSite* malloc_site(size_t bucket_idx, size_t pos_idx);\n+  static MallocSite* lookup_or_add(const NativeCallStack& key, uint32_t* marker, MEMFLAGS flags);\n+  static MallocSite* malloc_site(uint32_t marker);\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.hpp","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"services\/mallocTracker.inline.hpp\"\n@@ -118,14 +117,0 @@\n-void MallocHeader::release() {\n-  assert(MemTracker::enabled(), \"Sanity\");\n-\n-  assert_block_integrity();\n-\n-  MallocMemorySummary::record_free(size(), flags());\n-  MallocMemorySummary::record_free_malloc_header(sizeof(MallocHeader));\n-  if (MemTracker::tracking_level() == NMT_detail) {\n-    MallocSiteTable::deallocation_at(size(), _bucket_idx, _pos_idx);\n-  }\n-\n-  mark_block_as_dead();\n-}\n-\n@@ -236,5 +221,0 @@\n-bool MallocHeader::record_malloc_site(const NativeCallStack& stack, size_t size,\n-  size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags) const {\n-  return MallocSiteTable::allocation_at(stack, size, bucket_idx, pos_idx, flags);\n-}\n-\n@@ -242,1 +222,1 @@\n-  return MallocSiteTable::access_stack(stack, _bucket_idx, _pos_idx);\n+  return MallocSiteTable::access_stack(stack, _mst_marker);\n@@ -258,7 +238,10 @@\n-  const NativeCallStack& stack, NMT_TrackingLevel level) {\n-  assert(level != NMT_off, \"precondition\");\n-  void*         memblock;      \/\/ the address for user data\n-  MallocHeader* header = NULL;\n-\n-  if (malloc_base == NULL) {\n-    return NULL;\n+  const NativeCallStack& stack)\n+{\n+  assert(MemTracker::enabled(), \"precondition\");\n+  assert(malloc_base != NULL, \"precondition\");\n+\n+  MallocMemorySummary::record_malloc(size, flags);\n+  MallocMemorySummary::record_new_malloc_header(sizeof(MallocHeader));\n+  uint32_t mst_marker = 0;\n+  if (MemTracker::tracking_level() == NMT_detail) {\n+    MallocSiteTable::allocation_at(stack, size, &mst_marker, flags);\n@@ -268,3 +251,2 @@\n-\n-  header = ::new (malloc_base)MallocHeader(size, flags, stack, level);\n-  memblock = (void*)((char*)malloc_base + sizeof(MallocHeader));\n+  MallocHeader* const header = ::new (malloc_base)MallocHeader(size, flags, stack, mst_marker);\n+  void* const memblock = (void*)((char*)malloc_base + sizeof(MallocHeader));\n@@ -277,4 +259,6 @@\n-  if (level > NMT_off) {\n-    \/\/ Read back\n-    assert(get_size(memblock) == size,   \"Wrong size\");\n-    assert(get_flags(memblock) == flags, \"Wrong flags\");\n+  \/\/ Read back\n+  {\n+    MallocHeader* const header2 = malloc_header(memblock);\n+    assert(header2->size() == size, \"Wrong size\");\n+    assert(header2->flags() == flags, \"Wrong flags\");\n+    header2->assert_block_integrity();\n@@ -288,3 +272,14 @@\n-  assert(MemTracker::tracking_level() != NMT_off && memblock != NULL, \"precondition\");\n-  MallocHeader* header = malloc_header(memblock);\n-  header->release();\n+  assert(MemTracker::enabled(), \"Sanity\");\n+  assert(memblock != NULL, \"precondition\");\n+\n+  MallocHeader* const header = malloc_header(memblock);\n+  header->assert_block_integrity();\n+\n+  MallocMemorySummary::record_free(header->size(), header->flags());\n+  MallocMemorySummary::record_free_malloc_header(sizeof(MallocHeader));\n+  if (MemTracker::tracking_level() == NMT_detail) {\n+    MallocSiteTable::deallocation_at(header->size(), header->mst_marker());\n+  }\n+\n+  header->mark_block_as_dead();\n+\n@@ -303,1 +298,1 @@\n-    const MallocHeader* mhdr = (const MallocHeader*)MallocTracker::get_base(const_cast<void*>(p), tracking_level);\n+    const MallocHeader* mhdr = malloc_header(p);\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":34,"deletions":39,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n- *  ...  |   bucket idx    |     pos idx     | flags  | unused |     canary      |  ... User payload ....\n+ *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n@@ -282,1 +282,1 @@\n- *  ...  |   bucket idx    |     pos idx     | flags  | unused |     canary      |  ... User payload ....\n+ *  ...  |   malloc site table marker        | flags  | unused |     canary      |  ... User payload ....\n@@ -297,5 +297,4 @@\n-  size_t _size;\n-  uint16_t _bucket_idx;\n-  uint16_t _pos_idx;\n-  uint8_t _flags;\n-  uint8_t _unused;\n+  const size_t _size;\n+  const uint32_t _mst_marker;\n+  const uint8_t _flags;\n+  const uint8_t _unused;\n@@ -304,3 +303,0 @@\n-#define MAX_MALLOCSITE_TABLE_SIZE (USHRT_MAX - 1)\n-#define MAX_BUCKET_LENGTH         (USHRT_MAX - 1)\n-\n@@ -317,3 +313,0 @@\n-  \/\/ If block is broken, print out a report to tty (optionally with\n-  \/\/ hex dump surrounding the broken block), then trigger a fatal error\n-  void assert_block_integrity() const;\n@@ -321,1 +314,0 @@\n-  void mark_block_as_dead();\n@@ -331,1 +323,4 @@\n-  MallocHeader(size_t size, MEMFLAGS flags, const NativeCallStack& stack, NMT_TrackingLevel level) {\n+  MallocHeader(size_t size, MEMFLAGS flags, const NativeCallStack& stack, uint32_t mst_marker)\n+    : _size(size), _mst_marker(mst_marker), _flags(NMTUtil::flag_to_index(flags)),\n+      _unused(0), _canary(_header_canary_life_mark)\n+  {\n@@ -333,16 +328,0 @@\n-\n-    _flags = NMTUtil::flag_to_index(flags);\n-    set_size(size);\n-    if (level == NMT_detail) {\n-      size_t bucket_idx;\n-      size_t pos_idx;\n-      if (record_malloc_site(stack, size, &bucket_idx, &pos_idx, flags)) {\n-        assert(bucket_idx <= MAX_MALLOCSITE_TABLE_SIZE, \"Overflow bucket index\");\n-        assert(pos_idx <= MAX_BUCKET_LENGTH, \"Overflow bucket position index\");\n-        _bucket_idx = (uint16_t)bucket_idx;\n-        _pos_idx = (uint16_t)pos_idx;\n-      }\n-    }\n-\n-    _unused = 0;\n-    _canary = _header_canary_life_mark;\n@@ -353,3 +332,0 @@\n-\n-    MallocMemorySummary::record_malloc(size, flags);\n-    MallocMemorySummary::record_new_malloc_header(sizeof(MallocHeader));\n@@ -360,0 +336,1 @@\n+  inline uint32_t mst_marker() const { return _mst_marker; }\n@@ -362,2 +339,1 @@\n-  \/\/ Cleanup tracking information and mark block as dead before the memory is released.\n-  void release();\n+  void mark_block_as_dead();\n@@ -370,6 +346,3 @@\n- private:\n-  inline void set_size(size_t size) {\n-    _size = size;\n-  }\n-  bool record_malloc_site(const NativeCallStack& stack, size_t size,\n-    size_t* bucket_idx, size_t* pos_idx, MEMFLAGS flags) const;\n+  \/\/ If block is broken, print out a report to tty (optionally with\n+  \/\/ hex dump surrounding the broken block), then trigger a fatal error\n+  void assert_block_integrity() const;\n@@ -388,9 +361,3 @@\n-  \/\/ malloc tracking header size for specific tracking level\n-  static inline size_t malloc_header_size(NMT_TrackingLevel level) {\n-    return (level == NMT_off) ? 0 : sizeof(MallocHeader);\n-  }\n-\n-  \/\/ malloc tracking footer size for specific tracking level\n-  static inline size_t malloc_footer_size(NMT_TrackingLevel level) {\n-    return (level == NMT_off) ? 0 : sizeof(uint16_t);\n-  }\n+  \/\/ The overhead that is incurred by switching on NMT (we need, per malloc allocation,\n+  \/\/ space for header and 16-bit footer)\n+  static const size_t overhead_per_malloc = sizeof(MallocHeader) + sizeof(uint16_t);\n@@ -408,1 +375,1 @@\n-    const NativeCallStack& stack, NMT_TrackingLevel level);\n+    const NativeCallStack& stack);\n@@ -413,19 +380,0 @@\n-  \/\/ Offset memory address to header address\n-  static inline void* get_base(void* memblock);\n-  static inline void* get_base(void* memblock, NMT_TrackingLevel level) {\n-    if (memblock == NULL || level == NMT_off) return memblock;\n-    return (char*)memblock - malloc_header_size(level);\n-  }\n-\n-  \/\/ Get memory size\n-  static inline size_t get_size(void* memblock) {\n-    MallocHeader* header = malloc_header(memblock);\n-    return header->size();\n-  }\n-\n-  \/\/ Get memory type\n-  static inline MEMFLAGS get_flags(void* memblock) {\n-    MallocHeader* header = malloc_header(memblock);\n-    return header->flags();\n-  }\n-\n@@ -454,2 +402,5 @@\n-    MallocHeader* header = (MallocHeader*)((char*)memblock - sizeof(MallocHeader));\n-    return header;\n+    return (MallocHeader*)((char*)memblock - sizeof(MallocHeader));\n+  }\n+  static inline const MallocHeader* malloc_header(const void *memblock) {\n+    assert(memblock != NULL, \"NULL pointer\");\n+    return (const MallocHeader*)((const char*)memblock - sizeof(MallocHeader));\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":24,"deletions":73,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_SERVICES_MALLOCTRACKER_INLINE_HPP\n-#define SHARE_SERVICES_MALLOCTRACKER_INLINE_HPP\n-\n-#include \"services\/mallocTracker.hpp\"\n-\n-#include \"services\/memTracker.hpp\"\n-\n-inline void* MallocTracker::get_base(void* memblock){\n-  return get_base(memblock, MemTracker::tracking_level());\n-}\n-\n-#endif \/\/ SHARE_SERVICES_MALLOCTRACKER_INLINE_HPP\n","filename":"src\/hotspot\/share\/services\/mallocTracker.inline.hpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"services\/mallocTracker.inline.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n@@ -93,4 +93,0 @@\n-void* MemTracker::malloc_base(void* memblock) {\n-  return MallocTracker::get_base(memblock);\n-}\n-\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -90,0 +91,5 @@\n+  \/\/ Per-malloc overhead incurred by NMT, depending on the current NMT level\n+  static size_t overhead_per_malloc() {\n+    return enabled() ? MallocTracker::overhead_per_malloc : 0;\n+  }\n+\n@@ -91,3 +97,4 @@\n-    const NativeCallStack& stack, NMT_TrackingLevel level) {\n-    if (level != NMT_off) {\n-      return MallocTracker::record_malloc(mem_base, size, flag, stack, level);\n+    const NativeCallStack& stack) {\n+    assert(mem_base != NULL, \"caller should handle NULL\");\n+    if (enabled()) {\n+      return MallocTracker::record_malloc(mem_base, size, flag, stack);\n@@ -98,14 +105,0 @@\n-  static inline size_t malloc_header_size(NMT_TrackingLevel level) {\n-    return MallocTracker::malloc_header_size(level);\n-  }\n-\n-  \/\/ malloc tracking footer size for specific tracking level\n-  static inline size_t malloc_footer_size(NMT_TrackingLevel level) {\n-    return MallocTracker::malloc_footer_size(level);\n-  }\n-\n-  \/\/ To malloc base address, which is the starting address\n-  \/\/ of malloc tracking header if tracking is enabled.\n-  \/\/ Otherwise, it returns the same address.\n-  static void* malloc_base(void* memblock);\n-\n@@ -113,1 +106,1 @@\n-  static inline void* record_free(void* memblock, NMT_TrackingLevel level) {\n+  static inline void* record_free(void* memblock) {\n@@ -115,1 +108,2 @@\n-    if (level == NMT_off || memblock == NULL) {\n+    assert(memblock != NULL, \"caller should handle NULL\");\n+    if (!enabled()) {\n@@ -121,1 +115,0 @@\n-\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-    assert(flag_is_valid(flag), \"Invalid flag\");\n+    assert(flag_is_valid(flag), \"Invalid flag (%u)\", (unsigned)flag);\n@@ -101,1 +101,1 @@\n-    assert(flag_index_is_valid(index), \"Invalid flag\");\n+    assert(flag_index_is_valid(index), \"Invalid flag index (%d)\", index);\n","filename":"src\/hotspot\/share\/services\/nmtCommon.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -300,0 +301,22 @@\n+ protected:\n+  inline static void shared_disjoint_words_atomic(const HeapWord* from,\n+                                                  HeapWord* to, size_t count) {\n+\n+    switch (count) {\n+    case 8:  Atomic::store(&to[7], Atomic::load(&from[7]));\n+    case 7:  Atomic::store(&to[6], Atomic::load(&from[6]));\n+    case 6:  Atomic::store(&to[5], Atomic::load(&from[5]));\n+    case 5:  Atomic::store(&to[4], Atomic::load(&from[4]));\n+    case 4:  Atomic::store(&to[3], Atomic::load(&from[3]));\n+    case 3:  Atomic::store(&to[2], Atomic::load(&from[2]));\n+    case 2:  Atomic::store(&to[1], Atomic::load(&from[1]));\n+    case 1:  Atomic::store(&to[0], Atomic::load(&from[0]));\n+    case 0:  break;\n+    default:\n+      while (count-- > 0) {\n+        Atomic::store(to++, Atomic::load(from++));\n+      }\n+      break;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/copy.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -481,0 +481,4 @@\n+  if (p == NULL) {\n+    tty->print_cr(\"NULL\");\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -541,1 +541,5 @@\n-      fatal(\"Saw %s, aborting\", value_string);\n+      if (message == NULL) {\n+        fatal(\"Saw %s, aborting\", value_string);\n+      } else {\n+        fatal(\"Saw %s: %s, aborting\", value_string, message);\n+      }\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-\/\/ include hierachy reasons).\n+\/\/ include hierarchy reasons).\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -515,1 +515,1 @@\n-\/\/ 2. 64-bit port:   -DAARCH64 -D_LP64 -DTARGET_ARCH_aaarch64\n+\/\/ 2. 64-bit port:   -DAARCH64 -D_LP64 -DTARGET_ARCH_aarch64\n@@ -540,0 +540,6 @@\n+#ifdef TARGET_ARCH_aarch64\n+#define AARCH64_PORT_ONLY(code) code\n+#else\n+#define AARCH64_PORT_ONLY(code)\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -913,1 +913,1 @@\n-     if (_verbose && _context) {\n+     if (_verbose) {\n@@ -932,1 +932,2 @@\n-           frame fr = os::fetch_frame_from_context(_context);\n+           frame fr = _context ? os::fetch_frame_from_context(_context)\n+                               : os::current_frame();\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -185,1 +185,1 @@\n-            close(fd);\n+            close(fd, e -> null);\n@@ -280,1 +280,1 @@\n-            close(fd);\n+            close(fd, e -> null);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxDosFileAttributeView.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-            UnixNativeDispatcher.close(ifd);\n+            UnixNativeDispatcher.close(ifd, e -> null);\n@@ -299,3 +299,3 @@\n-            UnixNativeDispatcher.close(socketpair[0]);\n-            UnixNativeDispatcher.close(socketpair[1]);\n-            UnixNativeDispatcher.close(ifd);\n+            UnixNativeDispatcher.close(socketpair[0], e -> null);\n+            UnixNativeDispatcher.close(socketpair[1], e -> null);\n+            UnixNativeDispatcher.close(ifd, e -> null);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxWatchService.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,1 +162,1 @@\n-     *      {@code NoPadding} case insensitive).\n+     *      {@code NoPadding} case insensitive.\n@@ -396,1 +396,1 @@\n-        byte[] newNonce = null;\n+        byte[] newNonce;\n@@ -422,6 +422,0 @@\n-\n-        \/\/ If after all the above processing we still don't have a nonce value\n-        \/\/ then supply a random one provided a random source has been given.\n-        if (newNonce == null) {\n-            newNonce = createRandomNonce(random);\n-        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -347,0 +347,2 @@\n+                Arrays.fill(sharedSecret, offset,\n+                        offset + (expectedLen - secret.length), (byte)0);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKeyAgreement.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -528,2 +528,2 @@\n-        ps(\"AlgorithmParameters\", \"OAEP\",\n-                \"com.sun.crypto.provider.OAEPParameters\");\n+        psA(\"AlgorithmParameters\", \"OAEP\",\n+                \"com.sun.crypto.provider.OAEPParameters\", null);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2015,1 +2015,1 @@\n-            int suffixLength = suffix.length();;\n+            int suffixLength = suffix.length();\n","filename":"src\/java.base\/share\/classes\/java\/io\/File.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,24 @@\n+    \/**\n+     * Report an InvalidClassException for the reason and cause specified.\n+     *\n+     * @param reason  String describing the reason for the exception.\n+     * @param cause the cause\n+     * @since 19\n+     *\/\n+    public InvalidClassException(String reason, Throwable cause) {\n+        super(reason, cause);\n+    }\n+\n+    \/**\n+     * Report an InvalidClassException for the reason and cause specified.\n+     *\n+     * @param cname   a String naming the invalid class.\n+     * @param reason  String describing the reason for the exception.\n+     * @param cause the cause\n+     * @since 19\n+     *\/\n+    public InvalidClassException(String cname, String reason, Throwable cause) {\n+        super(reason, cause);\n+        classname = cname;\n+    }\n+\n@@ -79,0 +103,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/io\/InvalidClassException.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    public  InvalidObjectException(String reason) {\n+    public InvalidObjectException(String reason) {\n@@ -51,0 +51,14 @@\n+\n+    \/**\n+     * Constructs an {@code InvalidObjectException} with the given\n+     * reason and cause.\n+     *\n+     * @param reason Detailed message explaining the reason for the failure.\n+     * @param cause the cause\n+     *\n+     * @see ObjectInputValidation\n+     * @since 19\n+     *\/\n+    public InvalidObjectException(String reason, Throwable cause) {\n+        super(reason, cause);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/InvalidObjectException.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1432,3 +1432,1 @@\n-            InvalidClassException ice = new InvalidClassException(\"filter status: \" + status);\n-            ice.initCause(ex);\n-            throw ice;\n+            throw new InvalidClassException(\"filter status: \" + status, ex);\n@@ -1999,3 +1997,1 @@\n-            IOException ice = new InvalidClassException(aie.getMessage());\n-            ice.initCause(aie);\n-            throw ice;\n+            throw new InvalidClassException(aie.getMessage(), aie);\n@@ -2003,4 +1999,2 @@\n-            IOException ex = new InvalidObjectException(\"Proxy interface limit exceeded: \" +\n-                    Arrays.toString(ifaces));\n-            ex.initCause(memerr);\n-            throw ex;\n+            throw new InvalidObjectException(\"Proxy interface limit exceeded: \" +\n+                                             Arrays.toString(ifaces), memerr);\n@@ -2019,4 +2013,2 @@\n-            IOException ex = new InvalidObjectException(\"Proxy interface limit exceeded: \" +\n-                    Arrays.toString(ifaces));\n-            ex.initCause(memerr);\n-            throw ex;\n+            throw new InvalidObjectException(\"Proxy interface limit exceeded: \" +\n+                                             Arrays.toString(ifaces), memerr);\n@@ -2053,2 +2045,2 @@\n-            throw (IOException) new InvalidClassException(\n-                \"failed to read class descriptor\").initCause(ex);\n+            throw new InvalidClassException(\"failed to read class descriptor\",\n+                                            ex);\n@@ -2224,3 +2216,2 @@\n-                throw (IOException) new InvalidObjectException(\n-                    \"enum constant \" + name + \" does not exist in \" +\n-                    cl).initCause(ex);\n+                throw new InvalidObjectException(\"enum constant \" +\n+                                                 name + \" does not exist in \" + cl, ex);\n@@ -2265,3 +2256,2 @@\n-            throw (IOException) new InvalidClassException(\n-                desc.forClass().getName(),\n-                \"unable to create instance\").initCause(ex);\n+            throw new InvalidClassException(desc.forClass().getName(),\n+                                            \"unable to create instance\", ex);\n@@ -2391,3 +2381,1 @@\n-            InvalidObjectException ioe = new InvalidObjectException(e.getMessage());\n-            ioe.initCause(e);\n-            throw ioe;\n+            throw new InvalidObjectException(e.getMessage(), e);\n@@ -2397,4 +2385,2 @@\n-            ObjectStreamException ose = new InvalidObjectException(\n-                    \"ReflectiveOperationException during deserialization\");\n-            ose.initCause(t);\n-            throw ose;\n+            throw new InvalidObjectException(\"ReflectiveOperationException \" +\n+                                             \"during deserialization\", t);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":15,"deletions":29,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -712,2 +712,3 @@\n-                throw (IOException) new InvalidClassException(name,\n-                    \"invalid descriptor for field \" + fname).initCause(e);\n+                throw new InvalidClassException(name,\n+                                                \"invalid descriptor for field \" +\n+                                                fname, e);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,12 @@\n+    \/**\n+     * Create an ObjectStreamException with the specified message and\n+     * cause.\n+     *\n+     * @param message the detailed message for the exception\n+     * @param cause the cause\n+     * @since 19\n+     *\/\n+    protected ObjectStreamException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n@@ -53,0 +65,10 @@\n+\n+    \/**\n+     * Create an ObjectStreamException with the specified cause.\n+     *\n+     * @param cause the cause\n+     * @since 19\n+     *\/\n+    protected ObjectStreamException(Throwable cause) {\n+        super(cause);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamException.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -467,11 +467,1 @@\n-     * Flushes the stream and checks its error state. The internal error state\n-     * is set to {@code true} when the underlying output stream throws an\n-     * {@code IOException} other than {@code InterruptedIOException},\n-     * and when the {@code setError} method is invoked.  If an operation\n-     * on the underlying output stream throws an\n-     * {@code InterruptedIOException}, then the {@code PrintStream}\n-     * converts the exception back into an interrupt by doing:\n-     * <pre>{@code\n-     *     Thread.currentThread().interrupt();\n-     * }<\/pre>\n-     * or the equivalent.\n+     * Flushes the stream if it's not closed and checks its error state.\n@@ -480,3 +470,2 @@\n-     *         {@code IOException} other than\n-     *         {@code InterruptedIOException}, or the\n-     *         {@code setError} method has been invoked\n+     *         {@code IOException}, or the {@code setError} method has been\n+     *         invoked\n@@ -507,1 +496,1 @@\n-     * Clears the internal error state of this stream.\n+     * Clears the error state of this stream.\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintStream.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -431,3 +431,3 @@\n-     * @return {@code true} if the print stream has encountered an error,\n-     *          either on the underlying output stream or during a format\n-     *          conversion.\n+     * @return {@code true} if and only if this stream has encountered an\n+     *         {@code IOException}, or the {@code setError} method has been\n+     *         invoked\n@@ -448,1 +448,1 @@\n-     * Indicates that an error has occurred.\n+     * Sets the error state of the stream to {@code true}.\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintWriter.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * Unless otherwise noted, passing a null argument to a constructor or\n+ * Unless otherwise noted, passing a {@code null} argument to a constructor or\n@@ -34,0 +34,4 @@\n+ * A <i>pathname string<\/i> passed as a {@code String} argument to a\n+ * constructor or method in any class or interface in this package will be\n+ * interpreted as described in the class specification of {@link File}.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/io\/package-info.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,1 @@\n-    public static final double E = 2.7182818284590452354;\n+    public static final double E = 2.718281828459045;\n@@ -138,2 +138,2 @@\n-     * <i>pi<\/i>, the ratio of the circumference of a circle to its\n-     * diameter.\n+     * <i>pi<\/i> (&pi;), the ratio of the circumference of a circle to\n+     * its diameter.\n@@ -141,1 +141,14 @@\n-    public static final double PI = 3.14159265358979323846;\n+    public static final double PI = 3.141592653589793;\n+\n+    \/**\n+     * The {@code double} value that is closer than any other to\n+     * <i>tau<\/i> (&tau;), the ratio of the circumference of a circle\n+     * to its radius.\n+     *\n+     * @apiNote\n+     * The value of <i>pi<\/i> is one half that of <i>tau<\/i>; in other\n+     * words, <i>tau<\/i> is double <i>pi<\/i> .\n+     *\n+     * @since 19\n+     *\/\n+    public static final double TAU = 2.0 * PI;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-    public static final double E = 2.7182818284590452354;\n+    public static final double E = 2.718281828459045;\n@@ -99,1 +99,1 @@\n-     * <i>pi<\/i>, the ratio of the circumference of a circle to its\n+     * <i>pi<\/i> (&pi;), the ratio of the circumference of a circle to its\n@@ -102,1 +102,14 @@\n-    public static final double PI = 3.14159265358979323846;\n+    public static final double PI = 3.141592653589793;\n+\n+    \/**\n+     * The {@code double} value that is closer than any other to\n+     * <i>tau<\/i> (&tau;), the ratio of the circumference of a circle\n+     * to its radius.\n+     *\n+     * @apiNote\n+     * The value of <i>pi<\/i> is one half that of <i>tau<\/i>; in other\n+     * words, <i>tau<\/i> is double <i>pi<\/i> .\n+     *\n+     * @since 19\n+     *\/\n+    public static final double TAU = 2.0 * PI;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -528,4 +528,7 @@\n-            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n+            if (COMPACT_STRINGS) {\n+                int dp = StringCoding.countPositives(bytes, offset, length);\n+                if (dp == length) {\n+                    this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                    this.coder = LATIN1;\n+                    return;\n+                }\n@@ -533,8 +536,15 @@\n-                int dp = 0;\n-                byte[] dst = null;\n-                if (COMPACT_STRINGS) {\n-                    dst = new byte[length];\n-                    while (offset < sl) {\n-                        int b1 = bytes[offset];\n-                        if (b1 >= 0) {\n-                            dst[dp++] = (byte)b1;\n+                byte[] dst = new byte[length];\n+                if (dp > 0) {\n+                    System.arraycopy(bytes, offset, dst, 0, dp);\n+                    offset += dp;\n+                }\n+                while (offset < sl) {\n+                    int b1 = bytes[offset++];\n+                    if (b1 >= 0) {\n+                        dst[dp++] = (byte)b1;\n+                        continue;\n+                    }\n+                    if ((b1 & 0xfe) == 0xc2 && offset < sl) { \/\/ b1 either 0xc2 or 0xc3\n+                        int b2 = bytes[offset];\n+                        if (b2 < -64) { \/\/ continuation bytes are always negative values in the range -128 to -65\n+                            dst[dp++] = (byte)decode2(b1, b2);\n@@ -544,19 +554,0 @@\n-                        if ((b1 & 0xfe) == 0xc2 && offset + 1 < sl) { \/\/ b1 either 0xc2 or 0xc3\n-                            int b2 = bytes[offset + 1];\n-                            if (!isNotContinuation(b2)) {\n-                                dst[dp++] = (byte)decode2(b1, b2);\n-                                offset += 2;\n-                                continue;\n-                            }\n-                        }\n-                        \/\/ anything not a latin1, including the repl\n-                        \/\/ we have to go with the utf16\n-                        break;\n-                    }\n-                    if (offset == sl) {\n-                        if (dp != dst.length) {\n-                            dst = Arrays.copyOf(dst, dp);\n-                        }\n-                        this.value = dst;\n-                        this.coder = LATIN1;\n-                        return;\n@@ -564,0 +555,4 @@\n+                    \/\/ anything not a latin1, including the REPL\n+                    \/\/ we have to go with the utf16\n+                    offset--;\n+                    break;\n@@ -565,6 +560,7 @@\n-                if (dp == 0 || dst == null) {\n-                    dst = new byte[length << 1];\n-                } else {\n-                    byte[] buf = new byte[length << 1];\n-                    StringLatin1.inflate(dst, 0, buf, 0, dp);\n-                    dst = buf;\n+                if (offset == sl) {\n+                    if (dp != dst.length) {\n+                        dst = Arrays.copyOf(dst, dp);\n+                    }\n+                    this.value = dst;\n+                    this.coder = LATIN1;\n+                    return;\n@@ -572,0 +568,3 @@\n+                byte[] buf = new byte[length << 1];\n+                StringLatin1.inflate(dst, 0, buf, 0, dp);\n+                dst = buf;\n@@ -578,0 +577,8 @@\n+            } else { \/\/ !COMPACT_STRINGS\n+                byte[] dst = new byte[length << 1];\n+                int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n+                if (dp != length) {\n+                    dst = Arrays.copyOf(dst, dp << 1);\n+                }\n+                this.value = dst;\n+                this.coder = UTF16;\n@@ -685,3 +692,4 @@\n-        if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n-            return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n-        } else {\n+        int dp;\n+        byte[] dst;\n+        if (COMPACT_STRINGS) {\n+            dp = StringCoding.countPositives(bytes, offset, length);\n@@ -689,8 +697,16 @@\n-            int dp = 0;\n-            byte[] dst = null;\n-            if (COMPACT_STRINGS) {\n-                dst = new byte[length];\n-                while (offset < sl) {\n-                    int b1 = bytes[offset];\n-                    if (b1 >= 0) {\n-                        dst[dp++] = (byte) b1;\n+            if (dp == length) {\n+                return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n+            }\n+            dst = new byte[length];\n+            System.arraycopy(bytes, offset, dst, 0, dp);\n+            offset += dp;\n+            while (offset < sl) {\n+                int b1 = bytes[offset++];\n+                if (b1 >= 0) {\n+                    dst[dp++] = (byte)b1;\n+                    continue;\n+                }\n+                if ((b1 & 0xfe) == 0xc2 && offset < sl) { \/\/ b1 either 0xc2 or 0xc3\n+                    int b2 = bytes[offset];\n+                    if (b2 < -64) { \/\/ continuation bytes are always negative values in the range -128 to -65\n+                        dst[dp++] = (byte)decode2(b1, b2);\n@@ -700,11 +716,0 @@\n-                    if ((b1 & 0xfe) == 0xc2 && offset + 1 < sl) { \/\/ b1 either 0xc2 or 0xc3\n-                        int b2 = bytes[offset + 1];\n-                        if (!isNotContinuation(b2)) {\n-                            dst[dp++] = (byte) decode2(b1, b2);\n-                            offset += 2;\n-                            continue;\n-                        }\n-                    }\n-                    \/\/ anything not a latin1, including the REPL\n-                    \/\/ we have to go with the utf16\n-                    break;\n@@ -712,5 +717,8 @@\n-                if (offset == sl) {\n-                    if (dp != dst.length) {\n-                        dst = Arrays.copyOf(dst, dp);\n-                    }\n-                    return new String(dst, LATIN1);\n+                \/\/ anything not a latin1, including the REPL\n+                \/\/ we have to go with the utf16\n+                offset--;\n+                break;\n+            }\n+            if (offset == sl) {\n+                if (dp != dst.length) {\n+                    dst = Arrays.copyOf(dst, dp);\n@@ -718,0 +726,1 @@\n+                return new String(dst, LATIN1);\n@@ -719,1 +728,1 @@\n-            if (dp == 0 || dst == null) {\n+            if (dp == 0) {\n@@ -727,4 +736,6 @@\n-            if (dp != length) {\n-                dst = Arrays.copyOf(dst, dp << 1);\n-            }\n-            return new String(dst, UTF16);\n+        } else { \/\/ !COMPACT_STRINGS\n+            dst = new byte[length << 1];\n+            dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n+        }\n+        if (dp != length) {\n+            dst = Arrays.copyOf(dst, dp << 1);\n@@ -732,0 +743,1 @@\n+        return new String(dst, UTF16);\n@@ -1022,8 +1034,4 @@\n-        if (!StringCoding.hasNegatives(sa, sp, len)) {\n-            StringLatin1.inflate(sa, sp, da, dp, len);\n-            return len;\n-        } else {\n-            int start = sp;\n-            int end = sp + len;\n-            while (sp < end && sa[sp] >= 0) {\n-                da[dp++] = (char) sa[sp++];\n+        int count = StringCoding.countPositives(sa, sp, len);\n+        while (count < len) {\n+            if (sa[sp + count] < 0) {\n+                break;\n@@ -1031,1 +1039,1 @@\n-            return sp - start;\n+            count++;\n@@ -1033,0 +1041,2 @@\n+        StringLatin1.inflate(sa, sp, da, dp, count);\n+        return count;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":88,"deletions":78,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-    @IntrinsicCandidate\n@@ -39,1 +38,15 @@\n-        for (int i = off; i < off + len; i++) {\n+        return countPositives(ba, off, len) != len;\n+    }\n+\n+    \/**\n+     * Count the number of leading positive bytes in the range.\n+     *\n+     * @implSpec the implementation must return len if there are no negative\n+     *   bytes in the range. If there are negative bytes, the implementation must return\n+     *   a value that is less than or equal to the index of the first negative byte\n+     *   in the range.\n+     *\/\n+    @IntrinsicCandidate\n+    public static int countPositives(byte[] ba, int off, int len) {\n+        int limit = off + len;\n+        for (int i = off; i < limit; i++) {\n@@ -41,1 +54,1 @@\n-                return true;\n+                return i - off;\n@@ -44,1 +57,1 @@\n-        return false;\n+        return len;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -433,1 +433,1 @@\n-     * This will always create a new Object to comply with JLS 15.18.1:\n+     * This will always create a new Object to comply with JLS {@jls 15.18.1}:\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * correspond to the declaration contexts in JLS 9.6.4.1.\n+ * correspond to the declaration contexts in JLS {@jls 9.6.4.1}.\n@@ -50,1 +50,1 @@\n- * 4.11, as well as to two declaration contexts: class and interface\n+ * {@jls 4.11}, as well as to two declaration contexts: class and interface\n","filename":"src\/java.base\/share\/classes\/java\/lang\/annotation\/ElementType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-     * See JVMS 4.3.2 (\"Field Descriptors\") for more detail.\n+     * See JVMS {@jvms 4.3.2 }(\"Field Descriptors\") for more detail.\n@@ -151,1 +151,2 @@\n-     * @throws IllegalStateException if the resulting {@linkplain ClassDesc} would have an array rank of greater than 255\n+     * @throws IllegalStateException if the resulting {@linkplain\n+     * ClassDesc} would have an array rank of greater than 255\n@@ -170,1 +171,2 @@\n-     * @throws IllegalArgumentException if the rank is less than or equal to zero or if the rank of the resulting array type is\n+     * @throws IllegalArgumentException if the rank is less than or\n+     * equal to zero or if the rank of the resulting array type is\n@@ -175,3 +177,15 @@\n-        int currentDepth = ConstantUtils.arrayDepth(descriptorString());\n-        if (rank <= 0 || currentDepth + rank > ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS)\n-            throw new IllegalArgumentException(\"rank: \" + currentDepth + rank);\n+        int netRank;\n+        if (rank <= 0) {\n+            throw new IllegalArgumentException(\"rank \" + rank + \" is not a positive value\");\n+        }\n+        try {\n+            int currentDepth = ConstantUtils.arrayDepth(descriptorString());\n+            netRank = Math.addExact(currentDepth, rank);\n+            if (netRank > ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+                throw new IllegalArgumentException(\"rank: \" + netRank +\n+                                                   \" exceeds maximum supported dimension of \" +\n+                                                   ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n+            }\n+        } catch (ArithmeticException ae) {\n+            throw new IllegalArgumentException(\"Integer overflow in rank computation\");\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * classfile as described in JVMS 4.4, and whose instances can describe themselves\n+ * classfile as described in JVMS {@jvms 4.4}, and whose instances can describe themselves\n@@ -51,1 +51,1 @@\n- * generated constants (JVMS 4.4.10).\n+ * generated constants (JVMS {@jvms 4.4.10}).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/Constable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * constant value, as defined in JVMS 4.4. Such a descriptor can be resolved via\n+ * constant value, as defined in JVMS {@jvms 4.4}. Such a descriptor can be resolved via\n@@ -90,1 +90,1 @@\n-     * of JVMS 5.4.3 and the access control behavior of JVMS 5.4.4.  The resolution\n+     * of JVMS {@jvms 5.4.3} and the access control behavior of JVMS {@jvms 5.4.4}.  The resolution\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDesc.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n- * of constant values.  For each type of loadable constant pool entry defined in JVMS 4.4,\n+ * of constant values.  For each type of loadable constant pool entry defined in JVMS {@jvms 4.4},\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-     * @param name the descriptor (JVMS 4.3) of the desired primitive type\n+     * @param name the descriptor (JVMS {@jvms 4.3}) of the desired primitive type\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -810,1 +810,1 @@\n-     *     conversion (JLS 5.3) is applied, if one exists.\n+     *     conversion (JLS {@jls 5.3}) is applied, if one exists.\n@@ -813,1 +813,1 @@\n-     *     a Java casting conversion (JLS 5.5) is applied if one exists.\n+     *     a Java casting conversion (JLS {@jls 5.5}) is applied if one exists.\n@@ -818,1 +818,1 @@\n-     *     by a Java method invocation conversion (JLS 5.3)\n+     *     by a Java method invocation conversion (JLS {@jls 5.3})\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1887,1 +1887,1 @@\n-             * by a garbage collector (JLS 12.7).\n+             * by a garbage collector (JLS {@jls 12.7}).\n@@ -2027,1 +2027,1 @@\n-         * by a garbage collector (JLS 12.7).\n+         * by a garbage collector (JLS {@jls 12.7}).\n@@ -2762,1 +2762,1 @@\n-         * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,\n+         * Such a resolution, as specified in JVMS {@jvms 5.4.3.1}, attempts to locate and load the class,\n@@ -4760,1 +4760,1 @@\n-     *     <em>T0<\/em> is converted to byte via Java casting conversion (JLS 5.5),\n+     *     <em>T0<\/em> is converted to byte via Java casting conversion (JLS {@jls 5.5}),\n@@ -4763,1 +4763,1 @@\n-     *     then a Java casting conversion (JLS 5.5) is applied.\n+     *     then a Java casting conversion (JLS {@jls 5.5}) is applied.\n@@ -4768,1 +4768,1 @@\n-     *     by a Java casting conversion (JLS 5.5) on the primitive value,\n+     *     by a Java casting conversion (JLS {@jls 5.5}) on the primitive value,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,1 +145,1 @@\n-     *     input converted as per JLS 5.1.11 \"String Conversion\"; otherwise<\/li>\n+     *     input converted as per JLS {@jls 5.1.11} \"String Conversion\"; otherwise<\/li>\n@@ -147,2 +147,2 @@\n-     *     requirements stated in JLS 15.18.1 \"String Concatenation Operator +\".\n-     *     The inputs are converted as per JLS 5.1.11 \"String Conversion\",\n+     *     requirements stated in JLS {@jls 15.18.1} \"String Concatenation Operator +\".\n+     *     The inputs are converted as per JLS {@jls 5.1.11} \"String Conversion\",\n@@ -226,1 +226,1 @@\n-     *     input converted as per JLS 5.1.11 \"String Conversion\"; otherwise<\/li>\n+     *     input converted as per JLS {@jls 5.1.11} \"String Conversion\"; otherwise<\/li>\n@@ -228,2 +228,2 @@\n-     *     requirements stated in JLS 15.18.1 \"String Concatenation Operator +\".\n-     *     The inputs are converted as per JLS 5.1.11 \"String Conversion\",\n+     *     requirements stated in JLS {@jls 15.18.1} \"String Concatenation Operator +\".\n+     *     The inputs are converted as per JLS {@jls 5.1.11} \"String Conversion\",\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,2 @@\n- * by the nth enclosing class of T (see JLS 8.1.2), then the creation of t\n- * requires the resolution (see JVMS 5) of the ith enclosing class of T,\n+ * by the n<sup>th<\/sup> enclosing class of T (see JLS {@jls 8.1.2}), then the creation of t\n+ * requires the resolution (see JVMS {@jvms 5}) of the i<sup>th<\/sup> enclosing class of T,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/TypeVariable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,0 @@\n-    private static final int DEFAULT_DIGITS = 9;\n@@ -143,1 +142,0 @@\n-        return;\n@@ -165,1 +163,0 @@\n-        return;\n@@ -184,1 +181,0 @@\n-        boolean bad = false;\n@@ -235,1 +231,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/math\/MathContext.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1356,3 +1356,1 @@\n-        SocketException se = new SocketException(e.getMessage());\n-        se.initCause(e);\n-        return se;\n+        return new SocketException(e.getMessage(), e);\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocket.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,23 @@\n+\n+    \/**\n+     * Constructs a new {@code SocketException} with the\n+     * specified detail message and cause.\n+     *\n+     * @param msg the detail message.\n+     * @param cause the cause\n+     * @since 19\n+     *\/\n+    public SocketException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+\n+    \/**\n+     * Constructs a new {@code SocketException} with the\n+     * specified cause.\n+     *\n+     * @param cause the cause\n+     * @since 19\n+     *\/\n+    public SocketException(Throwable cause) {\n+        super(cause);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketException.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,4 @@\n+        \/\/ retrieve source posix view, null if unsupported\n+        final PosixFileAttributeView sourcePosixView =\n+            Files.getFileAttributeView(source, PosixFileAttributeView.class);\n+\n@@ -109,4 +113,9 @@\n-        BasicFileAttributes attrs = Files.readAttributes(source,\n-                                                         BasicFileAttributes.class,\n-                                                         linkOptions);\n-        if (attrs.isSymbolicLink())\n+        BasicFileAttributes sourceAttrs = sourcePosixView != null ?\n+            Files.readAttributes(source,\n+                                 PosixFileAttributes.class,\n+                                 linkOptions) :\n+            Files.readAttributes(source,\n+                                 BasicFileAttributes.class,\n+                                 linkOptions);\n+\n+        if (sourceAttrs.isSymbolicLink())\n@@ -122,1 +131,1 @@\n-        if (attrs.isDirectory()) {\n+        if (sourceAttrs.isDirectory()) {\n@@ -130,1 +139,1 @@\n-        \/\/ copy basic attributes to target\n+        \/\/ copy basic and, if supported, POSIX attributes to target\n@@ -132,2 +141,12 @@\n-            BasicFileAttributeView view =\n-                Files.getFileAttributeView(target, BasicFileAttributeView.class);\n+            BasicFileAttributeView targetView = null;\n+            if (sourcePosixView != null) {\n+                targetView = Files.getFileAttributeView(target,\n+                                                     PosixFileAttributeView.class);\n+            }\n+\n+            \/\/ target might not support posix even if source does\n+            if (targetView == null) {\n+                targetView = Files.getFileAttributeView(target,\n+                                                     BasicFileAttributeView.class);\n+            }\n+\n@@ -135,3 +154,8 @@\n-                view.setTimes(attrs.lastModifiedTime(),\n-                              attrs.lastAccessTime(),\n-                              attrs.creationTime());\n+                targetView.setTimes(sourceAttrs.lastModifiedTime(),\n+                                 sourceAttrs.lastAccessTime(),\n+                                 sourceAttrs.creationTime());\n+\n+                if (sourceAttrs instanceof PosixFileAttributes sourcePosixAttrs &&\n+                    targetView instanceof PosixFileAttributeView targetPosixView) {\n+                    targetPosixView.setPermissions(sourcePosixAttrs.permissions());\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/CopyMoveHelper.java","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -565,0 +565,4 @@\n+     *\n+     * OtherName ::= SEQUENCE {\n+     *      type-id    OBJECT IDENTIFIER,\n+     *      value      [0] EXPLICIT ANY DEFINED BY type-id }\n@@ -574,1 +578,1 @@\n-     * respectively).\n+     * respectively). More entries may exist depending on the name type.\n@@ -584,1 +588,1 @@\n-     * integers separated by periods. And directory names (distinguished names)\n+     * integers separated by periods. Directory names (distinguished names)\n@@ -586,4 +590,10 @@\n-     * RFC 2253<\/a> string format. No standard string format is\n-     * defined for otherNames, X.400 names, EDI party names, or any\n-     * other type of names. They are returned as byte arrays\n-     * containing the ASN.1 DER encoded form of the name.\n+     * RFC 2253<\/a> string format. No standard string format is defined for\n+     * X.400 names or EDI party names. They are returned as byte arrays\n+     * containing the ASN.1 DER encoded form of the name. otherNames are also\n+     * returned as byte arrays containing the ASN.1 DER encoded form of the\n+     * name. A third entry may also be present in the list containing the\n+     * {@code type-id} of the otherName in string form, and a fourth entry\n+     * containing its {@code value} as either a string (if the value is\n+     * a valid supported character string) or a byte array containing the\n+     * ASN.1 DER encoded form of the value without the context-specific\n+     * constructed tag with number 0.\n@@ -602,0 +612,3 @@\n+     * @implNote The JDK SUN provider supports the third and fourth\n+     * otherName entries.\n+     *\n@@ -630,1 +643,2 @@\n-     * respectively). For more details about the formats used for each\n+     * respectively).  More entries may exist depending on the name type.\n+     * For more details about the formats used for each\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509Certificate.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3213,2 +3213,3 @@\n-                    result.append(localized ? symbols.getGroupingSeparator() :\n-                                  PATTERN_GROUPING_SEPARATOR);\n+                    result.append(localized ?\n+                        (isCurrencyFormat ? symbols.getMonetaryGroupingSeparator() : symbols.getGroupingSeparator()) :\n+                        PATTERN_GROUPING_SEPARATOR);\n@@ -3221,2 +3222,3 @@\n-                result.append(localized ? symbols.getDecimalSeparator() :\n-                              PATTERN_DECIMAL_SEPARATOR);\n+                result.append(localized ?\n+                    (isCurrencyFormat ? symbols.getMonetaryDecimalSeparator() : symbols.getDecimalSeparator()) :\n+                    PATTERN_DECIMAL_SEPARATOR);\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,3 +172,3 @@\n- * This abstract class has two implementations, both of which are immutable and thread-safe.\n- * One implementation models region-based IDs, the other is {@code ZoneOffset} modelling\n- * offset-based IDs. This difference is visible in serialization.\n+ * This abstract sealed class permits two implementations, both of which are immutable and\n+ * thread-safe. One implementation models region-based IDs, the other is {@code ZoneOffset}\n+ * modelling offset-based IDs. This difference is visible in serialization.\n@@ -179,1 +179,1 @@\n-public abstract class ZoneId implements Serializable {\n+public abstract sealed class ZoneId implements Serializable permits ZoneOffset, ZoneRegion {\n@@ -474,5 +474,1 @@\n-    ZoneId() {\n-        if (getClass() != ZoneOffset.class && getClass() != ZoneRegion.class) {\n-            throw new AssertionError(\"Invalid subclass\");\n-        }\n-    }\n+    ZoneId() {}\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneId.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n- *   <tr><th scope=\"row\">F<\/th>       <td>day-of-week-in-month<\/td>        <td>number<\/td>            <td>3<\/td>\n+ *   <tr><th scope=\"row\">F<\/th>       <td>aligned-week-of-month<\/td>       <td>number<\/td>            <td>3<\/td>\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1777,1 +1777,1 @@\n-     *    F       1      appendValue(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH)\n+     *    F       1      appendValue(ChronoField.ALIGNED_WEEK_OF_MONTH)\n@@ -2186,1 +2186,1 @@\n-        FIELD_MAP.put('F', ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH);  \/\/ SDF, LDML\n+        FIELD_MAP.put('F', ChronoField.ALIGNED_WEEK_OF_MONTH);     \/\/ SDF, LDML\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,2 +79,2 @@\n-public abstract class EnumSet<E extends Enum<E>> extends AbstractSet<E>\n-    implements Cloneable, java.io.Serializable\n+public abstract sealed class EnumSet<E extends Enum<E>> extends AbstractSet<E>\n+    implements Cloneable, java.io.Serializable permits JumboEnumSet, RegularEnumSet\n","filename":"src\/java.base\/share\/classes\/java\/util\/EnumSet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -498,3 +498,3 @@\n-                float ft = ((float)s \/ loadFactor) + 1.0F;\n-                int t = ((ft < (float)MAXIMUM_CAPACITY) ?\n-                         (int)ft : MAXIMUM_CAPACITY);\n+                double dt = Math.ceil(s \/ (double)loadFactor);\n+                int t = ((dt < (double)MAXIMUM_CAPACITY) ?\n+                         (int)dt : MAXIMUM_CAPACITY);\n@@ -1530,2 +1530,2 @@\n-            float fc = (float)mappings \/ lf + 1.0f;\n-            int cap = ((fc < DEFAULT_INITIAL_CAPACITY) ?\n+            double dc = Math.ceil(mappings \/ (double)lf);\n+            int cap = ((dc < DEFAULT_INITIAL_CAPACITY) ?\n@@ -1533,1 +1533,1 @@\n-                       (fc >= MAXIMUM_CAPACITY) ?\n+                       (dc >= MAXIMUM_CAPACITY) ?\n@@ -1535,1 +1535,1 @@\n-                       tableSizeFor((int)fc));\n+                       tableSizeFor((int)dc));\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashMap.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-class JumboEnumSet<E extends Enum<E>> extends EnumSet<E> {\n+final class JumboEnumSet<E extends Enum<E>> extends EnumSet<E> {\n","filename":"src\/java.base\/share\/classes\/java\/util\/JumboEnumSet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -230,0 +230,1 @@\n+    @ForceInline\n@@ -255,0 +256,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/java\/util\/Objects.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-class RegularEnumSet<E extends Enum<E>> extends EnumSet<E> {\n+final class RegularEnumSet<E extends Enum<E>> extends EnumSet<E> {\n","filename":"src\/java.base\/share\/classes\/java\/util\/RegularEnumSet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,0 +259,6 @@\n+ * <p>\n+ * In cases where the {@code getBundle} factory method is called from a context\n+ * where there is no caller frame on the stack (e.g. when called directly from\n+ * a JNI attached thread), the caller module is default to the unnamed module for the\n+ * {@linkplain ClassLoader#getSystemClassLoader system class loader}.\n+ *\n@@ -1508,1 +1514,2 @@\n-        return getDefaultControl(caller.getModule(), baseName);\n+        Module callerModule = getCallerModule(caller);\n+        return getDefaultControl(callerModule, baseName);\n@@ -1539,1 +1546,2 @@\n-        if (caller.getModule().isNamed()) {\n+        Module callerModule = getCallerModule(caller);\n+        if (callerModule.isNamed()) {\n@@ -1549,1 +1557,13 @@\n-        return getBundleImpl(baseName, locale, caller, caller.getClassLoader(), control);\n+        ClassLoader loader = getLoader(getCallerModule(caller));\n+        return getBundleImpl(baseName, locale, caller, loader, control);\n+    }\n+\n+    \/*\n+     * Determine the module to be used for the caller.  If\n+     * Reflection::getCallerClass is called from JNI with an empty\n+     * stack frame the caller will be null, so the system class loader unnamed\n+     * module will be used.\n+     *\/\n+    private static Module getCallerModule(Class<?> caller) {\n+        return  (caller != null) ? caller.getModule()\n+                : ClassLoader.getSystemClassLoader().getUnnamedModule();\n@@ -1568,4 +1588,1 @@\n-        if (caller == null) {\n-            throw new InternalError(\"null caller\");\n-        }\n-        Module callerModule = caller.getModule();\n+        Module callerModule = getCallerModule(caller);\n@@ -1595,1 +1612,1 @@\n-        Module callerModule = caller.getModule();\n+        Module callerModule = getCallerModule(caller);\n@@ -2231,1 +2248,1 @@\n-        Class<?> caller = Reflection.getCallerClass();\n+        Module callerModule = getCallerModule(Reflection.getCallerClass());\n@@ -2233,1 +2250,1 @@\n-            key -> key.getCallerModule() == caller.getModule()\n+            key -> key.getCallerModule() == callerModule\n","filename":"src\/java.base\/share\/classes\/java\/util\/ResourceBundle.java","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -216,3 +216,1 @@\n-        int capacity = 1;\n-        while (capacity < initialCapacity)\n-            capacity <<= 1;\n+        int capacity = HashMap.tableSizeFor(initialCapacity);\n@@ -254,1 +252,1 @@\n-        this(Math.max((int) ((float)m.size() \/ DEFAULT_LOAD_FACTOR + 1.0F),\n+        this(Math.max((int) Math.ceil(m.size() \/ (double)DEFAULT_LOAD_FACTOR),\n@@ -471,1 +469,1 @@\n-        if (++size >= threshold)\n+        if (++size > threshold)\n@@ -560,1 +558,1 @@\n-            int targetCapacity = (int)(numKeysToBeAdded \/ loadFactor + 1);\n+            int targetCapacity = (int)Math.ceil(numKeysToBeAdded \/ (double)loadFactor);\n@@ -1043,1 +1041,1 @@\n-        Entry<K, V>[] tab = getTable();;\n+        Entry<K, V>[] tab = getTable();\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4008,0 +4008,2 @@\n+            } else {\n+                matcher.hitEnd = true;\n@@ -4009,1 +4011,0 @@\n-            matcher.hitEnd = true;\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -897,0 +897,10 @@\n+\n+    \/**\n+     * Returns the value of 'finish' flag.\n+     * 'finish' will be set to true if def.finish() method is called.\n+     *\/\n+    boolean shouldFinish() {\n+        synchronized (zsRef) {\n+            return finish;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,3 +223,9 @@\n-            def.finish();\n-            while (!def.finished()) {\n-                deflate();\n+            try{\n+                def.finish();\n+                while (!def.finished()) {\n+                    deflate();\n+                }\n+            } catch(IOException e) {\n+                if (usesDefaultDeflater)\n+                    def.end();\n+                throw e;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/DeflaterOutputStream.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1209,0 +1209,9 @@\n+                \/\/ Validate comment if it exists\n+                \/\/ if the bytes representing the comment cannot be converted to\n+                \/\/ a String via zcp.toString, an Exception will be thrown\n+                int clen = CENCOM(cen, pos);\n+                if (clen > 0) {\n+                    int elen = CENEXT(cen, pos);\n+                    int start = entryPos + nlen + elen;\n+                    zcp.toString(cen, start, clen);\n+                }\n@@ -1210,1 +1219,1 @@\n-                zerror(\"invalid CEN header (bad entry name)\");\n+                zerror(\"invalid CEN header (bad entry name or comment)\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -317,1 +317,1 @@\n-                if (usesDefaultDeflater && !(e instanceof ZipException))\n+                if (def.shouldFinish() && usesDefaultDeflater && !(e instanceof ZipException))\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,6 +123,2 @@\n-        UnsupportedOperationException uop = new\n-                UnsupportedOperationException();\n-        SocketException se =  new SocketException(\n-                \"Unconnected sockets not implemented\");\n-        se.initCause(uop);\n-        throw se;\n+        throw new SocketException(\"Unconnected sockets not implemented\",\n+                                  new UnsupportedOperationException());\n","filename":"src\/java.base\/share\/classes\/javax\/net\/SocketFactory.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,3 +39,1 @@\n-public\n-class SSLException extends IOException\n-{\n+public class SSLException extends IOException {\n@@ -51,2 +49,1 @@\n-    public SSLException(String reason)\n-    {\n+    public SSLException(String reason) {\n@@ -69,2 +66,1 @@\n-        super(message);\n-        initCause(cause);\n+        super(message, cause);\n@@ -86,2 +82,1 @@\n-        super(cause == null ? null : cause.toString());\n-        initCause(cause);\n+        super(cause);\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLException.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-\n@@ -29,1 +28,0 @@\n-\n@@ -37,3 +35,1 @@\n-public\n-class SSLHandshakeException extends SSLException\n-{\n+public class SSLHandshakeException extends SSLException {\n@@ -49,2 +45,1 @@\n-    public SSLHandshakeException(String reason)\n-    {\n+    public SSLHandshakeException(String reason) {\n@@ -53,0 +48,16 @@\n+\n+    \/**\n+     * Creates a {@code SSLHandshakeException} with the specified detail\n+     * message and cause.\n+     *\n+     * @param message the detail message (which is saved for later retrieval\n+     *        by the {@link #getMessage()} method).\n+     * @param cause the cause (which is saved for later retrieval by the\n+     *        {@link #getCause()} method).  (A {@code null} value is\n+     *        permitted, and indicates that the cause is nonexistent or\n+     *        unknown.)\n+     * @since 19\n+     *\/\n+    public SSLHandshakeException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLHandshakeException.java","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,1 @@\n-public\n-class SSLKeyException extends SSLException\n-{\n+public class SSLKeyException extends SSLException {\n@@ -48,2 +46,1 @@\n-    public SSLKeyException(String reason)\n-    {\n+    public SSLKeyException(String reason) {\n@@ -52,0 +49,16 @@\n+\n+    \/**\n+     * Creates a {@code SSLKeyException} with the specified detail\n+     * message and cause.\n+     *\n+     * @param message the detail message (which is saved for later retrieval\n+     *        by the {@link #getMessage()} method).\n+     * @param cause the cause (which is saved for later retrieval by the\n+     *        {@link #getCause()} method).  (A {@code null} value is\n+     *        permitted, and indicates that the cause is nonexistent or\n+     *        unknown.)\n+     * @since 19\n+     *\/\n+    public SSLKeyException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLKeyException.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -36,2 +36,3 @@\n- * the maximum network packet size, the algorithm constraints and whether\n- * SSL\/TLS\/DTLS servers should request or require client authentication, etc.\n+ * the maximum network packet size, the algorithm constraints, the signature\n+ * schemes and whether SSL\/TLS\/DTLS servers should request or require client\n+ * authentication, etc.\n@@ -39,3 +40,3 @@\n- * SSLParameters can be created via the constructors in this class.\n- * Objects can also be obtained using the {@code getSSLParameters()}\n- * methods in\n+ * {@code SSLParameter} objects can be created via the constructors in this\n+ * class, and can be described as pre-populated objects. {@code SSLParameter}\n+ * objects can also be obtained using the {@code getSSLParameters()} methods in\n@@ -47,1 +48,2 @@\n- * methods in {@code SSLContext}.\n+ * methods in {@code SSLContext}, and can be described as connection populated\n+ * objects.\n@@ -85,0 +87,1 @@\n+    private String[] signatureSchemes = null;\n@@ -90,5 +93,5 @@\n-     * constraints, endpoint identification algorithm, server names and\n-     * server name matchers are set to {@code null}; useCipherSuitesOrder,\n-     * wantClientAuth and needClientAuth are set to {@code false};\n-     * enableRetransmissions is set to {@code true}; maximum network packet\n-     * size is set to {@code 0}.\n+     * constraints, endpoint identification algorithm, signature schemes,\n+     * server names and server name matchers are set to {@code null};\n+     * useCipherSuitesOrder, wantClientAuth and needClientAuth are set\n+     * to {@code false}; enableRetransmissions is set to {@code true};\n+     * maximum network packet size is set to {@code 0}.\n@@ -370,1 +373,1 @@\n-     * In the following examples, the server name could be represented by an\n+     * In the following examples, the server name may be represented by an\n@@ -689,0 +692,121 @@\n+\n+    \/**\n+     * Returns a prioritized array of signature scheme names that can be used\n+     * over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of signature scheme names are defined in\n+     * the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#signature-schemes\">\n+     * Signature Schemes<\/a> section of the Java Security Standard Algorithm\n+     * Names Specification.  Providers may support signature schemes not defined\n+     * in this list or may not use the recommended name for a certain\n+     * signature scheme.\n+     * <p>\n+     * The set of signature schemes that will be used over the SSL\/TLS\/DTLS\n+     * connections is determined by the returned array of this method and the\n+     * underlying provider-specific default signature schemes.\n+     * <p>\n+     * If the returned array is {@code null}, then the underlying\n+     * provider-specific default signature schemes will be used over the\n+     * SSL\/TLS\/DTLS connections.\n+     * <p>\n+     * If the returned array is empty (zero-length), then the signature scheme\n+     * negotiation mechanism is turned off for SSL\/TLS\/DTLS protocols, and\n+     * the connections may not be able to be established if the negotiation\n+     * mechanism is required by a certain SSL\/TLS\/DTLS protocol.  This\n+     * parameter will override the underlying provider-specific default\n+     * signature schemes.\n+     * <p>\n+     * If the returned array is not {@code null} or empty (zero-length),\n+     * then the signature schemes in the returned array will be used over\n+     * the SSL\/TLS\/DTLS connections.  This parameter will override the\n+     * underlying provider-specific default signature schemes.\n+     * <p>\n+     * This method returns the most recent value passed to\n+     * {@link #setSignatureSchemes} if that method has been called and\n+     * otherwise returns the default signature schemes for connection\n+     * populated objects, or {@code null} for pre-populated objects.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may return {@code null} instead of the default\n+     * signature schemes for connection populated objects.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method.\n+     *\n+     * @implNote\n+     * Note that applications may use the\n+     * {@systemProperty jdk.tls.client.SignatureSchemes} and\/or\n+     * {@systemProperty jdk.tls.server.SignatureSchemes} system properties\n+     * with the SunJSSE provider to override the provider-specific default\n+     * signature schemes.\n+     *\n+     * @return an array of signature scheme {@code Strings} or {@code null} if\n+     *         none have been set.  For non-null returns, this method will\n+     *         return a new array each time it is invoked.  The array is\n+     *         ordered based on signature scheme preference, with the first\n+     *         entry being the most preferred.  Providers should ignore unknown\n+     *         signature scheme names while establishing the SSL\/TLS\/DTLS\n+     *         connections.\n+     * @see #setSignatureSchemes\n+     *\n+     * @since 19\n+     *\/\n+    public String[] getSignatureSchemes() {\n+        return clone(signatureSchemes);\n+    }\n+\n+    \/**\n+     * Sets the prioritized array of signature scheme names that\n+     * can be used over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of signature scheme names are defined in\n+     * the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#signature-schemes\">\n+     * Signature Schemes<\/a> section of the Java Security Standard Algorithm\n+     * Names Specification.  Providers may support signature schemes not\n+     * defined in this list or may not use the recommended name for a certain\n+     * signature scheme.\n+     * <p>\n+     * The set of signature schemes that will be used over the SSL\/TLS\/DTLS\n+     * connections is determined by the input parameter {@code signatureSchemes}\n+     * array and the underlying provider-specific default signature schemes.\n+     * See {@link #getSignatureSchemes} for specific details on how the\n+     * parameters are used in SSL\/TLS\/DTLS connections.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may ignore the schemes that are set.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method.\n+     *\n+     * @param signatureSchemes an ordered array of signature scheme names with\n+     *        the first entry being the most preferred, or {@code null}.  This\n+     *        method will make a copy of this array.  Providers should ignore\n+     *        unknown signature scheme names while establishing the\n+     *        SSL\/TLS\/DTLS connections.\n+     * @throws IllegalArgumentException if any element in the\n+     *        {@code signatureSchemes} array is {@code null} or\n+     *        {@linkplain String#isBlank() blank}.\n+     *\n+     * @see #getSignatureSchemes\n+     *\n+     * @since 19\n+     *\/\n+    public void setSignatureSchemes(String[] signatureSchemes) {\n+        String[] tempSchemes = null;\n+\n+        if (signatureSchemes != null) {\n+            tempSchemes = signatureSchemes.clone();\n+            for (String scheme : tempSchemes) {\n+                if (scheme == null || scheme.isBlank()) {\n+                    throw new IllegalArgumentException(\n+                        \"An element of signatureSchemes is null or blank\");\n+                }\n+            }\n+        }\n+\n+        this.signatureSchemes = tempSchemes;\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLParameters.java","additions":136,"deletions":12,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,1 @@\n-public\n-class SSLPeerUnverifiedException extends SSLException\n-{\n+public class SSLPeerUnverifiedException extends SSLException {\n@@ -54,2 +52,1 @@\n-    public SSLPeerUnverifiedException(String reason)\n-    {\n+    public SSLPeerUnverifiedException(String reason) {\n@@ -58,0 +55,16 @@\n+\n+    \/**\n+     * Creates a {@code SSLPeerUnverifiedException} with the specified detail\n+     * message and cause.\n+     *\n+     * @param message the detail message (which is saved for later retrieval\n+     *        by the {@link #getMessage()} method).\n+     * @param cause the cause (which is saved for later retrieval by the\n+     *        {@link #getCause()} method).  (A {@code null} value is\n+     *        permitted, and indicates that the cause is nonexistent or\n+     *        unknown.)\n+     * @since 19\n+     *\/\n+    public SSLPeerUnverifiedException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLPeerUnverifiedException.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,1 @@\n-public\n-class SSLProtocolException extends SSLException\n-{\n+public class SSLProtocolException extends SSLException {\n@@ -48,2 +46,1 @@\n-    public SSLProtocolException(String reason)\n-    {\n+    public SSLProtocolException(String reason) {\n@@ -52,0 +49,16 @@\n+\n+    \/**\n+     * Creates a {@code SSLProtocolException} with the specified detail\n+     * message and cause.\n+     *\n+     * @param message the detail message (which is saved for later retrieval\n+     *        by the {@link #getMessage()} method).\n+     * @param cause the cause (which is saved for later retrieval by the\n+     *        {@link #getCause()} method).  (A {@code null} value is\n+     *        permitted, and indicates that the cause is nonexistent or\n+     *        unknown.)\n+     * @since 19\n+     *\/\n+    public SSLProtocolException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLProtocolException.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -176,2 +176,1 @@\n-        throw (SocketException)\n-            new SocketException(reason.toString()).initCause(reason);\n+        throw new SocketException(reason.toString(), reason);\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLServerSocketFactory.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -177,11 +177,13 @@\n- * For {@code SSLSocket} objects, for example, an application can call\n- * {@link Socket#shutdownOutput()} or {@link java.io.OutputStream#close()}\n- * for output stream close and call {@link Socket#shutdownInput()} or\n- * {@link java.io.InputStream#close()} for input stream close.  Note that\n- * in some cases, closing the input stream may depend on the peer's output\n- * stream being closed first.  If the connection is not closed in an orderly\n- * manner (for example {@link Socket#shutdownInput()} is called before the\n- * peer's write closure notification has been received), exceptions may\n- * be raised to indicate that an error has occurred.  Once an\n- * {@code SSLSocket} is closed, it is not reusable: a new {@code SSLSocket}\n- * must be created.\n+ * This can be done either in one shot by calling {@link Socket#close()},\n+ * or by closing each side individually using\n+ * {@link Socket#shutdownOutput()} \/ {@link Socket#shutdownInput()} which is\n+ * useful for protocol versions that can support half-closed connections.\n+ *\n+ * <P> Note that in some cases, closing the input stream may depend on the\n+ * peer's output stream being closed first.  If the connection is not closed\n+ * in an orderly manner (for example {@link Socket#shutdownInput()} is called\n+ * before the peer's write closure notification has been received), exceptions\n+ * may be raised to indicate that an error has occurred.\n+ *\n+ * <P> Once an {@code SSLSocket} is closed, it is not reusable: a new\n+ * {@code SSLSocket} must be created.\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLSocket.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -266,2 +266,1 @@\n-        throw (SocketException)\n-            new SocketException(reason.toString()).initCause(reason);\n+        throw new SocketException(reason.toString(), reason);\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLSocketFactory.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-            NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin, true);\n+            NativeLibraryImpl lib = new NativeLibraryImpl(fromClass, name, isBuiltin);\n@@ -284,1 +284,1 @@\n-    static class NativeLibraryImpl implements NativeLibrary {\n+    static class NativeLibraryImpl extends NativeLibrary {\n@@ -293,2 +293,0 @@\n-        \/\/ Indicate if this is JNI native library\n-        final boolean isJNI;\n@@ -301,3 +299,1 @@\n-        NativeLibraryImpl(Class<?> fromClass, String name, boolean isBuiltin, boolean isJNI) {\n-            assert !isBuiltin || isJNI : \"a builtin native library must be JNI library\";\n-\n+        NativeLibraryImpl(Class<?> fromClass, String name, boolean isBuiltin) {\n@@ -307,1 +303,0 @@\n-            this.isJNI = isJNI;\n@@ -317,1 +312,1 @@\n-            return findEntry0(this, name);\n+            return findEntry0(handle, name);\n@@ -325,1 +320,1 @@\n-            return new Unloader(name, handle, isBuiltin, isJNI);\n+            return new Unloader(name, handle, isBuiltin);\n@@ -336,1 +331,1 @@\n-            return load(this, name, isBuiltin, isJNI, loadLibraryOnlyIfPresent);\n+            return load(this, name, isBuiltin, loadLibraryOnlyIfPresent);\n@@ -343,1 +338,1 @@\n-            unload(name, isBuiltin, isJNI, handle);\n+            unload(name, isBuiltin, handle);\n@@ -355,1 +350,1 @@\n-                new NativeLibraryImpl(null, \"dummy\", false, false);\n+                new NativeLibraryImpl(null, \"dummy\", false);\n@@ -360,1 +355,0 @@\n-        final boolean isJNI;\n@@ -362,2 +356,1 @@\n-        Unloader(String name, long handle, boolean isBuiltin, boolean isJNI) {\n-            assert !isBuiltin || isJNI : \"a builtin native library must be JNI library\";\n+        Unloader(String name, long handle, boolean isBuiltin) {\n@@ -372,1 +365,0 @@\n-            this.isJNI = isJNI;\n@@ -380,1 +372,1 @@\n-                if (isJNI && !loadedLibraryNames.remove(name)) {\n+                if (!loadedLibraryNames.remove(name)) {\n@@ -385,1 +377,1 @@\n-                    unload(name, isBuiltin, isJNI, handle);\n+                    unload(name, isBuiltin, handle);\n@@ -527,2 +519,9 @@\n-    \/\/ JNI FindClass expects the caller class if invoked from JNI_OnLoad\n-    \/\/ and JNI_OnUnload is NativeLibrary class\n+    \/*\n+     * Return true if the given library is successfully loaded.\n+     * If the given library cannot be loaded for any reason,\n+     * if throwExceptionIfFail is false, then this method returns false;\n+     * otherwise, UnsatisfiedLinkError will be thrown.\n+     *\n+     * JNI FindClass expects the caller class if invoked from JNI_OnLoad\n+     * and JNI_OnUnload is NativeLibrary class.\n+     *\/\n@@ -530,1 +529,1 @@\n-                                       boolean isBuiltin, boolean isJNI,\n+                                       boolean isBuiltin,\n@@ -532,1 +531,5 @@\n-    private static native void unload(String name, boolean isBuiltin, boolean isJNI, long handle);\n+    \/*\n+     * Unload the named library.  JNI_OnUnload, if present, will be invoked\n+     * before the native library is unloaded.\n+     *\/\n+    private static native void unload(String name, boolean isBuiltin, long handle);\n@@ -534,1 +537,0 @@\n-    private static native long findEntry0(NativeLibraryImpl lib, String name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":26,"deletions":24,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-public interface NativeLibrary {\n-    String name();\n+public abstract class NativeLibrary {\n+    public abstract String name();\n@@ -40,1 +40,1 @@\n-    long find(String name);\n+    public abstract long find(String name);\n@@ -48,1 +48,1 @@\n-    default long lookup(String name) throws NoSuchMethodException {\n+    public final long lookup(String name) throws NoSuchMethodException {\n@@ -55,0 +55,6 @@\n+\n+    \/*\n+     * Returns the address of the named symbol defined in the library of\n+     * the given handle.  Returns 0 if not found.\n+     *\/\n+    static native long findEntry0(long handle, String name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibrary.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,3 +38,0 @@\n-import static jdk.internal.loader.NativeLibraries.*;\n-\n-\n@@ -51,1 +48,1 @@\n-    final Map<String, NativeLibraryImpl> libraries = new ConcurrentHashMap<>();\n+    final Map<String, RawNativeLibraryImpl> libraries = new ConcurrentHashMap<>();\n@@ -119,2 +116,2 @@\n-    private NativeLibraryImpl get(String pathname) {\n-        NativeLibraryImpl lib = new NativeLibraryImpl(caller, pathname, false, false);\n+    private RawNativeLibraryImpl get(String pathname) {\n+        RawNativeLibraryImpl lib = new RawNativeLibraryImpl(caller, pathname);\n@@ -122,1 +119,1 @@\n-            return null;    \/\/ fail to open the native library\n+            return null;\n@@ -135,1 +132,1 @@\n-        NativeLibraryImpl nl = (NativeLibraryImpl)lib;\n+        RawNativeLibraryImpl nl = (RawNativeLibraryImpl)lib;\n@@ -138,0 +135,41 @@\n+\n+    static class RawNativeLibraryImpl extends NativeLibrary {\n+        \/\/ the name of the raw native library.\n+        final String name;\n+        \/\/ opaque handle to raw native library, used in native code.\n+        long handle;\n+\n+        RawNativeLibraryImpl(Class<?> fromClass, String name) {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public String name() {\n+            return name;\n+        }\n+\n+        @Override\n+        public long find(String name) {\n+            return findEntry0(handle, name);\n+        }\n+\n+        \/*\n+         * Loads the named native library.\n+         *\/\n+        boolean open() {\n+            if (handle != 0) {\n+                throw new InternalError(\"Native library \" + name + \" has been loaded\");\n+            }\n+            return load0(this, name);\n+        }\n+\n+        \/*\n+         * Close this native library.\n+         *\/\n+        void close() {\n+            unload0(name, handle);\n+        }\n+    }\n+\n+    private static native boolean load0(RawNativeLibraryImpl impl, String name);\n+    private static native void unload0(String name, long handle);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/RawNativeLibraries.java","additions":46,"deletions":8,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-                            \"More than on LoggerFinder implementation\");\n+                            \"More than one LoggerFinder implementation\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/LoggerFinderLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -665,0 +665,1 @@\n+        String separator = dir.getFileSystem().getSeparator();\n@@ -669,1 +670,1 @@\n-                    .map(this::toPackageName)\n+                    .map(path -> toPackageName(path, separator))\n@@ -740,1 +741,1 @@\n-    private Optional<String> toPackageName(Path file) {\n+    private Optional<String> toPackageName(Path file, String separator) {\n@@ -754,1 +755,1 @@\n-        String pn = parent.toString().replace(File.separatorChar, '.');\n+        String pn = parent.toString().replace(separator, \".\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModulePath.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-            result[j>>3] = (result[j>>3] << 8) | seed[j];\n+            result[j>>3] = (result[j>>3] << 8) | (seed[j] & 0xFF);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/random\/RandomSupport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -664,3 +664,10 @@\n-        if (inCache) {\n-            assert false : \"Duplicate put to keep alive cache\";\n-            return;\n+        lock();\n+        try {\n+            if (inCache) {\n+                assert false : \"Duplicate put to keep alive cache\";\n+                return;\n+            }\n+            inCache = true;\n+            kac.put(url, sslSocketFactory, this);\n+        } finally {\n+            unlock();\n@@ -668,2 +675,0 @@\n-        inCache = true;\n-        kac.put(url, sslSocketFactory, this);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,3 +222,1 @@\n-                var exc = new SocketException(\"Socket closed\");\n-                exc.initCause(e);\n-                throw exc;\n+                throw new SocketException(\"Socket closed\", e);\n@@ -252,3 +250,1 @@\n-            var exc = new SocketException(\"Socket closed\");\n-            exc.initCause(e);\n-            throw exc;\n+            throw new SocketException(\"Socket closed\", e);\n@@ -484,1 +480,1 @@\n-            throw (SocketException) new SocketException(\"joinGroup failed\").initCause(iae);\n+            throw new SocketException(\"joinGroup failed\", iae);\n@@ -496,1 +492,1 @@\n-            throw (SocketException) new SocketException(\"leaveGroup failed\").initCause(iae);\n+            throw new SocketException(\"leaveGroup failed\", iae);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramSocketAdaptor.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,2 +213,4 @@\n-        add(p, \"MessageDigest\", \"MD2\", \"sun.security.provider.MD2\", attrs);\n-        add(p, \"MessageDigest\", \"MD5\", \"sun.security.provider.MD5\", attrs);\n+        addWithAlias(p, \"MessageDigest\", \"MD2\", \"sun.security.provider.MD2\",\n+                attrs);\n+        addWithAlias(p, \"MessageDigest\", \"MD5\", \"sun.security.provider.MD5\",\n+                attrs);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SunEntries.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,0 @@\n-        SSLException ssle;\n@@ -127,1 +126,1 @@\n-            ssle = new SSLException(reason);\n+            return new SSLException(reason, cause);\n@@ -129,1 +128,1 @@\n-            ssle = new SSLProtocolException(reason);\n+            return new SSLProtocolException(reason, cause);\n@@ -131,1 +130,1 @@\n-            ssle = new SSLHandshakeException(reason);\n+            return new SSLHandshakeException(reason, cause);\n@@ -133,1 +132,1 @@\n-            ssle = new SSLException(reason);\n+            return new SSLException(reason, cause);\n@@ -135,6 +134,0 @@\n-\n-        if (cause != null) {\n-            ssle.initCause(cause);\n-        }\n-\n-        return ssle;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Alert.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -298,2 +298,2 @@\n-                throw (SSLHandshakeException)(new SSLHandshakeException(\n-                        \"Could not generate DHPublicKey\").initCause(e));\n+                throw new SSLHandshakeException(\n+                        \"Could not generate DHPublicKey\", e);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHClientKeyExchange.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,2 +163,1 @@\n-                throw (SSLHandshakeException) new SSLHandshakeException(\n-                    \"Could not generate secret\").initCause(e);\n+                throw new SSLHandshakeException(\"Could not generate secret\", e);\n@@ -180,2 +179,1 @@\n-                throw (SSLHandshakeException) new SSLHandshakeException(\n-                    \"Could not generate secret\").initCause(e);\n+                throw new SSLHandshakeException(\"Could not generate secret\", e);\n@@ -205,2 +203,2 @@\n-                throw (SSLHandshakeException) new SSLHandshakeException(\n-                        \"Could not generate ECPublicKey\").initCause(e);\n+                throw new SSLHandshakeException(\n+                        \"Could not generate ECPublicKey\", e);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECDHKeyExchange.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,2 +91,1 @@\n-            throw (SSLHandshakeException) new SSLHandshakeException(\n-                    \"Could not generate secret\").initCause(gse);\n+            throw new SSLHandshakeException(\"Could not generate secret\", gse);\n@@ -128,2 +127,1 @@\n-            throw (SSLHandshakeException) new SSLHandshakeException(\n-                    \"Could not generate secret\").initCause(gse);\n+            throw new SSLHandshakeException(\"Could not generate secret\", gse);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KAKeyDerivation.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,2 +305,1 @@\n-            throw (SSLHandshakeException) new SSLHandshakeException(\n-                    \"Could not derive PSK\").initCause(gse);\n+            throw new SSLHandshakeException(\"Could not derive PSK\", gse);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -293,1 +293,1 @@\n-                        \"Unsupported protocol\" + pn);\n+                        \"Unsupported protocol: \" + pn);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ProtocolVersion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,1 @@\n-            throw (SSLHandshakeException) new SSLHandshakeException(\n-                \"Could not generate secret\").initCause(gse);\n+            throw new SSLHandshakeException(\"Could not generate secret\", gse);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLBasicKeyDerivation.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1870,1 +1870,1 @@\n-                        algorithm.toUpperCase(Locale.ENGLISH) + \":\" + tag[0], 0L);\n+                    algorithm.toUpperCase(Locale.ENGLISH) + \":\" + tag[0], 0L);\n@@ -1873,1 +1873,1 @@\n-                            algorithm.toUpperCase(Locale.ENGLISH) + \":\" + tag[0] +\n+                            algorithm + \":\" + tag[0] +\n@@ -2024,1 +2024,1 @@\n-                        algorithm.toUpperCase(Locale.ENGLISH) + \":\" + tag[0], 0L);\n+                    algorithm.toUpperCase(Locale.ENGLISH) + \":\" + tag[0], 0L);\n@@ -2027,1 +2027,1 @@\n-                            + algorithm.toUpperCase(Locale.ENGLISH) + \":\" + tag[0] +\n+                            + algorithm + \":\" + tag[0] +\n@@ -2284,1 +2284,1 @@\n-                        algorithm.toUpperCase(Locale.ENGLISH) + \":\" + tag[0], 0L);\n+                    algorithm.toUpperCase(Locale.ENGLISH) + \":\" + tag[0], 0L);\n@@ -2286,1 +2286,1 @@\n-                    SSLLogger.fine(\"algorithm = \" + algorithm.toUpperCase(Locale.ENGLISH) +\n+                    SSLLogger.fine(\"algorithm = \" + algorithm +\n@@ -2566,1 +2566,1 @@\n-                        algorithm.toUpperCase(Locale.ENGLISH) + \":\" + tag[0], 0L);\n+                    algorithm.toUpperCase(Locale.ENGLISH) + \":\" + tag[0], 0L);\n@@ -2568,1 +2568,1 @@\n-                    SSLLogger.fine(\"algorithm = \" + algorithm.toUpperCase(Locale.ENGLISH) +\n+                    SSLLogger.fine(\"algorithm = \" + algorithm +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLCipher.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,5 +32,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n+import java.util.*;\n@@ -69,1 +65,1 @@\n-    List<SignatureScheme>       signatureSchemes;\n+    String[]                   signatureSchemes;\n@@ -207,0 +203,1 @@\n+        params.setSignatureSchemes(this.signatureSchemes);\n@@ -264,0 +261,7 @@\n+        String[] ss = params.getSignatureSchemes();\n+        if (ss != null) {\n+            \/\/ Note if 'ss' is empty, then no signature schemes should be\n+            \/\/ specified over the connections.\n+            this.signatureSchemes = ss;\n+        }   \/\/ Otherwise, use the default values\n+\n@@ -406,4 +410,9 @@\n-        \/\/ reset the signature schemes\n-        this.signatureSchemes = isClientMode ?\n-                CustomizedClientSignatureSchemes.signatureSchemes :\n-                CustomizedServerSignatureSchemes.signatureSchemes;\n+        \/\/ Reset the signature schemes, if it was configured with SSLParameters.\n+        if (Arrays.equals(signatureSchemes,\n+                CustomizedClientSignatureSchemes.signatureSchemes) ||\n+            Arrays.equals(signatureSchemes,\n+                    CustomizedServerSignatureSchemes.signatureSchemes)) {\n+            this.signatureSchemes = isClientMode ?\n+                    CustomizedClientSignatureSchemes.signatureSchemes :\n+                    CustomizedServerSignatureSchemes.signatureSchemes;\n+        }\n@@ -437,1 +446,1 @@\n-        private static final List<SignatureScheme> signatureSchemes =\n+        private static final String[] signatureSchemes =\n@@ -445,1 +454,1 @@\n-        private static final List<SignatureScheme> signatureSchemes =\n+        private static final String[] signatureSchemes =\n@@ -453,3 +462,1 @@\n-    private static List<SignatureScheme> getCustomizedSignatureScheme(\n-            String propertyName) {\n-\n+    private static String[] getCustomizedSignatureScheme(String propertyName) {\n@@ -460,1 +467,1 @@\n-                    property + \"'\");\n+                            property + \"'\");\n@@ -472,5 +479,5 @@\n-            List<SignatureScheme> signatureSchemes =\n-                        new ArrayList<>(signatureSchemeNames.length);\n-            for (int i = 0; i < signatureSchemeNames.length; i++) {\n-                signatureSchemeNames[i] = signatureSchemeNames[i].trim();\n-                if (signatureSchemeNames[i].isEmpty()) {\n+            List<String> signatureSchemes =\n+                    new ArrayList<>(signatureSchemeNames.length);\n+            for (String schemeName : signatureSchemeNames) {\n+                schemeName = schemeName.trim();\n+                if (schemeName.isEmpty()) {\n@@ -480,2 +487,2 @@\n-                SignatureScheme scheme =\n-                    SignatureScheme.nameOf(signatureSchemeNames[i]);\n+                \/\/ Check the availability\n+                SignatureScheme scheme = SignatureScheme.nameOf(schemeName);\n@@ -483,1 +490,1 @@\n-                    signatureSchemes.add(scheme);\n+                    signatureSchemes.add(schemeName);\n@@ -487,3 +494,2 @@\n-                                \"The current installed providers do not \" +\n-                                \"support signature scheme: \" +\n-                                signatureSchemeNames[i]);\n+                        \"The current installed providers do not \" +\n+                              \"support signature scheme: \" + schemeName);\n@@ -494,1 +500,3 @@\n-            return signatureSchemes;\n+            if (!signatureSchemes.isEmpty()) {\n+                return signatureSchemes.toArray(new String[0]);\n+            }\n@@ -497,1 +505,3 @@\n-        return Collections.emptyList();\n+        \/\/ Note that if the System Property value is not defined (JDK\n+        \/\/ default value) or empty, the provider-specific default is used.\n+        return null;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1170,2 +1170,1 @@\n-            return (SSLHandshakeException)\n-                new SSLHandshakeException(msg).initCause(taskThrown);\n+            return new SSLHandshakeException(msg, taskThrown);\n@@ -1173,2 +1172,1 @@\n-            return (SSLKeyException)\n-                new SSLKeyException(msg).initCause(taskThrown);\n+            return new SSLKeyException(msg, taskThrown);\n@@ -1176,2 +1174,1 @@\n-            return (SSLPeerUnverifiedException)\n-                new SSLPeerUnverifiedException(msg).initCause(taskThrown);\n+            return new SSLPeerUnverifiedException(msg, taskThrown);\n@@ -1179,2 +1176,1 @@\n-            return (SSLProtocolException)\n-                new SSLProtocolException(msg).initCause(taskThrown);\n+            return new SSLProtocolException(msg, taskThrown);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,2 +245,1 @@\n-            throw (SSLProtocolException)(new SSLProtocolException(\n-                    \"Unexpected exception\")).initCause(gse);\n+            throw new SSLProtocolException(\"Unexpected exception\", gse);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineInputRecord.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,2 +116,1 @@\n-            throw (SSLHandshakeException) new SSLHandshakeException(\n-                \"Could not generate secret\").initCause(gse);\n+            throw new SSLHandshakeException(\"Could not generate secret\", gse);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSecretDerivation.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1712,1 +1712,0 @@\n-            SSLException ssle;\n@@ -1714,2 +1713,2 @@\n-                ssle = new SSLHandshakeException(\n-                        \"Remote host terminated the handshake\");\n+                throw new SSLHandshakeException(\n+                        \"Remote host terminated the handshake\",  eofe);\n@@ -1717,6 +1716,2 @@\n-                ssle = new SSLProtocolException(\n-                        \"Remote host terminated the connection\");\n-            }\n-\n-            if (eofe != null) {\n-                ssle.initCause(eofe);\n+                throw new SSLProtocolException(\n+                        \"Remote host terminated the connection\", eofe);\n@@ -1724,1 +1719,0 @@\n-            throw ssle;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,2 +266,1 @@\n-            throw (SSLProtocolException)(new SSLProtocolException(\n-                    \"Unexpected exception\")).initCause(gse);\n+            throw new SSLProtocolException(\"Unexpected exception\", gse);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketInputRecord.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,2 +157,2 @@\n-                throw (SSLHandshakeException)(new SSLHandshakeException(\n-                    \"Could not generate secret\").initCause(gse));\n+                throw new SSLHandshakeException(\n+                        \"Could not generate secret\", gse);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTrafficKeyDerivation.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1208,2 +1208,1 @@\n-            throw (SSLHandshakeException) new SSLHandshakeException(\n-                \"Could not generate secret\").initCause(gse);\n+            throw new SSLHandshakeException(\"Could not generate secret\", gse);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,3 +138,2 @@\n-                            Utilities.toHexString(encoded) + \"}\");\n-                        throw hc.conContext.fatal(Alert.ILLEGAL_PARAMETER,\n-                                (SSLProtocolException)spe.initCause(iae));\n+                            Utilities.toHexString(encoded) + \"}\", iae);\n+                        throw hc.conContext.fatal(Alert.ILLEGAL_PARAMETER, spe);\n@@ -149,3 +148,2 @@\n-                            Utilities.toHexString(encoded) + \"}\");\n-                        throw hc.conContext.fatal(Alert.ILLEGAL_PARAMETER,\n-                                (SSLProtocolException)spe.initCause(iae));\n+                            Utilities.toHexString(encoded) + \"}\", iae);\n+                        throw hc.conContext.fatal(Alert.ILLEGAL_PARAMETER, spe);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerNameExtension.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-    static enum SigAlgParamSpec {   \/\/ support RSASSA-PSS only now\n+    enum SigAlgParamSpec {   \/\/ support RSASSA-PSS only now\n@@ -227,1 +227,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -233,1 +233,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -241,1 +241,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -250,1 +250,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -259,1 +259,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -379,5 +379,0 @@\n-        \/\/ If config.signatureSchemes is non-empty then it means that\n-        \/\/ it was defined by a System property.  Per\n-        \/\/ SSLConfiguration.getCustomizedSignatureScheme() the list will\n-        \/\/ only contain schemes that are in the enum.\n-        \/\/ Otherwise, use the enum constants (converted to a List).\n@@ -385,1 +380,1 @@\n-                config.signatureSchemes.isEmpty() ?\n+                config.signatureSchemes == null ?\n@@ -387,1 +382,1 @@\n-                    config.signatureSchemes;\n+                    namesOfAvailable(config.signatureSchemes);\n@@ -440,2 +435,2 @@\n-                    (config.signatureSchemes.isEmpty() ||\n-                        config.signatureSchemes.contains(ss)) &&\n+                    (config.signatureSchemes == null ||\n+                        Utilities.contains(config.signatureSchemes, ss.name)) &&\n@@ -566,0 +561,27 @@\n+    private static List<SignatureScheme> namesOfAvailable(\n+                String[] signatureSchemes) {\n+\n+        if (signatureSchemes == null || signatureSchemes.length == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<SignatureScheme> sss = new ArrayList<>(signatureSchemes.length);\n+        for (String ss : signatureSchemes) {\n+            SignatureScheme scheme = SignatureScheme.nameOf(ss);\n+            if (scheme == null || !scheme.isAvailable) {\n+                if (SSLLogger.isOn &&\n+                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                    SSLLogger.finest(\n+                            \"Ignore the signature algorithm (\" + ss\n+                          + \"), unsupported or unavailable\");\n+                }\n+\n+                continue;\n+            }\n+\n+            sss.add(scheme);\n+        }\n+\n+        return sss;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":38,"deletions":16,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,0 +232,10 @@\n+    static <T> boolean contains(T[] array, T item) {\n+        for (T t : array) {\n+            if (item.equals(t)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Utilities.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.security.interfaces.ECKey;\n-import java.security.interfaces.EdECKey;\n@@ -1289,0 +1287,1 @@\n+                    && !protectedPath\n@@ -1688,0 +1687,1 @@\n+                && !protectedPath\n@@ -2019,1 +2019,1 @@\n-                    fullDisplayAlgName(privKey),\n+                    KeyUtil.fullDisplayAlgName(privKey),\n@@ -2030,1 +2030,1 @@\n-                    fullDisplayAlgName(privKey),\n+                    KeyUtil.fullDisplayAlgName(privKey),\n@@ -3561,14 +3561,0 @@\n-    private String fullDisplayAlgName(Key key) {\n-        String result = key.getAlgorithm();\n-        if (key instanceof ECKey) {\n-            ECParameterSpec paramSpec = ((ECKey) key).getParams();\n-            if (paramSpec instanceof NamedCurve) {\n-                NamedCurve nc = (NamedCurve)paramSpec;\n-                result += \" (\" + nc.getNameAndAliases()[0] + \")\";\n-            }\n-        } else if (key instanceof EdECKey) {\n-            result = ((EdECKey) key).getParams().getName();\n-        }\n-        return result;\n-    }\n-\n@@ -3578,1 +3564,1 @@\n-        String displayAlg = fullDisplayAlgName(key);\n+        String displayAlg = KeyUtil.fullDisplayAlgName(key);\n@@ -4947,1 +4933,1 @@\n-                            KeyUtil.getKeySize(key), fullDisplayAlgName(key))));\n+                            KeyUtil.getKeySize(key), KeyUtil.fullDisplayAlgName(key))));\n@@ -4953,1 +4939,1 @@\n-                        KeyUtil.getKeySize(key), fullDisplayAlgName(key))));\n+                        KeyUtil.getKeySize(key), KeyUtil.fullDisplayAlgName(key))));\n@@ -4974,1 +4960,1 @@\n-                    KeyUtil.getKeySize(key), fullDisplayAlgName(key))));\n+                    KeyUtil.getKeySize(key), KeyUtil.fullDisplayAlgName(key))));\n@@ -4979,1 +4965,1 @@\n-                    KeyUtil.getKeySize(key), fullDisplayAlgName(key))));\n+                    KeyUtil.getKeySize(key), KeyUtil.fullDisplayAlgName(key))));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    private void permits(AlgorithmParameters ap, ConstraintsParameters cp)\n+    public void permits(AlgorithmParameters ap, ConstraintsParameters cp)\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-     * [RFC5280].  If more than one identity of a given type is present in\n+     * [RFC6125].  If more than one identity of a given type is present in\n@@ -265,1 +265,1 @@\n-     * The matching is performed as per RFC 2818 rules for TLS and\n+     * The matching is performed as per RFC 2818\/6125 rules for TLS and\n@@ -302,3 +302,1 @@\n-        if (checkType == TYPE_TLS) {\n-            return matchAllWildcards(name, template);\n-        } else if (checkType == TYPE_LDAP) {\n+        if (checkType == TYPE_TLS || checkType == TYPE_LDAP) {\n@@ -374,31 +372,0 @@\n-    \/**\n-     * Returns true if name matches against template.<p>\n-     *\n-     * According to RFC 2818, section 3.1 -\n-     * Names may contain the wildcard character * which is\n-     * considered to match any single domain name component\n-     * or component fragment.\n-     * E.g., *.a.com matches foo.a.com but not\n-     * bar.foo.a.com. f*.com matches foo.com but not bar.com.\n-     *\/\n-    private static boolean matchAllWildcards(String name,\n-         String template) {\n-        name = name.toLowerCase(Locale.ENGLISH);\n-        template = template.toLowerCase(Locale.ENGLISH);\n-        StringTokenizer nameSt = new StringTokenizer(name, \".\");\n-        StringTokenizer templateSt = new StringTokenizer(template, \".\");\n-\n-        if (nameSt.countTokens() != templateSt.countTokens()) {\n-            return false;\n-        }\n-\n-        while (nameSt.hasMoreTokens()) {\n-            if (!matchWildCards(nameSt.nextToken(),\n-                        templateSt.nextToken())) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/HostnameChecker.java","additions":4,"deletions":37,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,0 +193,22 @@\n+    \/**\n+     * Returns the algorithm name of the given key object. If an EC key is\n+     * specified, returns the algorithm name and its named curve.\n+     *\n+     * @param key the key object, cannot be null\n+     * @return the algorithm name of the given key object, or return in the\n+     *       form of \"EC (named curve)\" if the given key object is an EC key\n+     *\/\n+    public static final String fullDisplayAlgName(Key key) {\n+        String result = key.getAlgorithm();\n+        if (key instanceof ECKey) {\n+            ECParameterSpec paramSpec = ((ECKey) key).getParams();\n+            if (paramSpec instanceof NamedCurve) {\n+                NamedCurve nc = (NamedCurve)paramSpec;\n+                result += \" (\" + nc.getNameAndAliases()[0] + \")\";\n+            }\n+        } else if (key instanceof EdECKey) {\n+            result = ((EdECKey) key).getParams().getName();\n+        }\n+        return result;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,2 @@\n-     * Convert OID.1.2.3.4 or 1.2.3.4 to its matching stdName.\n+     * Convert OID.1.2.3.4 or 1.2.3.4 to its matching stdName, and return\n+     * upper case algorithm name.\n@@ -53,2 +54,1 @@\n-     * @return the matching stdName, or {@code algName} if it is not in the\n-     *      form of an OID, or the OID value if no match is found.\n+     * @return the matching algorithm name or the OID string in upper case.\n@@ -57,3 +57,2 @@\n-        if (!algName.contains(\".\")) {\n-            return algName;\n-        } else {\n+        algName = algName.toUpperCase(Locale.ENGLISH);\n+        if (algName.contains(\".\")) {\n@@ -64,0 +63,1 @@\n+\n@@ -65,1 +65,3 @@\n-            return ko != null ? ko.stdName() : algName;\n+            if (ko != null) {\n+                return ko.stdName().toUpperCase(Locale.ENGLISH);\n+            }\n@@ -67,0 +69,2 @@\n+\n+        return algName;\n@@ -71,0 +75,4 @@\n+    \/\/\n+    \/\/ Note this method can be called only after converting OID.1.2.3.4 or\n+    \/\/ 1.2.3.4 to its matching stdName, which is implemented in the\n+    \/\/ checkName(String) method.\n@@ -75,1 +83,0 @@\n-            algName = checkName(algName);\n@@ -99,1 +106,1 @@\n-            sigName = checkName(sigName).toUpperCase(Locale.ENGLISH);\n+            sigName = checkName(sigName);\n@@ -143,1 +150,1 @@\n-            sigName = checkName(sigName).toUpperCase(Locale.ENGLISH);\n+            sigName = checkName(sigName);\n@@ -316,1 +323,1 @@\n-        if (sigAlg.equalsIgnoreCase(\"RSASSA-PSS\")) {\n+        if (sigAlg.equals(\"RSASSA-PSS\")) {\n@@ -431,1 +438,1 @@\n-        sAlg = checkName(sAlg).toUpperCase(Locale.ENGLISH);\n+        sAlg = checkName(sAlg);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,4 +51,4 @@\n-    private String name;\n-    private ObjectIdentifier oid;\n-    private byte[] nameValue = null;\n-    private GeneralNameInterface gni = null;\n+    private final ObjectIdentifier oid;\n+    private final String name;\n+    private final byte[] nameValue; \/\/ value inside [0]\n+    private final GeneralNameInterface gni;\n@@ -92,2 +92,6 @@\n-        DerValue val = in.getDerValue();\n-        nameValue = val.toByteArray();\n+        DerValue derValue1 = in.getDerValue();\n+        if (derValue1.isContextSpecific((byte) 0) && derValue1.isConstructed()) {\n+            nameValue = derValue1.data.toByteArray();\n+        } else {\n+            throw new IOException(\"value is not EXPLICTly tagged [0]\");\n+        }\n@@ -128,6 +132,7 @@\n-            Constructor<?> cons = extClass.getConstructor(params);\n-\n-            Object[] passed = new Object[] { nameValue };\n-            GeneralNameInterface gni =\n-                       (GeneralNameInterface)cons.newInstance(passed);\n-            return gni;\n+            Constructor<?> cons;\n+            try {\n+                cons = extClass.getConstructor(Object.class);\n+            } catch (NoSuchMethodException e) {\n+                cons = extClass.getConstructor(byte[].class);\n+            }\n+            return (GeneralNameInterface)cons.newInstance(nameValue);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/OtherName.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1587,0 +1587,11 @@\n+                if (name.getType() == GeneralNameInterface.NAME_ANY\n+                        && name instanceof OtherName oname) {\n+                    nameEntry.add(oname.getOID().toString());\n+                    byte[] nameValue = oname.getNameValue();\n+                    try {\n+                        String v = new DerValue(nameValue).getAsString();\n+                        nameEntry.add(v == null ? nameValue : v);\n+                    } catch (IOException ioe) {\n+                        nameEntry.add(nameValue);\n+                    }\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-                PlatformLogger.ConfigurableBridge.getLoggerConfiguration(loggerProxy);;\n+                PlatformLogger.ConfigurableBridge.getLoggerConfiguration(loggerProxy);\n","filename":"src\/java.base\/share\/classes\/sun\/util\/logging\/PlatformLogger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1984,0 +1984,28 @@\n+.TP\n+.B \\f[CB]\\-XX:UseBranchProtection=\\f[R]\\f[I]mode\\f[R]\n+\\f[B]Linux AArch64 only:\\f[R] Specifies the branch protection mode.\n+All options other than \\f[CB]none\\f[R] require the VM to have been built\n+with branch protection enabled.\n+In addition, for full protection, any native libraries provided by\n+applications should be compiled with the same level of protection.\n+.RS\n+.PP\n+Possible \\f[I]mode\\f[R] arguments for this option include the following:\n+.TP\n+.B \\f[CB]none\\f[R]\n+Do not use branch protection.\n+This is the default value.\n+.RS\n+.RE\n+.TP\n+.B \\f[CB]standard\\f[R]\n+Enables all branch protection modes available on the current platform.\n+.RS\n+.RE\n+.TP\n+.B \\f[CB]pac\\-ret\\f[R]\n+Enables protection against ROP based attacks.\n+(AArch64 8.3+ only)\n+.RS\n+.RE\n+.RE\n@@ -2981,1 +3009,2 @@\n-\\f[B]Linux and macOS:\\f[R] Enable \\f[CB]dtrace\\f[R] tool probes for object allocation.\n+\\f[B]Linux and macOS:\\f[R] Enable \\f[CB]dtrace\\f[R] tool probes for object\n+allocation.\n@@ -2986,2 +3015,2 @@\n-\\f[B]Linux and macOS:\\f[R] Enable \\f[CB]dtrace\\f[R] tool probes for method-entry\n-and method-exit.\n+\\f[B]Linux and macOS:\\f[R] Enable \\f[CB]dtrace\\f[R] tool probes for\n+method\\-entry and method\\-exit.\n@@ -2992,1 +3021,2 @@\n-\\f[B]Linux and macOS:\\f[R] Enable \\f[CB]dtrace\\f[R] tool probes for monitor events.\n+\\f[B]Linux and macOS:\\f[R] Enable \\f[CB]dtrace\\f[R] tool probes for monitor\n+events.\n@@ -4024,2 +4054,3 @@\n-Use the combination of these flags instead: \\f[CB]\\-XX:+DTraceMethodProbes\\f[R],\n-\\f[CB]\\-XX:+DTraceAllocProbes\\f[R], \\f[CB]\\-XX:+DTraceMonitorProbes\\f[R].\n+Use the combination of these flags instead:\n+\\f[CB]\\-XX:+DTraceMethodProbes\\f[R], \\f[CB]\\-XX:+DTraceAllocProbes\\f[R],\n+\\f[CB]\\-XX:+DTraceMonitorProbes\\f[R].\n","filename":"src\/java.base\/share\/man\/java.1","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include <stdlib.h>\n@@ -28,0 +27,2 @@\n+#include <stdlib.h>\n+#include <string.h>\n@@ -29,0 +30,3 @@\n+#include \"check_classname.h\"\n+#include \"java_lang_ClassLoader.h\"\n+#include \"jlong.h\"\n@@ -31,1 +35,0 @@\n-#include \"jlong.h\"\n@@ -33,3 +36,0 @@\n-#include \"check_classname.h\"\n-#include \"java_lang_ClassLoader.h\"\n-#include <string.h>\n@@ -91,1 +91,1 @@\n-        return 0;\n+        return NULL;\n@@ -99,1 +99,1 @@\n-        return 0;\n+        return NULL;\n@@ -102,1 +102,7 @@\n-    body = (jbyte *)malloc(length);\n+    \/\/ On AIX malloc(0) returns NULL which looks like an out-of-memory\n+    \/\/ condition; so adjust it to malloc(1)\n+    #ifdef _AIX\n+        body = (jbyte *)malloc(length == 0 ? 1 : length);\n+    #else\n+        body = (jbyte *)malloc(length);\n+    #endif\n@@ -104,1 +110,1 @@\n-    if (body == 0) {\n+    if (body == NULL) {\n@@ -106,1 +112,1 @@\n-        return 0;\n+        return NULL;\n@@ -111,1 +117,1 @@\n-    if ((*env)->ExceptionOccurred(env))\n+    if ((*env)->ExceptionOccurred(env)) {\n@@ -113,0 +119,1 @@\n+    }\n@@ -171,1 +178,1 @@\n-    if (body == 0) {\n+    if (body == NULL) {\n@@ -173,1 +180,1 @@\n-        return 0;\n+        return NULL;\n@@ -231,1 +238,1 @@\n-        return 0;\n+        return NULL;\n@@ -239,1 +246,1 @@\n-        return 0;\n+        return NULL;\n@@ -242,2 +249,9 @@\n-    body = (jbyte *)malloc(length);\n-    if (body == 0) {\n+    \/\/ On AIX malloc(0) returns NULL which looks like an out-of-memory\n+    \/\/ condition; so adjust it to malloc(1)\n+    #ifdef _AIX\n+        body = (jbyte *)malloc(length == 0 ? 1 : length);\n+    #else\n+        body = (jbyte *)malloc(length);\n+    #endif\n+\n+    if (body == NULL) {\n@@ -245,1 +259,1 @@\n-        return 0;\n+        return NULL;\n@@ -285,1 +299,1 @@\n-        return 0;\n+        return NULL;\n@@ -314,1 +328,1 @@\n-        return 0;\n+        return NULL;\n","filename":"src\/java.base\/share\/native\/libjava\/ClassLoader.c","additions":35,"deletions":21,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include <string.h>\n@@ -34,1 +35,0 @@\n-#include <string.h>\n@@ -43,1 +43,0 @@\n-\n@@ -47,1 +46,1 @@\n-        jclass this =\n+        jclass nlClz =\n@@ -49,1 +48,1 @@\n-        if (this == 0)\n+        if (nlClz == 0)\n@@ -51,1 +50,1 @@\n-        handleID = (*env)->GetFieldID(env, this, \"handle\", \"J\");\n+        handleID = (*env)->GetFieldID(env, nlClz, \"handle\", \"J\");\n@@ -54,1 +53,1 @@\n-        jniVersionID = (*env)->GetFieldID(env, this, \"jniVersion\", \"I\");\n+        jniVersionID = (*env)->GetFieldID(env, nlClz, \"jniVersion\", \"I\");\n@@ -112,1 +111,1 @@\n- * Signature: (Ljava\/lang\/String;ZZ)Z\n+ * Signature: (Ljdk\/internal\/loader\/NativeLibraries\/NativeLibraryImpl;Ljava\/lang\/String;ZZ)Z\n@@ -116,2 +115,2 @@\n-  (JNIEnv *env, jobject this, jobject lib, jstring name,\n-   jboolean isBuiltin, jboolean isJNI, jboolean throwExceptionIfFail)\n+  (JNIEnv *env, jclass cls, jobject lib, jstring name,\n+   jboolean isBuiltin, jboolean throwExceptionIfFail)\n@@ -132,13 +131,12 @@\n-    if (isJNI) {\n-        if (handle) {\n-            JNI_OnLoad_t JNI_OnLoad;\n-            JNI_OnLoad = (JNI_OnLoad_t)findJniFunction(env, handle,\n-                                                       isBuiltin ? cname : NULL,\n-                                                       JNI_TRUE);\n-            if (JNI_OnLoad) {\n-                JavaVM *jvm;\n-                (*env)->GetJavaVM(env, &jvm);\n-                jniVersion = (*JNI_OnLoad)(jvm, NULL);\n-            } else {\n-                jniVersion = 0x00010001;\n-            }\n+    if (handle) {\n+        JNI_OnLoad_t JNI_OnLoad;\n+        JNI_OnLoad = (JNI_OnLoad_t)findJniFunction(env, handle,\n+                                                   isBuiltin ? cname : NULL,\n+                                                   JNI_TRUE);\n+        if (JNI_OnLoad) {\n+            JavaVM *jvm;\n+            (*env)->GetJavaVM(env, &jvm);\n+            jniVersion = (*JNI_OnLoad)(jvm, NULL);\n+        } else {\n+            jniVersion = 0x00010001;\n+        }\n@@ -146,8 +144,6 @@\n-            cause = (*env)->ExceptionOccurred(env);\n-            if (cause) {\n-                (*env)->ExceptionClear(env);\n-                (*env)->Throw(env, cause);\n-                if (!isBuiltin) {\n-                    JVM_UnloadLibrary(handle);\n-                }\n-                goto done;\n+        cause = (*env)->ExceptionOccurred(env);\n+        if (cause) {\n+            (*env)->ExceptionClear(env);\n+            (*env)->Throw(env, cause);\n+            if (!isBuiltin) {\n+                JVM_UnloadLibrary(handle);\n@@ -155,0 +151,2 @@\n+            goto done;\n+        }\n@@ -156,19 +154,9 @@\n-            if (!JVM_IsSupportedJNIVersion(jniVersion) ||\n-                (isBuiltin && jniVersion < JNI_VERSION_1_8)) {\n-                char msg[256];\n-                jio_snprintf(msg, sizeof(msg),\n-                             \"unsupported JNI version 0x%08X required by %s\",\n-                             jniVersion, cname);\n-                JNU_ThrowByName(env, \"java\/lang\/UnsatisfiedLinkError\", msg);\n-                if (!isBuiltin) {\n-                    JVM_UnloadLibrary(handle);\n-                }\n-                goto done;\n-            }\n-            (*env)->SetIntField(env, lib, jniVersionID, jniVersion);\n-        } else {\n-            cause = (*env)->ExceptionOccurred(env);\n-            if (cause) {\n-                (*env)->ExceptionClear(env);\n-                (*env)->SetLongField(env, lib, handleID, (jlong)0);\n-                (*env)->Throw(env, cause);\n+        if (!JVM_IsSupportedJNIVersion(jniVersion) ||\n+            (isBuiltin && jniVersion < JNI_VERSION_1_8)) {\n+            char msg[256];\n+            jio_snprintf(msg, sizeof(msg),\n+                         \"unsupported JNI version 0x%08X required by %s\",\n+                         jniVersion, cname);\n+            JNU_ThrowByName(env, \"java\/lang\/UnsatisfiedLinkError\", msg);\n+            if (!isBuiltin) {\n+                JVM_UnloadLibrary(handle);\n@@ -178,0 +166,9 @@\n+        (*env)->SetIntField(env, lib, jniVersionID, jniVersion);\n+    } else {\n+        cause = (*env)->ExceptionOccurred(env);\n+        if (cause) {\n+            (*env)->ExceptionClear(env);\n+            (*env)->SetLongField(env, lib, handleID, (jlong)0);\n+            (*env)->Throw(env, cause);\n+        }\n+        goto done;\n@@ -179,0 +176,1 @@\n+\n@@ -190,1 +188,1 @@\n- * Signature: (Ljava\/lang\/String;ZZJ)V\n+ * Signature: (Ljava\/lang\/String;ZJ)V\n@@ -194,1 +192,1 @@\n-(JNIEnv *env, jclass cls, jstring name, jboolean isBuiltin, jboolean isJNI, jlong address)\n+(JNIEnv *env, jclass cls, jstring name, jboolean isBuiltin, jlong address)\n@@ -208,9 +206,8 @@\n-    if (isJNI) {\n-        JNI_OnUnload = (JNI_OnUnload_t )findJniFunction(env, handle,\n-                                                        isBuiltin ? cname : NULL,\n-                                                        JNI_FALSE);\n-        if (JNI_OnUnload) {\n-            JavaVM *jvm;\n-            (*env)->GetJavaVM(env, &jvm);\n-            (*JNI_OnUnload)(jvm, NULL);\n-        }\n+\n+    JNI_OnUnload = (JNI_OnUnload_t )findJniFunction(env, handle,\n+                                                    isBuiltin ? cname : NULL,\n+                                                    JNI_FALSE);\n+    if (JNI_OnUnload) {\n+        JavaVM *jvm;\n+        (*env)->GetJavaVM(env, &jvm);\n+        (*JNI_OnUnload)(jvm, NULL);\n@@ -224,1 +221,0 @@\n-\n@@ -226,1 +222,1 @@\n- * Class:     jdk_internal_loader_NativeLibraries\n+ * Class:     jdk_internal_loader_NativeLibrary\n@@ -228,1 +224,1 @@\n- * Signature: (Ljava\/lang\/String;)J\n+ * Signature: (JLjava\/lang\/String;)J\n@@ -231,2 +227,2 @@\n-Java_jdk_internal_loader_NativeLibraries_findEntry0\n-  (JNIEnv *env, jobject this, jobject lib, jstring name)\n+Java_jdk_internal_loader_NativeLibrary_findEntry0\n+  (JNIEnv *env, jclass cls, jlong handle, jstring name)\n@@ -234,1 +230,0 @@\n-    jlong handle;\n@@ -238,4 +233,0 @@\n-    if (!initIDs(env))\n-        return jlong_zero;\n-\n-    handle = (*env)->GetLongField(env, lib, handleID);\n","filename":"src\/java.base\/share\/native\/libjava\/NativeLibraries.c","additions":61,"deletions":70,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+#include \"jvm.h\"\n+#include \"jdk_internal_loader_RawNativeLibraries.h\"\n+\n+static jfieldID handleID;\n+\n+static jboolean initIDs(JNIEnv *env)\n+{\n+    if (handleID == 0) {\n+        jclass rnlClz =\n+            (*env)->FindClass(env, \"jdk\/internal\/loader\/RawNativeLibraries$RawNativeLibraryImpl\");\n+        if (rnlClz == 0)\n+            return JNI_FALSE;\n+        handleID = (*env)->GetFieldID(env, rnlClz, \"handle\", \"J\");\n+        if (handleID == 0)\n+            return JNI_FALSE;\n+    }\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Class:     jdk_internal_loader_RawNativeLibraries\n+ * Method:    Java_jdk_internal_loader_RawNativeLibraries_load0\n+ * Signature: (Ljdk\/internal\/loader\/RawNativeLibraries\/RawNativeLibraryImpl;Ljava\/lang\/String;)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_loader_RawNativeLibraries_load0\n+  (JNIEnv *env, jclass cls, jobject lib, jstring name)\n+{\n+    const char *cname;\n+    void * handle;\n+\n+    if (!initIDs(env))\n+        return JNI_FALSE;\n+\n+    cname = JNU_GetStringPlatformChars(env, name, 0);\n+    if (cname == 0)\n+        return JNI_FALSE;\n+    handle = JVM_LoadLibrary(cname, JNI_FALSE);\n+    (*env)->SetLongField(env, lib, handleID, ptr_to_jlong(handle));\n+\n+    JNU_ReleaseStringPlatformChars(env, name, cname);\n+    return handle != 0L;\n+}\n+\n+\/*\n+ * Class:     jdk_internal_loader_RawNativeLibraries\n+ * Method:    unload0\n+ * Signature: (Ljava\/lang\/String;J)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_internal_loader_RawNativeLibraries_unload0\n+  (JNIEnv *env, jclass cls, jstring name, jlong address)\n+{\n+    void *handle;\n+    const char *cname;\n+\n+    if (!initIDs(env))\n+        return;\n+    cname = JNU_GetStringPlatformChars(env, name, 0);\n+    if (cname == NULL) {\n+        return;\n+    }\n+    handle = jlong_to_ptr(address);\n+\n+    JVM_UnloadLibrary(handle);\n+    JNU_ReleaseStringPlatformChars(env, name, cname);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libjava\/RawNativeLibraries.c","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -471,1 +471,2 @@\n-static void check_and_push(context_type *context, const void *ptr, int kind);\n+static void check_and_push_malloc_block(context_type *context, void *ptr);\n+static void check_and_push_string_utf(context_type *context, const char *ptr);\n@@ -607,1 +608,1 @@\n-    check_and_push(context, name, VM_STRING_UTF);\n+    check_and_push_string_utf(context, name);\n@@ -942,1 +943,1 @@\n-    check_and_push(context, lengths, VM_MALLOC_BLK);\n+    check_and_push_malloc_block(context, lengths);\n@@ -945,1 +946,1 @@\n-    check_and_push(context, code, VM_MALLOC_BLK);\n+    check_and_push_malloc_block(context, code);\n@@ -954,1 +955,1 @@\n-            check_and_push(context, code[i], VM_MALLOC_BLK);\n+            check_and_push_malloc_block(context, code[i]);\n@@ -1308,1 +1309,1 @@\n-        check_and_push(context, methodname, VM_STRING_UTF);\n+        check_and_push_string_utf(context, methodname);\n@@ -1357,1 +1358,1 @@\n-            check_and_push(context, signature, VM_STRING_UTF);\n+            check_and_push_string_utf(context, signature);\n@@ -1655,1 +1656,1 @@\n-            check_and_push(context, classname, VM_STRING_UTF);\n+            check_and_push_string_utf(context, classname);\n@@ -1810,1 +1811,1 @@\n-    check_and_push(context, signature, VM_STRING_UTF);\n+    check_and_push_string_utf(context, signature);\n@@ -2053,1 +2054,1 @@\n-            check_and_push(context, signature, VM_STRING_UTF);\n+            check_and_push_string_utf(context, signature);\n@@ -2079,1 +2080,1 @@\n-            check_and_push(context, signature, VM_STRING_UTF);\n+            check_and_push_string_utf(context, signature);\n@@ -2379,1 +2380,1 @@\n-            check_and_push(context, signature, VM_STRING_UTF);\n+            check_and_push_string_utf(context, signature);\n@@ -2761,1 +2762,1 @@\n-            check_and_push(context, signature, VM_STRING_UTF);\n+            check_and_push_string_utf(context, signature);\n@@ -2783,1 +2784,1 @@\n-            check_and_push(context, signature, VM_STRING_UTF);\n+            check_and_push_string_utf(context, signature);\n@@ -3624,1 +3625,1 @@\n-    check_and_push(context, classname, VM_STRING_UTF);\n+    check_and_push_string_utf(context, classname);\n@@ -3825,2 +3826,2 @@\n-                    buffer = calloc(length + 1, sizeof(char));\n-                    check_and_push(context, buffer, VM_MALLOC_BLK);\n+                    buffer = malloc(length + 1);\n+                    check_and_push_malloc_block(context, buffer);\n@@ -4145,1 +4146,1 @@\n-static void check_and_push(context_type *context, const void *ptr, int kind)\n+static void check_and_push_common(context_type *context, void *ptr, int kind)\n@@ -4157,1 +4158,1 @@\n-            free_block((void *)ptr, kind);\n+            free_block(ptr, kind);\n@@ -4162,1 +4163,1 @@\n-    p->ptr = (void *)ptr;\n+    p->ptr = ptr;\n@@ -4167,0 +4168,8 @@\n+static void check_and_push_malloc_block(context_type *context, void *ptr) {\n+  check_and_push_common(context, ptr, VM_MALLOC_BLK);\n+}\n+\n+static void check_and_push_string_utf(context_type *context, const char *ptr) {\n+  check_and_push_common(context, (void *)ptr, VM_STRING_UTF);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libverify\/check_code.c","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -189,1 +189,1 @@\n-                    close(sfd);\n+                    close(sfd, e -> null);\n@@ -213,1 +213,1 @@\n-                close(dfd);\n+                close(dfd, e -> null);\n@@ -291,1 +291,1 @@\n-                close(fo);\n+                close(fo, e -> null);\n@@ -301,1 +301,1 @@\n-            close(fi);\n+            close(fi, e -> null);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    protected final UnixPath directory() {\n+    final UnixPath directory() {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixDirectoryStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,1 @@\n-                close(fd);\n+                close(fd, e -> null);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileAttributeViews.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,1 @@\n-            UnixNativeDispatcher.close(fd);\n+            UnixNativeDispatcher.close(fd, e -> null);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileStore.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -434,0 +434,3 @@\n+            IOException ioe = x.errno() == UnixConstants.ENOTDIR ?\n+                new NotDirectoryException(dir.getPathForExceptionMessage()) :\n+                x.asIOException(dir);\n@@ -435,1 +438,1 @@\n-                UnixNativeDispatcher.close(dfd1);\n+                UnixNativeDispatcher.close(dfd1, e -> null);\n@@ -437,4 +440,2 @@\n-                UnixNativeDispatcher.close(dfd2);\n-            if (x.errno() == UnixConstants.ENOTDIR)\n-                throw new NotDirectoryException(dir.getPathForExceptionMessage());\n-            x.rethrowAsIOException(dir);\n+                UnixNativeDispatcher.close(dfd2, e -> null);\n+            throw ioe;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.util.function.Function;\n+\n@@ -93,1 +95,1 @@\n-    static void close(int fd) {\n+    static void close(int fd) throws UnixException {\n@@ -98,1 +100,19 @@\n-    private static native void close0(int fd);\n+    private static native void close0(int fd) throws UnixException;\n+\n+    \/**\n+     * close(fd). If close fails then the given exception supplier function is\n+     * invoked to produce an exception to throw. If the function returns null\n+     * then no exception is thrown. If close fails and the exception supplier\n+     * function is null, then no exception is thrown.\n+     *\/\n+    static <X extends Throwable>\n+    void close(int fd, Function<UnixException, X> mapper) throws X {\n+        try {\n+            close(fd);\n+        } catch (UnixException e) {\n+            if (mapper != null) {\n+                X ex = mapper.apply(e);\n+                if (ex != null) throw ex;\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-                UnixNativeDispatcher.close(dfd);\n+                UnixNativeDispatcher.close(dfd, e -> e.asIOException(ds.directory()));\n@@ -120,0 +120,3 @@\n+                IOException ioe = x.errno() == UnixConstants.ENOTDIR ?\n+                    new NotDirectoryException(file.toString()) :\n+                    x.asIOException(file);\n@@ -121,1 +124,1 @@\n-                    UnixNativeDispatcher.close(newdfd1);\n+                    UnixNativeDispatcher.close(newdfd1, e -> null);\n@@ -123,4 +126,2 @@\n-                    UnixNativeDispatcher.close(newdfd2);\n-                if (x.errno() == UnixConstants.ENOTDIR)\n-                    throw new NotDirectoryException(file.toString());\n-                x.rethrowAsIOException(file);\n+                    UnixNativeDispatcher.close(newdfd1, e -> null);\n+                throw ioe;\n@@ -425,1 +426,1 @@\n-                        UnixNativeDispatcher.close(fd);\n+                        UnixNativeDispatcher.close(fd, e-> null);\n@@ -507,1 +508,1 @@\n-                        UnixNativeDispatcher.close(fd);\n+                        UnixNativeDispatcher.close(fd, e-> null);\n@@ -530,1 +531,1 @@\n-                        UnixNativeDispatcher.close(fd);\n+                        UnixNativeDispatcher.close(fd, e-> null);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixSecureDirectoryStream.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-            close(fd);\n+            close(fd, e -> null);\n@@ -160,1 +160,1 @@\n-            close(fd);\n+            close(fd, e -> null);\n@@ -224,1 +224,1 @@\n-            close(fd);\n+            close(fd, e -> null);\n@@ -286,1 +286,1 @@\n-            close(fd);\n+            close(fd, e -> null);\n@@ -308,1 +308,1 @@\n-            close(fd);\n+            close(fd, e -> null);\n@@ -349,1 +349,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -491,2 +491,10 @@\n-        if (sprops.user_home == NULL) {\n-            sprops.user_home = \"?\";\n+        if (sprops.user_home == NULL || sprops.user_home[0] == '\\0' ||\n+            sprops.user_home[1] == '\\0') {\n+            \/\/ If the OS supplied home directory is not defined or less than two characters long\n+            \/\/ $HOME is the backup source for the home directory, if defined\n+            char* user_home = getenv(\"HOME\");\n+            if ((user_home != NULL) && (user_home[0] != '\\0')) {\n+                sprops.user_home = user_home;\n+            } else {\n+                sprops.user_home = \"?\";\n+            }\n","filename":"src\/java.base\/unix\/native\/libjava\/java_props_md.c","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-    hostname = JNU_GetStringPlatformChars(env, host, JNI_FALSE);\n+    hostname = JNU_GetStringPlatformChars(env, host, NULL);\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet4AddressImpl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,1 +223,1 @@\n-    hostname = JNU_GetStringPlatformChars(env, host, JNI_FALSE);\n+    hostname = JNU_GetStringPlatformChars(env, host, NULL);\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet6AddressImpl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-        this(sp, true, false);\n+        this(sp, false, true);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/PipeImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -277,1 +277,1 @@\n-    langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -362,1 +362,1 @@\n-    jstring ret;\n+    jstring ret = NULL;\n@@ -365,1 +365,1 @@\n-    langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -368,2 +368,4 @@\n-    CHECK_NULL_RETURN(pattern, NULL);\n-\n+    if (!IS_NULL(pattern)) {\n+        ret = (*env)->NewString(env, pattern, (jsize)wcslen(pattern));\n+        free(pattern);\n+    }\n@@ -371,3 +373,0 @@\n-    ret = (*env)->NewString(env, pattern, (jsize)wcslen(pattern));\n-    free(pattern);\n-\n@@ -386,1 +385,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -405,1 +404,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -426,1 +425,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -447,1 +446,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -468,1 +467,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -489,1 +488,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -510,1 +509,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -531,1 +530,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -552,1 +551,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -573,1 +572,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -595,1 +594,1 @@\n-    langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -618,1 +617,1 @@\n-    langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -642,1 +641,1 @@\n-    langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -759,1 +758,1 @@\n-    pjChar = (*env)->GetStringChars(env, jStr, JNI_FALSE);\n+    pjChar = (*env)->GetStringChars(env, jStr, NULL);\n@@ -836,1 +835,1 @@\n-    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar *langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n@@ -1026,1 +1025,1 @@\n-    const jchar * langtag = (*env)->GetStringChars(env, jlangtag, JNI_FALSE);\n+    const jchar * langtag = (*env)->GetStringChars(env, jlangtag, NULL);\n","filename":"src\/java.base\/windows\/native\/libjava\/HostLocaleProviderAdapter_md.c","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-    hostname = JNU_GetStringPlatformChars(env, host, JNI_FALSE);\n+    hostname = JNU_GetStringPlatformChars(env, host, NULL);\n","filename":"src\/java.base\/windows\/native\/libnet\/Inet4AddressImpl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-    hostname = JNU_GetStringPlatformChars(env, host, JNI_FALSE);\n+    hostname = JNU_GetStringPlatformChars(env, host, NULL);\n","filename":"src\/java.base\/windows\/native\/libnet\/Inet6AddressImpl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -179,0 +179,2 @@\n+    *netifPP = NULL;\n+\n@@ -216,3 +218,1 @@\n-        \/\/ this different error code is to handle the case when we call\n-        \/\/ GetIpAddrTable in pure IPv6 environment\n-        return -2;\n+        return -1;\n@@ -376,0 +376,3 @@\n+\n+    *tablePP = NULL;\n+\n@@ -437,0 +440,2 @@\n+    *netaddrPP = NULL;\n+\n@@ -441,1 +446,1 @@\n-    if (tableP == NULL)\n+    if (tableP == NULL) {\n@@ -443,0 +448,1 @@\n+    }\n@@ -455,1 +461,0 @@\n-                free(tableP);\n@@ -521,0 +526,3 @@\n+\n+    *netaddrPP = NULL;\n+\n@@ -523,1 +531,1 @@\n-      return NULL;\n+      return ret;\n@@ -853,3 +861,1 @@\n-        }\n-        if (tableP != NULL) {\n-          free(tableP);\n+            free(tableP);\n@@ -925,0 +931,2 @@\n+            } else {\n+                free_netaddr(addrList);\n@@ -930,4 +938,1 @@\n-    }\n-\n-    \/* release the IP address table *\/\n-    if (tableP != NULL)\n+        \/* release the IP address table *\/\n@@ -935,0 +940,1 @@\n+    }\n@@ -951,1 +957,1 @@\n-    netif *ifList = NULL, *curr;\n+    netif *ifList, *curr;\n","filename":"src\/java.base\/windows\/native\/libnet\/NetworkInterface.c","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+    *adapters = NULL;\n+\n@@ -236,2 +238,0 @@\n-static int ipinflen = 2048;\n-\n@@ -245,1 +245,1 @@\n-    ULONG len=ipinflen, count=0;\n+    ULONG count=0;\n@@ -249,1 +249,0 @@\n-    *netifPP = NULL;\n@@ -256,1 +255,1 @@\n-    if (ret == -1) {\n+    if (ret < 0) {\n@@ -258,4 +257,0 @@\n-    } else if( ret == -2){\n-        if ((*env)->ExceptionCheck(env)) {\n-            (*env)->ExceptionClear(env);\n-        }\n@@ -277,1 +272,2 @@\n-    if (ret < 0) {\n+    if (ret == -1) {\n+      free_netif(*netifPP);\n@@ -279,0 +275,6 @@\n+    } else if (ret == -2) {\n+        \/\/ Clear the exception and continue.\n+        if ((*env)->ExceptionCheck(env)) {\n+            (*env)->ExceptionClear(env);\n+        }\n+        tableP = NULL;\n@@ -283,1 +285,2 @@\n-        if (ret == -1) {\n+        if (ret < 0) {\n+            free_netif(*netifPP);\n@@ -286,5 +289,0 @@\n-        } else if (ret == -2) {\n-            if ((*env)->ExceptionCheck(env)) {\n-                (*env)->ExceptionClear(env);\n-            }\n-            break;\n@@ -304,1 +302,2 @@\n-        goto err;\n+        free_netif(*netifPP);\n+        return -1;\n@@ -343,0 +342,3 @@\n+                        if (c == -1) {\n+                            goto err;\n+                        }\n@@ -381,0 +383,1 @@\n+                                free(nif);\n@@ -393,1 +396,5 @@\n-                        last->next = nif;\n+                        if (last) {\n+                                last->next = nif;\n+                        } else {\n+                                *netifPP = nif;\n+                        }\n@@ -588,0 +595,2 @@\n+            netaddrCount = 0;\n+            netaddrPToFree = NULL;\n@@ -829,1 +838,1 @@\n-    netif *ifList = NULL, *curr;\n+    netif *ifList, *curr;\n","filename":"src\/java.base\/windows\/native\/libnet\/NetworkInterface_winXP.c","additions":28,"deletions":19,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,3 +56,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/AbstractProcessor.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Completion.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Completions.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,3 +135,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/FilerException.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,3 +49,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Messager.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,3 +56,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/ProcessingEnvironment.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,3 +201,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Processor.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,3 +40,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/RoundEnvironment.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/SupportedAnnotationTypes.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,3 +40,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/SupportedOptions.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/SupportedSourceVersion.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/package-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n- * @author Joseph D. Darcy\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/UnknownEntityException.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,3 +39,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/AnnotationMirror.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,3 +40,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/AnnotationValue.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,3 +118,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/AnnotationValueVisitor.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,3 +55,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Element.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n@@ -139,1 +136,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -154,0 +150,11 @@\n+    \/**\n+     * {@return {@code true} if this is a kind of declared type, a\n+     * {@linkplain #isClass() class} or an {@linkplain #isInterface()\n+     * interface}, and {@code false} otherwise}\n+     *\n+     * @since 19\n+     *\/\n+    public boolean isDeclaredType() {\n+        return isClass() || isInterface();\n+    }\n+\n@@ -163,0 +170,46 @@\n+\n+    \/**\n+     * Returns {@code true} if this is a kind of executable: either\n+     * {@code METHOD} or {@code CONSTRUCTOR} or {@code STATIC_INIT} or\n+     * {@code INSTANCE_INIT}.\n+     *\n+     * @return {@code true} if this is a kind of executable\n+     * @since 19\n+     *\/\n+    public boolean isExecutable() {\n+        return switch(this) {\n+        case METHOD, CONSTRUCTOR, STATIC_INIT, INSTANCE_INIT -> true;\n+        default -> false;\n+        };\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this is a kind of initializer: either\n+     * {@code STATIC_INIT} or {@code INSTANCE_INIT}.\n+     *\n+     * @return {@code true} if this is a kind of initializer\n+     * @since 19\n+     *\/\n+    public boolean isInitializer() {\n+        return switch(this) {\n+        case STATIC_INIT, INSTANCE_INIT -> true;\n+        default -> false;\n+        };\n+    }\n+    \/**\n+     * Returns {@code true} if this is a kind of variable: including\n+     * {@code ENUM_CONSTANT}, {@code FIELD}, {@code PARAMETER},\n+     * {@code LOCAL_VARIABLE}, {@code EXCEPTION_PARAMETER},\n+     * {@code RESOURCE_VARIABLE}, and {@code BINDING_VARIABLE}.\n+     *\n+     * @return {@code true} if this is a kind of variable\n+     * @since 19\n+     *\/\n+    public boolean isVariable() {\n+        return switch(this) {\n+        case ENUM_CONSTANT, FIELD, PARAMETER,\n+             LOCAL_VARIABLE, EXCEPTION_PARAMETER, RESOURCE_VARIABLE,\n+             BINDING_VARIABLE -> true;\n+        default -> false;\n+        };\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ElementKind.java","additions":58,"deletions":5,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,3 +120,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ElementVisitor.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ExecutableElement.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,3 +47,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,3 +49,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Name.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,3 +79,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/NestingKind.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/PackageElement.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @author Joseph D. Darcy\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Parameterizable.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @author Joseph D. Darcy\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/QualifiedNameable.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,3 +56,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeParameterElement.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/UnknownAnnotationValueException.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/UnknownDirectiveException.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/UnknownElementException.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,3 +110,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/package-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,3 +55,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/package-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,3 +34,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/ArrayType.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,3 +52,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/DeclaredType.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/ErrorType.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,3 +44,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/ExecutableType.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/MirroredTypeException.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,3 +40,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/MirroredTypesException.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,3 +43,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/NoType.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * This is the type of the expression {@code null},\n+ * This is the type of the expression {@code null}.\n@@ -33,3 +33,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/NullType.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,3 +34,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/PrimitiveType.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,3 +34,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/ReferenceType.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeKind.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,3 +53,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeMirror.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,3 +44,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeVariable.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,3 +115,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeVisitor.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/UnknownTypeException.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/WildcardType.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/package-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,4 +63,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n- *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitor6.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,4 +65,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n- *\n@@ -162,1 +158,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitor6.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,4 +64,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n- *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor6.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,4 +58,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n- * @author Martin Buchholz\n@@ -82,1 +78,0 @@\n-    @SuppressWarnings(\"preview\")\n@@ -90,1 +85,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementFilter.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,4 +76,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n- *\n@@ -142,1 +138,0 @@\n-    @SuppressWarnings(\"preview\")\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor6.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,4 +86,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n- *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner6.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,3 +45,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,4 +70,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n- *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitor6.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,4 +75,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n- *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor6.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,4 +75,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n- *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor6.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,4 +74,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n- *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitor6.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,0 @@\n- * @author Joseph D. Darcy\n- * @author Scott Seligman\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/package-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,0 @@\n- * @author Peter von der Ah&eacute;\n- * @author Jonathan Gibbons\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/Diagnostic.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/DiagnosticCollector.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n- * @author Jonathan Gibbons\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/DiagnosticListener.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,0 @@\n- * @author Peter von der Ah&eacute;\n- * @author Jonathan Gibbons\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/FileObject.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ForwardingFileObject.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ForwardingJavaFileManager.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ForwardingJavaFileObject.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,2 +193,0 @@\n- * @author Peter von der Ah&eacute;\n- * @author Jonathan Gibbons\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/JavaCompiler.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,2 +106,0 @@\n- * @author Peter von der Ah&eacute;\n- * @author Jonathan Gibbons\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/JavaFileManager.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,0 @@\n- * @author Peter von der Ah&eacute;\n- * @author Jonathan Gibbons\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/JavaFileObject.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/OptionChecker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/SimpleJavaFileObject.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,2 +158,0 @@\n- *\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/StandardJavaFileManager.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/StandardLocation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,0 @@\n- * @author Neal M Gafter\n- * @author Peter von der Ah&eacute;\n- * @author Jonathan Gibbons\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/Tool.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n- * @author Peter von der Ah&eacute;\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ToolProvider.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,2 +80,0 @@\n- * @author Peter von der Ah&eacute;\n- * @author Jonathan Gibbons\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/package-info.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -308,1 +308,9 @@\n-        final String text = layoutAndGetText(g, b, aquaBorder, i, viewRect, iconRect, textRect);\n+        final String text;\n+        final View v = (View)c.getClientProperty(BasicHTML.propertyKey);\n+        if (v != null) {\n+            \/\/ use zero insets for view since layout only handles text calculations\n+            text = layoutAndGetText(g, b, aquaBorder, new Insets(0,0,0,0),\n+                    viewRect, iconRect, textRect);\n+        } else {\n+            text = layoutAndGetText(g, b, aquaBorder, i, viewRect, iconRect, textRect);\n+        }\n@@ -320,1 +328,0 @@\n-            final View v = (View)c.getClientProperty(BasicHTML.propertyKey);\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaButtonUI.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,3 +84,49 @@\n-    public void drawGlyphVector(final SunGraphics2D sg2d, final GlyphVector gV, final float x, final float y) {\n-        final Font prevFont = sg2d.getFont();\n-        sg2d.setFont(gV.getFont());\n+    private boolean hasSlotData(GlyphVector gv) {\n+        final int length = gv.getNumGlyphs();\n+        for (int i = 0; i < length; i++) {\n+            if ((gv.getGlyphCode(i) & CompositeGlyphMapper.SLOTMASK) != 0) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private Font getSlotFont(Font font, int slot) {\n+        Font2D f2d = FontUtilities.getFont2D(font);\n+        if (f2d instanceof CFont) {\n+            CompositeFont cf = ((CFont)f2d).getCompositeFont2D();\n+            PhysicalFont pf = cf.getSlotFont(slot);\n+            Font f = new Font(pf.getFontName(null),\n+                              font.getStyle(), font.getSize());\n+            return f;\n+        }\n+        return null;\n+    }\n+\n+    private GlyphVector getGlyphVectorWithRange(final Font font, final GlyphVector gV, int start, int count) {\n+        int[] glyphs = new int[count];\n+        for (int i = 0; i < count; i++) {\n+            glyphs[i] = gV.getGlyphCode(start+i) & CompositeGlyphMapper.GLYPHMASK;\n+        }\n+        \/\/ Positions should be null to recalculate by native methods,\n+        \/\/ if GV was segmented.\n+        StandardGlyphVector sgv = new StandardGlyphVector(font,\n+                                          gV.getFontRenderContext(),\n+                                          glyphs,\n+                                          null, \/\/ positions\n+                                          null, \/\/ indices\n+                                          gV.getLayoutFlags());\n+        return sgv;\n+    }\n+\n+    private int getLengthOfSameSlot(final GlyphVector gV, final int targetSlot, final int start, final int length) {\n+        int count = 1;\n+        for (; start + count < length; count++) {\n+            int slot = (gV.getGlyphCode(start + count) &\n+                        CompositeGlyphMapper.SLOTMASK) >> 24;\n+            if (targetSlot != slot) {\n+                break;\n+            }\n+        }\n+        return count;\n+    }\n@@ -88,0 +134,1 @@\n+    private void drawGlyphVectorImpl(final SunGraphics2D sg2d, final GlyphVector gV, final float x, final float y) {\n@@ -95,0 +142,25 @@\n+    }\n+\n+    public void drawGlyphVector(final SunGraphics2D sg2d, final GlyphVector gV, final float x, final float y) {\n+        final Font prevFont = sg2d.getFont();\n+        sg2d.setFont(gV.getFont());\n+\n+        if (hasSlotData(gV)) {\n+            final int length = gV.getNumGlyphs();\n+            float[] positions = gV.getGlyphPositions(0, length, null);\n+            int start = 0;\n+            while (start < length) {\n+                int slot = (gV.getGlyphCode(start) &\n+                            CompositeGlyphMapper.SLOTMASK) >> 24;\n+                sg2d.setFont(getSlotFont(gV.getFont(), slot));\n+                int count = getLengthOfSameSlot(gV, slot, start, length);\n+                GlyphVector rangeGV = getGlyphVectorWithRange(sg2d.getFont(),\n+                                                              gV, start, count);\n+                drawGlyphVectorImpl(sg2d, rangeGV,\n+                                    x + positions[start * 2],\n+                                    y + positions[start * 2 + 1]);\n+                start += count;\n+            }\n+        } else {\n+            drawGlyphVectorImpl(sg2d, gV, x, y);\n+        }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CTextPipe.java","additions":76,"deletions":4,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1100,1 +1100,1 @@\n-     * @exception NullPointerException if the specified\n+     * @throws NullPointerException if the specified\n@@ -1102,1 +1102,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/AWTEventMulticaster.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-     * @exception   IllegalArgumentException  if the constraint object is not\n+     * @throws   IllegalArgumentException  if the constraint object is not\n@@ -517,1 +517,1 @@\n-     * @exception   IllegalArgumentException  if the constraint object is\n+     * @throws   IllegalArgumentException  if the constraint object is\n@@ -565,1 +565,1 @@\n-     * @exception   IllegalArgumentException  if the constraint object is\n+     * @throws   IllegalArgumentException  if the constraint object is\n@@ -567,1 +567,1 @@\n-     * @exception   NullPointerException  if the target parameter is null\n+     * @throws   NullPointerException  if the target parameter is null\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/BorderLayout.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-     * @exception IllegalArgumentException if frontCaps or backCaps are\n+     * @throws IllegalArgumentException if frontCaps or backCaps are\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/BufferCapabilities.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -156,1 +156,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -342,1 +342,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Button.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -169,2 +169,2 @@\n-     * @exception IllegalArgumentException if numBuffers is less than 1.\n-     * @exception IllegalStateException if the component is not displayable\n+     * @throws IllegalArgumentException if numBuffers is less than 1.\n+     * @throws IllegalStateException if the component is not displayable\n@@ -190,1 +190,1 @@\n-     * @exception AWTException if the capabilities supplied could not be\n+     * @throws AWTException if the capabilities supplied could not be\n@@ -194,1 +194,1 @@\n-     * @exception IllegalArgumentException if numBuffers is less than 1, or if\n+     * @throws IllegalArgumentException if numBuffers is less than 1, or if\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Canvas.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-     * @exception  IllegalArgumentException  if the constraint is not a string.\n+     * @throws  IllegalArgumentException  if the constraint is not a string.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/CardLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -164,1 +164,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -181,1 +181,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -199,1 +199,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -225,1 +225,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -511,1 +511,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Checkbox.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -128,1 +128,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -143,1 +143,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -319,1 +319,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/CheckboxMenuItem.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -208,1 +208,1 @@\n-     * @exception  NullPointerException   if the item's value is\n+     * @throws  NullPointerException   if the item's value is\n@@ -222,1 +222,1 @@\n-     * @exception NullPointerException if the item's value is equal to\n+     * @throws NullPointerException if the item's value is equal to\n@@ -241,1 +241,1 @@\n-     * @exception NullPointerException if the item's value is equal to\n+     * @throws NullPointerException if the item's value is equal to\n@@ -277,1 +277,1 @@\n-     * @exception IllegalArgumentException if index is less than 0\n+     * @throws IllegalArgumentException if index is less than 0\n@@ -303,1 +303,1 @@\n-     * @exception  IllegalArgumentException  if the item doesn't\n+     * @throws  IllegalArgumentException  if the item doesn't\n@@ -433,1 +433,1 @@\n-     * @exception  IllegalArgumentException if the specified\n+     * @throws  IllegalArgumentException if the specified\n@@ -564,1 +564,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Choice.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -725,1 +725,1 @@\n-     * @exception  NumberFormatException  if the specified string cannot\n+     * @throws  NumberFormatException  if the specified string cannot\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Color.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1423,1 +1423,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless() returns true\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless() returns true\n@@ -1987,1 +1987,1 @@\n-     * @exception IllegalComponentStateException if the {@code Component}\n+     * @throws IllegalComponentStateException if the {@code Component}\n@@ -3830,2 +3830,2 @@\n-     * @exception IllegalArgumentException if numBuffers is less than 1.\n-     * @exception IllegalStateException if the component is not displayable\n+     * @throws IllegalArgumentException if numBuffers is less than 1.\n+     * @throws IllegalStateException if the component is not displayable\n@@ -3887,1 +3887,1 @@\n-     * @exception AWTException if the capabilities supplied could not be\n+     * @throws AWTException if the capabilities supplied could not be\n@@ -3891,1 +3891,1 @@\n-     * @exception IllegalArgumentException if numBuffers is less than 1, or if\n+     * @throws IllegalArgumentException if numBuffers is less than 1, or if\n@@ -4035,1 +4035,1 @@\n-         * @exception AWTException if the capabilities supplied could not be\n+         * @throws AWTException if the capabilities supplied could not be\n@@ -4037,1 +4037,1 @@\n-         * @exception ClassCastException if the component is not a canvas or\n+         * @throws ClassCastException if the component is not a canvas or\n@@ -4039,2 +4039,2 @@\n-         * @exception IllegalStateException if the component has no peer\n-         * @exception IllegalArgumentException if {@code numBuffers} is less than two,\n+         * @throws IllegalStateException if the component has no peer\n+         * @throws IllegalArgumentException if {@code numBuffers} is less than two,\n@@ -4069,1 +4069,1 @@\n-         * @exception AWTException if the capabilities supplied could not be\n+         * @throws AWTException if the capabilities supplied could not be\n@@ -4071,2 +4071,2 @@\n-         * @exception IllegalStateException if the component has no peer\n-         * @exception IllegalArgumentException if numBuffers is less than two,\n+         * @throws IllegalStateException if the component has no peer\n+         * @throws IllegalArgumentException if numBuffers is less than two,\n@@ -4138,1 +4138,1 @@\n-         * @exception IllegalStateException if the buffers have not yet\n+         * @throws IllegalStateException if the buffers have not yet\n@@ -4157,1 +4157,1 @@\n-         * @exception IllegalStateException if the buffers have not yet\n+         * @throws IllegalStateException if the buffers have not yet\n@@ -6063,1 +6063,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n@@ -8355,1 +8355,1 @@\n-     * @exception NullPointerException if {@code popup} is {@code null}\n+     * @throws NullPointerException if {@code popup} is {@code null}\n@@ -9195,1 +9195,1 @@\n-     * @exception NullPointerException if {@code orientation} is null.\n+     * @throws NullPointerException if {@code orientation} is null.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Component.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-     * @exception  ArrayIndexOutOfBoundsException\n+     * @throws  ArrayIndexOutOfBoundsException\n@@ -432,1 +432,1 @@\n-     * @exception NullPointerException if {@code comp} is {@code null}\n+     * @throws NullPointerException if {@code comp} is {@code null}\n@@ -459,1 +459,1 @@\n-     * @exception NullPointerException if {@code comp} is {@code null}\n+     * @throws NullPointerException if {@code comp} is {@code null}\n@@ -482,2 +482,2 @@\n-     * @exception NullPointerException if {@code comp} is {@code null}\n-     * @exception IllegalArgumentException if {@code index} is invalid (see\n+     * @throws NullPointerException if {@code comp} is {@code null}\n+     * @throws IllegalArgumentException if {@code index} is invalid (see\n@@ -767,1 +767,1 @@\n-     * @exception NullPointerException if {@code comp} is\n+     * @throws NullPointerException if {@code comp} is\n@@ -769,1 +769,1 @@\n-     * @exception IllegalArgumentException if {@code comp} is one of the\n+     * @throws IllegalArgumentException if {@code comp} is one of the\n@@ -771,1 +771,1 @@\n-     * @exception IllegalArgumentException if {@code index} is not in\n+     * @throws IllegalArgumentException if {@code index} is not in\n@@ -776,2 +776,2 @@\n-     * @exception IllegalArgumentException if adding a container to itself\n-     * @exception IllegalArgumentException if adding a {@code Window}\n+     * @throws IllegalArgumentException if adding a container to itself\n+     * @throws IllegalArgumentException if adding a {@code Window}\n@@ -992,1 +992,1 @@\n-     * @exception NullPointerException if {@code comp} is {@code null}\n+     * @throws NullPointerException if {@code comp} is {@code null}\n@@ -1022,2 +1022,2 @@\n-     * @exception NullPointerException if {@code comp} is {@code null}\n-     * @exception IllegalArgumentException if {@code index} is invalid (see\n+     * @throws NullPointerException if {@code comp} is {@code null}\n+     * @throws IllegalArgumentException if {@code index} is invalid (see\n@@ -1085,1 +1085,1 @@\n-     * @exception IllegalArgumentException if {@code index} is invalid;\n+     * @throws IllegalArgumentException if {@code index} is invalid;\n@@ -1091,1 +1091,1 @@\n-     * @exception IllegalArgumentException if {@code comp} is an ancestor of\n+     * @throws IllegalArgumentException if {@code comp} is an ancestor of\n@@ -1093,2 +1093,2 @@\n-     * @exception IllegalArgumentException if adding a window to a container\n-     * @exception NullPointerException if {@code comp} is {@code null}\n+     * @throws IllegalArgumentException if adding a window to a container\n+     * @throws NullPointerException if {@code comp} is {@code null}\n@@ -2216,1 +2216,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n@@ -2219,1 +2219,1 @@\n-     * @exception NullPointerException if {@code listenerType} is {@code null}\n+     * @throws NullPointerException if {@code listenerType} is {@code null}\n@@ -2625,1 +2625,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless() returns true\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless() returns true\n@@ -3559,1 +3559,1 @@\n-     * @exception NullPointerException if {@code orientation} is null.\n+     * @throws NullPointerException if {@code orientation} is null.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Container.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -290,1 +290,1 @@\n-     * @exception AWTException in case of erroneous retrieving of the cursor\n+     * @throws AWTException in case of erroneous retrieving of the cursor\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Cursor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}'s\n@@ -334,1 +334,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -355,1 +355,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}'s\n@@ -357,1 +357,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -379,1 +379,1 @@\n-     * @exception IllegalArgumentException if the {@code owner}'s\n+     * @throws IllegalArgumentException if the {@code owner}'s\n@@ -381,1 +381,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -404,1 +404,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}'s\n@@ -406,1 +406,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -436,1 +436,1 @@\n-     * @exception java.lang.IllegalArgumentException if {@code gc}\n+     * @throws java.lang.IllegalArgumentException if {@code gc}\n@@ -438,1 +438,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -462,1 +462,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}'s\n@@ -464,1 +464,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -481,1 +481,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}'s\n@@ -483,1 +483,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -505,1 +505,1 @@\n-     * @exception IllegalArgumentException if the {@code owner}'s\n+     * @throws IllegalArgumentException if the {@code owner}'s\n@@ -507,1 +507,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -539,1 +539,1 @@\n-     * @exception java.lang.IllegalArgumentException if {@code gc}\n+     * @throws java.lang.IllegalArgumentException if {@code gc}\n@@ -541,1 +541,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -568,1 +568,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}\n@@ -571,1 +571,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}'s\n@@ -573,1 +573,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -594,1 +594,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}\n@@ -597,1 +597,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}'s\n@@ -599,1 +599,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -621,1 +621,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}\n@@ -624,1 +624,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}'s\n@@ -626,1 +626,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -628,1 +628,1 @@\n-     * @exception SecurityException if the calling thread does not have permission\n+     * @throws SecurityException if the calling thread does not have permission\n@@ -656,1 +656,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}\n@@ -659,1 +659,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}'s\n@@ -661,1 +661,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -663,1 +663,1 @@\n-     * @exception SecurityException if the calling thread does not have permission\n+     * @throws SecurityException if the calling thread does not have permission\n@@ -707,1 +707,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code owner}\n+     * @throws java.lang.IllegalArgumentException if the {@code owner}\n@@ -710,1 +710,1 @@\n-     * @exception java.lang.IllegalArgumentException if {@code gc}\n+     * @throws java.lang.IllegalArgumentException if {@code gc}\n@@ -712,1 +712,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -714,1 +714,1 @@\n-     * @exception SecurityException if the calling thread does not have permission\n+     * @throws SecurityException if the calling thread does not have permission\n@@ -851,1 +851,1 @@\n-     * @exception SecurityException if the calling thread does not have permission\n+     * @throws SecurityException if the calling thread does not have permission\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Dialog.java","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -547,1 +547,1 @@\n-     * @exception InterruptedException\n+     * @throws InterruptedException\n@@ -949,1 +949,1 @@\n-     * @exception EmptyStackException if no previous push was made\n+     * @throws EmptyStackException if no previous push was made\n@@ -1334,1 +1334,1 @@\n-     * @exception       InterruptedException  if any thread has\n+     * @throws       InterruptedException  if any thread has\n@@ -1336,1 +1336,1 @@\n-     * @exception       InvocationTargetException  if an throwable is thrown\n+     * @throws       InvocationTargetException  if an throwable is thrown\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/EventQueue.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-     * @exception  IllegalArgumentException if an illegal file\n+     * @throws  IllegalArgumentException if an illegal file\n@@ -258,1 +258,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code parent}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code parent}'s\n@@ -261,1 +261,1 @@\n-     * @exception java.lang.IllegalArgumentException if {@code parent}\n+     * @throws java.lang.IllegalArgumentException if {@code parent}\n@@ -288,1 +288,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code parent}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code parent}'s\n@@ -291,1 +291,1 @@\n-     * @exception java.lang.IllegalArgumentException if {@code parent}\n+     * @throws java.lang.IllegalArgumentException if {@code parent}\n@@ -324,1 +324,1 @@\n-     * @exception java.lang.IllegalArgumentException if an illegal\n+     * @throws java.lang.IllegalArgumentException if an illegal\n@@ -326,1 +326,1 @@\n-     * @exception java.lang.IllegalArgumentException if the {@code parent}'s\n+     * @throws java.lang.IllegalArgumentException if the {@code parent}'s\n@@ -329,1 +329,1 @@\n-     * @exception java.lang.IllegalArgumentException if {@code parent}\n+     * @throws java.lang.IllegalArgumentException if {@code parent}\n@@ -411,1 +411,1 @@\n-     * @exception  IllegalArgumentException if an illegal file\n+     * @throws  IllegalArgumentException if an illegal file\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/FileDialog.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -404,1 +404,1 @@\n-     * @exception IllegalArgumentException if\n+     * @throws IllegalArgumentException if\n@@ -406,1 +406,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -421,1 +421,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -443,1 +443,1 @@\n-     * @exception IllegalArgumentException if {@code gc}\n+     * @throws IllegalArgumentException if {@code gc}\n@@ -445,1 +445,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Frame.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-     * @exception AWTException if the supplied image capabilities could not\n+     * @throws AWTException if the supplied image capabilities could not\n@@ -297,1 +297,1 @@\n-     * @exception AWTException if the supplied image capabilities could not\n+     * @throws AWTException if the supplied image capabilities could not\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GraphicsConfiguration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -421,1 +421,1 @@\n-     * @exception IllegalArgumentException if the {@code DisplayMode}\n+     * @throws IllegalArgumentException if the {@code DisplayMode}\n@@ -424,1 +424,1 @@\n-     * @exception UnsupportedOperationException if\n+     * @throws UnsupportedOperationException if\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GraphicsDevice.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-     * @exception HeadlessException if isHeadless() returns true\n+     * @throws HeadlessException if isHeadless() returns true\n@@ -204,1 +204,1 @@\n-     * @exception HeadlessException if isHeadless() returns true\n+     * @throws HeadlessException if isHeadless() returns true\n@@ -386,1 +386,1 @@\n-     * @exception HeadlessException if isHeadless() returns true\n+     * @throws HeadlessException if isHeadless() returns true\n@@ -412,1 +412,1 @@\n-     * @exception HeadlessException if isHeadless() returns true\n+     * @throws HeadlessException if isHeadless() returns true\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GraphicsEnvironment.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -691,1 +691,1 @@\n-     * @exception IllegalArgumentException if {@code constraints}\n+     * @throws IllegalArgumentException if {@code constraints}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GridBagLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-     * @exception   IllegalArgumentException  if the value of both\n+     * @throws   IllegalArgumentException  if the value of both\n@@ -215,1 +215,1 @@\n-     * @exception    IllegalArgumentException  if the value of both\n+     * @throws    IllegalArgumentException  if the value of both\n@@ -243,1 +243,1 @@\n-     * @exception    IllegalArgumentException  if the value of both\n+     * @throws    IllegalArgumentException  if the value of both\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GridLayout.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-     * @exception UnsupportedOperationException if called for a\n+     * @throws UnsupportedOperationException if called for a\n@@ -165,1 +165,1 @@\n-     * @exception IllegalArgumentException if {@code width}\n+     * @throws IllegalArgumentException if {@code width}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Image.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -132,1 +132,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -150,1 +150,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -219,1 +219,1 @@\n-     * @exception  IllegalArgumentException if an improper value for\n+     * @throws  IllegalArgumentException if an improper value for\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Label.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -212,1 +212,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -241,1 +241,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -414,1 +414,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if {@code index}\n+     * @throws ArrayIndexOutOfBoundsException if {@code index}\n@@ -451,1 +451,1 @@\n-     * @exception    IllegalArgumentException\n+     * @throws    IllegalArgumentException\n@@ -473,1 +473,1 @@\n-     * @exception    ArrayIndexOutOfBoundsException\n+     * @throws    ArrayIndexOutOfBoundsException\n@@ -1056,1 +1056,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n@@ -1634,1 +1634,1 @@\n-             * @exception IllegalComponentStateException\n+             * @throws IllegalComponentStateException\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/List.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-     * @exception   InterruptedException  if any thread has\n+     * @throws   InterruptedException  if any thread has\n@@ -424,1 +424,1 @@\n-     * @exception   InterruptedException  if any thread has\n+     * @throws   InterruptedException  if any thread has\n@@ -630,1 +630,1 @@\n-     * @exception     InterruptedException  if any thread has\n+     * @throws     InterruptedException  if any thread has\n@@ -658,1 +658,1 @@\n-     * @exception     InterruptedException  if any thread has\n+     * @throws     InterruptedException  if any thread has\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/MediaTracker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -142,1 +142,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -161,1 +161,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -316,1 +316,1 @@\n-     * @exception     IllegalArgumentException if the value of\n+     * @throws     IllegalArgumentException if the value of\n@@ -360,1 +360,1 @@\n-     * @exception     IllegalArgumentException if the value of\n+     * @throws     IllegalArgumentException if the value of\n@@ -381,1 +381,1 @@\n-     * @exception   IllegalArgumentException if the value of\n+     * @throws   IllegalArgumentException if the value of\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Menu.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/MenuBar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/MenuComponent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -204,1 +204,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -221,1 +221,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -619,1 +619,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/MenuItem.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,2 +65,2 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless() returns true\n-     * @exception SecurityException if a security manager exists and its\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless() returns true\n+     * @throws SecurityException if a security manager exists and its\n@@ -127,1 +127,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless() returns true\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless() returns true\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/MouseInfo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-     * @exception  NegativeArraySizeException if the value of\n+     * @throws  NegativeArraySizeException if the value of\n@@ -144,1 +144,1 @@\n-     * @exception  IndexOutOfBoundsException if {@code npoints} is\n+     * @throws  IndexOutOfBoundsException if {@code npoints} is\n@@ -147,1 +147,1 @@\n-     * @exception  NullPointerException if {@code xpoints} or\n+     * @throws  NullPointerException if {@code xpoints} or\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Polygon.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -85,1 +85,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -152,2 +152,2 @@\n-     * @exception NullPointerException  if the parent is {@code null}\n-     * @exception IllegalArgumentException  if this {@code PopupMenu}\n+     * @throws NullPointerException  if the parent is {@code null}\n+     * @throws IllegalArgumentException  if this {@code PopupMenu}\n@@ -155,1 +155,1 @@\n-     * @exception IllegalArgumentException if the origin is not in the\n+     * @throws IllegalArgumentException if the origin is not in the\n@@ -157,1 +157,1 @@\n-     * @exception RuntimeException if the parent is not showing on screen\n+     * @throws RuntimeException if the parent is not showing on screen\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/PopupMenu.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1067,1 +1067,1 @@\n-     * @exception ClassCastException if the key can not\n+     * @throws ClassCastException if the key can not\n@@ -1102,1 +1102,1 @@\n-     * @exception ClassCastException if the key can not\n+     * @throws ClassCastException if the key can not\n@@ -1120,1 +1120,1 @@\n-     * @exception NullPointerException if the key is\n+     * @throws NullPointerException if the key is\n@@ -1122,1 +1122,1 @@\n-     * @exception ClassCastException if the key can not\n+     * @throws ClassCastException if the key can not\n@@ -1124,1 +1124,1 @@\n-     * @exception IllegalArgumentException if the\n+     * @throws IllegalArgumentException if the\n@@ -1166,1 +1166,1 @@\n-     * @exception ClassCastException if the key can not\n+     * @throws ClassCastException if the key can not\n@@ -1182,1 +1182,1 @@\n-     * @exception ClassCastException class of a key or value\n+     * @throws ClassCastException class of a key or value\n@@ -1185,1 +1185,1 @@\n-     * @exception IllegalArgumentException some aspect\n+     * @throws IllegalArgumentException some aspect\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/RenderingHints.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -369,1 +369,1 @@\n-     * @exception   IllegalArgumentException    when an illegal value for\n+     * @throws   IllegalArgumentException    when an illegal value for\n@@ -371,1 +371,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -397,1 +397,1 @@\n-     * @exception IllegalArgumentException    when an illegal value for\n+     * @throws IllegalArgumentException    when an illegal value for\n@@ -399,1 +399,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -460,1 +460,1 @@\n-     * @exception   IllegalArgumentException  if the value supplied\n+     * @throws   IllegalArgumentException  if the value supplied\n@@ -1065,1 +1065,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Scrollbar.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -176,1 +176,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -194,1 +194,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -215,1 +215,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -255,1 +255,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -424,1 +424,1 @@\n-     * @exception   IllegalArgumentException   if the value\n+     * @throws   IllegalArgumentException   if the value\n@@ -455,1 +455,1 @@\n-     * @exception   IllegalArgumentException   if the value\n+     * @throws   IllegalArgumentException   if the value\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/TextArea.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-     * @exception  HeadlessException if\n+     * @throws  HeadlessException if\n@@ -514,1 +514,1 @@\n-     * @exception    IllegalArgumentException if {@code position}\n+     * @throws    IllegalArgumentException if {@code position}\n@@ -648,1 +648,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/TextComponent.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -170,1 +170,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -185,1 +185,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -206,1 +206,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -372,1 +372,1 @@\n-     * @exception  IllegalArgumentException   if the value\n+     * @throws  IllegalArgumentException   if the value\n@@ -588,1 +588,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/TextField.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -184,1 +184,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -211,1 +211,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -277,1 +277,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -289,1 +289,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -300,1 +300,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -327,1 +327,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -976,1 +976,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -1023,1 +1023,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -1060,1 +1060,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -1114,1 +1114,1 @@\n-     * @exception java.lang.IllegalArgumentException if {@code keyCode}\n+     * @throws java.lang.IllegalArgumentException if {@code keyCode}\n@@ -1116,1 +1116,1 @@\n-     * @exception java.lang.UnsupportedOperationException if the host system doesn't\n+     * @throws java.lang.UnsupportedOperationException if the host system doesn't\n@@ -1119,1 +1119,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -1150,1 +1150,1 @@\n-     * @exception java.lang.IllegalArgumentException if {@code keyCode}\n+     * @throws java.lang.IllegalArgumentException if {@code keyCode}\n@@ -1152,1 +1152,1 @@\n-     * @exception java.lang.UnsupportedOperationException if the host system doesn't\n+     * @throws java.lang.UnsupportedOperationException if the host system doesn't\n@@ -1155,1 +1155,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -1196,1 +1196,1 @@\n-     * @exception IndexOutOfBoundsException if the hotSpot values are outside\n+     * @throws IndexOutOfBoundsException if the hotSpot values are outside\n@@ -1199,1 +1199,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -1235,1 +1235,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -1265,1 +1265,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -1313,1 +1313,1 @@\n-     * @exception HeadlessException\n+     * @throws HeadlessException\n@@ -2206,1 +2206,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -2363,1 +2363,1 @@\n-    * @exception HeadlessException if GraphicsEnvironment.isHeadless() returns true\n+    * @throws HeadlessException if GraphicsEnvironment.isHeadless() returns true\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Toolkit.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-     * @exception IllegalArgumentException if {@code gc}\n+     * @throws IllegalArgumentException if {@code gc}\n@@ -447,1 +447,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -547,1 +547,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -569,1 +569,1 @@\n-     * @exception IllegalArgumentException if the {@code owner}'s\n+     * @throws IllegalArgumentException if the {@code owner}'s\n@@ -571,1 +571,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -596,1 +596,1 @@\n-     * @exception IllegalArgumentException if the {@code owner}'s\n+     * @throws IllegalArgumentException if the {@code owner}'s\n@@ -598,1 +598,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -630,1 +630,1 @@\n-     * @exception IllegalArgumentException if {@code gc}\n+     * @throws IllegalArgumentException if {@code gc}\n@@ -632,1 +632,1 @@\n-     * @exception HeadlessException when\n+     * @throws HeadlessException when\n@@ -1967,1 +1967,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n@@ -1970,1 +1970,1 @@\n-     * @exception NullPointerException if {@code listenerType} is {@code null}\n+     * @throws NullPointerException if {@code listenerType} is {@code null}\n@@ -3375,2 +3375,2 @@\n-     * @exception IllegalArgumentException if numBuffers is less than 1.\n-     * @exception IllegalStateException if the component is not displayable\n+     * @throws IllegalArgumentException if numBuffers is less than 1.\n+     * @throws IllegalStateException if the component is not displayable\n@@ -3396,1 +3396,1 @@\n-     * @exception AWTException if the capabilities supplied could not be\n+     * @throws AWTException if the capabilities supplied could not be\n@@ -3400,1 +3400,1 @@\n-     * @exception IllegalArgumentException if numBuffers is less than 1, or if\n+     * @throws IllegalArgumentException if numBuffers is less than 1, or if\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Window.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -258,1 +258,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -685,1 +685,1 @@\n-     * @exception ClassCastException if {@code listenerType}\n+     * @throws ClassCastException if {@code listenerType}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/dnd\/DragSource.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -139,1 +139,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -152,1 +152,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -168,1 +168,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -188,1 +188,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/dnd\/DropTarget.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n- Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -382,4 +382,4 @@\n-        <li>Frame F is shown<br>\n-        <li>Document-modal dialog D<sub>i<\/sub> is shown<br>\n-        <li>F becomes blocked by D<sub>i<\/sub> &mdash; it's in the same document<br>\n-        <li>Document-modal dialog D<sub>ii<\/sub> is shown<br>\n+        <li>Frame F is shown\n+        <li>Document-modal dialog D<sub>i<\/sub> is shown\n+        <li>F becomes blocked by D<sub>i<\/sub> &mdash; it's in the same document\n+        <li>Document-modal dialog D<sub>ii<\/sub> is shown\n@@ -387,1 +387,1 @@\n-            same document<br>\n+            same document\n@@ -395,4 +395,4 @@\n-        <li>Frame F is shown<br>\n-        <li>Document-modal dialog D<sub>i<\/sub> is shown<br>\n-        <li>F becomes blocked by D<sub>i<\/sub> &mdash; it's in the same document<br>\n-        <li>Document-modal dialog D<sub>ii<\/sub> is shown<br>\n+        <li>Frame F is shown\n+        <li>Document-modal dialog D<sub>i<\/sub> is shown\n+        <li>F becomes blocked by D<sub>i<\/sub> &mdash; it's in the same document\n+        <li>Document-modal dialog D<sub>ii<\/sub> is shown\n@@ -400,1 +400,1 @@\n-            same document<br>\n+            same document\n@@ -408,5 +408,5 @@\n-        <li>Frame F is shown<br>\n-        <li>Toolkit-modal dialog D<sub>i<\/sub> is created, but not shown<br>\n-        <li>Document-modal dialog D<sub>ii<\/sub> is shown<br>\n-        <li>F becomes blocked by D<sub>ii<\/sub> &mdash; it's in the same document<br>\n-        <li>Application-modal dialog D<sub>iii<\/sub> is shown<br>\n+        <li>Frame F is shown\n+        <li>Toolkit-modal dialog D<sub>i<\/sub> is created, but not shown\n+        <li>Document-modal dialog D<sub>ii<\/sub> is shown\n+        <li>F becomes blocked by D<sub>ii<\/sub> &mdash; it's in the same document\n+        <li>Application-modal dialog D<sub>iii<\/sub> is shown\n@@ -414,3 +414,3 @@\n-            it's in the same application<br>\n-        <li>D<sub>i<\/sub> is shown<br>\n-        <li>D<sub>i<\/sub> becomes blocked by D<sub>ii<\/sub> &mdash; it's its owner<br>\n+            it's in the same application\n+        <li>D<sub>i<\/sub> is shown\n+        <li>D<sub>i<\/sub> becomes blocked by D<sub>ii<\/sub> &mdash; it's its owner\n@@ -418,1 +418,1 @@\n-            D<sub>ii<\/sub> blocks D<sub>i<\/sub><br>\n+            D<sub>ii<\/sub> blocks D<sub>i<\/sub>\n@@ -426,5 +426,5 @@\n-        <li>Frame F is shown<br>\n-        <li>Toolkit-modal dialog D<sub>i<\/sub> is created, but not shown<br>\n-        <li>Document-modal dialog D<sub>ii<\/sub> is shown<br>\n-        <li>F becomes blocked by D<sub>ii<\/sub> &mdash; it's in the same document<br>\n-        <li>Application-modal dialog D<sub>iii<\/sub> is shown<br>\n+        <li>Frame F is shown\n+        <li>Toolkit-modal dialog D<sub>i<\/sub> is created, but not shown\n+        <li>Document-modal dialog D<sub>ii<\/sub> is shown\n+        <li>F becomes blocked by D<sub>ii<\/sub> &mdash; it's in the same document\n+        <li>Application-modal dialog D<sub>iii<\/sub> is shown\n@@ -432,2 +432,2 @@\n-            same application<br>\n-        <li>D<sub>i<\/sub> is shown<br>\n+            same application\n+        <li>D<sub>i<\/sub> is shown\n@@ -435,2 +435,2 @@\n-            is not blocked<br>\n-        <li>D<sub>i<\/sub> remains unblocked<br>\n+            is not blocked\n+        <li>D<sub>i<\/sub> remains unblocked\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/Modality.html","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -439,1 +439,1 @@\n-     * @exception  IllegalArgumentException  if source is null.\n+     * @throws  IllegalArgumentException  if source is null.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/event\/InputMethodEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -792,1 +792,1 @@\n-     * @exception Error if this layout has already been justified, an Error is\n+     * @throws Error if this layout has already been justified, an Error is\n@@ -2641,0 +2641,3 @@\n+        if (graphic == null) {\n+            return (byte)GraphicAttribute.ROMAN_BASELINE;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/TextLayout.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2670,1 +2670,1 @@\n-     * @exception NoninvertibleTransformException\n+     * @throws NoninvertibleTransformException\n@@ -2765,1 +2765,1 @@\n-     * @exception NoninvertibleTransformException\n+     * @throws NoninvertibleTransformException\n@@ -3467,1 +3467,1 @@\n-     * @exception NoninvertibleTransformException  if the matrix cannot be\n+     * @throws NoninvertibleTransformException  if the matrix cannot be\n@@ -3553,1 +3553,1 @@\n-     * @exception NoninvertibleTransformException  if the matrix cannot be\n+     * @throws NoninvertibleTransformException  if the matrix cannot be\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/AffineTransform.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1567,1 +1567,1 @@\n-     * @exception  OutOfMemoryError            if there is not enough memory.\n+     * @throws  OutOfMemoryError            if there is not enough memory.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/CubicCurve2D.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-     * @exception  OutOfMemoryError            if there is not enough memory.\n+     * @throws  OutOfMemoryError            if there is not enough memory.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Dimension2D.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-     * @exception IllegalArgumentException if\n+     * @throws IllegalArgumentException if\n@@ -339,1 +339,1 @@\n-     * @exception NoSuchElementException if there\n+     * @throws NoSuchElementException if there\n@@ -374,1 +374,1 @@\n-     * @exception NoSuchElementException if there\n+     * @throws NoSuchElementException if there\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/FlatteningPathIterator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1114,1 +1114,1 @@\n-     * @exception  OutOfMemoryError            if there is not enough memory.\n+     * @throws  OutOfMemoryError            if there is not enough memory.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Line2D.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -845,1 +845,1 @@\n-         * @exception  OutOfMemoryError    if there is not enough memory.\n+         * @throws  OutOfMemoryError    if there is not enough memory.\n@@ -1641,1 +1641,1 @@\n-         * @exception  OutOfMemoryError    if there is not enough memory.\n+         * @throws  OutOfMemoryError    if there is not enough memory.\n@@ -2021,1 +2021,1 @@\n-     * @exception IllegalArgumentException if\n+     * @throws IllegalArgumentException if\n@@ -2533,1 +2533,1 @@\n-     * @exception  OutOfMemoryError            if there is not enough memory.\n+     * @throws  OutOfMemoryError            if there is not enough memory.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Path2D.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -390,1 +390,1 @@\n-     * @exception  OutOfMemoryError            if there is not enough memory.\n+     * @throws  OutOfMemoryError            if there is not enough memory.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Point2D.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1391,1 +1391,1 @@\n-     * @exception  OutOfMemoryError            if there is not enough memory.\n+     * @throws  OutOfMemoryError            if there is not enough memory.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/QuadCurve2D.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -385,1 +385,1 @@\n-     * @exception  OutOfMemoryError            if there is not enough memory.\n+     * @throws  OutOfMemoryError            if there is not enough memory.\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/RectangularShape.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-     * @exception NullPointerException if {@code locale} is null\n+     * @throws NullPointerException if {@code locale} is null\n@@ -271,1 +271,1 @@\n-     * @exception NullPointerException if {@code event} is null\n+     * @throws NullPointerException if {@code event} is null\n@@ -289,1 +289,1 @@\n-     * @exception NullPointerException if {@code client} is null\n+     * @throws NullPointerException if {@code client} is null\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/im\/InputContext.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-     * @exception IllegalArgumentException if a state other than RAW_TEXT or CONVERTED_TEXT is given\n+     * @throws IllegalArgumentException if a state other than RAW_TEXT or CONVERTED_TEXT is given\n@@ -128,1 +128,1 @@\n-     * @exception IllegalArgumentException if a state other than RAW_TEXT or CONVERTED_TEXT is given\n+     * @throws IllegalArgumentException if a state other than RAW_TEXT or CONVERTED_TEXT is given\n@@ -143,1 +143,1 @@\n-     * @exception IllegalArgumentException if a state other than RAW_TEXT or CONVERTED_TEXT is given\n+     * @throws IllegalArgumentException if a state other than RAW_TEXT or CONVERTED_TEXT is given\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/im\/InputMethodHighlight.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-     * @exception NullPointerException if {@code context} is null\n+     * @throws NullPointerException if {@code context} is null\n@@ -83,1 +83,1 @@\n-     * @exception NullPointerException if {@code locale} is null\n+     * @throws NullPointerException if {@code locale} is null\n@@ -214,1 +214,1 @@\n-     * @exception NullPointerException if {@code event} is null\n+     * @throws NullPointerException if {@code event} is null\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/im\/spi\/InputMethod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-     * @exception HeadlessException if {@code GraphicsEnvironment.isHeadless}\n+     * @throws HeadlessException if {@code GraphicsEnvironment.isHeadless}\n@@ -127,1 +127,1 @@\n-     * @exception HeadlessException if {@code GraphicsEnvironment.isHeadless}\n+     * @throws HeadlessException if {@code GraphicsEnvironment.isHeadless}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/im\/spi\/InputMethodContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-     * @exception AWTException if it can be determined that the input method\n+     * @throws AWTException if it can be determined that the input method\n@@ -125,1 +125,1 @@\n-     * @exception Exception any exception that may occur while creating the\n+     * @throws Exception any exception that may occur while creating the\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/im\/spi\/InputMethodDescriptor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -597,1 +597,1 @@\n-     * @exception RasterFormatException if the number and\n+     * @throws RasterFormatException if the number and\n@@ -602,1 +602,1 @@\n-     * @exception IllegalArgumentException if\n+     * @throws IllegalArgumentException if\n@@ -1198,1 +1198,1 @@\n-     * @exception RasterFormatException if the specified\n+     * @throws RasterFormatException if the specified\n@@ -1394,1 +1394,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if both\n+     * @throws ArrayIndexOutOfBoundsException if both\n@@ -1564,1 +1564,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if both\n+     * @throws ArrayIndexOutOfBoundsException if both\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/BufferedImage.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if {@code src} is\n+     * @throws ArrayIndexOutOfBoundsException if {@code src} is\n@@ -171,1 +171,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if {@code src} is\n+     * @throws ArrayIndexOutOfBoundsException if {@code src} is\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ByteLookupTable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-     * @exception IllegalArgumentException when the profile sequence does not\n+     * @throws IllegalArgumentException when the profile sequence does not\n@@ -199,1 +199,1 @@\n-     * @exception NullPointerException if profiles is null\n+     * @throws NullPointerException if profiles is null\n@@ -245,1 +245,1 @@\n-     * @exception IllegalArgumentException if dest is null and this op was\n+     * @throws IllegalArgumentException if dest is null and this op was\n@@ -459,1 +459,1 @@\n-     * @exception IllegalArgumentException if the number of source or\n+     * @throws IllegalArgumentException if the number of source or\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorConvertOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-     * @exception ClassCastException if {@code inData}\n+     * @throws ClassCastException if {@code inData}\n@@ -647,1 +647,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if\n+     * @throws ArrayIndexOutOfBoundsException if\n@@ -650,1 +650,1 @@\n-     * @exception UnsupportedOperationException if this\n+     * @throws UnsupportedOperationException if this\n@@ -697,1 +697,1 @@\n-     * @exception UnsupportedOperationException if this\n+     * @throws UnsupportedOperationException if this\n@@ -747,1 +747,1 @@\n-     * @exception ClassCastException if {@code pixel}\n+     * @throws ClassCastException if {@code pixel}\n@@ -749,1 +749,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if\n+     * @throws ArrayIndexOutOfBoundsException if\n@@ -752,1 +752,1 @@\n-     * @exception UnsupportedOperationException if this\n+     * @throws UnsupportedOperationException if this\n@@ -966,1 +966,1 @@\n-     * @exception ClassCastException if {@code pixel}\n+     * @throws ClassCastException if {@code pixel}\n@@ -968,1 +968,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if\n+     * @throws ArrayIndexOutOfBoundsException if\n@@ -973,1 +973,1 @@\n-     * @exception UnsupportedOperationException if this\n+     * @throws UnsupportedOperationException if this\n@@ -1058,1 +1058,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if\n+     * @throws ArrayIndexOutOfBoundsException if\n@@ -1100,1 +1100,1 @@\n-     * @exception ClassCastException if {@code obj}\n+     * @throws ClassCastException if {@code obj}\n@@ -1102,1 +1102,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if\n+     * @throws ArrayIndexOutOfBoundsException if\n@@ -1107,1 +1107,1 @@\n-     * @exception UnsupportedOperationException if this\n+     * @throws UnsupportedOperationException if this\n@@ -1172,1 +1172,1 @@\n-     * @exception UnsupportedOperationException if this\n+     * @throws UnsupportedOperationException if this\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/DirectColorModel.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-     * @exception NullPointerException if {@code props} is null\n+     * @throws NullPointerException if {@code props} is null\n@@ -248,1 +248,1 @@\n-     * @exception NullPointerException if {@code ip} is null\n+     * @throws NullPointerException if {@code ip} is null\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ImageFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-     * @exception RasterFormatException if the number of bits per pixel\n+     * @throws RasterFormatException if the number of bits per pixel\n@@ -324,1 +324,1 @@\n-     * @exception RasterFormatException if the number of bands requested\n+     * @throws RasterFormatException if the number of bands requested\n@@ -351,1 +351,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if the specified\n+     * @throws ArrayIndexOutOfBoundsException if the specified\n@@ -380,1 +380,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if the coordinates are\n+     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n@@ -445,1 +445,1 @@\n-     * @exception ClassCastException if {@code obj} is not a\n+     * @throws ClassCastException if {@code obj} is not a\n@@ -447,1 +447,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if the coordinates are\n+     * @throws ArrayIndexOutOfBoundsException if the coordinates are\n@@ -529,1 +529,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if the coordinates\n+     * @throws ArrayIndexOutOfBoundsException if the coordinates\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/MultiPixelPackedSampleModel.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-     * @exception InterruptedException\n+     * @throws InterruptedException\n@@ -246,1 +246,1 @@\n-     * @exception InterruptedException\n+     * @throws InterruptedException\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/PixelGrabber.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-     * @exception NullPointerException if {@code icm} is null\n+     * @throws NullPointerException if {@code icm} is null\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/RGBImageFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1378,1 +1378,1 @@\n-     * @exception RasterFormatException if the width or height is less than\n+     * @throws RasterFormatException if the width or height is less than\n@@ -1504,1 +1504,1 @@\n-     * @exception RasterFormatException if the specified subregion is outside\n+     * @throws RasterFormatException if the specified subregion is outside\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/Raster.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if {@code src} is\n+     * @throws ArrayIndexOutOfBoundsException if {@code src} is\n@@ -165,1 +165,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if {@code src} is\n+     * @throws ArrayIndexOutOfBoundsException if {@code src} is\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ShortLookupTable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-     * @exception RasterFormatException if the length of the bands argument is\n+     * @throws RasterFormatException if the length of the bands argument is\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/SinglePixelPackedSampleModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-     * @exception RasterFormatException if the subregion is outside of the\n+     * @throws RasterFormatException if the subregion is outside of the\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/WritableRaster.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-     * @exception NullPointerException\n+     * @throws NullPointerException\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/print\/PageFormat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-     * @exception java.awt.print.PrinterException\n+     * @throws java.awt.print.PrinterException\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/print\/Printable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-     * @exception PrinterException if the specified service does not support\n+     * @throws PrinterException if the specified service does not support\n@@ -215,1 +215,1 @@\n-     * @exception NullPointerException the {@code Pageable} passed in\n+     * @throws NullPointerException the {@code Pageable} passed in\n@@ -238,1 +238,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -282,1 +282,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -284,1 +284,1 @@\n-     * @exception NullPointerException if {@code attributes} parameter\n+     * @throws NullPointerException if {@code attributes} parameter\n@@ -316,1 +316,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -345,1 +345,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -347,1 +347,1 @@\n-     * @exception NullPointerException if {@code attributes} parameter\n+     * @throws NullPointerException if {@code attributes} parameter\n@@ -498,1 +498,1 @@\n-     * @exception PrinterException an error in the print system\n+     * @throws PrinterException an error in the print system\n@@ -536,1 +536,1 @@\n-     * @exception PrinterException an error in the print system\n+     * @throws PrinterException an error in the print system\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/print\/PrinterJob.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -879,1 +879,1 @@\n-     * @exception IllegalArgumentException if <code>textPosition<\/code>\n+     * @throws IllegalArgumentException if <code>textPosition<\/code>\n@@ -956,1 +956,1 @@\n-     * @exception IllegalArgumentException if key is not one of the legal\n+     * @throws IllegalArgumentException if key is not one of the legal\n@@ -987,1 +987,1 @@\n-     * @exception IllegalArgumentException if key is not one of the legal\n+     * @throws IllegalArgumentException if key is not one of the legal\n@@ -1574,1 +1574,1 @@\n-     * @exception IllegalArgumentException will be thrown if <code>index<\/code>\n+     * @throws IllegalArgumentException will be thrown if <code>index<\/code>\n@@ -1657,1 +1657,1 @@\n-     * @exception   IllegalArgumentException if threshhold &lt; 0\n+     * @throws   IllegalArgumentException if threshhold &lt; 0\n@@ -1794,2 +1794,2 @@\n-     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n-     * @exception IllegalArgumentException if adding the container's parent\n+     * @throws IllegalArgumentException if <code>index<\/code> is invalid\n+     * @throws IllegalArgumentException if adding the container's parent\n@@ -1797,1 +1797,1 @@\n-     * @exception IllegalArgumentException if adding a window to a container\n+     * @throws IllegalArgumentException if adding a window to a container\n@@ -3067,1 +3067,1 @@\n-             * @exception IllegalArgumentException if the index is\n+             * @throws IllegalArgumentException if the index is\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/AbstractButton.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code> doesn't\n+     * @throws ClassCastException if <code>listenerType<\/code> doesn't\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/AbstractListModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-     * @exception IllegalArgumentException if type is not either\n+     * @throws IllegalArgumentException if type is not either\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/BorderFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-     * @exception AWTError  if the value of {@code axis} is invalid\n+     * @throws AWTError  if the value of {@code axis} is invalid\n@@ -237,1 +237,1 @@\n-     * @exception AWTError  if the target isn't the container specified to the\n+     * @throws AWTError  if the target isn't the container specified to the\n@@ -283,1 +283,1 @@\n-     * @exception AWTError  if the target isn't the container specified to the\n+     * @throws AWTError  if the target isn't the container specified to the\n@@ -309,1 +309,1 @@\n-     * @exception AWTError  if the target isn't the container specified to the\n+     * @throws AWTError  if the target isn't the container specified to the\n@@ -334,1 +334,1 @@\n-     * @exception AWTError  if the target isn't the container specified to the\n+     * @throws AWTError  if the target isn't the container specified to the\n@@ -361,1 +361,1 @@\n-     * @exception AWTError  if the target isn't the container specified to the\n+     * @throws AWTError  if the target isn't the container specified to the\n@@ -378,1 +378,1 @@\n-     * @exception AWTError  if the target isn't the container specified to the\n+     * @throws AWTError  if the target isn't the container specified to the\n@@ -393,1 +393,1 @@\n-     * @exception AWTError  if the target isn't the container specified to the\n+     * @throws AWTError  if the target isn't the container specified to the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/BoxLayout.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code> doesn't\n+     * @throws ClassCastException if <code>listenerType<\/code> doesn't\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultBoundedRangeModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code> doesn't\n+     * @throws ClassCastException if <code>listenerType<\/code> doesn't\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultButtonModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-     * @exception  ArrayIndexOutOfBoundsException if the index was invalid\n+     * @throws  ArrayIndexOutOfBoundsException if the index was invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultListModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code> doesn't\n+     * @throws ClassCastException if <code>listenerType<\/code> doesn't\n@@ -753,1 +753,1 @@\n-     * @exception CloneNotSupportedException if the selection model does not\n+     * @throws CloneNotSupportedException if the selection model does not\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultListSelectionModel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code> doesn't\n+     * @throws ClassCastException if <code>listenerType<\/code> doesn't\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultSingleSelectionModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -315,2 +315,2 @@\n-     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n-     * @exception IllegalArgumentException if adding the container's parent\n+     * @throws IllegalArgumentException if <code>index<\/code> is invalid\n+     * @throws IllegalArgumentException if adding the container's parent\n@@ -318,1 +318,1 @@\n-     * @exception IllegalArgumentException if adding a window to a container\n+     * @throws IllegalArgumentException if adding a window to a container\n@@ -426,1 +426,1 @@\n-     * @exception java.awt.IllegalComponentStateException (a runtime\n+     * @throws java.awt.IllegalComponentStateException (a runtime\n@@ -440,1 +440,1 @@\n-     * @exception java.awt.IllegalComponentStateException (a runtime\n+     * @throws java.awt.IllegalComponentStateException (a runtime\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JApplet.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -176,1 +176,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -220,1 +220,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -346,1 +346,1 @@\n-     * @exception IllegalArgumentException if r,g,b values are out of range\n+     * @throws IllegalArgumentException if r,g,b values are out of range\n@@ -389,1 +389,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -467,1 +467,1 @@\n-     * @exception IllegalArgumentException if panel is not in list of\n+     * @throws IllegalArgumentException if panel is not in list of\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JColorChooser.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -641,1 +641,1 @@\n-     * @exception IllegalArgumentException if <code>anIndex<\/code> &lt; -1 or\n+     * @throws IllegalArgumentException if <code>anIndex<\/code> &lt; -1 or\n@@ -818,1 +818,1 @@\n-     * @exception RuntimeException if <code>dataModel<\/code> is not an\n+     * @throws RuntimeException if <code>dataModel<\/code> is not an\n@@ -2301,1 +2301,1 @@\n-             * @exception IllegalComponentStateException\n+             * @throws IllegalComponentStateException\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComboBox.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2458,1 +2458,1 @@\n-     * @exception IllegalArgumentException if <code>condition<\/code> is\n+     * @throws IllegalArgumentException if <code>condition<\/code> is\n@@ -2557,1 +2557,1 @@\n-     * @exception IllegalArgumentException if <code>condition<\/code>\n+     * @throws IllegalArgumentException if <code>condition<\/code>\n@@ -4626,1 +4626,1 @@\n-     * @exception java.beans.PropertyVetoException when the attempt to set the\n+     * @throws java.beans.PropertyVetoException when the attempt to set the\n@@ -4802,1 +4802,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code>\n+     * @throws ClassCastException if <code>listenerType<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComponent.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-     * @exception IOException if the URL is <code>null<\/code>\n+     * @throws IOException if the URL is <code>null<\/code>\n@@ -328,1 +328,1 @@\n-     * @exception IOException if the URL is <code>null<\/code> or\n+     * @throws IOException if the URL is <code>null<\/code> or\n@@ -343,1 +343,1 @@\n-     * @exception NullPointerException if the <code>type<\/code> parameter\n+     * @throws NullPointerException if the <code>type<\/code> parameter\n@@ -465,1 +465,1 @@\n-     * @exception IOException for a <code>null<\/code> or invalid\n+     * @throws IOException for a <code>null<\/code> or invalid\n@@ -581,1 +581,1 @@\n-     * @exception IOException as thrown by the stream being\n+     * @throws IOException as thrown by the stream being\n@@ -928,1 +928,1 @@\n-     * @exception IOException for a <code>null<\/code> or invalid URL\n+     * @throws IOException for a <code>null<\/code> or invalid URL\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JEditorPane.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -661,1 +661,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -686,1 +686,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -746,1 +746,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -803,1 +803,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -927,1 +927,1 @@\n-     * @exception IllegalArgumentException if <code>dialogType<\/code> is\n+     * @throws IllegalArgumentException if <code>dialogType<\/code> is\n@@ -1314,1 +1314,1 @@\n-     * @exception IllegalArgumentException  if <code>mode<\/code> is an\n+     * @throws IllegalArgumentException  if <code>mode<\/code> is an\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JFileChooser.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -196,1 +196,1 @@\n-     * @exception IllegalArgumentException if <code>gc<\/code> is not from\n+     * @throws IllegalArgumentException if <code>gc<\/code> is not from\n@@ -216,1 +216,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -242,1 +242,1 @@\n-     * @exception IllegalArgumentException if <code>gc<\/code> is not from\n+     * @throws IllegalArgumentException if <code>gc<\/code> is not from\n@@ -360,1 +360,1 @@\n-     * @exception IllegalArgumentException if defaultCloseOperation value\n+     * @throws IllegalArgumentException if defaultCloseOperation value\n@@ -543,2 +543,2 @@\n-     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n-     * @exception IllegalArgumentException if adding the container's parent\n+     * @throws IllegalArgumentException if <code>index<\/code> is invalid\n+     * @throws IllegalArgumentException if adding the container's parent\n@@ -546,1 +546,1 @@\n-     * @exception IllegalArgumentException if adding a window to a container\n+     * @throws IllegalArgumentException if adding a window to a container\n@@ -671,1 +671,1 @@\n-     * @exception java.awt.IllegalComponentStateException (a runtime\n+     * @throws java.awt.IllegalComponentStateException (a runtime\n@@ -699,1 +699,1 @@\n-     * @exception java.awt.IllegalComponentStateException (a runtime\n+     * @throws java.awt.IllegalComponentStateException (a runtime\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JFrame.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -500,2 +500,2 @@\n-     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n-     * @exception IllegalArgumentException if adding the container's parent\n+     * @throws IllegalArgumentException if <code>index<\/code> is invalid\n+     * @throws IllegalArgumentException if adding the container's parent\n@@ -503,1 +503,1 @@\n-     * @exception IllegalArgumentException if adding a window to a container\n+     * @throws IllegalArgumentException if adding a window to a container\n@@ -631,1 +631,1 @@\n-     * @exception java.awt.IllegalComponentStateException (a runtime\n+     * @throws java.awt.IllegalComponentStateException (a runtime\n@@ -660,1 +660,1 @@\n-     * @exception java.awt.IllegalComponentStateException (a runtime\n+     * @throws java.awt.IllegalComponentStateException (a runtime\n@@ -797,1 +797,1 @@\n-     * @exception PropertyVetoException when the attempt to set the\n+     * @throws PropertyVetoException when the attempt to set the\n@@ -909,1 +909,1 @@\n-     * @exception PropertyVetoException when the attempt to set the\n+     * @throws PropertyVetoException when the attempt to set the\n@@ -988,1 +988,1 @@\n-     * @exception PropertyVetoException when the attempt to set the\n+     * @throws PropertyVetoException when the attempt to set the\n@@ -1050,1 +1050,1 @@\n-     * @exception PropertyVetoException when the attempt to set the\n+     * @throws PropertyVetoException when the attempt to set the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JInternalFrame.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -554,1 +554,1 @@\n-     * @exception IllegalArgumentException will be thrown if <code>index<\/code>\n+     * @throws IllegalArgumentException will be thrown if <code>index<\/code>\n@@ -598,1 +598,1 @@\n-     * @exception IllegalArgumentException if key isn't LEFT, CENTER, RIGHT,\n+     * @throws IllegalArgumentException if key isn't LEFT, CENTER, RIGHT,\n@@ -625,1 +625,1 @@\n-     * @exception IllegalArgumentException if key isn't TOP, CENTER, or BOTTOM.\n+     * @throws IllegalArgumentException if key isn't TOP, CENTER, or BOTTOM.\n@@ -1640,1 +1640,1 @@\n-             * @exception IllegalArgumentException if the index is\n+             * @throws IllegalArgumentException if the index is\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JLabel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-     * @exception IllegalArgumentException this method is not supported\n+     * @throws IllegalArgumentException this method is not supported\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JLayer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -448,1 +448,1 @@\n-     * @exception IllegalArgumentException if the model is {@code null}\n+     * @throws IllegalArgumentException if the model is {@code null}\n@@ -1205,1 +1205,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -1496,1 +1496,1 @@\n-     * @exception IllegalArgumentException if prefix is {@code null}\n+     * @throws IllegalArgumentException if prefix is {@code null}\n@@ -1698,1 +1698,1 @@\n-     * @exception IllegalArgumentException  if <code>model<\/code> is\n+     * @throws IllegalArgumentException  if <code>model<\/code> is\n@@ -1913,1 +1913,1 @@\n-     * @exception IllegalArgumentException   if <code>selectionModel<\/code>\n+     * @throws IllegalArgumentException   if <code>selectionModel<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JList.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -511,1 +511,1 @@\n-     * @exception   IllegalArgumentException if <code>d<\/code>\n+     * @throws   IllegalArgumentException if <code>d<\/code>\n@@ -677,1 +677,1 @@\n-     * @exception IllegalArgumentException when the value of\n+     * @throws IllegalArgumentException when the value of\n@@ -696,1 +696,1 @@\n-     * @exception IllegalArgumentException if the value of\n+     * @throws IllegalArgumentException if the value of\n@@ -716,1 +716,1 @@\n-     * @exception IllegalArgumentException if the value of\n+     * @throws IllegalArgumentException if the value of\n@@ -737,1 +737,1 @@\n-     * @exception   IllegalArgumentException if the value of\n+     * @throws   IllegalArgumentException if the value of\n@@ -758,1 +758,1 @@\n-     * @exception  IllegalArgumentException if the value of\n+     * @throws  IllegalArgumentException if the value of\n@@ -793,1 +793,1 @@\n-     * @exception  Error  if invoked -- this method is not yet implemented\n+     * @throws  Error  if invoked -- this method is not yet implemented\n@@ -815,1 +815,1 @@\n-     * @exception   IllegalArgumentException if the value of\n+     * @throws   IllegalArgumentException if the value of\n@@ -1027,1 +1027,1 @@\n-     * @exception Error  if there is a <code>null<\/code> listener\n+     * @throws Error  if there is a <code>null<\/code> listener\n@@ -1057,1 +1057,1 @@\n-     * @exception Error if there is a <code>null<\/code> listener\n+     * @throws Error if there is a <code>null<\/code> listener\n@@ -1087,1 +1087,1 @@\n-     * @exception Error if there is a <code>null<\/code> listener\n+     * @throws Error if there is a <code>null<\/code> listener\n@@ -1241,1 +1241,1 @@\n-     * @exception NullPointerException if <code>orientation<\/code> is null.\n+     * @throws NullPointerException if <code>orientation<\/code> is null.\n@@ -1278,1 +1278,1 @@\n-     * @exception Error  if invoked -- this method is not defined for JMenu.\n+     * @throws Error  if invoked -- this method is not defined for JMenu.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JMenu.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -438,1 +438,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -474,1 +474,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -526,1 +526,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -569,1 +569,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -612,1 +612,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -640,1 +640,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -669,1 +669,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -693,1 +693,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -721,1 +721,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -760,1 +760,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -798,1 +798,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -859,1 +859,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -922,1 +922,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -949,1 +949,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -1511,1 +1511,1 @@\n-     * @exception RuntimeException if <code>parentComponent<\/code> does\n+     * @throws RuntimeException if <code>parentComponent<\/code> does\n@@ -1603,1 +1603,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -1629,1 +1629,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -1686,1 +1686,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -2053,1 +2053,1 @@\n-     * @exception RuntimeException if <code>newType<\/code> is not one of the\n+     * @throws RuntimeException if <code>newType<\/code> is not one of the\n@@ -2099,1 +2099,1 @@\n-     * @exception RuntimeException if <code>newType<\/code> is not one of\n+     * @throws RuntimeException if <code>newType<\/code> is not one of\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JOptionPane.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-     * @exception BadLocationException if the offset or length are invalid\n+     * @throws BadLocationException if the offset or length are invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JPasswordField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-     * @exception   IllegalArgumentException if the value of\n+     * @throws   IllegalArgumentException if the value of\n@@ -576,1 +576,1 @@\n-     * @exception IllegalArgumentException if <code>index<\/code> &lt; 0\n+     * @throws IllegalArgumentException if <code>index<\/code> &lt; 0\n@@ -592,1 +592,1 @@\n-     * @exception IllegalArgumentException if <code>index<\/code> &lt; 0\n+     * @throws IllegalArgumentException if <code>index<\/code> &lt; 0\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JPopupMenu.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-     * @exception      IllegalArgumentException    if <code>newOrientation<\/code>\n+     * @throws      IllegalArgumentException    if <code>newOrientation<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JProgressBar.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -581,1 +581,1 @@\n-     * @exception java.awt.IllegalComponentStateException (a runtime\n+     * @throws java.awt.IllegalComponentStateException (a runtime\n@@ -608,1 +608,1 @@\n-     * @exception java.awt.IllegalComponentStateException (a runtime\n+     * @throws java.awt.IllegalComponentStateException (a runtime\n@@ -650,1 +650,1 @@\n-     * @exception NullPointerException if the <code>glass<\/code> parameter is\n+     * @throws NullPointerException if the <code>glass<\/code> parameter is\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JRootPane.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-     * @exception IllegalArgumentException if orientation is not one of VERTICAL, HORIZONTAL\n+     * @throws IllegalArgumentException if orientation is not one of VERTICAL, HORIZONTAL\n@@ -282,1 +282,1 @@\n-     * @exception IllegalArgumentException if orientation is not one of VERTICAL, HORIZONTAL\n+     * @throws IllegalArgumentException if orientation is not one of VERTICAL, HORIZONTAL\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JScrollBar.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -421,1 +421,1 @@\n-     * @exception ClassCastException if layout is not a\n+     * @throws ClassCastException if layout is not a\n@@ -479,1 +479,1 @@\n-     * @exception IllegalArgumentException if <code>policy<\/code>\n+     * @throws IllegalArgumentException if <code>policy<\/code>\n@@ -524,1 +524,1 @@\n-     * @exception IllegalArgumentException if <code>policy<\/code>\n+     * @throws IllegalArgumentException if <code>policy<\/code>\n@@ -1198,1 +1198,1 @@\n-     * @exception IllegalArgumentException if corner key is invalid\n+     * @throws IllegalArgumentException if corner key is invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JScrollPane.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-     * @exception IllegalArgumentException if <code>orientation<\/code>\n+     * @throws IllegalArgumentException if <code>orientation<\/code>\n@@ -193,1 +193,1 @@\n-     * @exception IllegalArgumentException  if <code>orientation<\/code>\n+     * @throws IllegalArgumentException  if <code>orientation<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSeparator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -923,1 +923,1 @@\n-     * @exception IllegalArgumentException if {@code start} is\n+     * @throws IllegalArgumentException if {@code start} is\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSlider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1018,1 +1018,1 @@\n-         * @exception IllegalArgumentException if the spinners model is not\n+         * @throws IllegalArgumentException if the spinners model is not\n@@ -1042,1 +1042,1 @@\n-         * @exception IllegalArgumentException if the spinners model is not\n+         * @throws IllegalArgumentException if the spinners model is not\n@@ -1067,1 +1067,1 @@\n-         * @exception IllegalArgumentException if the spinners model is not\n+         * @throws IllegalArgumentException if the spinners model is not\n@@ -1205,1 +1205,1 @@\n-         * @exception IllegalArgumentException if the spinners model is not\n+         * @throws IllegalArgumentException if the spinners model is not\n@@ -1228,1 +1228,1 @@\n-         * @exception IllegalArgumentException if the spinners model is not\n+         * @throws IllegalArgumentException if the spinners model is not\n@@ -1254,1 +1254,1 @@\n-         * @exception IllegalArgumentException if the spinners model is not\n+         * @throws IllegalArgumentException if the spinners model is not\n@@ -1349,1 +1349,1 @@\n-         * @exception IllegalArgumentException if the spinners model is not\n+         * @throws IllegalArgumentException if the spinners model is not\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSpinner.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-     * @exception IllegalArgumentException if <code>orientation<\/code>\n+     * @throws IllegalArgumentException if <code>orientation<\/code>\n@@ -284,1 +284,1 @@\n-     * @exception IllegalArgumentException if <code>orientation<\/code>\n+     * @throws IllegalArgumentException if <code>orientation<\/code>\n@@ -307,1 +307,1 @@\n-     * @exception IllegalArgumentException if <code>orientation<\/code>\n+     * @throws IllegalArgumentException if <code>orientation<\/code>\n@@ -337,1 +337,1 @@\n-     * @exception IllegalArgumentException if <code>orientation<\/code>\n+     * @throws IllegalArgumentException if <code>orientation<\/code>\n@@ -625,1 +625,1 @@\n-     * @exception IllegalArgumentException if orientation is not one of:\n+     * @throws IllegalArgumentException if orientation is not one of:\n@@ -704,1 +704,1 @@\n-     * @exception IllegalArgumentException if <code>value<\/code> is &lt; 0 or &gt; 1\n+     * @throws IllegalArgumentException if <code>value<\/code> is &lt; 0 or &gt; 1\n@@ -757,1 +757,1 @@\n-     * @exception IllegalArgumentException if the specified location is &lt; 0\n+     * @throws IllegalArgumentException if the specified location is &lt; 0\n@@ -967,1 +967,1 @@\n-     * @exception IllegalArgumentException  if the <code>constraints<\/code>\n+     * @throws IllegalArgumentException  if the <code>constraints<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JSplitPane.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-     * @exception IllegalArgumentException if tab placement or tab layout policy are not\n+     * @throws IllegalArgumentException if tab placement or tab layout policy are not\n@@ -508,1 +508,1 @@\n-     * @exception IllegalArgumentException if tab placement value isn't one\n+     * @throws IllegalArgumentException if tab placement value isn't one\n@@ -564,1 +564,1 @@\n-     * @exception IllegalArgumentException if layoutPolicy value isn't one\n+     * @throws IllegalArgumentException if layoutPolicy value isn't one\n@@ -612,1 +612,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -699,1 +699,1 @@\n-     * @exception IllegalArgumentException if component not found in tabbed\n+     * @throws IllegalArgumentException if component not found in tabbed\n@@ -966,1 +966,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1087,1 +1087,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1151,1 +1151,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1164,1 +1164,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1183,1 +1183,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1201,1 +1201,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1217,1 +1217,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1232,1 +1232,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1248,1 +1248,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1262,1 +1262,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1281,1 +1281,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1302,1 +1302,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1327,1 +1327,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1349,1 +1349,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1389,1 +1389,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1431,1 +1431,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1454,1 +1454,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1489,1 +1489,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1520,1 +1520,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1545,1 +1545,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1565,1 +1565,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n@@ -1641,1 +1641,1 @@\n-     * @exception IndexOutOfBoundsException if <code>tabIndex<\/code> is\n+     * @throws IndexOutOfBoundsException if <code>tabIndex<\/code> is\n@@ -1644,1 +1644,1 @@\n-     * @exception IllegalArgumentException will be thrown if\n+     * @throws IllegalArgumentException will be thrown if\n@@ -1681,1 +1681,1 @@\n-     * @exception IndexOutOfBoundsException if <code>tabIndex<\/code> is out\n+     * @throws IndexOutOfBoundsException if <code>tabIndex<\/code> is out\n@@ -2004,1 +2004,1 @@\n-         * @exception IllegalArgumentException if index is out of bounds\n+         * @throws IllegalArgumentException if index is out of bounds\n@@ -2429,1 +2429,1 @@\n-    * @exception IndexOutOfBoundsException if index is out of range\n+    * @throws IndexOutOfBoundsException if index is out of range\n@@ -2431,1 +2431,1 @@\n-    * @exception IllegalArgumentException if component has already been\n+    * @throws IllegalArgumentException if component has already been\n@@ -2459,1 +2459,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTabbedPane.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -994,1 +994,1 @@\n-     * @exception IllegalArgumentException      if <code>rowHeight<\/code> is\n+     * @throws IllegalArgumentException      if <code>rowHeight<\/code> is\n@@ -1040,1 +1040,1 @@\n-     * @exception IllegalArgumentException      if <code>rowHeight<\/code> is\n+     * @throws IllegalArgumentException      if <code>rowHeight<\/code> is\n@@ -1129,1 +1129,1 @@\n-     * @exception IllegalArgumentException      if <code>gridColor<\/code> is <code>null<\/code>\n+     * @throws IllegalArgumentException      if <code>gridColor<\/code> is <code>null<\/code>\n@@ -1488,1 +1488,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -2223,1 +2223,1 @@\n-     * @exception IllegalArgumentException      if <code>index0<\/code> or\n+     * @throws IllegalArgumentException      if <code>index0<\/code> or\n@@ -2237,1 +2237,1 @@\n-     * @exception IllegalArgumentException      if <code>index0<\/code> or\n+     * @throws IllegalArgumentException      if <code>index0<\/code> or\n@@ -2251,1 +2251,1 @@\n-     * @exception IllegalArgumentException      if <code>index0<\/code> or <code>index1<\/code>\n+     * @throws IllegalArgumentException      if <code>index0<\/code> or <code>index1<\/code>\n@@ -2264,1 +2264,1 @@\n-     * @exception IllegalArgumentException      if <code>index0<\/code> or\n+     * @throws IllegalArgumentException      if <code>index0<\/code> or\n@@ -2277,1 +2277,1 @@\n-     * @exception IllegalArgumentException      if <code>index0<\/code> or\n+     * @throws IllegalArgumentException      if <code>index0<\/code> or\n@@ -2290,1 +2290,1 @@\n-     * @exception IllegalArgumentException      if <code>index0<\/code> or\n+     * @throws IllegalArgumentException      if <code>index0<\/code> or\n@@ -2599,1 +2599,1 @@\n-     * @exception IllegalArgumentException      if <code>identifier<\/code> is <code>null<\/code> or no <code>TableColumn<\/code> has this identifier\n+     * @throws IllegalArgumentException      if <code>identifier<\/code> is <code>null<\/code> or no <code>TableColumn<\/code> has this identifier\n@@ -5484,0 +5484,15 @@\n+\n+        @Override\n+        public AccessibleContext getAccessibleContext() {\n+            if (accessibleContext == null) {\n+                accessibleContext = new AccessibleBooleanRenderer();\n+            }\n+            return accessibleContext;\n+        }\n+\n+        class AccessibleBooleanRenderer extends JCheckBox.AccessibleJCheckBox {\n+            @Override\n+            public AccessibleAction getAccessibleAction() {\n+                return null;\n+            }\n+        }\n@@ -8343,1 +8358,1 @@\n-             * @exception IllegalComponentStateException if the\n+             * @throws IllegalComponentStateException if the\n@@ -8399,1 +8414,5 @@\n-                return getCurrentAccessibleContext().getAccessibleAction();\n+                AccessibleContext ac = getCurrentAccessibleContext();\n+                if (ac != null) {\n+                    return ac.getAccessibleAction();\n+                }\n+                return null;\n@@ -9145,1 +9164,1 @@\n-             * @exception IllegalComponentStateException if the\n+             * @throws IllegalComponentStateException if the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTable.java","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-     * @exception IllegalArgumentException if the rows or columns\n+     * @throws IllegalArgumentException if the rows or columns\n@@ -183,1 +183,1 @@\n-     * @exception IllegalArgumentException if the rows or columns\n+     * @throws IllegalArgumentException if the rows or columns\n@@ -209,1 +209,1 @@\n-     * @exception IllegalArgumentException if the rows or columns\n+     * @throws IllegalArgumentException if the rows or columns\n@@ -373,1 +373,1 @@\n-     * @exception BadLocationException thrown if the offset is\n+     * @throws BadLocationException thrown if the offset is\n@@ -404,1 +404,1 @@\n-     * @exception BadLocationException thrown if the line is\n+     * @throws BadLocationException thrown if the line is\n@@ -427,1 +427,1 @@\n-     * @exception BadLocationException Thrown if the line is\n+     * @throws BadLocationException Thrown if the line is\n@@ -455,1 +455,1 @@\n-     * @exception IllegalArgumentException  if pos is an\n+     * @throws IllegalArgumentException  if pos is an\n@@ -496,1 +496,1 @@\n-     * @exception IllegalArgumentException  if part of the range is an\n+     * @throws IllegalArgumentException  if part of the range is an\n@@ -535,1 +535,1 @@\n-     * @exception IllegalArgumentException if rows is less than 0\n+     * @throws IllegalArgumentException if rows is less than 0\n@@ -579,1 +579,1 @@\n-     * @exception IllegalArgumentException if columns is less than 0\n+     * @throws IllegalArgumentException if columns is less than 0\n@@ -729,1 +729,1 @@\n-     * @exception IllegalArgumentException for an invalid orientation\n+     * @throws IllegalArgumentException for an invalid orientation\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTextArea.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -245,1 +245,1 @@\n-     * @exception IllegalArgumentException if <code>columns<\/code> &lt; 0\n+     * @throws IllegalArgumentException if <code>columns<\/code> &lt; 0\n@@ -346,1 +346,1 @@\n-     * @exception IllegalArgumentException if <code>alignment<\/code>\n+     * @throws IllegalArgumentException if <code>alignment<\/code>\n@@ -396,1 +396,1 @@\n-     * @exception IllegalArgumentException if <code>columns<\/code>\n+     * @throws IllegalArgumentException if <code>columns<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTextField.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-     * @exception IllegalArgumentException  if <code>doc<\/code> can't\n+     * @throws IllegalArgumentException  if <code>doc<\/code> can't\n@@ -483,1 +483,1 @@\n-     * @exception IllegalArgumentException if kit is not a\n+     * @throws IllegalArgumentException if kit is not a\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTextPane.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-     * @exception IllegalArgumentException if orientation is neither\n+     * @throws IllegalArgumentException if orientation is neither\n@@ -409,1 +409,1 @@\n-     * @exception IllegalArgumentException if orientation is neither\n+     * @throws IllegalArgumentException if orientation is neither\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JToolBar.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1254,1 +1254,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -3090,1 +3090,1 @@\n-     * @exception IllegalArgumentException if prefix is null\n+     * @throws IllegalArgumentException if prefix is null\n@@ -5056,1 +5056,1 @@\n-             * @exception IllegalComponentStateException\n+             * @throws IllegalComponentStateException\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTree.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -568,1 +568,1 @@\n-     * @exception IllegalArgumentException this method is not implemented\n+     * @throws IllegalArgumentException this method is not implemented\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JViewport.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -390,2 +390,2 @@\n-     * @exception IllegalArgumentException if <code>index<\/code> is invalid\n-     * @exception IllegalArgumentException if adding the container's parent\n+     * @throws IllegalArgumentException if <code>index<\/code> is invalid\n+     * @throws IllegalArgumentException if adding the container's parent\n@@ -393,1 +393,1 @@\n-     * @exception IllegalArgumentException if adding a window to a container\n+     * @throws IllegalArgumentException if adding a window to a container\n@@ -507,1 +507,1 @@\n-     * @exception IllegalComponentStateException (a runtime\n+     * @throws IllegalComponentStateException (a runtime\n@@ -535,1 +535,1 @@\n-     * @exception IllegalComponentStateException (a runtime\n+     * @throws IllegalComponentStateException (a runtime\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JWindow.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-     * @exception AWTError  if the target isn't the container specified to the\n+     * @throws AWTError  if the target isn't the container specified to the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/OverlayLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-     * @exception IllegalArgumentException if contents is null\n+     * @throws IllegalArgumentException if contents is null\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/Popup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-     * @exception IllegalArgumentException if <code>factory<\/code> is null\n+     * @throws IllegalArgumentException if <code>factory<\/code> is null\n@@ -189,1 +189,1 @@\n-     * @exception IllegalArgumentException if contents is null\n+     * @throws IllegalArgumentException if contents is null\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/PopupFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -797,1 +797,1 @@\n-         * @exception IllegalComponentStateException\n+         * @throws IllegalComponentStateException\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ProgressMonitor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -969,1 +969,1 @@\n-        \/\/                                   \"component bounds is \" + cBounds);;\n+        \/\/                                   \"component bounds is \" + cBounds);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-     * @exception java.awt.IllegalComponentStateException (a runtime\n+     * @throws java.awt.IllegalComponentStateException (a runtime\n@@ -137,1 +137,1 @@\n-     * @exception java.awt.IllegalComponentStateException (a runtime\n+     * @throws java.awt.IllegalComponentStateException (a runtime\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RootPaneContainer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-     * @exception IllegalArgumentException if <code>s<\/code> is an invalid key\n+     * @throws IllegalArgumentException if <code>s<\/code> is an invalid key\n@@ -331,1 +331,1 @@\n-     * @exception IllegalArgumentException if <code>x<\/code> is an invalid\n+     * @throws IllegalArgumentException if <code>x<\/code> is an invalid\n@@ -369,1 +369,1 @@\n-     * @exception IllegalArgumentException if <code>x<\/code> is not a valid\n+     * @throws IllegalArgumentException if <code>x<\/code> is not a valid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ScrollPaneLayout.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-     * @exception NegativeArraySizeException if\n+     * @throws NegativeArraySizeException if\n@@ -358,1 +358,1 @@\n-     * @exception ArrayIndexOutOfBoundsException if the parameters\n+     * @throws ArrayIndexOutOfBoundsException if the parameters\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SizeSequence.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1469,1 +1469,1 @@\n-     * @exception  InterruptedException if we're interrupted while waiting for\n+     * @throws  InterruptedException if we're interrupted while waiting for\n@@ -1472,1 +1472,1 @@\n-     * @exception  InvocationTargetException  if an exception is thrown\n+     * @throws  InvocationTargetException  if an exception is thrown\n@@ -1987,1 +1987,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n@@ -2005,1 +2005,1 @@\n-     * @exception HeadlessException if GraphicsEnvironment.isHeadless()\n+     * @throws HeadlessException if GraphicsEnvironment.isHeadless()\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SwingUtilities.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -398,0 +398,3 @@\n+        Rectangle bounds = table.getBounds();\n+        bounds.x = bounds.y = 0;\n+\n@@ -399,1 +402,1 @@\n-        Rectangle visibleBounds = clip.intersection(table.getBounds());\n+        Rectangle visibleBounds = clip.intersection(bounds);\n@@ -401,2 +404,2 @@\n-        Point lowerRight = new Point(visibleBounds.x + visibleBounds.width,\n-                                     visibleBounds.y + visibleBounds.height);\n+        Point lowerRight = new Point(visibleBounds.x + visibleBounds.width - 1,\n+                                     visibleBounds.y + visibleBounds.height - 1);\n@@ -413,1 +416,1 @@\n-        for(int visrow = rMin; visrow < rMax; visrow++) {\n+        for(int visrow = rMin; visrow <= rMax; visrow++) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/TablePrintable.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -344,1 +344,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code> doesn't\n+     * @throws ClassCastException if <code>listenerType<\/code> doesn't\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/Timer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1175,1 +1175,1 @@\n-         * @exception IOException                if the data is no longer available\n+         * @throws IOException                if the data is no longer available\n@@ -1177,1 +1177,1 @@\n-         * @exception UnsupportedFlavorException if the requested data flavor is\n+         * @throws UnsupportedFlavorException if the requested data flavor is\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/TransferHandler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-     * @exception RuntimeException  if the chooser panel has already been\n+     * @throws RuntimeException  if the chooser panel has already been\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/colorchooser\/AbstractColorChooserPanel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-     * @exception  ClassCastException if the supplied class\n+     * @throws  ClassCastException if the supplied class\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/event\/EventListenerList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n@@ -69,1 +69,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n@@ -89,1 +89,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n@@ -181,2 +181,2 @@\n-     * @exception BadLocationException for a bad location within a document model\n-     * @exception IllegalArgumentException for an invalid direction\n+     * @throws BadLocationException for a bad location within a document model\n+     * @throws IllegalArgumentException for an invalid direction\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/TextUI.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -588,1 +588,1 @@\n-         * @exception BadLocationException  if the given position does\n+         * @throws BadLocationException  if the given position does\n@@ -590,1 +590,1 @@\n-         * @exception IllegalArgumentException for an invalid bias argument\n+         * @throws IllegalArgumentException for an invalid bias argument\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicHTML.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.awt.ComponentOrientation;\n@@ -539,0 +540,5 @@\n+                \/\/ direction traversal to be reversed for RTL orientation\n+                if (path[0].getComponent().getComponentOrientation().\n+                        equals(ComponentOrientation.RIGHT_TO_LEFT)) {\n+                    direction = !direction;\n+                }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicPopupMenuUI.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1009,2 +1009,2 @@\n-                    toScroll = scrollpane.getHorizontalScrollBar();\n-                    if (toScroll == null || !toScroll.isVisible()) {\n+                    JScrollBar hScroll = scrollpane.getHorizontalScrollBar();\n+                    if (hScroll == null) {\n@@ -1012,0 +1012,8 @@\n+                    } else if (hScroll.isVisible()) {\n+                        toScroll = hScroll;\n+                        orientation = SwingConstants.HORIZONTAL;\n+                    } else if (!hScroll.isVisible()) {\n+                        if (e.isShiftDown()) {\n+                            return;\n+                        }\n+                        orientation = SwingConstants.VERTICAL;\n@@ -1013,1 +1021,0 @@\n-                    orientation = SwingConstants.HORIZONTAL;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicScrollPaneUI.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -778,1 +778,1 @@\n-     * @exception IndexOutOfBoundsException if index is out of range\n+     * @throws IndexOutOfBoundsException if index is out of range\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTabbedPaneUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1875,17 +1875,0 @@\n-        if (comp != null && !(comp instanceof JViewport) && !(comp instanceof JScrollPane)) {\n-            \/\/ We did rMax-1 to paint the same number of rows that are drawn on console\n-            \/\/ otherwise 1 extra row is printed per page than that are displayed\n-            \/\/ when there is no scrollPane and we do printing of table\n-            \/\/ but not when rmax is already pointing to index of last row\n-            \/\/ and if there is any selected rows\n-            if (rMax != (table.getRowCount() - 1) &&\n-                    (table.getSelectedRow() == -1)) {\n-                \/\/ Do not decrement rMax if rMax becomes\n-                \/\/ less than or equal to rMin\n-                \/\/ else cells will not be painted\n-                if (rMax - rMin > 1) {\n-                    rMax = rMax - 1;\n-                }\n-            }\n-        }\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTableUI.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-         * @exception BadLocationException  if the given position does not\n+         * @throws BadLocationException  if the given position does not\n@@ -370,1 +370,1 @@\n-         * @exception BadLocationException  if the given position does\n+         * @throws BadLocationException  if the given position does\n@@ -372,1 +372,1 @@\n-         * @exception IllegalArgumentException for an invalid bias argument\n+         * @throws IllegalArgumentException for an invalid bias argument\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTextFieldUI.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1048,1 +1048,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n@@ -1070,1 +1070,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n@@ -1629,1 +1629,1 @@\n-         * @exception BadLocationException  if the given position does\n+         * @throws BadLocationException  if the given position does\n@@ -1631,1 +1631,1 @@\n-         * @exception IllegalArgumentException for an invalid bias argument\n+         * @throws IllegalArgumentException for an invalid bias argument\n@@ -1677,1 +1677,1 @@\n-         * @exception BadLocationException the given position is not a valid\n+         * @throws BadLocationException the given position is not a valid\n@@ -1679,1 +1679,1 @@\n-         * @exception IllegalArgumentException for an invalid direction\n+         * @throws IllegalArgumentException for an invalid direction\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTextUI.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-     * @exception IOException                if the data is no longer available\n+     * @throws IOException                if the data is no longer available\n@@ -135,1 +135,1 @@\n-     * @exception UnsupportedFlavorException if the requested data flavor is\n+     * @throws UnsupportedFlavorException if the requested data flavor is\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTransferable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1938,1 +1938,1 @@\n-                     Graphics g, int x, int y, int w, int h, int direction) {\n+                     Graphics g, int x, int y, int w, int h, int tabIndex) {\n@@ -1940,1 +1940,1 @@\n-                paintTabbedPaneTabBackground(context, g, x, y, w, h, direction);\n+                paintTabbedPaneTabBackground(context, g, x, y, w, h, tabIndex);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/ParsedSynthStyle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-      <th scope=\"col\">Expected Type<br>\n+      <th scope=\"col\">Expected Type\n@@ -201,1 +201,1 @@\n-      <th scope=\"col\">Default Value<br>\n+      <th scope=\"col\">Default Value\n@@ -207,1 +207,1 @@\n-      <th scope=\"row\">FileChooser.cancelIcon<br>\n+      <th scope=\"row\">FileChooser.cancelIcon\n@@ -209,1 +209,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -211,1 +211,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -214,1 +214,1 @@\n-of the file chooser.<br>\n+of the file chooser.\n@@ -218,1 +218,1 @@\n-      <th scope=\"row\">FileChooser.okIcon<br>\n+      <th scope=\"row\">FileChooser.okIcon\n@@ -220,1 +220,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -222,1 +222,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -225,1 +225,1 @@\n-of the file chooser.<br>\n+of the file chooser.\n@@ -229,1 +229,1 @@\n-      <th scope=\"row\">FileView.directoryIcon<br>\n+      <th scope=\"row\">FileView.directoryIcon\n@@ -231,1 +231,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -233,1 +233,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -239,1 +239,1 @@\n-      <th scope=\"row\">FileView.fileIcon<br>\n+      <th scope=\"row\">FileView.fileIcon\n@@ -241,1 +241,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -243,1 +243,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -249,1 +249,1 @@\n-      <th scope=\"row\">FileView.computerIcon<br>\n+      <th scope=\"row\">FileView.computerIcon\n@@ -251,1 +251,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -253,1 +253,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -261,1 +261,1 @@\n-      <th scope=\"row\">FileView.hardDriveIcon<br>\n+      <th scope=\"row\">FileView.hardDriveIcon\n@@ -263,1 +263,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -265,1 +265,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -273,1 +273,1 @@\n-      <th scope=\"row\">FileView.floppyDriveIcon<br>\n+      <th scope=\"row\">FileView.floppyDriveIcon\n@@ -275,1 +275,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -277,1 +277,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -284,1 +284,1 @@\n-      <th scope=\"row\">FileChooser.newFolderIcon<br>\n+      <th scope=\"row\">FileChooser.newFolderIcon\n@@ -286,1 +286,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -288,1 +288,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -295,1 +295,1 @@\n-      <th scope=\"row\">FileChooser.upFolderIcon<br>\n+      <th scope=\"row\">FileChooser.upFolderIcon\n@@ -297,1 +297,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -299,1 +299,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -306,1 +306,1 @@\n-      <th scope=\"row\">FileChooser.homeFolderIcon<br>\n+      <th scope=\"row\">FileChooser.homeFolderIcon\n@@ -308,1 +308,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -310,1 +310,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -317,1 +317,1 @@\n-      <th scope=\"row\">FileChooser.detailsViewIcon<br>\n+      <th scope=\"row\">FileChooser.detailsViewIcon\n@@ -319,1 +319,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -321,1 +321,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -328,1 +328,1 @@\n-      <th scope=\"row\">FileChooser.listViewIcon<br>\n+      <th scope=\"row\">FileChooser.listViewIcon\n@@ -330,1 +330,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -332,1 +332,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -340,1 +340,1 @@\n-      <th scope=\"row\">FileChooser.viewMenuIcon<br>\n+      <th scope=\"row\">FileChooser.viewMenuIcon\n@@ -342,1 +342,1 @@\n-      <td>Icon<br>\n+      <td>Icon\n@@ -344,1 +344,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -357,1 +357,1 @@\n-      <th scope=\"col\">Property<br>\n+      <th scope=\"col\">Property\n@@ -359,1 +359,1 @@\n-      <th scope=\"col\">Expected Type<br>\n+      <th scope=\"col\">Expected Type\n@@ -361,1 +361,1 @@\n-      <th scope=\"col\">DefaultValue<br>\n+      <th scope=\"col\">DefaultValue\n@@ -363,1 +363,1 @@\n-      <th scope=\"col\">Description<br>\n+      <th scope=\"col\">Description\n@@ -368,1 +368,1 @@\n-      <th scope=\"row\">InternalFrame.icon<br>\n+      <th scope=\"row\">InternalFrame.icon\n@@ -371,1 +371,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -374,3 +374,3 @@\n-system<br>\n-icon of the internal frame.&nbsp; If pressed<br>\n-the system menu will be shown.<br>\n+system\n+icon of the internal frame.&nbsp; If pressed\n+the system menu will be shown.\n@@ -384,1 +384,1 @@\n-internal frame similar to that found in a frame.<br>\n+internal frame similar to that found in a frame.\n@@ -389,1 +389,1 @@\n-      <th scope=\"col\">Property<br>\n+      <th scope=\"col\">Property\n@@ -391,1 +391,1 @@\n-      <th scope=\"col\">Expected Type<br>\n+      <th scope=\"col\">Expected Type\n@@ -393,1 +393,1 @@\n-      <th scope=\"col\">Default Value<br>\n+      <th scope=\"col\">Default Value\n@@ -395,1 +395,1 @@\n-      <th scope=\"col\">Description<br>\n+      <th scope=\"col\">Description\n@@ -400,1 +400,1 @@\n-      <th scope=\"row\">InternalFrameTitlePane.maximizeIcon<br>\n+      <th scope=\"row\">InternalFrameTitlePane.maximizeIcon\n@@ -403,1 +403,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -406,1 +406,1 @@\n-ability to maximize the internal frame.<br>\n+ability to maximize the internal frame.\n@@ -410,1 +410,1 @@\n-      <th scope=\"row\">InternalFrameTitlePane.minimizeIcon<br>\n+      <th scope=\"row\">InternalFrameTitlePane.minimizeIcon\n@@ -413,1 +413,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -416,1 +416,1 @@\n-ability to restore the internal frame back to its previous state.<br>\n+ability to restore the internal frame back to its previous state.\n@@ -420,1 +420,1 @@\n-      <th scope=\"row\">InternalFrameTitlePane.iconifyIcon<br>\n+      <th scope=\"row\">InternalFrameTitlePane.iconifyIcon\n@@ -423,1 +423,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -426,1 +426,1 @@\n-ability to minimize the internal frame.<br>\n+ability to minimize the internal frame.\n@@ -430,1 +430,1 @@\n-      <th scope=\"row\">InternalFrameTitlePane.closeIcon<br>\n+      <th scope=\"row\">InternalFrameTitlePane.closeIcon\n@@ -433,1 +433,1 @@\n-      <td>null<br>\n+      <td>null\n@@ -440,1 +440,1 @@\n-      <th scope=\"row\">InternalFrameTitlePane.titleSpacing<br>\n+      <th scope=\"row\">InternalFrameTitlePane.titleSpacing\n@@ -449,1 +449,1 @@\n-      <th scope=\"row\">InternalFrameTitlePane.buttonSpacing<br>\n+      <th scope=\"row\">InternalFrameTitlePane.buttonSpacing\n@@ -458,1 +458,1 @@\n-      <th scope=\"row\">InternalFrameTitlePane.maxFrameIconSize<br>\n+      <th scope=\"row\">InternalFrameTitlePane.maxFrameIconSize\n@@ -468,1 +468,1 @@\n-      <th scope=\"row\">InternalFrameTitlePane.titleAlignment<br>\n+      <th scope=\"row\">InternalFrameTitlePane.titleAlignment\n@@ -723,1 +723,1 @@\n-<h2><a id=\"JProgressBar\"><\/a>JProgressBar<br>\n+<h2><a id=\"JProgressBar\"><\/a>JProgressBar\n@@ -729,1 +729,1 @@\n-      <th scope=\"col\">Expected Type<br>\n+      <th scope=\"col\">Expected Type\n@@ -731,1 +731,1 @@\n-      <th scope=\"col\">Default Value<br>\n+      <th scope=\"col\">Default Value\n@@ -737,1 +737,1 @@\n-      <th scope=\"row\">ProgressBar.repaintInterval<br>\n+      <th scope=\"row\">ProgressBar.repaintInterval\n@@ -739,1 +739,1 @@\n-      <td>Integer<br>\n+      <td>Integer\n@@ -741,1 +741,1 @@\n-      <td>50<br>\n+      <td>50\n@@ -744,1 +744,1 @@\n-repaints for indeterminate progress bars.<br>\n+repaints for indeterminate progress bars.\n@@ -748,1 +748,1 @@\n-      <th scope=\"row\">ProgressBar.cycleTime<br>\n+      <th scope=\"row\">ProgressBar.cycleTime\n@@ -750,1 +750,1 @@\n-      <td>Integer<br>\n+      <td>Integer\n@@ -752,1 +752,1 @@\n-      <td>3000<br>\n+      <td>3000\n@@ -755,2 +755,2 @@\n-determine how far to move<br>\n-the bouncing box per frame when the progress bar is indeterminate.<br>\n+determine how far to move\n+the bouncing box per frame when the progress bar is indeterminate.\n@@ -983,1 +983,1 @@\n-      <th scope=\"col\">Property<br>\n+      <th scope=\"col\">Property\n@@ -985,1 +985,1 @@\n-      <th scope=\"col\">Expected Type<br>\n+      <th scope=\"col\">Expected Type\n@@ -987,1 +987,1 @@\n-      <th scope=\"col\">Default Value<br>\n+      <th scope=\"col\">Default Value\n@@ -989,1 +989,1 @@\n-      <th scope=\"col\">Description<br>\n+      <th scope=\"col\">Description\n@@ -994,1 +994,1 @@\n-      <th scope=\"row\">Slider.thumbWidth<br>\n+      <th scope=\"row\">Slider.thumbWidth\n@@ -996,1 +996,1 @@\n-      <td>Integer<br>\n+      <td>Integer\n@@ -998,1 +998,1 @@\n-      <td>30<br>\n+      <td>30\n@@ -1000,1 +1000,1 @@\n-      <td>Width of the slider thumb<br>\n+      <td>Width of the slider thumb\n@@ -1004,1 +1004,1 @@\n-      <th scope=\"row\">Slider.thumbHeight<br>\n+      <th scope=\"row\">Slider.thumbHeight\n@@ -1006,1 +1006,1 @@\n-      <td>Integer<br>\n+      <td>Integer\n@@ -1008,1 +1008,1 @@\n-      <td>14<br>\n+      <td>14\n@@ -1010,1 +1010,1 @@\n-      <td>Height of the slider thumb<br>\n+      <td>Height of the slider thumb\n@@ -1014,1 +1014,1 @@\n-      <th scope=\"row\">Slider.trackBorder<br>\n+      <th scope=\"row\">Slider.trackBorder\n@@ -1016,1 +1016,1 @@\n-      <td>Integer<br>\n+      <td>Integer\n@@ -1018,1 +1018,1 @@\n-      <td>1<br>\n+      <td>1\n@@ -1020,1 +1020,1 @@\n-      <td>Width of the track border<br>\n+      <td>Width of the track border\n@@ -1024,1 +1024,1 @@\n-      <th scope=\"row\">Slider.paintValue<br>\n+      <th scope=\"row\">Slider.paintValue\n@@ -1026,1 +1026,1 @@\n-      <td>Boolean<br>\n+      <td>Boolean\n@@ -1028,1 +1028,1 @@\n-      <td>true<br>\n+      <td>true\n@@ -1031,2 +1031,2 @@\n-current value<br>\n-of the slider.<br>\n+current value\n+of the slider.\n@@ -1043,1 +1043,1 @@\n-      <th scope=\"col\">Expected Type<br>\n+      <th scope=\"col\">Expected Type\n@@ -1045,1 +1045,1 @@\n-      <th scope=\"col\">Default Value<br>\n+      <th scope=\"col\">Default Value\n@@ -1051,1 +1051,1 @@\n-      <th scope=\"row\">TabbedPane.tabRunOverlay<br>\n+      <th scope=\"row\">TabbedPane.tabRunOverlay\n@@ -1053,1 +1053,1 @@\n-      <td>Integer<br>\n+      <td>Integer\n@@ -1055,1 +1055,1 @@\n-      <td>0<br>\n+      <td>0\n@@ -1058,1 +1058,1 @@\n-\t    tabs when there is more than one row.  <br>\n+\t    tabs when there is more than one row.\n@@ -1062,1 +1062,1 @@\n-      <th scope=\"row\">TabbedPane.textIconGap<br>\n+      <th scope=\"row\">TabbedPane.textIconGap\n@@ -1064,1 +1064,1 @@\n-      <td>Integer<br>\n+      <td>Integer\n@@ -1066,1 +1066,1 @@\n-      <td>0<br>\n+      <td>0\n@@ -1074,1 +1074,1 @@\n-      <th scope=\"row\">TabbedPane.selectedTabPadInsets<br>\n+      <th scope=\"row\">TabbedPane.selectedTabPadInsets\n@@ -1076,1 +1076,1 @@\n-      <td>Insets<br>\n+      <td>Insets\n@@ -1078,1 +1078,1 @@\n-      <td>Empty Insets (0, 0, 0, 0)<br>\n+      <td>Empty Insets (0, 0, 0, 0)\n@@ -1081,1 +1081,1 @@\n-selected tab.<br>\n+selected tab.\n@@ -1085,1 +1085,1 @@\n-      <th scope=\"row\">TabbedPane.selectionFollowsFocus<br>\n+      <th scope=\"row\">TabbedPane.selectionFollowsFocus\n@@ -1087,1 +1087,1 @@\n-      <td>Boolean<br>\n+      <td>Boolean\n@@ -1089,1 +1089,1 @@\n-      <td>true<br>\n+      <td>true\n@@ -1093,1 +1093,1 @@\n-\t    mouse.<br>\n+\t    mouse.\n@@ -1301,1 +1301,1 @@\n-JToggleButton.<br>\n+JToggleButton.\n@@ -1303,1 +1303,1 @@\n-<h2><a id=\"textProperties\"><\/a>Text Properties<br>\n+<h2><a id=\"textProperties\"><\/a>Text Properties\n@@ -1309,1 +1309,1 @@\n-      <th scope=\"col\">Expected Type<br>\n+      <th scope=\"col\">Expected Type\n@@ -1311,1 +1311,1 @@\n-      <th scope=\"col\">Default Value<br>\n+      <th scope=\"col\">Default Value\n@@ -1313,1 +1313,1 @@\n-      <th scope=\"col\">Description<br>\n+      <th scope=\"col\">Description\n@@ -1318,1 +1318,1 @@\n-      <th scope=\"row\">prefix.caretForeground<br>\n+      <th scope=\"row\">prefix.caretForeground\n@@ -1320,1 +1320,1 @@\n-      <td>Color<br>\n+      <td>Color\n@@ -1323,1 +1323,1 @@\n-      <td>Color of the caret.<br>\n+      <td>Color of the caret.\n@@ -1327,1 +1327,1 @@\n-      <th scope=\"row\">prefix.margin<br>\n+      <th scope=\"row\">prefix.margin\n@@ -1330,2 +1330,2 @@\n-      <td>Empty Insets (0, 0, 0, 0),<br>\n-EditorPane and TextPane (3, 3, 3, 3)<br>\n+      <td>Empty Insets (0, 0, 0, 0),\n+EditorPane and TextPane (3, 3, 3, 3)\n@@ -1333,1 +1333,1 @@\n-      <td>Margins of the text component.<br>\n+      <td>Margins of the text component.\n@@ -1337,1 +1337,1 @@\n-      <th scope=\"row\">prefix.caretBlinkRate<br>\n+      <th scope=\"row\">prefix.caretBlinkRate\n@@ -1339,1 +1339,1 @@\n-      <td>Integer<br>\n+      <td>Integer\n@@ -1341,1 +1341,1 @@\n-      <td>500<br>\n+      <td>500\n@@ -1344,1 +1344,1 @@\n-the blink rate fo the caret.<br>\n+the blink rate fo the caret.\n@@ -1350,1 +1350,1 @@\n-PasswordField, TextArea, TextField or TextPane.<br>\n+PasswordField, TextArea, TextField or TextPane.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/doc-files\/componentProperties.html","additions":139,"deletions":139,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -334,1 +334,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code>\n+     * @throws ClassCastException if <code>listenerType<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/table\/AbstractTableModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-     * @exception IllegalArgumentException      if <code>aColumn<\/code> is\n+     * @throws IllegalArgumentException      if <code>aColumn<\/code> is\n@@ -173,1 +173,1 @@\n-     * @exception IllegalArgumentException      if <code>column<\/code> or\n+     * @throws IllegalArgumentException      if <code>column<\/code> or\n@@ -261,1 +261,1 @@\n-     * @exception       IllegalArgumentException  if <code>identifier<\/code>\n+     * @throws       IllegalArgumentException  if <code>identifier<\/code>\n@@ -293,0 +293,3 @@\n+     * @throws  ArrayIndexOutOfBoundsException if <code>columnIndex<\/code>\n+     *             is out of range:\n+     *             (<code>columnIndex &lt; 0 || columnIndex &gt;= getColumnCount()<\/code>)\n@@ -368,1 +371,1 @@\n-     * @exception IllegalArgumentException      if <code>newModel<\/code>\n+     * @throws IllegalArgumentException      if <code>newModel<\/code>\n@@ -636,1 +639,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code>\n+     * @throws ClassCastException if <code>listenerType<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/table\/DefaultTableColumnModel.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-     * @exception  ArrayIndexOutOfBoundsException  if the row was invalid\n+     * @throws  ArrayIndexOutOfBoundsException  if the row was invalid\n@@ -393,1 +393,1 @@\n-     * @exception  ArrayIndexOutOfBoundsException  if the row was invalid\n+     * @throws  ArrayIndexOutOfBoundsException  if the row was invalid\n@@ -441,1 +441,1 @@\n-     * @exception  ArrayIndexOutOfBoundsException  if any of the elements\n+     * @throws  ArrayIndexOutOfBoundsException  if any of the elements\n@@ -466,1 +466,1 @@\n-     * @exception  ArrayIndexOutOfBoundsException  if the row was invalid\n+     * @throws  ArrayIndexOutOfBoundsException  if the row was invalid\n@@ -655,1 +655,1 @@\n-     * @exception  ArrayIndexOutOfBoundsException  if an invalid row or\n+     * @throws  ArrayIndexOutOfBoundsException  if an invalid row or\n@@ -672,1 +672,1 @@\n-     * @exception  ArrayIndexOutOfBoundsException  if an invalid row or\n+     * @throws  ArrayIndexOutOfBoundsException  if an invalid row or\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/table\/DefaultTableModel.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -553,1 +553,1 @@\n-     * @exception IllegalArgumentException\n+     * @throws IllegalArgumentException\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/table\/JTableHeader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-     * @exception IllegalArgumentException      if <code>columnIndex<\/code> or\n+     * @throws IllegalArgumentException      if <code>columnIndex<\/code> or\n@@ -122,1 +122,1 @@\n-     * @exception IllegalArgumentException      if <code>identifier<\/code>\n+     * @throws IllegalArgumentException      if <code>identifier<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/table\/TableColumnModel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -347,1 +347,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code>\n+     * @throws ClassCastException if <code>listenerType<\/code>\n@@ -607,1 +607,1 @@\n-     * @exception BadLocationException  the given remove position is not a valid\n+     * @throws BadLocationException  the given remove position is not a valid\n@@ -677,1 +677,1 @@\n-     * @exception BadLocationException the given position is not a valid\n+     * @throws BadLocationException the given position is not a valid\n@@ -721,1 +721,1 @@\n-     * @exception BadLocationException  the given insert position is not a valid\n+     * @throws BadLocationException  the given insert position is not a valid\n@@ -795,1 +795,1 @@\n-     * @exception BadLocationException  the range given includes a position\n+     * @throws BadLocationException  the range given includes a position\n@@ -836,1 +836,1 @@\n-     * @exception BadLocationException  the range given includes a position\n+     * @throws BadLocationException  the range given includes a position\n@@ -857,1 +857,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n@@ -1357,1 +1357,1 @@\n-     * @exception IllegalStateException thrown on illegal lock\n+     * @throws IllegalStateException thrown on illegal lock\n@@ -1636,1 +1636,1 @@\n-         * @exception BadLocationException for an invalid offset\n+         * @throws BadLocationException for an invalid offset\n@@ -1655,1 +1655,1 @@\n-         * @exception BadLocationException  thrown if the area covered by\n+         * @throws BadLocationException  thrown if the area covered by\n@@ -1669,1 +1669,1 @@\n-         * @exception BadLocationException  Thrown if the area covered by\n+         * @throws BadLocationException  Thrown if the area covered by\n@@ -1680,1 +1680,1 @@\n-         * @exception BadLocationException  Thrown if the area covered by\n+         * @throws BadLocationException  Thrown if the area covered by\n@@ -1691,1 +1691,1 @@\n-         * @exception BadLocationException  Thrown if the area covered by\n+         * @throws BadLocationException  Thrown if the area covered by\n@@ -2822,1 +2822,1 @@\n-         * @exception CannotRedoException if the change cannot be redone\n+         * @throws CannotRedoException if the change cannot be redone\n@@ -2846,1 +2846,1 @@\n-         * @exception CannotUndoException if the change cannot be undone\n+         * @throws CannotUndoException if the change cannot be undone\n@@ -3190,1 +3190,1 @@\n-         * @exception CannotRedoException if the change cannot be redone\n+         * @throws CannotRedoException if the change cannot be redone\n@@ -3207,1 +3207,1 @@\n-         * @exception CannotUndoException if the change cannot be undone\n+         * @throws CannotUndoException if the change cannot be undone\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/AbstractDocument.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws BadLocationException if pos represents an invalid\n@@ -289,2 +289,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -465,1 +465,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -488,1 +488,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -503,1 +503,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -674,1 +674,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/AbstractWriter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -643,1 +643,1 @@\n-     * @exception IllegalArgumentException for an invalid axis type\n+     * @throws IllegalArgumentException for an invalid axis type\n@@ -668,1 +668,1 @@\n-     * @exception IllegalArgumentException for an invalid axis type\n+     * @throws IllegalArgumentException for an invalid axis type\n@@ -696,1 +696,1 @@\n-     * @exception IllegalArgumentException for an invalid axis type\n+     * @throws IllegalArgumentException for an invalid axis type\n@@ -776,1 +776,1 @@\n-     * @exception BadLocationException  if the given position does\n+     * @throws BadLocationException  if the given position does\n@@ -778,1 +778,1 @@\n-     * @exception IllegalArgumentException for an invalid bias argument\n+     * @throws IllegalArgumentException for an invalid bias argument\n@@ -867,1 +867,1 @@\n-     * @exception BadLocationException the given position is not a valid\n+     * @throws BadLocationException the given position is not a valid\n@@ -869,1 +869,1 @@\n-     * @exception IllegalArgumentException if <code>direction<\/code> is invalid\n+     * @throws IllegalArgumentException if <code>direction<\/code> is invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/AsyncBoxView.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-     * @exception IllegalArgumentException for an invalid axis\n+     * @throws IllegalArgumentException for an invalid axis\n@@ -476,1 +476,1 @@\n-     * @exception BadLocationException  if the given position does\n+     * @throws BadLocationException  if the given position does\n@@ -522,1 +522,1 @@\n-     * @exception IllegalArgumentException for an invalid axis\n+     * @throws IllegalArgumentException for an invalid axis\n@@ -543,1 +543,1 @@\n-     * @exception IllegalArgumentException for an invalid axis type\n+     * @throws IllegalArgumentException for an invalid axis type\n@@ -566,1 +566,1 @@\n-     * @exception IllegalArgumentException for an invalid axis type\n+     * @throws IllegalArgumentException for an invalid axis type\n@@ -589,1 +589,1 @@\n-     * @exception IllegalArgumentException for an invalid axis type\n+     * @throws IllegalArgumentException for an invalid axis type\n@@ -922,1 +922,1 @@\n-     * @exception IllegalArgumentException if <code>axis<\/code> is\n+     * @throws IllegalArgumentException if <code>axis<\/code> is\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/BoxView.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-     * @exception IllegalArgumentException for an invalid axis\n+     * @throws IllegalArgumentException for an invalid axis\n@@ -163,1 +163,1 @@\n-     * @exception IllegalArgumentException for an invalid axis\n+     * @throws IllegalArgumentException for an invalid axis\n@@ -191,1 +191,1 @@\n-     * @exception IllegalArgumentException for an invalid axis\n+     * @throws IllegalArgumentException for an invalid axis\n@@ -328,1 +328,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/ComponentView.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-     * @exception BadLocationException  if the given position does\n+     * @throws BadLocationException  if the given position does\n@@ -297,1 +297,1 @@\n-     * @exception BadLocationException  if the given position does\n+     * @throws BadLocationException  if the given position does\n@@ -299,1 +299,1 @@\n-     * @exception IllegalArgumentException for an invalid bias argument\n+     * @throws IllegalArgumentException for an invalid bias argument\n@@ -461,1 +461,1 @@\n-     * @exception BadLocationException the given position is not a valid\n+     * @throws BadLocationException the given position is not a valid\n@@ -463,1 +463,1 @@\n-     * @exception IllegalArgumentException if <code>direction<\/code> is invalid\n+     * @throws IllegalArgumentException if <code>direction<\/code> is invalid\n@@ -718,2 +718,2 @@\n-     * @exception BadLocationException for a bad location within a document model\n-     * @exception IllegalArgumentException if <code>direction<\/code> is invalid\n+     * @throws BadLocationException for a bad location within a document model\n+     * @throws IllegalArgumentException if <code>direction<\/code> is invalid\n@@ -751,2 +751,2 @@\n-     * @exception BadLocationException for a bad location within a document model\n-     * @exception IllegalArgumentException if <code>direction<\/code> is invalid\n+     * @throws BadLocationException for a bad location within a document model\n+     * @throws IllegalArgumentException if <code>direction<\/code> is invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/CompositeView.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -873,1 +873,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code>\n+     * @throws ClassCastException if <code>listenerType<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultCaret.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,2 +145,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -164,2 +164,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -196,2 +196,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -306,2 +306,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos is not within 0 and\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos is not within 0 and\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultEditorKit.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-     * @exception BadLocationException if the specified location is invalid\n+     * @throws BadLocationException if the specified location is invalid\n@@ -225,1 +225,1 @@\n-     * @exception BadLocationException if the specified location is invalid\n+     * @throws BadLocationException if the specified location is invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultHighlighter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-     * @exception BadLocationException for an invalid starting offset\n+     * @throws BadLocationException for an invalid starting offset\n@@ -2551,1 +2551,1 @@\n-         * @exception CannotRedoException if the change cannot be redone\n+         * @throws CannotRedoException if the change cannot be redone\n@@ -2565,1 +2565,1 @@\n-         * @exception CannotUndoException if the change cannot be undone\n+         * @throws CannotUndoException if the change cannot be undone\n@@ -2607,1 +2607,1 @@\n-         * @exception CannotRedoException if the change cannot be redone\n+         * @throws CannotRedoException if the change cannot be redone\n@@ -2617,1 +2617,1 @@\n-         * @exception CannotUndoException if the change cannot be undone\n+         * @throws CannotUndoException if the change cannot be undone\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultStyledDocument.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -456,1 +456,1 @@\n-     * @exception BadLocationException  some portion of the removal range\n+     * @throws BadLocationException  some portion of the removal range\n@@ -493,1 +493,1 @@\n-     * @exception BadLocationException  the given insert position is not a valid\n+     * @throws BadLocationException  the given insert position is not a valid\n@@ -510,1 +510,1 @@\n-     * @exception BadLocationException  some portion of the given range\n+     * @throws BadLocationException  some portion of the given range\n@@ -549,1 +549,1 @@\n-     * @exception BadLocationException  Some portion of the given range\n+     * @throws BadLocationException  Some portion of the given range\n@@ -585,1 +585,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/Document.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-     * @exception BadLocationException  some portion of the removal range\n+     * @throws BadLocationException  some portion of the removal range\n@@ -100,1 +100,1 @@\n-     * @exception BadLocationException  the given insert position is not a\n+     * @throws BadLocationException  the given insert position is not a\n@@ -120,1 +120,1 @@\n-     * @exception BadLocationException  the given insert position is not a\n+     * @throws BadLocationException  the given insert position is not a\n@@ -156,1 +156,1 @@\n-         * @exception BadLocationException some portion of the removal range\n+         * @throws BadLocationException some portion of the removal range\n@@ -172,1 +172,1 @@\n-         * @exception BadLocationException  the given insert position is not a\n+         * @throws BadLocationException  the given insert position is not a\n@@ -189,1 +189,1 @@\n-         * @exception BadLocationException  the given insert is not a\n+         * @throws BadLocationException  the given insert is not a\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DocumentFilter.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -144,2 +144,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -160,2 +160,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -181,2 +181,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -202,2 +202,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/EditorKit.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/FieldView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-     * @exception BadLocationException if the specified position is invalid\n+     * @throws BadLocationException if the specified position is invalid\n@@ -151,1 +151,1 @@\n-     * @exception BadLocationException if the specified position is invalid\n+     * @throws BadLocationException if the specified position is invalid\n@@ -171,1 +171,1 @@\n-     * @exception BadLocationException if the specified position is invalid\n+     * @throws BadLocationException if the specified position is invalid\n@@ -189,1 +189,1 @@\n-     * @exception BadLocationException if the specified position is invalid\n+     * @throws BadLocationException if the specified position is invalid\n@@ -240,1 +240,1 @@\n-     * @exception BadLocationException if the specified position is invalid\n+     * @throws BadLocationException if the specified position is invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/GapContent.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-         * @exception BadLocationException\n-         * @exception IllegalArgumentException for an invalid direction\n+         * @throws BadLocationException\n+         * @throws IllegalArgumentException for an invalid direction\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/GlyphPainter2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -640,1 +640,1 @@\n-     * @exception BadLocationException  if the given position does not represent a\n+     * @throws BadLocationException  if the given position does not represent a\n@@ -888,1 +888,1 @@\n-     * @exception BadLocationException the given position is not a valid\n+     * @throws BadLocationException the given position is not a valid\n@@ -890,1 +890,1 @@\n-     * @exception IllegalArgumentException for an invalid direction\n+     * @throws IllegalArgumentException for an invalid direction\n@@ -1202,1 +1202,1 @@\n-         * @exception BadLocationException  if the given position does not represent a\n+         * @throws BadLocationException  if the given position does not represent a\n@@ -1286,2 +1286,2 @@\n-         * @exception BadLocationException for a bad location within a document model\n-         * @exception IllegalArgumentException for an invalid direction\n+         * @throws BadLocationException for a bad location within a document model\n+         * @throws IllegalArgumentException for an invalid direction\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/GlyphView.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-     * @exception BadLocationException for an invalid range specification\n+     * @throws BadLocationException for an invalid range specification\n@@ -98,1 +98,1 @@\n-     * @exception BadLocationException for an invalid range specification\n+     * @throws BadLocationException for an invalid range specification\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/Highlighter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-     * @exception IllegalArgumentException for an invalid axis\n+     * @throws IllegalArgumentException for an invalid axis\n@@ -126,1 +126,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/IconView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-     * @exception HeadlessException if\n+     * @throws HeadlessException if\n@@ -1361,1 +1361,1 @@\n-     * @exception BadLocationException if the offset or length are invalid\n+     * @throws BadLocationException if the offset or length are invalid\n@@ -1379,1 +1379,1 @@\n-     * @exception BadLocationException if the given position does not\n+     * @throws BadLocationException if the given position does not\n@@ -1403,1 +1403,1 @@\n-     * @exception BadLocationException if the given position does not\n+     * @throws BadLocationException if the given position does not\n@@ -1548,1 +1548,1 @@\n-     * @exception    IllegalArgumentException if the value supplied\n+     * @throws    IllegalArgumentException if the value supplied\n@@ -1620,1 +1620,1 @@\n-     * @exception IOException as thrown by the stream being\n+     * @throws IOException as thrown by the stream being\n@@ -1646,1 +1646,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -1675,1 +1675,1 @@\n-     * @exception    IllegalArgumentException if the value supplied\n+     * @throws    IllegalArgumentException if the value supplied\n@@ -1746,1 +1746,1 @@\n-     * @exception NullPointerException if the document is <code>null<\/code>\n+     * @throws NullPointerException if the document is <code>null<\/code>\n@@ -1766,1 +1766,1 @@\n-     * @exception IllegalArgumentException if the selection doesn't\n+     * @throws IllegalArgumentException if the selection doesn't\n@@ -2016,1 +2016,1 @@\n-     * @exception IllegalArgumentException for an invalid orientation\n+     * @throws IllegalArgumentException for an invalid orientation\n@@ -2046,1 +2046,1 @@\n-     * @exception IllegalArgumentException for an invalid orientation\n+     * @throws IllegalArgumentException for an invalid orientation\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/JTextComponent.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -108,2 +108,2 @@\n-     * @exception BadLocationException for a bad location within a document model\n-     * @exception IllegalArgumentException if <code>direction<\/code>\n+     * @throws BadLocationException for a bad location within a document model\n+     * @throws IllegalArgumentException if <code>direction<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/NavigationFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -879,1 +879,1 @@\n-         * @exception BadLocationException  if the given position does not represent a\n+         * @throws BadLocationException  if the given position does not represent a\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/ParagraphView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-     * @exception BadLocationException if p0 or p1 are out of range\n+     * @throws BadLocationException if p0 or p1 are out of range\n@@ -134,1 +134,1 @@\n-     * @exception BadLocationException if p0 or p1 are out of range\n+     * @throws BadLocationException if p0 or p1 are out of range\n@@ -243,1 +243,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/PasswordView.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-     * @exception BadLocationException  the given insert position is not a valid\n+     * @throws BadLocationException  the given insert position is not a valid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/PlainDocument.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-     * @exception BadLocationException if the range is invalid\n+     * @throws BadLocationException if the range is invalid\n@@ -227,1 +227,1 @@\n-     * @exception BadLocationException if the range is invalid\n+     * @throws BadLocationException if the range is invalid\n@@ -248,1 +248,1 @@\n-     * @exception BadLocationException if the range is invalid\n+     * @throws BadLocationException if the range is invalid\n@@ -297,1 +297,1 @@\n-     * @exception BadLocationException if the range is invalid\n+     * @throws BadLocationException if the range is invalid\n@@ -354,1 +354,1 @@\n-     * @exception IllegalArgumentException for an invalid axis\n+     * @throws IllegalArgumentException for an invalid axis\n@@ -471,1 +471,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/PlainView.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-     * @exception BadLocationException if the specified position is invalid\n+     * @throws BadLocationException if the specified position is invalid\n@@ -114,1 +114,1 @@\n-     * @exception BadLocationException if the specified position is invalid\n+     * @throws BadLocationException if the specified position is invalid\n@@ -137,1 +137,1 @@\n-     * @exception BadLocationException if the specified position is invalid\n+     * @throws BadLocationException if the specified position is invalid\n@@ -153,1 +153,1 @@\n-     * @exception BadLocationException if the specified position is invalid\n+     * @throws BadLocationException if the specified position is invalid\n@@ -171,1 +171,1 @@\n-     * @exception BadLocationException if the specified position is invalid\n+     * @throws BadLocationException if the specified position is invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/StringContent.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -582,1 +582,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -594,1 +594,1 @@\n-     * @exception ClassNotFoundException passed upward if encountered\n+     * @throws ClassNotFoundException passed upward if encountered\n@@ -596,1 +596,1 @@\n-     * @exception IOException passed upward if encountered when\n+     * @throws IOException passed upward if encountered when\n@@ -616,1 +616,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -663,1 +663,1 @@\n-     * @exception ClassNotFoundException passed upward if encountered\n+     * @throws ClassNotFoundException passed upward if encountered\n@@ -665,1 +665,1 @@\n-     * @exception IOException passed upward if encountered when\n+     * @throws IOException passed upward if encountered when\n@@ -1080,1 +1080,1 @@\n-         * @exception  NoSuchElementException  if no more elements exist.\n+         * @throws  NoSuchElementException  if no more elements exist.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/StyleContext.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -414,1 +414,1 @@\n-         * @exception IllegalArgumentException for the wrong document type\n+         * @throws IllegalArgumentException for the wrong document type\n@@ -429,1 +429,1 @@\n-         * @exception IllegalArgumentException for the wrong document type\n+         * @throws IllegalArgumentException for the wrong document type\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/StyledEditorKit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -808,1 +808,1 @@\n-         * @exception IllegalArgumentException for an invalid axis\n+         * @throws IllegalArgumentException for an invalid axis\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/TableView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -686,1 +686,1 @@\n-     * @exception BadLocationException if the offset is out of range\n+     * @throws BadLocationException if the offset is out of range\n@@ -717,1 +717,1 @@\n-     * @exception BadLocationException if the offset is out of range\n+     * @throws BadLocationException if the offset is out of range\n@@ -750,1 +750,1 @@\n-     * @exception BadLocationException if the offset is out of range\n+     * @throws BadLocationException if the offset is out of range\n@@ -805,1 +805,1 @@\n-     * @exception BadLocationException if the offset is out of range\n+     * @throws BadLocationException if the offset is out of range\n@@ -825,1 +825,1 @@\n-     * @exception BadLocationException if the offset is out of range\n+     * @throws BadLocationException if the offset is out of range\n@@ -881,1 +881,1 @@\n-     * @exception BadLocationException if the offset is out of range\n+     * @throws BadLocationException if the offset is out of range\n@@ -897,1 +897,1 @@\n-     * @exception BadLocationException if the offset is out of range\n+     * @throws BadLocationException if the offset is out of range\n@@ -931,1 +931,1 @@\n-     * @exception BadLocationException if the offset is out of range\n+     * @throws BadLocationException if the offset is out of range\n@@ -964,1 +964,1 @@\n-     * @exception BadLocationException if the offset is out of range\n+     * @throws BadLocationException if the offset is out of range\n@@ -1042,1 +1042,1 @@\n-     * @exception BadLocationException if the offset is out of range\n+     * @throws BadLocationException if the offset is out of range\n@@ -1274,2 +1274,2 @@\n-     * @exception BadLocationException\n-     * @exception IllegalArgumentException if <code>direction<\/code> is invalid\n+     * @throws BadLocationException\n+     * @throws IllegalArgumentException if <code>direction<\/code> is invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/Utilities.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -498,1 +498,1 @@\n-     * @exception BadLocationException the given position is not a valid\n+     * @throws BadLocationException the given position is not a valid\n@@ -500,1 +500,1 @@\n-     * @exception IllegalArgumentException if <code>direction<\/code>\n+     * @throws IllegalArgumentException if <code>direction<\/code>\n@@ -588,1 +588,1 @@\n-     * @exception BadLocationException  if the specified position does\n+     * @throws BadLocationException  if the specified position does\n@@ -590,1 +590,1 @@\n-     * @exception IllegalArgumentException if <code>b<\/code> is not one of the\n+     * @throws IllegalArgumentException if <code>b<\/code> is not one of the\n@@ -618,1 +618,1 @@\n-     * @exception BadLocationException  if the given position does\n+     * @throws BadLocationException  if the given position does\n@@ -620,1 +620,1 @@\n-     * @exception IllegalArgumentException if <code>b0<\/code> or\n+     * @throws IllegalArgumentException if <code>b0<\/code> or\n@@ -1340,1 +1340,1 @@\n-     * @exception BadLocationException  if the given position does\n+     * @throws BadLocationException  if the given position does\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/View.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n-     * @exception BadLocationException if the range is invalid\n+     * @throws BadLocationException if the range is invalid\n@@ -255,1 +255,1 @@\n-     * @exception BadLocationException if the range is invalid\n+     * @throws BadLocationException if the range is invalid\n@@ -275,1 +275,1 @@\n-     * @exception BadLocationException if the range is invalid\n+     * @throws BadLocationException if the range is invalid\n@@ -323,1 +323,1 @@\n-     * @exception BadLocationException if the range is invalid\n+     * @throws BadLocationException if the range is invalid\n@@ -751,1 +751,1 @@\n-         * @exception BadLocationException  if the given position does not represent a\n+         * @throws BadLocationException  if the given position does not represent a\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/WrappedPlainView.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-     * @exception IllegalArgumentException if <code>mzl<\/code> is &lt; 1\n+     * @throws IllegalArgumentException if <code>mzl<\/code> is &lt; 1\n@@ -582,1 +582,1 @@\n-         * @exception BadLocationException  if the given position does not represent a\n+         * @throws BadLocationException  if the given position does not represent a\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/ZoneView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -387,1 +387,1 @@\n-         * @exception IllegalComponentStateException\n+         * @throws IllegalComponentStateException\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/AccessibleHTML.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-     * @exception IllegalArgumentException for an invalid axis\n+     * @throws IllegalArgumentException for an invalid axis\n@@ -359,1 +359,1 @@\n-     * @exception IllegalArgumentException for an invalid axis type\n+     * @throws IllegalArgumentException for an invalid axis type\n@@ -375,1 +375,1 @@\n-     * @exception IllegalArgumentException for an invalid axis type\n+     * @throws IllegalArgumentException for an invalid axis type\n@@ -391,1 +391,1 @@\n-     * @exception IllegalArgumentException for an invalid axis type\n+     * @throws IllegalArgumentException for an invalid axis type\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/BlockView.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-     * @exception IllegalArgumentException for an invalid axis\n+     * @throws IllegalArgumentException for an invalid axis\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/FormView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HRuleView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-     * @exception BadLocationException  if the given position does not\n+     * @throws BadLocationException  if the given position does not\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLDocument.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -301,2 +301,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -304,1 +304,1 @@\n-     * @exception RuntimeException (will eventually be a BadLocationException)\n+     * @throws RuntimeException (will eventually be a BadLocationException)\n@@ -340,1 +340,1 @@\n-     * @exception RuntimeException (will eventually be a BadLocationException)\n+     * @throws RuntimeException (will eventually be a BadLocationException)\n@@ -370,2 +370,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if {@code pos} represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if {@code pos} represents an invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLEditorKit.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -128,2 +128,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -251,1 +251,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -276,2 +276,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -454,2 +454,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -488,2 +488,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -526,1 +526,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -555,1 +555,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -583,1 +583,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -618,2 +618,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -640,2 +640,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -715,1 +715,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -770,1 +770,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLWriter.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-     * @exception BadLocationException  if the given position does not represent a\n+     * @throws BadLocationException  if the given position does not represent a\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/ImageView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,2 +131,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -155,1 +155,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -181,1 +181,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -199,1 +199,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -214,1 +214,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -233,1 +233,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -251,1 +251,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -341,1 +341,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -362,1 +362,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -380,1 +380,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -437,2 +437,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -460,1 +460,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -525,1 +525,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -545,1 +545,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -572,1 +572,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -639,1 +639,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -658,1 +658,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -679,1 +679,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n@@ -696,1 +696,1 @@\n-     * @exception IOException on any I\/O error\n+     * @throws IOException on any I\/O error\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/MinimalHTMLWriter.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -467,1 +467,1 @@\n-     * @exception CloneNotSupportedException if the receiver does not\n+     * @throws CloneNotSupportedException if the receiver does not\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/OptionListModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1889,1 +1889,1 @@\n-         * @exception IllegalArgumentException for an invalid direction\n+         * @throws IllegalArgumentException for an invalid direction\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/StyleSheet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1614,1 +1614,1 @@\n-         * @exception IllegalArgumentException for an invalid axis\n+         * @throws IllegalArgumentException for an invalid axis\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/TableView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -100,2 +100,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -120,2 +120,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n@@ -146,2 +146,2 @@\n-     * @exception IOException on any I\/O error\n-     * @exception BadLocationException if pos represents an invalid\n+     * @throws IOException on any I\/O error\n+     * @throws BadLocationException if pos represents an invalid\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/rtf\/RTFEditorKit.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-     * @exception       ArrayIndexOutOfBoundsException  if\n+     * @throws       ArrayIndexOutOfBoundsException  if\n@@ -179,1 +179,1 @@\n-     * @exception       IllegalArgumentException        if\n+     * @throws       IllegalArgumentException        if\n@@ -182,1 +182,1 @@\n-     * @exception       IllegalStateException   if this node does not allow\n+     * @throws       IllegalStateException   if this node does not allow\n@@ -214,1 +214,1 @@\n-     * @exception       ArrayIndexOutOfBoundsException  if\n+     * @throws       ArrayIndexOutOfBoundsException  if\n@@ -250,1 +250,1 @@\n-     * @exception       ArrayIndexOutOfBoundsException  if <code>index<\/code>\n+     * @throws       ArrayIndexOutOfBoundsException  if <code>index<\/code>\n@@ -281,1 +281,1 @@\n-     * @exception       IllegalArgumentException        if <code>aChild<\/code>\n+     * @throws       IllegalArgumentException        if <code>aChild<\/code>\n@@ -385,1 +385,1 @@\n-     * @exception       IllegalArgumentException        if <code>aChild<\/code>\n+     * @throws       IllegalArgumentException        if <code>aChild<\/code>\n@@ -415,1 +415,1 @@\n-     * @exception       IllegalArgumentException    if <code>newChild<\/code>\n+     * @throws       IllegalArgumentException    if <code>newChild<\/code>\n@@ -417,1 +417,1 @@\n-     * @exception       IllegalStateException   if this node does not allow\n+     * @throws       IllegalStateException   if this node does not allow\n@@ -849,1 +849,1 @@\n-     * @exception       IllegalArgumentException if <code>ancestor<\/code> is\n+     * @throws       IllegalArgumentException if <code>ancestor<\/code> is\n@@ -893,1 +893,1 @@\n-     * @exception       NoSuchElementException  if this node has no children\n+     * @throws       NoSuchElementException  if this node has no children\n@@ -908,1 +908,1 @@\n-     * @exception       NoSuchElementException  if this node has no children\n+     * @throws       NoSuchElementException  if this node has no children\n@@ -928,1 +928,1 @@\n-     * @exception       IllegalArgumentException if <code>aChild<\/code> is\n+     * @throws       IllegalArgumentException if <code>aChild<\/code> is\n@@ -960,1 +960,1 @@\n-     * @exception       IllegalArgumentException if <code>aChild<\/code> is null\n+     * @throws       IllegalArgumentException if <code>aChild<\/code> is null\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/tree\/DefaultMutableTreeNode.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code>\n+     * @throws ClassCastException if <code>listenerType<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/tree\/DefaultTreeModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-     * @exception ClassCastException if <code>listenerType<\/code>\n+     * @throws ClassCastException if <code>listenerType<\/code>\n@@ -1190,1 +1190,1 @@\n-     * @exception CloneNotSupportedException never thrown by instances of\n+     * @throws CloneNotSupportedException never thrown by instances of\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/tree\/DefaultTreeSelectionModel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-     * @exception CannotUndoException if <code>canUndo<\/code>\n+     * @throws CannotUndoException if <code>canUndo<\/code>\n@@ -137,1 +137,1 @@\n-     * @exception CannotRedoException if <code>canRedo<\/code>\n+     * @throws CannotRedoException if <code>canRedo<\/code>\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/undo\/AbstractUndoableEdit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -737,0 +737,1 @@\n+    void* buf = NULL;\n@@ -738,1 +739,1 @@\n-        void* buf = malloc(pfSize);\n+        buf = malloc(pfSize);\n@@ -744,1 +745,0 @@\n-            free(buf);\n@@ -748,0 +748,2 @@\n+    cmsCloseProfile(p); \/\/ No longer needed.\n+\n@@ -752,2 +754,2 @@\n-        cmsCloseProfile(p);\n-        p =  NULL;\n+        free(buf);\n+        return NULL;\n@@ -759,2 +761,3 @@\n-            cmsCloseProfile(p);\n-            p = NULL;\n+            free(buf);\n+            cmsCloseProfile(pfSanity);\n+            return NULL;\n@@ -762,0 +765,6 @@\n+        \/\/ The profile we used for sanity checking needs to be returned\n+        \/\/ since the one we updated is raw - not cooked.\n+        \/\/ Except we want to re-open it since the call to cmsReadTag()\n+        \/\/ means we may not get back the same bytes as we set.\n+        \/\/ Whilst this may change later anyway, we can at least prevent\n+        \/\/ it from happening immediately.\n@@ -763,1 +772,3 @@\n-        pfSanity = NULL;\n+        pfSanity = cmsOpenProfileFromMem(buf, pfSize);\n+        free(buf);\n+        return pfSanity;\n@@ -765,2 +776,0 @@\n-\n-    return p;\n","filename":"src\/java.desktop\/share\/native\/liblcms\/LCMS.c","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -938,2 +938,4 @@\n-                JNU_CHECK_EXCEPTION(env);\n-\n+                if (IS_NULL(jstr)) {\n+                    (*FcStrListDone)(cacheDirs);\n+                    return;\n+                }\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/fontpath.c","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -828,1 +828,1 @@\n-        cname = (char *) (*env)->GetStringUTFChars(env, jstr, JNI_FALSE);\n+        cname = (char *) (*env)->GetStringUTFChars(env, jstr, NULL);\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/xawt\/XlibWrapper.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-            if (!d3dw.isSurfaceLost() || validate(d3dw)) {\n+            if (!d3dw.isSurfaceLost() || validate(d3dw, false)) {\n@@ -455,1 +455,1 @@\n-                    } else if (!validate(sd)) {\n+                    } else if (!validate(sd, true)) {\n@@ -477,1 +477,1 @@\n-    private boolean validate(D3DWindowSurfaceData sd) {\n+    private boolean validate(D3DWindowSurfaceData sd, boolean postEvent) {\n@@ -494,1 +494,3 @@\n-                repaintPeerTarget(sd.getPeer());\n+                if (postEvent) {\n+                    repaintPeerTarget(sd.getPeer());\n+                }\n","filename":"src\/java.desktop\/windows\/classes\/sun\/java2d\/d3d\/D3DScreenUpdateManager.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-            labelStr = JNU_GetStringPlatformChars(env, label, JNI_FALSE);\n+            labelStr = JNU_GetStringPlatformChars(env, label, NULL);\n@@ -314,1 +314,1 @@\n-            labelStr = JNU_GetStringPlatformChars(env, label, JNI_FALSE);\n+            labelStr = JNU_GetStringPlatformChars(env, label, NULL);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Button.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-                labelStr = JNU_GetStringPlatformChars(env, label, 0);\n+                labelStr = JNU_GetStringPlatformChars(env, label, NULL);\n@@ -378,1 +378,1 @@\n-            labelStr = JNU_GetStringPlatformChars(env, label, JNI_FALSE);\n+            labelStr = JNU_GetStringPlatformChars(env, label, NULL);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Checkbox.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-    LPCWSTR fileOrUri_c = JNU_GetStringPlatformChars(env, fileOrUri_j, JNI_FALSE);\n+    LPCWSTR fileOrUri_c = JNU_GetStringPlatformChars(env, fileOrUri_j, NULL);\n@@ -80,1 +80,1 @@\n-    LPCWSTR verb_c = JNU_GetStringPlatformChars(env, verb_j, JNI_FALSE);\n+    LPCWSTR verb_c = JNU_GetStringPlatformChars(env, verb_j, NULL);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Desktop.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,5 +31,0 @@\n-static int signum(int i) {\n-  \/\/ special version of signum which returns 1 when value is 0\n-  return i >= 0 ? 1 : -1;\n-}\n-\n@@ -41,3 +36,20 @@\n-    mouseInput.mi.dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;\n-    mouseInput.mi.dx = (x * 65536 \/::GetSystemMetrics(SM_CXSCREEN)) + signum(x);\n-    mouseInput.mi.dy = (y * 65536 \/::GetSystemMetrics(SM_CYSCREEN)) + signum(y);\n+\n+    \/\/ The following calculations take into account a multi-monitor setup using\n+    \/\/ a virtual screen for all monitors combined.\n+    \/\/ More details from Microsoft are here --\n+    \/\/ https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/gdi\/the-virtual-screen\n+\n+    x -= ::GetSystemMetrics(SM_XVIRTUALSCREEN);\n+    y -= ::GetSystemMetrics(SM_YVIRTUALSCREEN);\n+\n+    mouseInput.mi.dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE |\n+                            MOUSEEVENTF_VIRTUALDESK;\n+\n+    int scW = ::GetSystemMetrics(SM_CXVIRTUALSCREEN);\n+    int scH = ::GetSystemMetrics(SM_CYVIRTUALSCREEN);\n+\n+    \/\/ The following calculation to deduce mouse coordinates is based on\n+    \/\/ empirical data\n+    mouseInput.mi.dx = (x * 65536 + scW - 1) \/ scW;\n+    mouseInput.mi.dy = (y * 65536 + scH - 1) \/ scH;\n+\n@@ -45,0 +57,1 @@\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Robot.cpp","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,1 +186,1 @@\n-    LPTSTR file = (LPTSTR)JNU_GetStringPlatformChars(env, fontName, JNI_FALSE);\n+    LPTSTR file = (LPTSTR)JNU_GetStringPlatformChars(env, fontName, NULL);\n@@ -206,1 +206,1 @@\n-    LPTSTR file = (LPTSTR)JNU_GetStringPlatformChars(env, fontName, JNI_FALSE);\n+    LPTSTR file = (LPTSTR)JNU_GetStringPlatformChars(env, fontName, NULL);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsEnv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -438,2 +438,1 @@\n-            throw(SSLPeerUnverifiedException)\n-                new SSLPeerUnverifiedException(\"hostname of the server '\" +\n+            throw new SSLPeerUnverifiedException(\"hostname of the server '\" +\n@@ -442,1 +441,1 @@\n-                                \"server's certificate.\").initCause(e);\n+                                \"server's certificate.\", e);\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/ext\/StartTlsResponseImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,2 +147,13 @@\n-            this.connection = connection;\n-            if (closeRequested) closeConnection();\n+            boolean closeRequested;\n+            synchronized (this) {\n+                \/\/ check whether this new connection should be\n+                \/\/ closed\n+                closeRequested = this.closeRequested;\n+                if (!closeRequested) {\n+                    this.connection = connection;\n+                } else {\n+                    \/\/ assert this.connection == null\n+                    this.closeRequested = false;\n+                }\n+            }\n+            if (closeRequested) closeConnection(connection);\n@@ -152,3 +163,23 @@\n-            closeRequested = true;\n-            HttpConnection connection = this.connection;\n-            this.connection = null;\n+            HttpConnection connection;\n+            synchronized (this) {\n+                connection = this.connection;\n+                if (connection == null) {\n+                    closeRequested = true;\n+                } else {\n+                    this.connection = null;\n+                }\n+            }\n+            closeConnection(connection);\n+        }\n+\n+        HttpConnection disable() {\n+            HttpConnection connection;\n+            synchronized (this) {\n+                connection = this.connection;\n+                this.connection = null;\n+                this.closeRequested = false;\n+            }\n+            return connection;\n+        }\n+\n+        private static void closeConnection(HttpConnection connection) {\n@@ -163,5 +194,0 @@\n-\n-        void disable() {\n-            connection = null;\n-            closeRequested = false;\n-        }\n@@ -527,0 +553,1 @@\n+                            HttpConnection connection = connectionAborter.disable();\n@@ -528,1 +555,3 @@\n-                            if (cached) connectionAborter.disable();\n+                            if (!cached && connection != null) {\n+                                connectionAborter.connection(connection);\n+                            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":41,"deletions":12,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.net.ConnectException;\n@@ -104,1 +103,1 @@\n-                    if (connection.closed || !connection.reserveStream(true)) {\n+                    if (!connection.isOpen() || !connection.reserveStream(true)) {\n@@ -156,1 +155,1 @@\n-        if (c.closed || c.finalStream()) {\n+        if (!c.isOpen() || c.finalStream()) {\n@@ -164,0 +163,5 @@\n+            if (!c.isOpen()) {\n+                if (debug.on())\n+                    debug.log(\"skipping offered closed or closing connection: %s\", c);\n+                return false;\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -883,0 +883,4 @@\n+    boolean isOpen() {\n+        return !closed && connection.channel().isOpen();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -576,3 +576,1 @@\n-                SSLHandshakeException he = new SSLHandshakeException(msg);\n-                he.initCause(throwable);\n-                throw he;\n+                throw new SSLHandshakeException(msg, throwable);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -595,3 +595,1 @@\n-        SSLHandshakeException e = new SSLHandshakeException(handshakeFailed);\n-        if (t != null) e.initCause(t);\n-        return e;\n+        return new SSLHandshakeException(handshakeFailed, t);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SSLTube.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-                    buffer.setLength(0);;\n+                    buffer.setLength(0);\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/LogStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,3 +130,1 @@\n-            IOException ioe = new IOException(\"Negotiate support not initiated\");\n-            ioe.initCause(e);\n-            throw ioe;\n+            throw new IOException(\"Negotiate support not initiated\", e);\n@@ -160,3 +158,1 @@\n-            IOException ioe = new IOException(\"Negotiate support cannot continue\");\n-            ioe.initCause(e);\n-            throw ioe;\n+            throw new IOException(\"Negotiate support cannot continue\", e);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/net\/www\/protocol\/http\/spnego\/NegotiatorImpl.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -237,4 +237,2 @@\n-                IOException ioe = new IOException(\n-                        \"Unable to parse eData field of KRB-ERROR\");\n-                ioe.initCause(e);\n-                throw ioe;\n+                throw new IOException(\n+                        \"Unable to parse eData field of KRB-ERROR\", e);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/KRBError.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import sun.security.krb5.EncryptedData;\n@@ -162,4 +161,1 @@\n-            GeneralSecurityException gse =\n-                new GeneralSecurityException(\"Calculate Checkum Failed!\");\n-            gse.initCause(e);\n-            throw gse;\n+            throw new GeneralSecurityException(\"Calculate Checksum Failed!\", e);\n@@ -176,4 +172,1 @@\n-            GeneralSecurityException gse =\n-                new GeneralSecurityException(\"Calculate Checkum Failed!\");\n-            gse.initCause(e);\n-            throw gse;\n+            throw new GeneralSecurityException(\"Calculate Checksum Failed!\", e);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/crypto\/dk\/ArcFourCrypto.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -137,2 +137,2 @@\n-        byte[] c = cstring.getBytes(StandardCharsets.UTF_8);;\n-        byte[] s = sstring.getBytes(StandardCharsets.UTF_8);;\n+        byte[] c = cstring.getBytes(StandardCharsets.UTF_8);\n+        byte[] s = sstring.getBytes(StandardCharsets.UTF_8);\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/internal\/rcache\/AuthTime.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-show_time(char* label, TimeStamp* ts)\n+show_time(const char* label, TimeStamp* ts)\n@@ -289,1 +289,1 @@\n-    WCHAR* realm = _wgetenv(L\"USERDNSDOMAIN\");\n+    const WCHAR* realm = _wgetenv(L\"USERDNSDOMAIN\");\n@@ -656,1 +656,1 @@\n-                L\"Kerberos\",\n+                (LPWSTR)L\"Kerberos\",\n@@ -686,1 +686,1 @@\n-                L\"Negotiate\",\n+                (LPWSTR)L\"Negotiate\",\n@@ -948,1 +948,1 @@\n-                    isSPNEGO ? L\"Negotiate\" : L\"Kerberos\",\n+                    (LPWSTR)(isSPNEGO ? L\"Negotiate\" : L\"Kerberos\"),\n","filename":"src\/java.security.jgss\/windows\/native\/libsspi_bridge\/sspi.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-        this.crsResolve = new CachedRowSetImpl();;\n+        this.crsResolve = new CachedRowSetImpl();\n","filename":"src\/java.sql.rowset\/share\/classes\/com\/sun\/rowset\/internal\/CachedRowSetWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -538,1 +538,1 @@\n-        SerialStruct s = new SerialStruct(x,map);;\n+        SerialStruct s = new SerialStruct(x,map);\n","filename":"src\/java.sql.rowset\/share\/classes\/javax\/sql\/rowset\/serial\/SQLOutputImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1014,1 +1014,1 @@\n-                        : _xsltc.registerNamespacePrefix(name);;\n+                        : _xsltc.registerNamespacePrefix(name);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/XPathParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @LastModified: Sep 2021\n+ * @LastModified: Mar 2022\n@@ -2165,1 +2165,1 @@\n-                    if (c == '\\r') {\n+                    if (c == '\\r' && isExternal) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLEntityScanner.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -6,8 +6,5 @@\n-    =========================================================================\n-    ==  NOTICE file corresponding to the section 4 d of                    ==\n-    ==  the Apache License, Version 2.0,                                   ==\n-    ==  in this case for the Apache Commons BCEL distribution.             ==\n-    =========================================================================\n-\n-   This product includes software developed by\n-   The Apache Software Foundation (http:\/\/www.apache.org\/).\n+    Apache Commons BCEL\n+    Copyright 2004-2020 The Apache Software Foundation\n+\n+    This product includes software developed at\n+    The Apache Software Foundation (https:\/\/www.apache.org\/).\n","filename":"src\/java.xml\/share\/legal\/bcel.md","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -303,4 +303,1 @@\n-                AssertionError assertError =\n-                    new AssertionError(\"Problem instantiating PrintingProcessor.\");\n-                assertError.initCause(t);\n-                throw assertError;\n+                throw new AssertionError(\"Problem instantiating PrintingProcessor.\", t);\n@@ -496,1 +493,1 @@\n-        private Map<String, Processor> namedProcessorsMap = new HashMap<>();;\n+        private Map<String, Processor> namedProcessorsMap = new HashMap<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,3 +197,1 @@\n-            IOException e = new IOException(ex.getMessage());\n-            e.initCause(ex);\n-            throw e;\n+            throw new IOException(ex.getMessage(), ex);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-void dump(LPSTR title, PBYTE data, DWORD len)\n+void dump(LPCSTR title, PBYTE data, DWORD len)\n@@ -536,1 +536,1 @@\n-            if (GetCertificateChain(OID_EKU_ANY, pCertContext, &pCertChainContext))\n+            if (GetCertificateChain((LPSTR)OID_EKU_ANY, pCertContext, &pCertChainContext))\n@@ -1270,1 +1270,1 @@\n-    bb.pvBuffer = L\"changeit\";\n+    bb.pvBuffer = (LPWSTR)L\"changeit\";\n","filename":"src\/jdk.crypto.mscapi\/windows\/native\/libsunmscapi\/security.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        ZObjectAlignmentLargeShift = db.lookupIntConstant(\"ZObjectAlignmentLargeShift\").intValue();;\n+        ZObjectAlignmentLargeShift = db.lookupIntConstant(\"ZObjectAlignmentLargeShift\").intValue();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/z\/ZGlobals.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-      iterated = end.minus(base);;\n+      iterated = end.minus(base);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/FindInCodeCachePanel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-      updates = new ArrayList<>();;\n+      updates = new ArrayList<>();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/FindInHeapPanel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -371,0 +371,6 @@\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public final Byte128Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte128Mask.class, op, (Byte128Mask) m);  \/\/ specialize\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Byte256Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte256Mask.class, op, (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Byte512Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte512Mask.class, op, (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Byte64Mask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(Byte64Mask.class, op, (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final ByteMaxMask test(Test op, VectorMask<Byte> m) {\n+        return super.testTemplate(ByteMaxMask.class, op, (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1917,1 +1917,0 @@\n-            ByteVector bits = this.viewAsIntegralLanes();\n@@ -1920,1 +1919,1 @@\n-                m = bits.compare(EQ, (byte) 0);\n+                m = compare(EQ, (byte) 0);\n@@ -1922,1 +1921,1 @@\n-                m = bits.compare(LT, (byte) 0);\n+                m = compare(LT, (byte) 0);\n@@ -1937,2 +1936,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1940,2 +1938,23 @@\n-                                  VectorMask<Byte> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Byte> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        ByteSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            VectorMask<Byte> m = mask;\n+            if (op == IS_DEFAULT) {\n+                m = compare(EQ, (byte) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = compare(LT, (byte) 0, m);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n@@ -4416,6 +4435,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (ByteSpecies) SPECIES_64;\n-            case S_128_BIT: return (ByteSpecies) SPECIES_128;\n-            case S_256_BIT: return (ByteSpecies) SPECIES_256;\n-            case S_512_BIT: return (ByteSpecies) SPECIES_512;\n-            case S_Max_BIT: return (ByteSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (ByteSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (ByteSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (ByteSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (ByteSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (ByteSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Double128Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double128Mask.class, op, (Double128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Double256Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double256Mask.class, op, (Double256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Double512Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double512Mask.class, op, (Double512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Double64Mask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(Double64Mask.class, op, (Double64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final DoubleMaxMask test(Test op, VectorMask<Double> m) {\n+        return super.testTemplate(DoubleMaxMask.class, op, (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1749,1 +1749,1 @@\n-            return maskType.cast(m.cast(this.vspecies()));\n+            return maskType.cast(m.cast(vsp));\n@@ -1759,2 +1759,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1762,2 +1761,40 @@\n-                                  VectorMask<Double> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Double> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Double>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        DoubleSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            LongVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Long> m = mask.cast(LongVector.species(shape()));\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (long) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (long) 0, m);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Long.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                long infbits = (long) toBits(Double.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, m);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, m);\n+                } else {\n+                    m = bits.compare(EQ, infbits, m);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n@@ -3997,6 +4034,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (DoubleSpecies) SPECIES_64;\n-            case S_128_BIT: return (DoubleSpecies) SPECIES_128;\n-            case S_256_BIT: return (DoubleSpecies) SPECIES_256;\n-            case S_512_BIT: return (DoubleSpecies) SPECIES_512;\n-            case S_Max_BIT: return (DoubleSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (DoubleSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (DoubleSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (DoubleSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (DoubleSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (DoubleSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float128Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float128Mask.class, op, (Float128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float256Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float256Mask.class, op, (Float256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float512Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float512Mask.class, op, (Float512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final Float64Mask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(Float64Mask.class, op, (Float64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,6 @@\n+    @Override\n+    @ForceInline\n+    public final FloatMaxMask test(Test op, VectorMask<Float> m) {\n+        return super.testTemplate(FloatMaxMask.class, op, (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1761,1 +1761,1 @@\n-            return maskType.cast(m.cast(this.vspecies()));\n+            return maskType.cast(m.cast(vsp));\n@@ -1771,2 +1771,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1774,2 +1773,40 @@\n-                                  VectorMask<Float> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Float> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Float>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        FloatSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            IntVector bits = this.viewAsIntegralLanes();\n+            VectorMask<Integer> m = mask.cast(IntVector.species(shape()));\n+            if (op == IS_DEFAULT) {\n+                m = bits.compare(EQ, (int) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = bits.compare(LT, (int) 0, m);\n+            }\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and(Integer.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                int infbits = (int) toBits(Float.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, m);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, m);\n+                } else {\n+                    m = bits.compare(EQ, infbits, m);\n+                }\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m.cast(vsp));\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n@@ -3947,6 +3984,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (FloatSpecies) SPECIES_64;\n-            case S_128_BIT: return (FloatSpecies) SPECIES_128;\n-            case S_256_BIT: return (FloatSpecies) SPECIES_256;\n-            case S_512_BIT: return (FloatSpecies) SPECIES_512;\n-            case S_Max_BIT: return (FloatSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (FloatSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (FloatSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (FloatSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (FloatSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (FloatSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Int128Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int128Mask.class, op, (Int128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Int256Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int256Mask.class, op, (Int256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Int512Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int512Mask.class, op, (Int512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Int64Mask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(Int64Mask.class, op, (Int64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final IntMaxMask test(Test op, VectorMask<Integer> m) {\n+        return super.testTemplate(IntMaxMask.class, op, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1898,1 +1898,0 @@\n-            IntVector bits = this.viewAsIntegralLanes();\n@@ -1901,1 +1900,1 @@\n-                m = bits.compare(EQ, (int) 0);\n+                m = compare(EQ, (int) 0);\n@@ -1903,1 +1902,1 @@\n-                m = bits.compare(LT, (int) 0);\n+                m = compare(LT, (int) 0);\n@@ -1918,2 +1917,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1921,2 +1919,23 @@\n-                                  VectorMask<Integer> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Integer> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        IntSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            VectorMask<Integer> m = mask;\n+            if (op == IS_DEFAULT) {\n+                m = compare(EQ, (int) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = compare(LT, (int) 0, m);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n@@ -4123,6 +4142,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (IntSpecies) SPECIES_64;\n-            case S_128_BIT: return (IntSpecies) SPECIES_128;\n-            case S_256_BIT: return (IntSpecies) SPECIES_256;\n-            case S_512_BIT: return (IntSpecies) SPECIES_512;\n-            case S_Max_BIT: return (IntSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (IntSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (IntSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (IntSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (IntSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (IntSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long128Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long128Mask.class, op, (Long128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long256Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long256Mask.class, op, (Long256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long512Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long512Mask.class, op, (Long512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final Long64Mask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(Long64Mask.class, op, (Long64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,6 @@\n+    @Override\n+    @ForceInline\n+    public final LongMaxMask test(Test op, VectorMask<Long> m) {\n+        return super.testTemplate(LongMaxMask.class, op, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1811,1 +1811,0 @@\n-            LongVector bits = this.viewAsIntegralLanes();\n@@ -1814,1 +1813,1 @@\n-                m = bits.compare(EQ, (long) 0);\n+                m = compare(EQ, (long) 0);\n@@ -1816,1 +1815,1 @@\n-                m = bits.compare(LT, (long) 0);\n+                m = compare(LT, (long) 0);\n@@ -1831,2 +1830,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1834,2 +1832,23 @@\n-                                  VectorMask<Long> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Long> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        LongSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            VectorMask<Long> m = mask;\n+            if (op == IS_DEFAULT) {\n+                m = compare(EQ, (long) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = compare(LT, (long) 0, m);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n@@ -4049,6 +4068,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (LongSpecies) SPECIES_64;\n-            case S_128_BIT: return (LongSpecies) SPECIES_128;\n-            case S_256_BIT: return (LongSpecies) SPECIES_256;\n-            case S_512_BIT: return (LongSpecies) SPECIES_512;\n-            case S_Max_BIT: return (LongSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (LongSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (LongSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (LongSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (LongSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (LongSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short128Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short128Mask.class, op, (Short128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short256Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short256Mask.class, op, (Short256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short512Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short512Mask.class, op, (Short512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final Short64Mask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(Short64Mask.class, op, (Short64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,0 +373,6 @@\n+    @Override\n+    @ForceInline\n+    public final ShortMaxMask test(Test op, VectorMask<Short> m) {\n+        return super.testTemplate(ShortMaxMask.class, op, (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1918,1 +1918,0 @@\n-            ShortVector bits = this.viewAsIntegralLanes();\n@@ -1921,1 +1920,1 @@\n-                m = bits.compare(EQ, (short) 0);\n+                m = compare(EQ, (short) 0);\n@@ -1923,1 +1922,1 @@\n-                m = bits.compare(LT, (short) 0);\n+                m = compare(LT, (short) 0);\n@@ -1938,2 +1937,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -1941,2 +1939,23 @@\n-                                  VectorMask<Short> m) {\n-        return test(op).and(m);\n+                                  VectorMask<Short> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        ShortSpecies vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+            VectorMask<Short> m = mask;\n+            if (op == IS_DEFAULT) {\n+                m = compare(EQ, (short) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = compare(LT, (short) 0, m);\n+            }\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m);\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n@@ -4411,6 +4430,6 @@\n-        switch (s) {\n-            case S_64_BIT: return (ShortSpecies) SPECIES_64;\n-            case S_128_BIT: return (ShortSpecies) SPECIES_128;\n-            case S_256_BIT: return (ShortSpecies) SPECIES_256;\n-            case S_512_BIT: return (ShortSpecies) SPECIES_512;\n-            case S_Max_BIT: return (ShortSpecies) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return (ShortSpecies) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return (ShortSpecies) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return (ShortSpecies) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return (ShortSpecies) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return (ShortSpecies) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2241,0 +2241,1 @@\n+#if[FP]\n@@ -2242,0 +2243,1 @@\n+#end[FP]\n@@ -2244,1 +2246,1 @@\n-                m = bits.compare(EQ, ($bitstype$) 0);\n+                m = {#if[FP]?bits.}compare(EQ, ($bitstype$) 0);\n@@ -2246,1 +2248,1 @@\n-                m = bits.compare(LT, ($bitstype$) 0);\n+                m = {#if[FP]?bits.}compare(LT, ($bitstype$) 0);\n@@ -2269,1 +2271,1 @@\n-            return maskType.cast(m{#if[FP]?.cast(this.vspecies())});\n+            return maskType.cast(m{#if[FP]?.cast(vsp)});\n@@ -2279,2 +2281,1 @@\n-    @ForceInline\n-    public final\n+    public abstract\n@@ -2282,2 +2283,46 @@\n-                                  VectorMask<$Boxtype$> m) {\n-        return test(op).and(m);\n+                                  VectorMask<$Boxtype$> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    M testTemplate(Class<M> maskType, Test op, M mask) {\n+        $Type$Species vsp = vspecies();\n+        mask.check(maskType, this);\n+        if (opKind(op, VO_SPECIAL)) {\n+#if[FP]\n+            $Bitstype$Vector bits = this.viewAsIntegralLanes();\n+            VectorMask<$Boxbitstype$> m = mask.cast($Bitstype$Vector.species(shape()));\n+#else[FP]\n+            VectorMask<$Boxbitstype$> m = mask;\n+#end[FP]\n+            if (op == IS_DEFAULT) {\n+                m = {#if[FP]?bits.}compare(EQ, ($bitstype$) 0, m);\n+            } else if (op == IS_NEGATIVE) {\n+                m = {#if[FP]?bits.}compare(LT, ($bitstype$) 0, m);\n+            }\n+#if[FP]\n+            else if (op == IS_FINITE ||\n+                     op == IS_NAN ||\n+                     op == IS_INFINITE) {\n+                \/\/ first kill the sign:\n+                bits = bits.and($Boxbitstype$.MAX_VALUE);\n+                \/\/ next find the bit pattern for infinity:\n+                $bitstype$ infbits = ($bitstype$) toBits($Boxtype$.POSITIVE_INFINITY);\n+                \/\/ now compare:\n+                if (op == IS_FINITE) {\n+                    m = bits.compare(LT, infbits, m);\n+                } else if (op == IS_NAN) {\n+                    m = bits.compare(GT, infbits, m);\n+                } else {\n+                    m = bits.compare(EQ, infbits, m);\n+                }\n+            }\n+#end[FP]\n+            else {\n+                throw new AssertionError(op);\n+            }\n+            return maskType.cast(m{#if[FP]?.cast(vsp)});\n+        }\n+        int opc = opCode(op);\n+        throw new AssertionError(op);\n@@ -5648,6 +5693,6 @@\n-        switch (s) {\n-            case S_64_BIT: return ($Type$Species) SPECIES_64;\n-            case S_128_BIT: return ($Type$Species) SPECIES_128;\n-            case S_256_BIT: return ($Type$Species) SPECIES_256;\n-            case S_512_BIT: return ($Type$Species) SPECIES_512;\n-            case S_Max_BIT: return ($Type$Species) SPECIES_MAX;\n+        switch (s.switchKey) {\n+            case VectorShape.SK_64_BIT: return ($Type$Species) SPECIES_64;\n+            case VectorShape.SK_128_BIT: return ($Type$Species) SPECIES_128;\n+            case VectorShape.SK_256_BIT: return ($Type$Species) SPECIES_256;\n+            case VectorShape.SK_512_BIT: return ($Type$Species) SPECIES_512;\n+            case VectorShape.SK_Max_BIT: return ($Type$Species) SPECIES_MAX;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":58,"deletions":13,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -377,0 +377,6 @@\n+    @Override\n+    @ForceInline\n+    public final $masktype$ test(Test op, VectorMask<$Boxtype$> m) {\n+        return super.testTemplate($masktype$.class, op, ($masktype$) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,0 +180,1 @@\n+        PACA,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.aarch64\/src\/jdk\/vm\/ci\/aarch64\/AArch64.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,5 @@\n+    public static final char PACKAGE_SEPARATOR_INTERNAL = '\/';\n+    public static final char HIDDEN_SEPARATOR_INTERNAL = '.';\n+    public static final char PACKAGE_SEPARATOR_JAVA = HIDDEN_SEPARATOR_INTERNAL;\n+    public static final char HIDDEN_SEPARATOR_JAVA = PACKAGE_SEPARATOR_INTERNAL;\n+\n@@ -90,2 +95,3 @@\n-     * Classes for lambdas can have {@code \/} characters that are not package separators. These are\n-     * distinguished by being followed by a character that is not a\n+     * Hidden classes have {@code \/} characters in their internal names and {@code .} characters in their names returned\n+     * by {@link Class#getName()} that are not package separators.\n+     * These are distinguished by being followed by a character that is not a\n@@ -94,0 +100,4 @@\n+     *\n+     * @param name the name to perform the replacements on\n+     * @param packageSeparator the {@link Character} used as the package separator, e.g. {@code \/} in internal form\n+     * @param hiddenSeparator the {@link Character} used as the hidden class separator, e.g. {@code .} in internal form\n@@ -95,1 +105,2 @@\n-    private static String replacePackageSeparatorsWithDot(String name) {\n+    private static String replacePackageAndHiddenSeparators(String name, Character packageSeparator, Character hiddenSeparator) {\n+        int index = name.indexOf(hiddenSeparator);   \/\/ check if it's a hidden class\n@@ -97,1 +108,0 @@\n-        int i = 0;\n@@ -99,8 +109,6 @@\n-        while (i < length - 1) {\n-            char ch = name.charAt(i);\n-            if (ch == '\/' && Character.isJavaIdentifierStart(name.charAt(i + 1))) {\n-                buf.append('.');\n-            } else {\n-                buf.append(ch);\n-            }\n-            i++;\n+        if (index < 0) {\n+            buf.append(name.replace(packageSeparator, hiddenSeparator));\n+        } else {\n+            buf.append(name.substring(0, index).replace(packageSeparator, hiddenSeparator));\n+            buf.append(packageSeparator);\n+            buf.append(name.substring(index + 1));\n@@ -108,1 +116,0 @@\n-        buf.append(name.charAt(length - 1));\n@@ -125,1 +132,2 @@\n-                String result = replacePackageSeparatorsWithDot(name.substring(1, name.length() - 1));\n+                String type = name.substring(1, name.length() - 1);\n+                String result = replacePackageAndHiddenSeparators(type, PACKAGE_SEPARATOR_INTERNAL, HIDDEN_SEPARATOR_INTERNAL);\n@@ -127,1 +135,1 @@\n-                    final int lastDot = result.lastIndexOf('.');\n+                    final int lastDot = result.lastIndexOf(HIDDEN_SEPARATOR_INTERNAL);\n@@ -135,1 +143,5 @@\n-                return classForNameCompatible ? replacePackageSeparatorsWithDot(name) : internalNameToJava(name.substring(1), qualified, classForNameCompatible) + \"[]\";\n+                if (classForNameCompatible) {\n+                    return replacePackageAndHiddenSeparators(name, PACKAGE_SEPARATOR_INTERNAL, HIDDEN_SEPARATOR_INTERNAL);\n+                } else {\n+                    return internalNameToJava(name.substring(1), qualified, false) + \"[]\";\n+                }\n@@ -216,1 +228,1 @@\n-            return className.replace('.', '\/');\n+            return replacePackageAndHiddenSeparators(className, PACKAGE_SEPARATOR_JAVA, HIDDEN_SEPARATOR_JAVA);\n@@ -255,1 +267,3 @@\n-                result.append(\"L\").append(base.replace('.', '\/')).append(\";\");\n+                result.append(\"L\")\n+                        .append(replacePackageAndHiddenSeparators(base, PACKAGE_SEPARATOR_JAVA, HIDDEN_SEPARATOR_JAVA))\n+                        .append(\";\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.meta\/src\/jdk\/vm\/ci\/meta\/MetaUtil.java","additions":33,"deletions":19,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.security.interfaces.ECKey;\n@@ -1024,0 +1025,2 @@\n+                            AlgorithmId encAlgId = si.getDigestEncryptionAlgorithmId();\n+                            AlgorithmParameters sigAlgParams = encAlgId.getParameters();\n@@ -1038,0 +1041,2 @@\n+                                AlgorithmId tsEncAlgId = tsSi.getDigestEncryptionAlgorithmId();\n+                                AlgorithmParameters tsSigAlgParams = tsEncAlgId.getParameters();\n@@ -1052,2 +1057,2 @@\n-                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false, jcp),\n-                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false, jcp),\n+                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false, jcp, null),\n+                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false, jcp, sigAlgParams),\n@@ -1057,2 +1062,2 @@\n-                                        verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true, jcpts),\n-                                        verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true, jcpts),\n+                                        verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true, jcpts, null),\n+                                        verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true, jcpts, tsSigAlgParams),\n@@ -1066,2 +1071,2 @@\n-                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false, jcp),\n-                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false, jcp),\n+                                        verifyWithWeak(digestAlg, DIGEST_PRIMITIVE_SET, false, jcp, null),\n+                                        verifyWithWeak(sigAlg, SIG_PRIMITIVE_SET, false, jcp, sigAlgParams),\n@@ -1243,1 +1248,1 @@\n-                        privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));\n+                        KeyUtil.fullDisplayAlgName(privateKey), KeyUtil.getKeySize(privateKey)));\n@@ -1249,1 +1254,1 @@\n-                        privateKey.getAlgorithm(), KeyUtil.getKeySize(privateKey)));\n+                        KeyUtil.fullDisplayAlgName(privateKey), KeyUtil.getKeySize(privateKey)));\n@@ -1273,1 +1278,1 @@\n-                        weakPublicKey.getAlgorithm(), KeyUtil.getKeySize(weakPublicKey)));\n+                        KeyUtil.fullDisplayAlgName(weakPublicKey), KeyUtil.getKeySize(weakPublicKey)));\n@@ -1396,1 +1401,1 @@\n-        boolean tsa, JarConstraintsParameters jcp) {\n+        boolean tsa, JarConstraintsParameters jcp, AlgorithmParameters algParams) {\n@@ -1404,0 +1409,10 @@\n+        if (algParams != null) {\n+            try {\n+                JAR_DISABLED_CHECK.permits(algParams, jcp);\n+            } catch (CertPathValidatorException e) {\n+                disabledAlgFound = true;\n+                return String.format(rb.getString(\"with.algparams.disabled\"),\n+                        alg, algParams);\n+            }\n+        }\n+\n@@ -1406,1 +1421,0 @@\n-            return alg;\n@@ -1422,0 +1436,11 @@\n+        if (algParams != null) {\n+            try {\n+                LEGACY_CHECK.permits(algParams, jcp);\n+            } catch (CertPathValidatorException e) {\n+                legacyAlg |= 2;\n+                legacySigAlg = alg;\n+                return String.format(rb.getString(\"with.algparams.weak\"),\n+                        alg, algParams);\n+            }\n+        }\n+        return alg;\n@@ -1430,1 +1455,6 @@\n-            return String.format(rb.getString(\"key.bit.disabled\"), kLen);\n+            if (key instanceof ECKey) {\n+                return String.format(rb.getString(\"key.bit.eccurve.disabled\"), kLen,\n+                        KeyUtil.fullDisplayAlgName(key));\n+            } else {\n+                return String.format(rb.getString(\"key.bit.disabled\"), kLen);\n+            }\n@@ -1442,1 +1472,6 @@\n-            return String.format(rb.getString(\"key.bit.weak\"), kLen);\n+            if (key instanceof ECKey) {\n+                return String.format(rb.getString(\"key.bit.eccurve.weak\"), kLen,\n+                        KeyUtil.fullDisplayAlgName(key));\n+            } else {\n+                return String.format(rb.getString(\"key.bit.weak\"), kLen);\n+            }\n@@ -1495,1 +1530,6 @@\n-            return String.format(rb.getString(\"key.bit.disabled\"), kLen);\n+            if (key instanceof ECKey) {\n+                return String.format(rb.getString(\"key.bit.eccurve.disabled\"), kLen,\n+                        KeyUtil.fullDisplayAlgName(key));\n+            } else {\n+                return String.format(rb.getString(\"key.bit.disabled\"), kLen);\n+            }\n@@ -1505,1 +1545,6 @@\n-            return String.format(rb.getString(\"key.bit.weak\"), kLen);\n+            if (key instanceof ECKey) {\n+                return String.format(rb.getString(\"key.bit.eccurve.weak\"), kLen,\n+                        KeyUtil.fullDisplayAlgName(key));\n+            } else {\n+                return String.format(rb.getString(\"key.bit.weak\"), kLen);\n+            }\n@@ -2188,1 +2233,1 @@\n-            } else if (!token && storepass == null && prompt) {\n+            } else if (!token && storepass == null && prompt && !protectedPath) {\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":61,"deletions":16,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+        {\"with.algparams.weak\", \"%1$s using %2$s (weak)\"},\n@@ -180,0 +181,1 @@\n+        {\"with.algparams.disabled\", \"%1$s using %2$s (disabled)\"},\n@@ -182,0 +184,1 @@\n+        {\"key.bit.eccurve.weak\", \"%1$d-bit %2$s key (weak)\"},\n@@ -183,0 +186,1 @@\n+        {\"key.bit.eccurve.disabled\", \"%1$d-bit %2$s key (disabled)\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-        if (type.equals(typeElement.asType())) {\n+        if (utils.typeUtils.isSameType(type, typeElement.asType())) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-                \"jquery-3.5.1.min.js\",\n+                \"jquery-3.6.0.min.js\",\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1013,0 +1013,4 @@\n+                    case ERRONEOUS -> {\n+                        return invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", seeText),\n+                                Optional.empty());\n+                    }\n@@ -2402,0 +2406,4 @@\n+            if (utils.isPreviewAPI(enclosed)) {\n+                \/\/for class summary, ignore methods that are themselves preview:\n+                continue;\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-\/*! jQuery v3.5.1 | (c) JS Foundation and other contributors | jquery.org\/license *\/\n-!function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.5.1\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for(\"boolean\"==typeof a&&(l=a,a=arguments[s]||{},s++),\"object\"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],\"__proto__\"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:\"jQuery\"+(f+Math.random()).replace(\/\\D\/g,\"\"),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||\"[object Object]\"!==o.call(e))&&(!(t=r(e))||\"function\"==typeof(n=v.call(t,\"constructor\")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,\"string\"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),\"function\"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(e,t){n[\"[object \"+t+\"]\"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S=\"sizzle\"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",M=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",I=\"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",W=\"\\\\[\"+M+\"*(\"+I+\")(?:\"+M+\"*([*^$|!~]?=)\"+M+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+I+\"))|)\"+M+\"*\\\\]\",F=\":(\"+I+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+W+\")*)|.*)\\\\)|)\",B=new RegExp(M+\"+\",\"g\"),$=new RegExp(\"^\"+M+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+M+\"+$\",\"g\"),_=new RegExp(\"^\"+M+\"*,\"+M+\"*\"),z=new RegExp(\"^\"+M+\"*([>+~]|\"+M+\")\"+M+\"*\"),U=new RegExp(M+\"|>\"),X=new RegExp(F),V=new RegExp(\"^\"+I+\"$\"),G={ID:new RegExp(\"^#(\"+I+\")\"),CLASS:new RegExp(\"^\\\\.(\"+I+\")\"),TAG:new RegExp(\"^(\"+I+\"|[*])\"),ATTR:new RegExp(\"^\"+W),PSEUDO:new RegExp(\"^\"+F),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+M+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+M+\"*(?:([+-]|)\"+M+\"*(\\\\d+)|))\"+M+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+R+\")$\",\"i\"),needsContext:new RegExp(\"^\"+M+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+M+\"*((?:-\\\\d)?\\\\d*)\"+M+\"*\\\\)|)(?=[^-]|$)\",\"i\")},Y=\/HTML$\/i,Q=\/^(?:input|select|textarea|button)$\/i,J=\/^h\\d$\/i,K=\/^[^{]+\\{\\s*\\[native \\w\/,Z=\/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$\/,ee=\/[+~]\/,te=new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\",\"g\"),ne=function(e,t){var n=\"0x\"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=\/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]\/g,ie=function(e,t){return t?\"\\0\"===e?\"\\ufffd\":e.slice(0,-1)+\"\\\\\"+e.charCodeAt(e.length-1).toString(16)+\" \":\"\\\\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&\"fieldset\"===e.nodeName.toLowerCase()},{dir:\"parentNode\",next:\"legend\"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],\"string\"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+\" \"]&&(!v||!v.test(t))&&(1!==p||\"object\"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute(\"id\"))?s=s.replace(re,ie):e.setAttribute(\"id\",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?\"#\"+s:\":scope\")+\" \"+xe(l[o]);c=l.join(\",\")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute(\"id\")}}}return g(t.replace($,\"$1\"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+\" \")>b.cacheLength&&delete e[r.shift()],e[t+\" \"]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement(\"fieldset\");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split(\"|\"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return\"input\"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return(\"input\"===t||\"button\"===t)&&e.type===n}}function ge(t){return function(e){return\"form\"in e?e.parentNode&&!1===e.disabled?\"label\"in e?\"label\"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:\"label\"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&\"undefined\"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||\"HTML\")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener(\"unload\",oe,!1):n.attachEvent&&n.attachEvent(\"onunload\",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement(\"div\")),\"undefined\"!=typeof e.querySelectorAll&&!e.querySelectorAll(\":scope fieldset div\").length}),d.attributes=ce(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute(\"id\")===t}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t=\"undefined\"!=typeof e.getAttributeNode&&e.getAttributeNode(\"id\");return t&&t.value===n}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return\"undefined\"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if(\"undefined\"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML=\"<a id='\"+S+\"'><\/a><select id='\"+S+\"-\\r\\\\' msallowcapture=''><option selected=''><\/option><\/select>\",e.querySelectorAll(\"[msallowcapture^='']\").length&&v.push(\"[*^$]=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\"[selected]\").length||v.push(\"\\\\[\"+M+\"*(?:value|\"+R+\")\"),e.querySelectorAll(\"[id~=\"+S+\"-]\").length||v.push(\"~=\"),(t=C.createElement(\"input\")).setAttribute(\"name\",\"\"),e.appendChild(t),e.querySelectorAll(\"[name='']\").length||v.push(\"\\\\[\"+M+\"*name\"+M+\"*=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\":checked\").length||v.push(\":checked\"),e.querySelectorAll(\"a#\"+S+\"+*\").length||v.push(\".#.+[+~]\"),e.querySelectorAll(\"\\\\\\f\"),v.push(\"[\\\\r\\\\n\\\\f]\")}),ce(function(e){e.innerHTML=\"<a href='' disabled='disabled'><\/a><select disabled='disabled'><option\/><\/select>\";var t=C.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"name\",\"D\"),e.querySelectorAll(\"[name=d]\").length&&v.push(\"name\"+M+\"*[*^$|!~]?=\"),2!==e.querySelectorAll(\":enabled\").length&&v.push(\":enabled\",\":disabled\"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(\":disabled\").length&&v.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),v.push(\",.*:\")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,\"*\"),c.call(e,\"[s!='']:x\"),s.push(\"!=\",F)}),v=v.length&&new RegExp(v.join(\"|\")),s=s.length&&new RegExp(s.join(\"|\")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+\" \"]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+\"\").replace(re,ie)},se.error=function(e){throw new Error(\"Syntax error, unrecognized expression: \"+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n=\"\",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||\"\").replace(te,ne),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||\"\":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(\")\",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+\" \"];return t||(t=new RegExp(\"(^|\"+M+\")\"+e+\"(\"+M+\"|$)\"))&&m(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||\"undefined\"!=typeof e.getAttribute&&e.getAttribute(\"class\")||\"\")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?\"!=\"===r:!r||(t+=\"\",\"=\"===r?t===i:\"!=\"===r?t!==i:\"^=\"===r?i&&0===t.indexOf(i):\"*=\"===r?i&&-1<t.indexOf(i):\"$=\"===r?i&&t.slice(-i.length)===i:\"~=\"===r?-1<(\" \"+t.replace(B,\" \")+\" \").indexOf(i):\"|=\"===r&&(t===i||t.slice(0,i.length+1)===i+\"-\"))}},CHILD:function(h,e,t,g,v){var y=\"nth\"!==h.slice(0,3),m=\"last\"!==h.slice(-4),x=\"of-type\"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?\"nextSibling\":\"previousSibling\",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l=\"only\"===h&&!u&&\"nextSibling\"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d\/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error(\"unsupported pseudo: \"+e);return a[S]?a(o):1<a.length?(t=[e,e,\"\",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,\"$1\"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||\"\")||se.error(\"unsupported lang: \"+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute(\"xml:lang\")||e.getAttribute(\"lang\"))return(t=t.toLowerCase())===n||0===t.indexOf(n+\"-\")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&\"button\"===e.type||\"button\"===t},text:function(e){var t;return\"input\"===e.nodeName.toLowerCase()&&\"text\"===e.type&&(null==(t=e.getAttribute(\"type\"))||\"text\"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r=\"\";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&\"parentNode\"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||\"*\",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[\" \"],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:\" \"===e[s-2].type?\"*\":\"\"})).replace($,\"$1\"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+\" \"];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($,\" \")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+\" \"];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l=\"0\",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG(\"*\",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l=\"function\"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&\"ID\"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split(\"\").sort(D).join(\"\")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement(\"fieldset\"))}),ce(function(e){return e.innerHTML=\"<a href='#'><\/a>\",\"#\"===e.firstChild.getAttribute(\"href\")})||fe(\"type|href|height|width\",function(e,t,n){if(!n)return e.getAttribute(t,\"type\"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML=\"<input\/>\",e.firstChild.setAttribute(\"value\",\"\"),\"\"===e.firstChild.getAttribute(\"value\")})||fe(\"value\",function(e,t,n){if(!n&&\"input\"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute(\"disabled\")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[\":\"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=\/^<([a-z][^\\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\\/?>(?:<\\\/\\1>|)$\/i;function D(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):\"string\"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=\":not(\"+e+\")\"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if(\"string\"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(D(this,e||[],!1))},not:function(e){return this.pushStack(D(this,e||[],!0))},is:function(e){return!!D(this,\"string\"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var j,q=\/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$\/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||j,\"string\"==typeof e){if(!(r=\"<\"===e[0]&&\">\"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,j=S(E);var L=\/^(?:parents|prev(?:Until|All))\/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a=\"string\"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?\"string\"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,\"parentNode\")},parentsUntil:function(e,t,n){return h(e,\"parentNode\",n)},next:function(e){return O(e,\"nextSibling\")},prev:function(e){return O(e,\"previousSibling\")},nextAll:function(e){return h(e,\"nextSibling\")},prevAll:function(e){return h(e,\"previousSibling\")},nextUntil:function(e,t,n){return h(e,\"nextSibling\",n)},prevUntil:function(e,t,n){return h(e,\"previousSibling\",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,\"template\")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return\"Until\"!==r.slice(-5)&&(t=e),t&&\"string\"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=\/[^\\x20\\t\\r\\n\\f]+\/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r=\"string\"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:\"\")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&\"string\"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t=\"\",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=\"\"),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[[\"notify\",\"progress\",S.Callbacks(\"memory\"),S.Callbacks(\"memory\"),2],[\"resolve\",\"done\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),0,\"resolved\"],[\"reject\",\"fail\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),1,\"rejected\"]],i=\"pending\",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},\"catch\":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+\"With\"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError(\"Thenable self-resolution\");t=e&&(\"object\"==typeof e||\"function\"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+\"With\"](this===s?void 0:this,arguments),this},s[t[0]+\"With\"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),\"pending\"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=\/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$\/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn(\"jQuery.Deferred exception: \"+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener(\"DOMContentLoaded\",B),C.removeEventListener(\"load\",B),S.ready()}S.fn.ready=function(e){return F.then(e)[\"catch\"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,\"complete\"===E.readyState||\"loading\"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener(\"DOMContentLoaded\",B),C.addEventListener(\"load\",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if(\"object\"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=\/^-ms-\/,z=\/-([a-z])\/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,\"ms-\").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if(\"string\"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&\"string\"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=\/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$\/,K=\/[A-Z]\/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r=\"data-\"+t.replace(K,\"-$&\").toLowerCase(),\"string\"==typeof(n=e.getAttribute(r))){try{n=\"true\"===(i=n)||\"false\"!==i&&(\"null\"===i?null:i===+i+\"\"?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,\"hasDataAttrs\"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf(\"data-\")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,\"hasDataAttrs\",!0)}return i}return\"object\"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||\"fx\")+\"queue\",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||\"fx\";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks(\"once memory\").add(function(){Y.remove(e,[t+\"queue\",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return\"string\"!=typeof t&&(n=t,t=\"fx\",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),\"fx\"===t&&\"inprogress\"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||\"fx\",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};\"string\"!=typeof e&&(t=e,e=void 0),e=e||\"fx\";while(a--)(n=Y.get(o[a],e+\"queueHooks\"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=\/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)\/.source,te=new RegExp(\"^(?:([+-])=|)(\"+ee+\")([a-z%]*)$\",\"i\"),ne=[\"Top\",\"Right\",\"Bottom\",\"Left\"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return\"none\"===(e=t||e).style.display||\"\"===e.style.display&&ie(e)&&\"none\"===S.css(e,\"display\")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,\"\")},u=s(),l=n&&n[3]||(S.cssNumber[t]?\"\":\"px\"),c=e.nodeType&&(S.cssNumber[t]||\"px\"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u\/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()\/u||.5))<=0&&(a=0),c\/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?(\"none\"===n&&(l[c]=Y.get(r,\"display\")||null,l[c]||(r.style.display=\"\")),\"\"===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,\"display\"),o.parentNode.removeChild(o),\"none\"===u&&(u=\"block\"),ue[s]=u)))):\"none\"!==n&&(l[c]=\"none\",Y.set(r,\"display\",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return\"boolean\"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=\/^(?:checkbox|radio)$\/i,de=\/<([a-z][^\\\/\\0>\\x20\\t\\r\\n\\f]*)\/i,he=\/^$|^module$|\\\/(?:java|ecma)script\/i;ce=E.createDocumentFragment().appendChild(E.createElement(\"div\")),(fe=E.createElement(\"input\")).setAttribute(\"type\",\"radio\"),fe.setAttribute(\"checked\",\"checked\"),fe.setAttribute(\"name\",\"t\"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML=\"<textarea>x<\/textarea>\",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML=\"<option><\/option>\",y.option=!!ce.lastChild;var ge={thead:[1,\"<table>\",\"<\/table>\"],col:[2,\"<table><colgroup>\",\"<\/colgroup><\/table>\"],tr:[2,\"<table><tbody>\",\"<\/tbody><\/table>\"],td:[3,\"<table><tbody><tr>\",\"<\/tr><\/tbody><\/table>\"],_default:[0,\"\",\"\"]};function ve(e,t){var n;return n=\"undefined\"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||\"*\"):\"undefined\"!=typeof e.querySelectorAll?e.querySelectorAll(t||\"*\"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],\"globalEval\",!t||Y.get(t[n],\"globalEval\"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,\"<select multiple='multiple'>\",\"<\/select>\"]);var me=\/<|&#?\\w+;\/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if(\"object\"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement(\"div\")),s=(de.exec(o)||[\"\",\"\"])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=\"\"}else p.push(t.createTextNode(o));f.textContent=\"\",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),\"script\"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||\"\")&&n.push(o)}return f}var be=\/^key\/,we=\/^(?:mouse|pointer|contextmenu|drag|drop)|click\/,Te=\/^([^.]*)(?:\\.(.+)|)\/;function Ce(){return!0}function Ee(){return!1}function Se(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==(\"focus\"===t)}function ke(e,t,n,r,i,o){var a,s;if(\"object\"==typeof t){for(s in\"string\"!=typeof n&&(r=r||n,n=void 0),t)ke(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&(\"string\"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Ee;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Ae(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,Ce)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return\"undefined\"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||\"\").match(P)||[\"\"]).length;while(l--)d=g=(s=Te.exec(e[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(\".\")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||\"\").match(P)||[\"\"]).length;while(l--)if(d=g=(s=Te.exec(t[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&(\"**\"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,\"handle events\")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,\"events\")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!(\"click\"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&(\"click\"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+\" \"]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Ae(t,\"click\",Ce),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Ae(t,\"click\"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Y.get(t,\"click\")||A(t,\"a\")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ce:Ee,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Ee,isPropagationStopped:Ee,isImmediatePropagationStopped:Ee,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ce,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ce,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ce,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,\"char\":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&be.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&we.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},S.event.addProp),S.each({focus:\"focusin\",blur:\"focusout\"},function(e,t){S.event.special[e]={setup:function(){return Ae(this,e,Se),!1},trigger:function(){return Ae(this,e),!0},delegateType:t}}),S.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return ke(this,e,t,n,r)},one:function(e,t,n,r){return ke(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+\".\"+r.namespace:r.origType,r.selector,r.handler),this;if(\"object\"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&\"function\"!=typeof t||(n=t,t=void 0),!1===n&&(n=Ee),this.each(function(){S.event.remove(this,e,n,t)})}});var Ne=\/<script|<style|<link\/i,De=\/checked\\s*(?:[^=]|=\\s*.checked.)\/i,je=\/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$\/g;function qe(e,t){return A(e,\"table\")&&A(11!==t.nodeType?t:t.firstChild,\"tr\")&&S(e).children(\"tbody\")[0]||e}function Le(e){return e.type=(null!==e.getAttribute(\"type\"))+\"\/\"+e.type,e}function He(e){return\"true\/\"===(e.type||\"\").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute(\"type\"),e}function Oe(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,\"handle events\"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function Pe(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&\"string\"==typeof d&&!y.checkClone&&De.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Pe(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,\"script\"),Le)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,\"script\"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,He),c=0;c<s;c++)u=a[c],he.test(u.type||\"\")&&!Y.access(u,\"globalEval\")&&S.contains(l,u)&&(u.src&&\"module\"!==(u.type||\"\").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute(\"nonce\")},l):b(u.textContent.replace(je,\"\"),u,l))}return n}function Re(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,\"script\")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,\"input\"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:\"input\"!==l&&\"textarea\"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Oe(o[r],a[r]);else Oe(e,c);return 0<(a=ve(c,\"script\")).length&&ye(a,!f&&ve(e,\"script\")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Re(this,e,!0)},remove:function(e){return Re(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Pe(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||qe(this,e).appendChild(e)})},prepend:function(){return Pe(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=qe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent=\"\");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if(\"string\"==typeof e&&!Ne.test(e)&&!ge[(de.exec(e)||[\"\",\"\"])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Pe(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Me=new RegExp(\"^(\"+ee+\")(?!px)[a-z%]+$\",\"i\"),Ie=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},We=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Fe=new RegExp(ne.join(\"|\"),\"i\");function Be(e,t,n){var r,i,o,a,s=e.style;return(n=n||Ie(e))&&(\"\"!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Me.test(a)&&Fe.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+\"\":a}function $e(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText=\"position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0\",l.style.cssText=\"position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%\",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n=\"1%\"!==e.top,s=12===t(e.marginLeft),l.style.right=\"60%\",o=36===t(e.right),r=36===t(e.width),l.style.position=\"absolute\",i=12===t(l.offsetWidth\/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement(\"div\"),l=E.createElement(\"div\");l.style&&(l.style.backgroundClip=\"content-box\",l.cloneNode(!0).style.backgroundClip=\"\",y.clearCloneStyle=\"content-box\"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement(\"table\"),t=E.createElement(\"tr\"),n=E.createElement(\"div\"),e.style.cssText=\"position:absolute;left:-11111px\",t.style.height=\"1px\",n.style.height=\"9px\",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=3<parseInt(r.height),re.removeChild(e)),a}}))}();var _e=[\"Webkit\",\"Moz\",\"ms\"],ze=E.createElement(\"div\").style,Ue={};function Xe(e){var t=S.cssProps[e]||Ue[e];return t||(e in ze?e:Ue[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=_e.length;while(n--)if((e=_e[n]+t)in ze)return e}(e)||e)}var Ve=\/^(none|table(?!-c[ea]).+)\/,Ge=\/^--\/,Ye={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Qe={letterSpacing:\"0\",fontWeight:\"400\"};function Je(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||\"px\"):t}function Ke(e,t,n,r,i,o){var a=\"width\"===t?1:0,s=0,u=0;if(n===(r?\"border\":\"content\"))return 0;for(;a<4;a+=2)\"margin\"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?(\"content\"===n&&(u-=S.css(e,\"padding\"+ne[a],!0,i)),\"margin\"!==n&&(u-=S.css(e,\"border\"+ne[a]+\"Width\",!0,i))):(u+=S.css(e,\"padding\"+ne[a],!0,i),\"padding\"!==n?u+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i):s+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e[\"offset\"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Ze(e,t,n){var r=Ie(e),i=(!y.boxSizingReliable()||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,r),o=i,a=Be(e,t,r),s=\"offset\"+t[0].toUpperCase()+t.slice(1);if(Me.test(a)){if(!n)return a;a=\"auto\"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,\"tr\")||\"auto\"===a||!parseFloat(a)&&\"inline\"===S.css(e,\"display\",!1,r))&&e.getClientRects().length&&(i=\"border-box\"===S.css(e,\"boxSizing\",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Ke(e,t,n||(i?\"border\":\"content\"),o,r,a)+\"px\"}function et(e,t,n,r,i){return new et.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Be(e,\"opacity\");return\"\"===n?\"1\":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Ge.test(t),l=e.style;if(u||(t=Xe(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&\"get\"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];\"string\"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o=\"number\"),null!=n&&n==n&&(\"number\"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?\"\":\"px\")),y.clearCloneStyle||\"\"!==n||0!==t.indexOf(\"background\")||(l[t]=\"inherit\"),a&&\"set\"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Ge.test(t)||(t=Xe(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&\"get\"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=Be(e,t,r)),\"normal\"===i&&t in Qe&&(i=Qe[t]),\"\"===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each([\"height\",\"width\"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ve.test(S.css(e,\"display\"))||e.getClientRects().length&&e.getBoundingClientRect().width?Ze(e,u,n):We(e,Ye,function(){return Ze(e,u,n)})},set:function(e,t,n){var r,i=Ie(e),o=!y.scrollboxSize()&&\"absolute\"===i.position,a=(o||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,i),s=n?Ke(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e[\"offset\"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Ke(e,u,\"border\",!1,i)-.5)),s&&(r=te.exec(t))&&\"px\"!==(r[3]||\"px\")&&(e.style[u]=t,t=S.css(e,u)),Je(0,t,s)}}}),S.cssHooks.marginLeft=$e(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(Be(e,\"marginLeft\"))||e.getBoundingClientRect().left-We(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+\"px\"}),S.each({margin:\"\",padding:\"\",border:\"Width\"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r=\"string\"==typeof e?e.split(\" \"):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},\"margin\"!==i&&(S.cssHooks[i+o].set=Je)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Ie(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=et).prototype={constructor:et,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?\"\":\"px\")},cur:function(){var e=et.propHooks[this.prop];return e&&e.get?e.get(this):et.propHooks._default.get(this)},run:function(e){var t,n=et.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):et.propHooks._default.set(this),this}}).init.prototype=et.prototype,(et.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,\"\"))&&\"auto\"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[Xe(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=et.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)\/2},_default:\"swing\"},S.fx=et.prototype.init,S.fx.step={};var tt,nt,rt,it,ot=\/^(?:toggle|show|hide)$\/,at=\/queueHooks$\/;function st(){nt&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(st):C.setTimeout(st,S.fx.interval),S.fx.tick())}function ut(){return C.setTimeout(function(){tt=void 0}),tt=Date.now()}function lt(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i[\"margin\"+(n=ne[r])]=i[\"padding\"+n]=e;return t&&(i.opacity=i.width=e),i}function ct(e,t,n){for(var r,i=(ft.tweeners[t]||[]).concat(ft.tweeners[\"*\"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function ft(o,e,t){var n,a,r=0,i=ft.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=tt||ut(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t\/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:tt||ut(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&\"expand\"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=ft.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ct,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(ft,{tweeners:{\"*\":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=[\"*\"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],ft.tweeners[n]=ft.tweeners[n]||[],ft.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f=\"width\"in t||\"height\"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,\"fxshow\");for(r in n.queue||(null==(a=S._queueHooks(e,\"fx\")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,\"fx\").length||a.empty.fire()})})),t)if(i=t[r],ot.test(i)){if(delete t[r],o=o||\"toggle\"===i,i===(g?\"hide\":\"show\")){if(\"show\"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,\"display\")),\"none\"===(c=S.css(e,\"display\"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,\"display\"),le([e]))),(\"inline\"===c||\"inline-block\"===c&&null!=l)&&\"none\"===S.css(e,\"float\")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l=\"none\"===c?\"\":c)),h.display=\"inline-block\")),n.overflow&&(h.overflow=\"hidden\",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?\"hidden\"in v&&(g=v.hidden):v=Y.access(e,\"fxshow\",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,\"fxshow\"),d)S.style(e,r,d[r])})),u=ct(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?ft.prefilters.unshift(e):ft.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&\"object\"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:\"number\"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue=\"fx\"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css(\"opacity\",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=ft(this,S.extend({},t),o);(i||Y.get(this,\"finish\"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return\"string\"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||\"fx\",[]),this.each(function(){var e=!0,t=null!=i&&i+\"queueHooks\",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&at.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||\"fx\"),this.each(function(){var e,t=Y.get(this),n=t[a+\"queue\"],r=t[a+\"queueHooks\"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each([\"toggle\",\"show\",\"hide\"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||\"boolean\"==typeof e?i.apply(this,arguments):this.animate(lt(r,!0),e,t,n)}}),S.each({slideDown:lt(\"show\"),slideUp:lt(\"hide\"),slideToggle:lt(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(tt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),tt=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){nt||(nt=!0,st())},S.fx.stop=function(){nt=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||\"fx\",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},rt=E.createElement(\"input\"),it=E.createElement(\"select\").appendChild(E.createElement(\"option\")),rt.type=\"checkbox\",y.checkOn=\"\"!==rt.value,y.optSelected=it.selected,(rt=E.createElement(\"input\")).value=\"t\",rt.type=\"radio\",y.radioValue=\"t\"===rt.value;var pt,dt=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return\"undefined\"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?pt:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+\"\"),n):i&&\"get\"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&\"radio\"===t&&A(e,\"input\")){var n=e.value;return e.setAttribute(\"type\",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),pt={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(\/\\w+\/g),function(e,t){var a=dt[t]||S.find.attr;dt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=dt[o],dt[o]=r,r=null!=a(e,t,n)?o:null,dt[o]=i),r}});var ht=\/^(?:input|select|textarea|button)$\/i,gt=\/^(?:a|area)$\/i;function vt(e){return(e.match(P)||[]).join(\" \")}function yt(e){return e.getAttribute&&e.getAttribute(\"class\")||\"\"}function mt(e){return Array.isArray(e)?e:\"string\"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&\"get\"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,\"tabindex\");return t?parseInt(t,10):ht.test(e.nodeName)||gt.test(e.nodeName)&&e.href?0:-1}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,yt(this)))});if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&\" \"+vt(i)+\" \"){a=0;while(o=e[a++])r.indexOf(\" \"+o+\" \")<0&&(r+=o+\" \");i!==(s=vt(r))&&n.setAttribute(\"class\",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,yt(this)))});if(!arguments.length)return this.attr(\"class\",\"\");if((e=mt(t)).length)while(n=this[u++])if(i=yt(n),r=1===n.nodeType&&\" \"+vt(i)+\" \"){a=0;while(o=e[a++])while(-1<r.indexOf(\" \"+o+\" \"))r=r.replace(\" \"+o+\" \",\" \");i!==(s=vt(r))&&n.setAttribute(\"class\",s)}return this},toggleClass:function(i,t){var o=typeof i,a=\"string\"===o||Array.isArray(i);return\"boolean\"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,yt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=mt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&\"boolean\"!==o||((e=yt(this))&&Y.set(this,\"__className__\",e),this.setAttribute&&this.setAttribute(\"class\",e||!1===i?\"\":Y.get(this,\"__className__\")||\"\"))})},hasClass:function(e){var t,n,r=0;t=\" \"+e+\" \";while(n=this[r++])if(1===n.nodeType&&-1<(\" \"+vt(yt(n))+\" \").indexOf(t))return!0;return!1}});var xt=\/\\r\/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t=\"\":\"number\"==typeof t?t+=\"\":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?\"\":e+\"\"})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&\"set\"in r&&void 0!==r.set(this,t,\"value\")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&\"get\"in r&&void 0!==(e=r.get(t,\"value\"))?e:\"string\"==typeof(e=t.value)?e.replace(xt,\"\"):null==e?\"\":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,\"value\");return null!=t?t:vt(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a=\"select-one\"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,\"optgroup\"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each([\"radio\",\"checkbox\"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute(\"value\")?\"on\":e.value})}),y.focusin=\"onfocusin\"in C;var bt=\/^(?:focusinfocus|focusoutblur)$\/,wt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,\"type\")?e.type:e,h=v.call(e,\"namespace\")?e.namespace.split(\".\"):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!bt.test(d+S.event.triggered)&&(-1<d.indexOf(\".\")&&(d=(h=d.split(\".\")).shift(),h.sort()),u=d.indexOf(\":\")<0&&\"on\"+d,(e=e[S.expando]?e:new S.Event(d,\"object\"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join(\".\"),e.rnamespace=e.namespace?new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,bt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,\"events\")||Object.create(null))[e.type]&&Y.get(o,\"handle\"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,wt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,wt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:\"focusin\",blur:\"focusout\"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var Tt=C.location,Ct={guid:Date.now()},Et=\/\\?\/;S.parseXML=function(e){var t;if(!e||\"string\"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,\"text\/xml\")}catch(e){t=void 0}return t&&!t.getElementsByTagName(\"parsererror\").length||S.error(\"Invalid XML: \"+e),t};var St=\/\\[\\]$\/,kt=\/\\r?\\n\/g,At=\/^(?:submit|button|image|reset|file)$\/i,Nt=\/^(?:input|select|textarea|keygen)\/i;function Dt(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||St.test(n)?i(n,t):Dt(n+\"[\"+(\"object\"==typeof t&&null!=t?e:\"\")+\"]\",t,r,i)});else if(r||\"object\"!==w(e))i(n,e);else for(t in e)Dt(n+\"[\"+t+\"]\",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+\"=\"+encodeURIComponent(null==n?\"\":n)};if(null==e)return\"\";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)Dt(n,e[n],t,i);return r.join(\"&\")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,\"elements\");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(\":disabled\")&&Nt.test(this.nodeName)&&!At.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(kt,\"\\r\\n\")}}):{name:t.name,value:n.replace(kt,\"\\r\\n\")}}).get()}});var jt=\/%20\/g,qt=\/#.*$\/,Lt=\/([?&])_=[^&]*\/,Ht=\/^(.*?):[ \\t]*([^\\r\\n]*)$\/gm,Ot=\/^(?:GET|HEAD)$\/,Pt=\/^\\\/\\\/\/,Rt={},Mt={},It=\"*\/\".concat(\"*\"),Wt=E.createElement(\"a\");function Ft(o){return function(e,t){\"string\"!=typeof e&&(t=e,e=\"*\");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])\"+\"===n[0]?(n=n.slice(1)||\"*\",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Bt(t,i,o,a){var s={},u=t===Mt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return\"string\"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s[\"*\"]&&l(\"*\")}function $t(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Wt.href=Tt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Tt.href,type:\"GET\",isLocal:\/^(?:about|app|app-storage|.+-extension|file|res|widget):$\/.test(Tt.protocol),global:!0,processData:!0,async:!0,contentType:\"application\/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":It,text:\"text\/plain\",html:\"text\/html\",xml:\"application\/xml, text\/xml\",json:\"application\/json, text\/javascript\"},contents:{xml:\/\\bxml\\b\/,html:\/\\bhtml\/,json:\/\\bjson\\b\/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":JSON.parse,\"text xml\":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?$t($t(e,S.ajaxSettings),t):$t(S.ajaxSettings,e)},ajaxPrefilter:Ft(Rt),ajaxTransport:Ft(Mt),ajax:function(e,t){\"object\"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks(\"once memory\"),w=v.statusCode||{},a={},s={},u=\"canceled\",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Ht.exec(p))n[t[1].toLowerCase()+\" \"]=(n[t[1].toLowerCase()+\" \"]||[]).concat(t[2])}t=n[e.toLowerCase()+\" \"]}return null==t?null:t.join(\", \")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Tt.href)+\"\").replace(Pt,Tt.protocol+\"\/\/\"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||\"*\").toLowerCase().match(P)||[\"\"],null==v.crossDomain){r=E.createElement(\"a\");try{r.href=v.url,r.href=r.href,v.crossDomain=Wt.protocol+\"\/\/\"+Wt.host!=r.protocol+\"\/\/\"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&\"string\"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Bt(Rt,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger(\"ajaxStart\"),v.type=v.type.toUpperCase(),v.hasContent=!Ot.test(v.type),f=v.url.replace(qt,\"\"),v.hasContent?v.data&&v.processData&&0===(v.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&(v.data=v.data.replace(jt,\"+\")):(o=v.url.slice(f.length),v.data&&(v.processData||\"string\"==typeof v.data)&&(f+=(Et.test(f)?\"&\":\"?\")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Lt,\"$1\"),o=(Et.test(f)?\"&\":\"?\")+\"_=\"+Ct.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader(\"If-Modified-Since\",S.lastModified[f]),S.etag[f]&&T.setRequestHeader(\"If-None-Match\",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader(\"Content-Type\",v.contentType),T.setRequestHeader(\"Accept\",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+(\"*\"!==v.dataTypes[0]?\", \"+It+\"; q=0.01\":\"\"):v.accepts[\"*\"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u=\"abort\",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Bt(Mt,v,t,T)){if(T.readyState=1,g&&m.trigger(\"ajaxSend\",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort(\"timeout\")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,\"No Transport\");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||\"\",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while(\"*\"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader(\"Content-Type\"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+\" \"+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray(\"script\",v.dataTypes)&&(v.converters[\"text script\"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if(\"*\"===o)o=u;else if(\"*\"!==u&&u!==o){if(!(a=l[u+\" \"+o]||l[\"* \"+o]))for(i in l)if((s=i.split(\" \"))[1]===o&&(a=l[u+\" \"+s[0]]||l[\"* \"+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e[\"throws\"])t=a(t);else try{t=a(t)}catch(e){return{state:\"parsererror\",error:a?e:\"No conversion from \"+u+\" to \"+o}}}return{state:\"success\",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader(\"Last-Modified\"))&&(S.lastModified[f]=u),(u=T.getResponseHeader(\"etag\"))&&(S.etag[f]=u)),204===e||\"HEAD\"===v.type?l=\"nocontent\":304===e?l=\"notmodified\":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l=\"error\",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+\"\",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?\"ajaxSuccess\":\"ajaxError\",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger(\"ajaxComplete\",[T,v]),--S.active||S.event.trigger(\"ajaxStop\")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,\"json\")},getScript:function(e,t){return S.get(e,void 0,t,\"script\")}}),S.each([\"get\",\"post\"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)\"content-type\"===t.toLowerCase()&&(e.contentType=e.headers[t]||\"\")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:\"GET\",dataType:\"script\",cache:!0,async:!1,global:!1,converters:{\"text script\":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not(\"body\").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var _t={0:200,1223:204},zt=S.ajaxSettings.xhr();y.cors=!!zt&&\"withCredentials\"in zt,y.ajax=zt=!!zt,S.ajaxTransport(function(i){var o,a;if(y.cors||zt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e[\"X-Requested-With\"]||(e[\"X-Requested-With\"]=\"XMLHttpRequest\"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,\"abort\"===e?r.abort():\"error\"===e?\"number\"!=typeof r.status?t(0,\"error\"):t(r.status,r.statusText):t(_t[r.status]||r.status,r.statusText,\"text\"!==(r.responseType||\"text\")||\"string\"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o(\"error\"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o(\"abort\");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:\"text\/javascript, application\/javascript, application\/ecmascript, application\/x-ecmascript\"},contents:{script:\/\\b(?:java|ecma)script\\b\/},converters:{\"text script\":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter(\"script\",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type=\"GET\")}),S.ajaxTransport(\"script\",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S(\"<script>\").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on(\"load error\",i=function(e){r.remove(),i=null,e&&t(\"error\"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Ut,Xt=[],Vt=\/(=)\\?(?=&|$)|\\?\\?\/;S.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var e=Xt.pop()||S.expando+\"_\"+Ct.guid++;return this[e]=!0,e}}),S.ajaxPrefilter(\"json jsonp\",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Vt.test(e.url)?\"url\":\"string\"==typeof e.data&&0===(e.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&Vt.test(e.data)&&\"data\");if(a||\"jsonp\"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Vt,\"$1\"+r):!1!==e.jsonp&&(e.url+=(Et.test(e.url)?\"&\":\"?\")+e.jsonp+\"=\"+r),e.converters[\"script json\"]=function(){return o||S.error(r+\" was not called\"),o[0]},e.dataTypes[0]=\"json\",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Xt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),\"script\"}),y.createHTMLDocument=((Ut=E.implementation.createHTMLDocument(\"\").body).innerHTML=\"<form><\/form><form><\/form>\",2===Ut.childNodes.length),S.parseHTML=function(e,t,n){return\"string\"!=typeof e?[]:(\"boolean\"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument(\"\")).createElement(\"base\")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(\" \");return-1<s&&(r=vt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&\"object\"==typeof t&&(i=\"POST\"),0<a.length&&S.ajax({url:e,type:i||\"GET\",dataType:\"html\",data:t}).done(function(e){o=arguments,a.html(r?S(\"<div>\").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,\"position\"),c=S(e),f={};\"static\"===l&&(e.style.position=\"relative\"),s=c.offset(),o=S.css(e,\"top\"),u=S.css(e,\"left\"),(\"absolute\"===l||\"fixed\"===l)&&-1<(o+u).indexOf(\"auto\")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),\"using\"in t?t.using.call(e,f):(\"number\"==typeof f.top&&(f.top+=\"px\"),\"number\"==typeof f.left&&(f.left+=\"px\"),c.css(f))}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if(\"fixed\"===S.css(r,\"position\"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&\"static\"===S.css(e,\"position\"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,\"borderTopWidth\",!0),i.left+=S.css(e,\"borderLeftWidth\",!0))}return{top:t.top-i.top-S.css(r,\"marginTop\",!0),left:t.left-i.left-S.css(r,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&\"static\"===S.css(e,\"position\"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(t,i){var o=\"pageYOffset\"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each([\"top\",\"left\"],function(e,n){S.cssHooks[n]=$e(y.pixelPosition,function(e,t){if(t)return t=Be(e,n),Me.test(t)?S(e).position()[n]+\"px\":t})}),S.each({Height:\"height\",Width:\"width\"},function(a,s){S.each({padding:\"inner\"+a,content:s,\"\":\"outer\"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||\"boolean\"!=typeof e),i=r||(!0===e||!0===t?\"margin\":\"border\");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf(\"outer\")?e[\"inner\"+a]:e.document.documentElement[\"client\"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body[\"scroll\"+a],r[\"scroll\"+a],e.body[\"offset\"+a],r[\"offset\"+a],r[\"client\"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,\"**\"):this.off(t,e||\"**\",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each(\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\".split(\" \"),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Gt=\/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$\/g;S.proxy=function(e,t){var n,r,i;if(\"string\"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return(\"number\"===t||\"string\"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?\"\":(e+\"\").replace(Gt,\"\")},\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return S});var Yt=C.jQuery,Qt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Qt),e&&C.jQuery===S&&(C.jQuery=Yt),S},\"undefined\"==typeof e&&(C.jQuery=C.$=S),S});\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-3.5.1.min.js","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * jQuery JavaScript Library v3.5.1\n+ * jQuery JavaScript Library v3.6.0\n@@ -8,1 +8,1 @@\n- * Copyright JS Foundation and other contributors\n+ * Copyright OpenJS Foundation and other contributors\n@@ -12,1 +12,1 @@\n- * Date: 2020-05-04T22:49Z\n+ * Date: 2021-03-02T17:08Z\n@@ -79,6 +79,10 @@\n-      \/\/ Support: Chrome <=57, Firefox <=52\n-      \/\/ In some browsers, typeof returns \"function\" for HTML <object> elements\n-      \/\/ (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n-      \/\/ We don't want to classify *any* DOM node as a function.\n-      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n-  };\n+\t\t\/\/ Support: Chrome <=57, Firefox <=52\n+\t\t\/\/ In some browsers, typeof returns \"function\" for HTML <object> elements\n+\t\t\/\/ (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n+\t\t\/\/ We don't want to classify *any* DOM node as a function.\n+\t\t\/\/ Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n+\t\t\/\/ Plus for old WebKit, typeof returns \"function\" for HTML collections\n+\t\t\/\/ (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n+\t\treturn typeof obj === \"function\" && typeof obj.nodeType !== \"number\" &&\n+\t\t\ttypeof obj.item !== \"function\";\n+\t};\n@@ -150,1 +154,1 @@\n-\tversion = \"3.5.1\",\n+\tversion = \"3.6.0\",\n@@ -404,1 +408,1 @@\n-\t\t\t\t\t[ arr ] : arr\n+\t\t\t\t\t\t[ arr ] : arr\n@@ -499,3 +503,3 @@\n-function( _i, name ) {\n-\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n-} );\n+\tfunction( _i, name ) {\n+\t\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n+\t} );\n@@ -521,1 +525,1 @@\n- * Sizzle CSS Selector Engine v2.3.5\n+ * Sizzle CSS Selector Engine v2.3.6\n@@ -528,1 +532,1 @@\n- * Date: 2020-03-14\n+ * Date: 2021-02-16\n@@ -1111,2 +1115,2 @@\n-\tvar namespace = elem.namespaceURI,\n-\t\tdocElem = ( elem.ownerDocument || elem ).documentElement;\n+\tvar namespace = elem && elem.namespaceURI,\n+\t\tdocElem = elem && ( elem.ownerDocument || elem ).documentElement;\n@@ -3027,1 +3031,1 @@\n-  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n+\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n@@ -3029,1 +3033,1 @@\n-};\n+}\n@@ -4000,2 +4004,2 @@\n-\t\t\t\/\/ the master Deferred\n-\t\t\tmaster = jQuery.Deferred(),\n+\t\t\t\/\/ the primary Deferred\n+\t\t\tprimary = jQuery.Deferred(),\n@@ -4009,1 +4013,1 @@\n-\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n+\t\t\t\t\t\tprimary.resolveWith( resolveContexts, resolveValues );\n@@ -4016,1 +4020,1 @@\n-\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n+\t\t\tadoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,\n@@ -4020,1 +4024,1 @@\n-\t\t\tif ( master.state() === \"pending\" ||\n+\t\t\tif ( primary.state() === \"pending\" ||\n@@ -4023,1 +4027,1 @@\n-\t\t\t\treturn master.then();\n+\t\t\t\treturn primary.then();\n@@ -4029,1 +4033,1 @@\n-\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n+\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );\n@@ -4032,1 +4036,1 @@\n-\t\treturn master.promise();\n+\t\treturn primary.promise();\n@@ -4183,2 +4187,2 @@\n-\t\t\t\t\tvalue :\n-\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n+\t\t\t\t\t\tvalue :\n+\t\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n@@ -5092,4 +5096,1 @@\n-var\n-\trkeyEvent = \/^key\/,\n-\trmouseEvent = \/^(?:mouse|pointer|contextmenu|drag|drop)|click\/,\n-\trtypenamespace = \/^([^.]*)(?:\\.(.+)|)\/;\n+var rtypenamespace = \/^([^.]*)(?:\\.(.+)|)\/;\n@@ -5390,2 +5391,2 @@\n-\t\t\t\t\tdataPriv.get( this, \"events\" ) || Object.create( null )\n-\t\t\t\t)[ event.type ] || [],\n+\t\t\t\tdataPriv.get( this, \"events\" ) || Object.create( null )\n+\t\t\t)[ event.type ] || [],\n@@ -5515,1 +5516,1 @@\n-\t\t\t\t\t\t\treturn hook( this.originalEvent );\n+\t\t\t\t\t\treturn hook( this.originalEvent );\n@@ -5520,1 +5521,1 @@\n-\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n+\t\t\t\t\t\treturn this.originalEvent[ name ];\n@@ -5659,1 +5660,7 @@\n-\t\t\t\t\t\treturn result.value;\n+\n+\t\t\t\t\t\t\/\/ Support: Chrome 86+\n+\t\t\t\t\t\t\/\/ In Chrome, if an element having a focusout handler is blurred by\n+\t\t\t\t\t\t\/\/ clicking outside of it, it invokes the handler synchronously. If\n+\t\t\t\t\t\t\/\/ that handler calls `.remove()` on the element, the data is cleared,\n+\t\t\t\t\t\t\/\/ leaving `result` undefined. We need to guard against this.\n+\t\t\t\t\t\treturn result && result.value;\n@@ -5824,28 +5831,1 @@\n-\n-\twhich: function( event ) {\n-\t\tvar button = event.button;\n-\n-\t\t\/\/ Add which for key events\n-\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n-\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n-\t\t}\n-\n-\t\t\/\/ Add which for click: 1 === left; 2 === middle; 3 === right\n-\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n-\t\t\tif ( button & 1 ) {\n-\t\t\t\treturn 1;\n-\t\t\t}\n-\n-\t\t\tif ( button & 2 ) {\n-\t\t\t\treturn 3;\n-\t\t\t}\n-\n-\t\t\tif ( button & 4 ) {\n-\t\t\t\treturn 2;\n-\t\t\t}\n-\n-\t\t\treturn 0;\n-\t\t}\n-\n-\t\treturn event.which;\n-\t}\n+\twhich: true\n@@ -5877,0 +5857,6 @@\n+\t\t\/\/ Suppress native focus or blur as it's already being fired\n+\t\t\/\/ in leverageNative.\n+\t\t_default: function() {\n+\t\t\treturn true;\n+\t\t},\n+\n@@ -6544,0 +6530,4 @@\n+\t\t\/\/\n+\t\t\/\/ Support: Firefox 70+\n+\t\t\/\/ Only Firefox includes border widths\n+\t\t\/\/ in computed dimensions. (gh-4529)\n@@ -6551,1 +6541,6 @@\n-\t\t\t\ttable.style.cssText = \"position:absolute;left:-11111px\";\n+\t\t\t\ttable.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n+\t\t\t\ttr.style.cssText = \"border:1px solid\";\n+\n+\t\t\t\t\/\/ Support: Chrome 86+\n+\t\t\t\t\/\/ Height set through cssText does not get applied.\n+\t\t\t\t\/\/ Computed height then comes back as 0.\n@@ -6555,0 +6550,8 @@\n+\t\t\t\t\/\/ Support: Android 8 Chrome 86+\n+\t\t\t\t\/\/ In our bodyBackground.html iframe,\n+\t\t\t\t\/\/ display for all div elements is set to \"inline\",\n+\t\t\t\t\/\/ which causes a problem only in Android 8 Chrome 86.\n+\t\t\t\t\/\/ Ensuring the div is display: block\n+\t\t\t\t\/\/ gets around this issue.\n+\t\t\t\ttrChild.style.display = \"block\";\n+\n@@ -6561,1 +6564,3 @@\n-\t\t\t\treliableTrDimensionsVal = parseInt( trStyle.height ) > 3;\n+\t\t\t\treliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +\n+\t\t\t\t\tparseInt( trStyle.borderTopWidth, 10 ) +\n+\t\t\t\t\tparseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;\n@@ -7025,4 +7030,4 @@\n-\t\t\t\t\t\tswap( elem, cssShow, function() {\n-\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n-\t\t\t\t\t\t} ) :\n-\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n+\t\t\t\t\tswap( elem, cssShow, function() {\n+\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n+\t\t\t\t\t} ) :\n+\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n@@ -7087,1 +7092,1 @@\n-\t\t\t\t) + \"px\";\n+\t\t\t) + \"px\";\n@@ -7226,1 +7231,1 @@\n-\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n+\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n@@ -7471,1 +7476,1 @@\n-\t\t\t\/* eslint-enable no-loop-func *\/\n+\t\t\t\t\/* eslint-enable no-loop-func *\/\n@@ -7591,1 +7596,1 @@\n-\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n+\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n@@ -7764,1 +7769,2 @@\n-\t\t\tdoAnimation.finish = doAnimation;\n+\n+\t\tdoAnimation.finish = doAnimation;\n@@ -8404,2 +8410,2 @@\n-\t\t\t\t\t\t\"\" :\n-\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n+\t\t\t\t\t\t\t\"\" :\n+\t\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n@@ -8420,1 +8426,1 @@\n-\t\t\t\t\treturn true;\n+\t\t\t\treturn true;\n@@ -8710,3 +8716,1 @@\n-\t\t\thandle = (\n-\t\t\t\t\tdataPriv.get( cur, \"events\" ) || Object.create( null )\n-\t\t\t\t)[ event.type ] &&\n+\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || Object.create( null ) )[ event.type ] &&\n@@ -8859,1 +8863,1 @@\n-\tvar xml;\n+\tvar xml, parserErrorElem;\n@@ -8868,3 +8872,1 @@\n-\t} catch ( e ) {\n-\t\txml = undefined;\n-\t}\n+\t} catch ( e ) {}\n@@ -8872,2 +8874,9 @@\n-\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n-\t\tjQuery.error( \"Invalid XML: \" + data );\n+\tparserErrorElem = xml && xml.getElementsByTagName( \"parsererror\" )[ 0 ];\n+\tif ( !xml || parserErrorElem ) {\n+\t\tjQuery.error( \"Invalid XML: \" + (\n+\t\t\tparserErrorElem ?\n+\t\t\t\tjQuery.map( parserErrorElem.childNodes, function( el ) {\n+\t\t\t\t\treturn el.textContent;\n+\t\t\t\t} ).join( \"\\n\" ) :\n+\t\t\t\tdata\n+\t\t) );\n@@ -8974,2 +8983,1 @@\n-\t\t} )\n-\t\t.filter( function() {\n+\t\t} ).filter( function() {\n@@ -8982,2 +8990,1 @@\n-\t\t} )\n-\t\t.map( function( _i, elem ) {\n+\t\t} ).map( function( _i, elem ) {\n@@ -9036,1 +9043,2 @@\n-\toriginAnchor.href = location.href;\n+\n+originAnchor.href = location.href;\n@@ -9417,2 +9425,2 @@\n-\t\t\t\t\tjQuery( callbackContext ) :\n-\t\t\t\t\tjQuery.event,\n+\t\t\t\tjQuery( callbackContext ) :\n+\t\t\t\tjQuery.event,\n@@ -9730,2 +9738,4 @@\n-\t\t\t\/\/ Use a noop converter for missing script\n-\t\t\tif ( !isSuccess && jQuery.inArray( \"script\", s.dataTypes ) > -1 ) {\n+\t\t\t\/\/ Use a noop converter for missing script but not if jsonp\n+\t\t\tif ( !isSuccess &&\n+\t\t\t\tjQuery.inArray( \"script\", s.dataTypes ) > -1 &&\n+\t\t\t\tjQuery.inArray( \"json\", s.dataTypes ) < 0 ) {\n@@ -10469,6 +10479,0 @@\n-\t\t\tif ( typeof props.top === \"number\" ) {\n-\t\t\t\tprops.top += \"px\";\n-\t\t\t}\n-\t\t\tif ( typeof props.left === \"number\" ) {\n-\t\t\t\tprops.left += \"px\";\n-\t\t\t}\n@@ -10643,2 +10647,5 @@\n-\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n-\t\tfunction( defaultExtra, funcName ) {\n+\tjQuery.each( {\n+\t\tpadding: \"inner\" + name,\n+\t\tcontent: type,\n+\t\t\"\": \"outer\" + name\n+\t}, function( defaultExtra, funcName ) {\n@@ -10729,1 +10736,2 @@\n-jQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n+jQuery.each(\n+\t( \"blur focus focusin focusout resize scroll click dblclick \" +\n@@ -10740,1 +10748,2 @@\n-\t} );\n+\t}\n+);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-3.6.0.js","additions":118,"deletions":109,"binary":false,"changes":227,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-3.5.1.js","status":"renamed"},{"patch":"@@ -0,0 +1,2 @@\n+\/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org\/license *\/\n+!function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.0\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for(\"boolean\"==typeof a&&(l=a,a=arguments[s]||{},s++),\"object\"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],\"__proto__\"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:\"jQuery\"+(f+Math.random()).replace(\/\\D\/g,\"\"),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||\"[object Object]\"!==o.call(e))&&(!(t=r(e))||\"function\"==typeof(n=v.call(t,\"constructor\")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,\"string\"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),\"function\"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(e,t){n[\"[object \"+t+\"]\"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S=\"sizzle\"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),j=function(e,t){return e===t&&(l=!0),0},D={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",M=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",I=\"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",W=\"\\\\[\"+M+\"*(\"+I+\")(?:\"+M+\"*([*^$|!~]?=)\"+M+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+I+\"))|)\"+M+\"*\\\\]\",F=\":(\"+I+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+W+\")*)|.*)\\\\)|)\",B=new RegExp(M+\"+\",\"g\"),$=new RegExp(\"^\"+M+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+M+\"+$\",\"g\"),_=new RegExp(\"^\"+M+\"*,\"+M+\"*\"),z=new RegExp(\"^\"+M+\"*([>+~]|\"+M+\")\"+M+\"*\"),U=new RegExp(M+\"|>\"),X=new RegExp(F),V=new RegExp(\"^\"+I+\"$\"),G={ID:new RegExp(\"^#(\"+I+\")\"),CLASS:new RegExp(\"^\\\\.(\"+I+\")\"),TAG:new RegExp(\"^(\"+I+\"|[*])\"),ATTR:new RegExp(\"^\"+W),PSEUDO:new RegExp(\"^\"+F),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+M+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+M+\"*(?:([+-]|)\"+M+\"*(\\\\d+)|))\"+M+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+R+\")$\",\"i\"),needsContext:new RegExp(\"^\"+M+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+M+\"*((?:-\\\\d)?\\\\d*)\"+M+\"*\\\\)|)(?=[^-]|$)\",\"i\")},Y=\/HTML$\/i,Q=\/^(?:input|select|textarea|button)$\/i,J=\/^h\\d$\/i,K=\/^[^{]+\\{\\s*\\[native \\w\/,Z=\/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$\/,ee=\/[+~]\/,te=new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\"+M+\"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\",\"g\"),ne=function(e,t){var n=\"0x\"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=\/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]\/g,ie=function(e,t){return t?\"\\0\"===e?\"\\ufffd\":e.slice(0,-1)+\"\\\\\"+e.charCodeAt(e.length-1).toString(16)+\" \":\"\\\\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&\"fieldset\"===e.nodeName.toLowerCase()},{dir:\"parentNode\",next:\"legend\"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],\"string\"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+\" \"]&&(!v||!v.test(t))&&(1!==p||\"object\"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute(\"id\"))?s=s.replace(re,ie):e.setAttribute(\"id\",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?\"#\"+s:\":scope\")+\" \"+xe(l[o]);c=l.join(\",\")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute(\"id\")}}}return g(t.replace($,\"$1\"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+\" \")>b.cacheLength&&delete e[r.shift()],e[t+\" \"]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement(\"fieldset\");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split(\"|\"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return\"input\"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return(\"input\"===t||\"button\"===t)&&e.type===n}}function ge(t){return function(e){return\"form\"in e?e.parentNode&&!1===e.disabled?\"label\"in e?\"label\"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:\"label\"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&\"undefined\"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||\"HTML\")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener(\"unload\",oe,!1):n.attachEvent&&n.attachEvent(\"onunload\",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement(\"div\")),\"undefined\"!=typeof e.querySelectorAll&&!e.querySelectorAll(\":scope fieldset div\").length}),d.attributes=ce(function(e){return e.className=\"i\",!e.getAttribute(\"className\")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment(\"\")),!e.getElementsByTagName(\"*\").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute(\"id\")===t}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t=\"undefined\"!=typeof e.getAttributeNode&&e.getAttributeNode(\"id\");return t&&t.value===n}},b.find.ID=function(e,t){if(\"undefined\"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode(\"id\"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return\"undefined\"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if(\"*\"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if(\"undefined\"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML=\"<a id='\"+S+\"'><\/a><select id='\"+S+\"-\\r\\\\' msallowcapture=''><option selected=''><\/option><\/select>\",e.querySelectorAll(\"[msallowcapture^='']\").length&&v.push(\"[*^$]=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\"[selected]\").length||v.push(\"\\\\[\"+M+\"*(?:value|\"+R+\")\"),e.querySelectorAll(\"[id~=\"+S+\"-]\").length||v.push(\"~=\"),(t=C.createElement(\"input\")).setAttribute(\"name\",\"\"),e.appendChild(t),e.querySelectorAll(\"[name='']\").length||v.push(\"\\\\[\"+M+\"*name\"+M+\"*=\"+M+\"*(?:''|\\\"\\\")\"),e.querySelectorAll(\":checked\").length||v.push(\":checked\"),e.querySelectorAll(\"a#\"+S+\"+*\").length||v.push(\".#.+[+~]\"),e.querySelectorAll(\"\\\\\\f\"),v.push(\"[\\\\r\\\\n\\\\f]\")}),ce(function(e){e.innerHTML=\"<a href='' disabled='disabled'><\/a><select disabled='disabled'><option\/><\/select>\";var t=C.createElement(\"input\");t.setAttribute(\"type\",\"hidden\"),e.appendChild(t).setAttribute(\"name\",\"D\"),e.querySelectorAll(\"[name=d]\").length&&v.push(\"name\"+M+\"*[*^$|!~]?=\"),2!==e.querySelectorAll(\":enabled\").length&&v.push(\":enabled\",\":disabled\"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(\":disabled\").length&&v.push(\":enabled\",\":disabled\"),e.querySelectorAll(\"*,:x\"),v.push(\",.*:\")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,\"*\"),c.call(e,\"[s!='']:x\"),s.push(\"!=\",F)}),v=v.length&&new RegExp(v.join(\"|\")),s=s.length&&new RegExp(s.join(\"|\")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},j=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+\" \"]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&D.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+\"\").replace(re,ie)},se.error=function(e){throw new Error(\"Syntax error, unrecognized expression: \"+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(j),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n=\"\",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if(\"string\"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||\"\").replace(te,ne),\"~=\"===e[2]&&(e[3]=\" \"+e[3]+\" \"),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),\"nth\"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*(\"even\"===e[3]||\"odd\"===e[3])),e[5]=+(e[7]+e[8]||\"odd\"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||\"\":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(\")\",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return\"*\"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+\" \"];return t||(t=new RegExp(\"(^|\"+M+\")\"+e+\"(\"+M+\"|$)\"))&&m(e,function(e){return t.test(\"string\"==typeof e.className&&e.className||\"undefined\"!=typeof e.getAttribute&&e.getAttribute(\"class\")||\"\")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?\"!=\"===r:!r||(t+=\"\",\"=\"===r?t===i:\"!=\"===r?t!==i:\"^=\"===r?i&&0===t.indexOf(i):\"*=\"===r?i&&-1<t.indexOf(i):\"$=\"===r?i&&t.slice(-i.length)===i:\"~=\"===r?-1<(\" \"+t.replace(B,\" \")+\" \").indexOf(i):\"|=\"===r&&(t===i||t.slice(0,i.length+1)===i+\"-\"))}},CHILD:function(h,e,t,g,v){var y=\"nth\"!==h.slice(0,3),m=\"last\"!==h.slice(-4),x=\"of-type\"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?\"nextSibling\":\"previousSibling\",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l=\"only\"===h&&!u&&\"nextSibling\"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d\/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error(\"unsupported pseudo: \"+e);return a[S]?a(o):1<a.length?(t=[e,e,\"\",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,\"$1\"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||\"\")||se.error(\"unsupported lang: \"+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute(\"xml:lang\")||e.getAttribute(\"lang\"))return(t=t.toLowerCase())===n||0===t.indexOf(n+\"-\")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&\"button\"===e.type||\"button\"===t},text:function(e){var t;return\"input\"===e.nodeName.toLowerCase()&&\"text\"===e.type&&(null==(t=e.getAttribute(\"type\"))||\"text\"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r=\"\";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&\"parentNode\"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||\"*\",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[\" \"],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:\" \"===e[s-2].type?\"*\":\"\"})).replace($,\"$1\"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+\" \"];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($,\" \")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+\" \"];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l=\"0\",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG(\"*\",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l=\"function\"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&\"ID\"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split(\"\").sort(j).join(\"\")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement(\"fieldset\"))}),ce(function(e){return e.innerHTML=\"<a href='#'><\/a>\",\"#\"===e.firstChild.getAttribute(\"href\")})||fe(\"type|href|height|width\",function(e,t,n){if(!n)return e.getAttribute(t,\"type\"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML=\"<input\/>\",e.firstChild.setAttribute(\"value\",\"\"),\"\"===e.firstChild.getAttribute(\"value\")})||fe(\"value\",function(e,t,n){if(!n&&\"input\"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute(\"disabled\")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[\":\"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=\/^<([a-z][^\\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\\/?>(?:<\\\/\\1>|)$\/i;function j(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):\"string\"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=\":not(\"+e+\")\"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if(\"string\"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,\"string\"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var D,q=\/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$\/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||D,\"string\"==typeof e){if(!(r=\"<\"===e[0]&&\">\"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,D=S(E);var L=\/^(?:parents|prev(?:Until|All))\/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a=\"string\"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?\"string\"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,\"parentNode\")},parentsUntil:function(e,t,n){return h(e,\"parentNode\",n)},next:function(e){return O(e,\"nextSibling\")},prev:function(e){return O(e,\"previousSibling\")},nextAll:function(e){return h(e,\"nextSibling\")},prevAll:function(e){return h(e,\"previousSibling\")},nextUntil:function(e,t,n){return h(e,\"nextSibling\",n)},prevUntil:function(e,t,n){return h(e,\"previousSibling\",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,\"template\")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return\"Until\"!==r.slice(-5)&&(t=e),t&&\"string\"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=\/[^\\x20\\t\\r\\n\\f]+\/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r=\"string\"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:\"\")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&\"string\"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t=\"\",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=\"\"),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[[\"notify\",\"progress\",S.Callbacks(\"memory\"),S.Callbacks(\"memory\"),2],[\"resolve\",\"done\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),0,\"resolved\"],[\"reject\",\"fail\",S.Callbacks(\"once memory\"),S.Callbacks(\"once memory\"),1,\"rejected\"]],i=\"pending\",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},\"catch\":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+\"With\"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError(\"Thenable self-resolution\");t=e&&(\"object\"==typeof e||\"function\"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+\"With\"](this===s?void 0:this,arguments),this},s[t[0]+\"With\"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),\"pending\"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=\/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$\/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn(\"jQuery.Deferred exception: \"+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener(\"DOMContentLoaded\",B),C.removeEventListener(\"load\",B),S.ready()}S.fn.ready=function(e){return F.then(e)[\"catch\"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,\"complete\"===E.readyState||\"loading\"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener(\"DOMContentLoaded\",B),C.addEventListener(\"load\",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if(\"object\"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=\/^-ms-\/,z=\/-([a-z])\/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,\"ms-\").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if(\"string\"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&\"string\"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=\/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$\/,K=\/[A-Z]\/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r=\"data-\"+t.replace(K,\"-$&\").toLowerCase(),\"string\"==typeof(n=e.getAttribute(r))){try{n=\"true\"===(i=n)||\"false\"!==i&&(\"null\"===i?null:i===+i+\"\"?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,\"hasDataAttrs\"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf(\"data-\")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,\"hasDataAttrs\",!0)}return i}return\"object\"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||\"fx\")+\"queue\",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||\"fx\";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks(\"once memory\").add(function(){Y.remove(e,[t+\"queue\",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return\"string\"!=typeof t&&(n=t,t=\"fx\",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),\"fx\"===t&&\"inprogress\"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||\"fx\",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};\"string\"!=typeof e&&(t=e,e=void 0),e=e||\"fx\";while(a--)(n=Y.get(o[a],e+\"queueHooks\"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=\/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)\/.source,te=new RegExp(\"^(?:([+-])=|)(\"+ee+\")([a-z%]*)$\",\"i\"),ne=[\"Top\",\"Right\",\"Bottom\",\"Left\"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return\"none\"===(e=t||e).style.display||\"\"===e.style.display&&ie(e)&&\"none\"===S.css(e,\"display\")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,\"\")},u=s(),l=n&&n[3]||(S.cssNumber[t]?\"\":\"px\"),c=e.nodeType&&(S.cssNumber[t]||\"px\"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u\/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()\/u||.5))<=0&&(a=0),c\/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?(\"none\"===n&&(l[c]=Y.get(r,\"display\")||null,l[c]||(r.style.display=\"\")),\"\"===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,\"display\"),o.parentNode.removeChild(o),\"none\"===u&&(u=\"block\"),ue[s]=u)))):\"none\"!==n&&(l[c]=\"none\",Y.set(r,\"display\",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return\"boolean\"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=\/^(?:checkbox|radio)$\/i,de=\/<([a-z][^\\\/\\0>\\x20\\t\\r\\n\\f]*)\/i,he=\/^$|^module$|\\\/(?:java|ecma)script\/i;ce=E.createDocumentFragment().appendChild(E.createElement(\"div\")),(fe=E.createElement(\"input\")).setAttribute(\"type\",\"radio\"),fe.setAttribute(\"checked\",\"checked\"),fe.setAttribute(\"name\",\"t\"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML=\"<textarea>x<\/textarea>\",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML=\"<option><\/option>\",y.option=!!ce.lastChild;var ge={thead:[1,\"<table>\",\"<\/table>\"],col:[2,\"<table><colgroup>\",\"<\/colgroup><\/table>\"],tr:[2,\"<table><tbody>\",\"<\/tbody><\/table>\"],td:[3,\"<table><tbody><tr>\",\"<\/tr><\/tbody><\/table>\"],_default:[0,\"\",\"\"]};function ve(e,t){var n;return n=\"undefined\"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||\"*\"):\"undefined\"!=typeof e.querySelectorAll?e.querySelectorAll(t||\"*\"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],\"globalEval\",!t||Y.get(t[n],\"globalEval\"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,\"<select multiple='multiple'>\",\"<\/select>\"]);var me=\/<|&#?\\w+;\/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if(\"object\"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement(\"div\")),s=(de.exec(o)||[\"\",\"\"])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=\"\"}else p.push(t.createTextNode(o));f.textContent=\"\",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),\"script\"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||\"\")&&n.push(o)}return f}var be=\/^([^.]*)(?:\\.(.+)|)\/;function we(){return!0}function Te(){return!1}function Ce(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==(\"focus\"===t)}function Ee(e,t,n,r,i,o){var a,s;if(\"object\"==typeof t){for(s in\"string\"!=typeof n&&(r=r||n,n=void 0),t)Ee(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&(\"string\"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Te;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Se(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n&&n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,we)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return\"undefined\"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||\"\").match(P)||[\"\"]).length;while(l--)d=g=(s=be.exec(e[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(\".\")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||\"\").match(P)||[\"\"]).length;while(l--)if(d=g=(s=be.exec(t[l])||[])[1],h=(s[2]||\"\").split(\".\").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&(\"**\"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,\"handle events\")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,\"events\")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!(\"click\"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&(\"click\"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+\" \"]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Se(t,\"click\",we),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Se(t,\"click\"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,\"input\")&&Y.get(t,\"click\")||A(t,\"a\")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?we:Te,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Te,isPropagationStopped:Te,isImmediatePropagationStopped:Te,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=we,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=we,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=we,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,\"char\":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},S.event.addProp),S.each({focus:\"focusin\",blur:\"focusout\"},function(e,t){S.event.special[e]={setup:function(){return Se(this,e,Ce),!1},trigger:function(){return Se(this,e),!0},_default:function(){return!0},delegateType:t}}),S.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return Ee(this,e,t,n,r)},one:function(e,t,n,r){return Ee(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+\".\"+r.namespace:r.origType,r.selector,r.handler),this;if(\"object\"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&\"function\"!=typeof t||(n=t,t=void 0),!1===n&&(n=Te),this.each(function(){S.event.remove(this,e,n,t)})}});var ke=\/<script|<style|<link\/i,Ae=\/checked\\s*(?:[^=]|=\\s*.checked.)\/i,Ne=\/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$\/g;function je(e,t){return A(e,\"table\")&&A(11!==t.nodeType?t:t.firstChild,\"tr\")&&S(e).children(\"tbody\")[0]||e}function De(e){return e.type=(null!==e.getAttribute(\"type\"))+\"\/\"+e.type,e}function qe(e){return\"true\/\"===(e.type||\"\").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute(\"type\"),e}function Le(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,\"handle events\"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function He(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&\"string\"==typeof d&&!y.checkClone&&Ae.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),He(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,\"script\"),De)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,\"script\"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,qe),c=0;c<s;c++)u=a[c],he.test(u.type||\"\")&&!Y.access(u,\"globalEval\")&&S.contains(l,u)&&(u.src&&\"module\"!==(u.type||\"\").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute(\"nonce\")},l):b(u.textContent.replace(Ne,\"\"),u,l))}return n}function Oe(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,\"script\")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,\"input\"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:\"input\"!==l&&\"textarea\"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Le(o[r],a[r]);else Le(e,c);return 0<(a=ve(c,\"script\")).length&&ye(a,!f&&ve(e,\"script\")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Oe(this,e,!0)},remove:function(e){return Oe(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return He(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||je(this,e).appendChild(e)})},prepend:function(){return He(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=je(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent=\"\");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if(\"string\"==typeof e&&!ke.test(e)&&!ge[(de.exec(e)||[\"\",\"\"])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return He(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Pe=new RegExp(\"^(\"+ee+\")(?!px)[a-z%]+$\",\"i\"),Re=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Me=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Ie=new RegExp(ne.join(\"|\"),\"i\");function We(e,t,n){var r,i,o,a,s=e.style;return(n=n||Re(e))&&(\"\"!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Pe.test(a)&&Ie.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+\"\":a}function Fe(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText=\"position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0\",l.style.cssText=\"position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%\",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n=\"1%\"!==e.top,s=12===t(e.marginLeft),l.style.right=\"60%\",o=36===t(e.right),r=36===t(e.width),l.style.position=\"absolute\",i=12===t(l.offsetWidth\/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement(\"div\"),l=E.createElement(\"div\");l.style&&(l.style.backgroundClip=\"content-box\",l.cloneNode(!0).style.backgroundClip=\"\",y.clearCloneStyle=\"content-box\"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement(\"table\"),t=E.createElement(\"tr\"),n=E.createElement(\"div\"),e.style.cssText=\"position:absolute;left:-11111px;border-collapse:separate\",t.style.cssText=\"border:1px solid\",t.style.height=\"1px\",n.style.height=\"9px\",n.style.display=\"block\",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,re.removeChild(e)),a}}))}();var Be=[\"Webkit\",\"Moz\",\"ms\"],$e=E.createElement(\"div\").style,_e={};function ze(e){var t=S.cssProps[e]||_e[e];return t||(e in $e?e:_e[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Be.length;while(n--)if((e=Be[n]+t)in $e)return e}(e)||e)}var Ue=\/^(none|table(?!-c[ea]).+)\/,Xe=\/^--\/,Ve={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Ge={letterSpacing:\"0\",fontWeight:\"400\"};function Ye(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||\"px\"):t}function Qe(e,t,n,r,i,o){var a=\"width\"===t?1:0,s=0,u=0;if(n===(r?\"border\":\"content\"))return 0;for(;a<4;a+=2)\"margin\"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?(\"content\"===n&&(u-=S.css(e,\"padding\"+ne[a],!0,i)),\"margin\"!==n&&(u-=S.css(e,\"border\"+ne[a]+\"Width\",!0,i))):(u+=S.css(e,\"padding\"+ne[a],!0,i),\"padding\"!==n?u+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i):s+=S.css(e,\"border\"+ne[a]+\"Width\",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e[\"offset\"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Je(e,t,n){var r=Re(e),i=(!y.boxSizingReliable()||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,r),o=i,a=We(e,t,r),s=\"offset\"+t[0].toUpperCase()+t.slice(1);if(Pe.test(a)){if(!n)return a;a=\"auto\"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,\"tr\")||\"auto\"===a||!parseFloat(a)&&\"inline\"===S.css(e,\"display\",!1,r))&&e.getClientRects().length&&(i=\"border-box\"===S.css(e,\"boxSizing\",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Qe(e,t,n||(i?\"border\":\"content\"),o,r,a)+\"px\"}function Ke(e,t,n,r,i){return new Ke.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=We(e,\"opacity\");return\"\"===n?\"1\":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Xe.test(t),l=e.style;if(u||(t=ze(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&\"get\"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];\"string\"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o=\"number\"),null!=n&&n==n&&(\"number\"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?\"\":\"px\")),y.clearCloneStyle||\"\"!==n||0!==t.indexOf(\"background\")||(l[t]=\"inherit\"),a&&\"set\"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Xe.test(t)||(t=ze(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&\"get\"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=We(e,t,r)),\"normal\"===i&&t in Ge&&(i=Ge[t]),\"\"===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each([\"height\",\"width\"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ue.test(S.css(e,\"display\"))||e.getClientRects().length&&e.getBoundingClientRect().width?Je(e,u,n):Me(e,Ve,function(){return Je(e,u,n)})},set:function(e,t,n){var r,i=Re(e),o=!y.scrollboxSize()&&\"absolute\"===i.position,a=(o||n)&&\"border-box\"===S.css(e,\"boxSizing\",!1,i),s=n?Qe(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e[\"offset\"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Qe(e,u,\"border\",!1,i)-.5)),s&&(r=te.exec(t))&&\"px\"!==(r[3]||\"px\")&&(e.style[u]=t,t=S.css(e,u)),Ye(0,t,s)}}}),S.cssHooks.marginLeft=Fe(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(We(e,\"marginLeft\"))||e.getBoundingClientRect().left-Me(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+\"px\"}),S.each({margin:\"\",padding:\"\",border:\"Width\"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r=\"string\"==typeof e?e.split(\" \"):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},\"margin\"!==i&&(S.cssHooks[i+o].set=Ye)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Re(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=Ke).prototype={constructor:Ke,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?\"\":\"px\")},cur:function(){var e=Ke.propHooks[this.prop];return e&&e.get?e.get(this):Ke.propHooks._default.get(this)},run:function(e){var t,n=Ke.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Ke.propHooks._default.set(this),this}}).init.prototype=Ke.prototype,(Ke.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,\"\"))&&\"auto\"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[ze(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=Ke.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)\/2},_default:\"swing\"},S.fx=Ke.prototype.init,S.fx.step={};var Ze,et,tt,nt,rt=\/^(?:toggle|show|hide)$\/,it=\/queueHooks$\/;function ot(){et&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(ot):C.setTimeout(ot,S.fx.interval),S.fx.tick())}function at(){return C.setTimeout(function(){Ze=void 0}),Ze=Date.now()}function st(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i[\"margin\"+(n=ne[r])]=i[\"padding\"+n]=e;return t&&(i.opacity=i.width=e),i}function ut(e,t,n){for(var r,i=(lt.tweeners[t]||[]).concat(lt.tweeners[\"*\"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function lt(o,e,t){var n,a,r=0,i=lt.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=Ze||at(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t\/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:Ze||at(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&\"expand\"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=lt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ut,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(lt,{tweeners:{\"*\":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=[\"*\"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],lt.tweeners[n]=lt.tweeners[n]||[],lt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f=\"width\"in t||\"height\"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,\"fxshow\");for(r in n.queue||(null==(a=S._queueHooks(e,\"fx\")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,\"fx\").length||a.empty.fire()})})),t)if(i=t[r],rt.test(i)){if(delete t[r],o=o||\"toggle\"===i,i===(g?\"hide\":\"show\")){if(\"show\"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,\"display\")),\"none\"===(c=S.css(e,\"display\"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,\"display\"),le([e]))),(\"inline\"===c||\"inline-block\"===c&&null!=l)&&\"none\"===S.css(e,\"float\")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l=\"none\"===c?\"\":c)),h.display=\"inline-block\")),n.overflow&&(h.overflow=\"hidden\",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?\"hidden\"in v&&(g=v.hidden):v=Y.access(e,\"fxshow\",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,\"fxshow\"),d)S.style(e,r,d[r])})),u=ut(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?lt.prefilters.unshift(e):lt.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&\"object\"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:\"number\"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue=\"fx\"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css(\"opacity\",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=lt(this,S.extend({},t),o);(i||Y.get(this,\"finish\"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return\"string\"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||\"fx\",[]),this.each(function(){var e=!0,t=null!=i&&i+\"queueHooks\",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&it.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||\"fx\"),this.each(function(){var e,t=Y.get(this),n=t[a+\"queue\"],r=t[a+\"queueHooks\"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each([\"toggle\",\"show\",\"hide\"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||\"boolean\"==typeof e?i.apply(this,arguments):this.animate(st(r,!0),e,t,n)}}),S.each({slideDown:st(\"show\"),slideUp:st(\"hide\"),slideToggle:st(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(Ze=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),Ze=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){et||(et=!0,ot())},S.fx.stop=function(){et=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||\"fx\",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},tt=E.createElement(\"input\"),nt=E.createElement(\"select\").appendChild(E.createElement(\"option\")),tt.type=\"checkbox\",y.checkOn=\"\"!==tt.value,y.optSelected=nt.selected,(tt=E.createElement(\"input\")).value=\"t\",tt.type=\"radio\",y.radioValue=\"t\"===tt.value;var ct,ft=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return\"undefined\"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?ct:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+\"\"),n):i&&\"get\"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&\"radio\"===t&&A(e,\"input\")){var n=e.value;return e.setAttribute(\"type\",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ct={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(\/\\w+\/g),function(e,t){var a=ft[t]||S.find.attr;ft[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=ft[o],ft[o]=r,r=null!=a(e,t,n)?o:null,ft[o]=i),r}});var pt=\/^(?:input|select|textarea|button)$\/i,dt=\/^(?:a|area)$\/i;function ht(e){return(e.match(P)||[]).join(\" \")}function gt(e){return e.getAttribute&&e.getAttribute(\"class\")||\"\"}function vt(e){return Array.isArray(e)?e:\"string\"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&\"set\"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&\"get\"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,\"tabindex\");return t?parseInt(t,10):pt.test(e.nodeName)||dt.test(e.nodeName)&&e.href?0:-1}}},propFix:{\"for\":\"htmlFor\",\"class\":\"className\"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,gt(this)))});if((e=vt(t)).length)while(n=this[u++])if(i=gt(n),r=1===n.nodeType&&\" \"+ht(i)+\" \"){a=0;while(o=e[a++])r.indexOf(\" \"+o+\" \")<0&&(r+=o+\" \");i!==(s=ht(r))&&n.setAttribute(\"class\",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,gt(this)))});if(!arguments.length)return this.attr(\"class\",\"\");if((e=vt(t)).length)while(n=this[u++])if(i=gt(n),r=1===n.nodeType&&\" \"+ht(i)+\" \"){a=0;while(o=e[a++])while(-1<r.indexOf(\" \"+o+\" \"))r=r.replace(\" \"+o+\" \",\" \");i!==(s=ht(r))&&n.setAttribute(\"class\",s)}return this},toggleClass:function(i,t){var o=typeof i,a=\"string\"===o||Array.isArray(i);return\"boolean\"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,gt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=vt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&\"boolean\"!==o||((e=gt(this))&&Y.set(this,\"__className__\",e),this.setAttribute&&this.setAttribute(\"class\",e||!1===i?\"\":Y.get(this,\"__className__\")||\"\"))})},hasClass:function(e){var t,n,r=0;t=\" \"+e+\" \";while(n=this[r++])if(1===n.nodeType&&-1<(\" \"+ht(gt(n))+\" \").indexOf(t))return!0;return!1}});var yt=\/\\r\/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t=\"\":\"number\"==typeof t?t+=\"\":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?\"\":e+\"\"})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&\"set\"in r&&void 0!==r.set(this,t,\"value\")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&\"get\"in r&&void 0!==(e=r.get(t,\"value\"))?e:\"string\"==typeof(e=t.value)?e.replace(yt,\"\"):null==e?\"\":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,\"value\");return null!=t?t:ht(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a=\"select-one\"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,\"optgroup\"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each([\"radio\",\"checkbox\"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute(\"value\")?\"on\":e.value})}),y.focusin=\"onfocusin\"in C;var mt=\/^(?:focusinfocus|focusoutblur)$\/,xt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,\"type\")?e.type:e,h=v.call(e,\"namespace\")?e.namespace.split(\".\"):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!mt.test(d+S.event.triggered)&&(-1<d.indexOf(\".\")&&(d=(h=d.split(\".\")).shift(),h.sort()),u=d.indexOf(\":\")<0&&\"on\"+d,(e=e[S.expando]?e:new S.Event(d,\"object\"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join(\".\"),e.rnamespace=e.namespace?new RegExp(\"(^|\\\\.)\"+h.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,mt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,\"events\")||Object.create(null))[e.type]&&Y.get(o,\"handle\"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,xt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,xt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:\"focusin\",blur:\"focusout\"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var bt=C.location,wt={guid:Date.now()},Tt=\/\\?\/;S.parseXML=function(e){var t,n;if(!e||\"string\"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,\"text\/xml\")}catch(e){}return n=t&&t.getElementsByTagName(\"parsererror\")[0],t&&!n||S.error(\"Invalid XML: \"+(n?S.map(n.childNodes,function(e){return e.textContent}).join(\"\\n\"):e)),t};var Ct=\/\\[\\]$\/,Et=\/\\r?\\n\/g,St=\/^(?:submit|button|image|reset|file)$\/i,kt=\/^(?:input|select|textarea|keygen)\/i;function At(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||Ct.test(n)?i(n,t):At(n+\"[\"+(\"object\"==typeof t&&null!=t?e:\"\")+\"]\",t,r,i)});else if(r||\"object\"!==w(e))i(n,e);else for(t in e)At(n+\"[\"+t+\"]\",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+\"=\"+encodeURIComponent(null==n?\"\":n)};if(null==e)return\"\";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)At(n,e[n],t,i);return r.join(\"&\")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,\"elements\");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(\":disabled\")&&kt.test(this.nodeName)&&!St.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(Et,\"\\r\\n\")}}):{name:t.name,value:n.replace(Et,\"\\r\\n\")}}).get()}});var Nt=\/%20\/g,jt=\/#.*$\/,Dt=\/([?&])_=[^&]*\/,qt=\/^(.*?):[ \\t]*([^\\r\\n]*)$\/gm,Lt=\/^(?:GET|HEAD)$\/,Ht=\/^\\\/\\\/\/,Ot={},Pt={},Rt=\"*\/\".concat(\"*\"),Mt=E.createElement(\"a\");function It(o){return function(e,t){\"string\"!=typeof e&&(t=e,e=\"*\");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])\"+\"===n[0]?(n=n.slice(1)||\"*\",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Wt(t,i,o,a){var s={},u=t===Pt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return\"string\"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s[\"*\"]&&l(\"*\")}function Ft(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Mt.href=bt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:bt.href,type:\"GET\",isLocal:\/^(?:about|app|app-storage|.+-extension|file|res|widget):$\/.test(bt.protocol),global:!0,processData:!0,async:!0,contentType:\"application\/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":Rt,text:\"text\/plain\",html:\"text\/html\",xml:\"application\/xml, text\/xml\",json:\"application\/json, text\/javascript\"},contents:{xml:\/\\bxml\\b\/,html:\/\\bhtml\/,json:\/\\bjson\\b\/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":JSON.parse,\"text xml\":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Ft(Ft(e,S.ajaxSettings),t):Ft(S.ajaxSettings,e)},ajaxPrefilter:It(Ot),ajaxTransport:It(Pt),ajax:function(e,t){\"object\"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks(\"once memory\"),w=v.statusCode||{},a={},s={},u=\"canceled\",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=qt.exec(p))n[t[1].toLowerCase()+\" \"]=(n[t[1].toLowerCase()+\" \"]||[]).concat(t[2])}t=n[e.toLowerCase()+\" \"]}return null==t?null:t.join(\", \")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||bt.href)+\"\").replace(Ht,bt.protocol+\"\/\/\"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||\"*\").toLowerCase().match(P)||[\"\"],null==v.crossDomain){r=E.createElement(\"a\");try{r.href=v.url,r.href=r.href,v.crossDomain=Mt.protocol+\"\/\/\"+Mt.host!=r.protocol+\"\/\/\"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&\"string\"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Wt(Ot,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger(\"ajaxStart\"),v.type=v.type.toUpperCase(),v.hasContent=!Lt.test(v.type),f=v.url.replace(jt,\"\"),v.hasContent?v.data&&v.processData&&0===(v.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&(v.data=v.data.replace(Nt,\"+\")):(o=v.url.slice(f.length),v.data&&(v.processData||\"string\"==typeof v.data)&&(f+=(Tt.test(f)?\"&\":\"?\")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Dt,\"$1\"),o=(Tt.test(f)?\"&\":\"?\")+\"_=\"+wt.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader(\"If-Modified-Since\",S.lastModified[f]),S.etag[f]&&T.setRequestHeader(\"If-None-Match\",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader(\"Content-Type\",v.contentType),T.setRequestHeader(\"Accept\",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+(\"*\"!==v.dataTypes[0]?\", \"+Rt+\"; q=0.01\":\"\"):v.accepts[\"*\"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u=\"abort\",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Wt(Pt,v,t,T)){if(T.readyState=1,g&&m.trigger(\"ajaxSend\",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort(\"timeout\")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,\"No Transport\");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||\"\",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while(\"*\"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader(\"Content-Type\"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+\" \"+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray(\"script\",v.dataTypes)&&S.inArray(\"json\",v.dataTypes)<0&&(v.converters[\"text script\"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if(\"*\"===o)o=u;else if(\"*\"!==u&&u!==o){if(!(a=l[u+\" \"+o]||l[\"* \"+o]))for(i in l)if((s=i.split(\" \"))[1]===o&&(a=l[u+\" \"+s[0]]||l[\"* \"+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e[\"throws\"])t=a(t);else try{t=a(t)}catch(e){return{state:\"parsererror\",error:a?e:\"No conversion from \"+u+\" to \"+o}}}return{state:\"success\",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader(\"Last-Modified\"))&&(S.lastModified[f]=u),(u=T.getResponseHeader(\"etag\"))&&(S.etag[f]=u)),204===e||\"HEAD\"===v.type?l=\"nocontent\":304===e?l=\"notmodified\":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l=\"error\",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+\"\",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?\"ajaxSuccess\":\"ajaxError\",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger(\"ajaxComplete\",[T,v]),--S.active||S.event.trigger(\"ajaxStop\")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,\"json\")},getScript:function(e,t){return S.get(e,void 0,t,\"script\")}}),S.each([\"get\",\"post\"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)\"content-type\"===t.toLowerCase()&&(e.contentType=e.headers[t]||\"\")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:\"GET\",dataType:\"script\",cache:!0,async:!1,global:!1,converters:{\"text script\":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not(\"body\").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Bt={0:200,1223:204},$t=S.ajaxSettings.xhr();y.cors=!!$t&&\"withCredentials\"in $t,y.ajax=$t=!!$t,S.ajaxTransport(function(i){var o,a;if(y.cors||$t&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e[\"X-Requested-With\"]||(e[\"X-Requested-With\"]=\"XMLHttpRequest\"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,\"abort\"===e?r.abort():\"error\"===e?\"number\"!=typeof r.status?t(0,\"error\"):t(r.status,r.statusText):t(Bt[r.status]||r.status,r.statusText,\"text\"!==(r.responseType||\"text\")||\"string\"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o(\"error\"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o(\"abort\");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:\"text\/javascript, application\/javascript, application\/ecmascript, application\/x-ecmascript\"},contents:{script:\/\\b(?:java|ecma)script\\b\/},converters:{\"text script\":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter(\"script\",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type=\"GET\")}),S.ajaxTransport(\"script\",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S(\"<script>\").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on(\"load error\",i=function(e){r.remove(),i=null,e&&t(\"error\"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var _t,zt=[],Ut=\/(=)\\?(?=&|$)|\\?\\?\/;S.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var e=zt.pop()||S.expando+\"_\"+wt.guid++;return this[e]=!0,e}}),S.ajaxPrefilter(\"json jsonp\",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Ut.test(e.url)?\"url\":\"string\"==typeof e.data&&0===(e.contentType||\"\").indexOf(\"application\/x-www-form-urlencoded\")&&Ut.test(e.data)&&\"data\");if(a||\"jsonp\"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Ut,\"$1\"+r):!1!==e.jsonp&&(e.url+=(Tt.test(e.url)?\"&\":\"?\")+e.jsonp+\"=\"+r),e.converters[\"script json\"]=function(){return o||S.error(r+\" was not called\"),o[0]},e.dataTypes[0]=\"json\",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,zt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),\"script\"}),y.createHTMLDocument=((_t=E.implementation.createHTMLDocument(\"\").body).innerHTML=\"<form><\/form><form><\/form>\",2===_t.childNodes.length),S.parseHTML=function(e,t,n){return\"string\"!=typeof e?[]:(\"boolean\"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument(\"\")).createElement(\"base\")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(\" \");return-1<s&&(r=ht(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&\"object\"==typeof t&&(i=\"POST\"),0<a.length&&S.ajax({url:e,type:i||\"GET\",dataType:\"html\",data:t}).done(function(e){o=arguments,a.html(r?S(\"<div>\").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,\"position\"),c=S(e),f={};\"static\"===l&&(e.style.position=\"relative\"),s=c.offset(),o=S.css(e,\"top\"),u=S.css(e,\"left\"),(\"absolute\"===l||\"fixed\"===l)&&-1<(o+u).indexOf(\"auto\")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),\"using\"in t?t.using.call(e,f):c.css(f)}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if(\"fixed\"===S.css(r,\"position\"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&\"static\"===S.css(e,\"position\"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,\"borderTopWidth\",!0),i.left+=S.css(e,\"borderLeftWidth\",!0))}return{top:t.top-i.top-S.css(r,\"marginTop\",!0),left:t.left-i.left-S.css(r,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&\"static\"===S.css(e,\"position\"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(t,i){var o=\"pageYOffset\"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each([\"top\",\"left\"],function(e,n){S.cssHooks[n]=Fe(y.pixelPosition,function(e,t){if(t)return t=We(e,n),Pe.test(t)?S(e).position()[n]+\"px\":t})}),S.each({Height:\"height\",Width:\"width\"},function(a,s){S.each({padding:\"inner\"+a,content:s,\"\":\"outer\"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||\"boolean\"!=typeof e),i=r||(!0===e||!0===t?\"margin\":\"border\");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf(\"outer\")?e[\"inner\"+a]:e.document.documentElement[\"client\"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body[\"scroll\"+a],r[\"scroll\"+a],e.body[\"offset\"+a],r[\"offset\"+a],r[\"client\"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,\"**\"):this.off(t,e||\"**\",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each(\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\".split(\" \"),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Xt=\/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$\/g;S.proxy=function(e,t){var n,r,i;if(\"string\"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return(\"number\"===t||\"string\"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?\"\":(e+\"\").replace(Xt,\"\")},\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return S});var Vt=C.jQuery,Gt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Gt),e&&C.jQuery===S&&(C.jQuery=Vt),S},\"undefined\"==typeof e&&(C.jQuery=C.$=S),S});\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script-dir\/jquery-3.6.0.min.js","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -362,5 +362,1 @@\n-                if (top !== window) {\n-                    parent.classFrame.location = pathtoroot + url;\n-                } else {\n-                    window.location.href = pathtoroot + url;\n-                }\n+                window.location.href = pathtoroot + url;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/search.js.template","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,1 +209,1 @@\n-    VisibleMemberCache visibleMemberCache = null;\n+    private VisibleMemberCache visibleMemberCache;\n@@ -712,1 +712,1 @@\n-    public synchronized VisibleMemberTable getVisibleMemberTable(TypeElement te) {\n+    public VisibleMemberTable getVisibleMemberTable(TypeElement te) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-     * or  {@code --override-methods detail}.\n+     * or {@code --override-methods detail}.\n@@ -1051,1 +1051,1 @@\n-     * or  {@code --override-methods detail}.\n+     * or {@code --override-methods detail}.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import javax.lang.model.type.DeclaredType;\n@@ -49,1 +50,0 @@\n-import com.sun.tools.javac.code.Attribute;\n@@ -58,0 +58,1 @@\n+import com.sun.tools.javac.code.Type;\n@@ -204,5 +205,12 @@\n-    \/**\n-     * Return the type containing the method that this method overrides.\n-     * It may be a <code>TypeElement<\/code> or a <code>TypeParameterElement<\/code>.\n-     * @param method target\n-     * @return a type\n+    \/*\n+     * Returns the closest superclass (not the superinterface) that contains\n+     * a method that is both:\n+     *\n+     *   - overridden by the specified method, and\n+     *   - is not itself a *simple* override\n+     *\n+     * If no such class can be found, returns null.\n+     *\n+     * If the specified method belongs to an interface, the only considered\n+     * superclass is java.lang.Object no matter how many other interfaces\n+     * that interface extends.\n@@ -210,1 +218,1 @@\n-    public TypeMirror overriddenType(ExecutableElement method) {\n+    public DeclaredType overriddenType(ExecutableElement method) {\n@@ -216,3 +224,3 @@\n-        for (com.sun.tools.javac.code.Type t = javacTypes.supertype(origin.type);\n-                t.hasTag(TypeTag.CLASS);\n-                t = javacTypes.supertype(t)) {\n+        for (Type t = javacTypes.supertype(origin.type);\n+             t.hasTag(TypeTag.CLASS);\n+             t = javacTypes.supertype(t)) {\n@@ -220,1 +228,1 @@\n-            for (com.sun.tools.javac.code.Symbol sym2 : c.members().getSymbolsByName(sym.name)) {\n+            for (Symbol sym2 : c.members().getSymbolsByName(sym.name)) {\n@@ -227,1 +235,2 @@\n-                    return t;\n+                    assert t.hasTag(TypeTag.CLASS) && !t.isInterface();\n+                    return (Type.ClassType) t;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,6 +111,6 @@\n-     \/**\n-      * Handles the {@literal <TypeElement>} tag.\n-      *\n-      * @throws DocletException if there is a problem while building the documentation\n-      *\/\n-     protected void buildClassDoc() throws DocletException {\n+    \/**\n+     * Handles the {@literal <TypeElement>} tag.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildClassDoc() throws DocletException {\n@@ -125,1 +125,1 @@\n-         Content contentTree = writer.getHeader(resources.getText(key) + \" \"\n+        Content contentTree = writer.getHeader(resources.getText(key) + \" \"\n@@ -140,5 +140,5 @@\n-     \/**\n-      * Build the class tree documentation.\n-      *\n-      * @param classContentTree the content tree to which the documentation will be added\n-      *\/\n+    \/**\n+     * Build the class tree documentation.\n+     *\n+     * @param classContentTree the content tree to which the documentation will be added\n+     *\/\n@@ -259,1 +259,1 @@\n-     private void copyDocFiles() throws DocletException {\n+    private void copyDocFiles() throws DocletException {\n@@ -273,1 +273,1 @@\n-     }\n+    }\n@@ -290,1 +290,1 @@\n-       writer.addClassDescription(classInfoTree);\n+        writer.addClassDescription(classInfoTree);\n@@ -299,1 +299,1 @@\n-       writer.addClassTagInfo(classInfoTree);\n+        writer.addClassTagInfo(classInfoTree);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ClassBuilder.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import javax.lang.model.util.Types;\n@@ -169,1 +170,3 @@\n-                ((ExecutableElement) holder).getThrownTypes(), thrownTypes);\n+                writer.configuration().utils.typeUtils,\n+                ((ExecutableElement) holder).getThrownTypes(),\n+                thrownTypes);\n@@ -236,1 +239,2 @@\n-    private Map<String, TypeMirror> getSubstitutedThrownTypes(List<? extends TypeMirror> declaredThrownTypes,\n+    private Map<String, TypeMirror> getSubstitutedThrownTypes(Types types,\n+                                                              List<? extends TypeMirror> declaredThrownTypes,\n@@ -245,1 +249,1 @@\n-                if (!t1.equals(t2))\n+                if (!types.isSameType(t1, t2))\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-    public static final DocPath JQUERY_JS = DocPath.create(\"jquery-3.5.1.min.js\");\n+    public static final DocPath JQUERY_JS = DocPath.create(\"jquery-3.6.0.min.js\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,6 +48,1 @@\n-    public synchronized Throwable getCause() {\n-        return super.getCause();\n-    }\n-\n-    @Override\n-    public synchronized Throwable initCause(Throwable cause) {\n+    public Throwable initCause(Throwable cause) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/UncheckedDocletException.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-    private HashMap<String, TypeMirror> symtab = new HashMap<>();\n+    private final Map<String, TypeMirror> symtab = new HashMap<>();\n@@ -165,11 +165,4 @@\n-        TypeMirror type = symtab.get(signature);\n-        if (type == null) {\n-            TypeElement typeElement = elementUtils.getTypeElement(signature);\n-            if (typeElement == null)\n-                return null;\n-            type = typeElement.asType();\n-            if (type == null)\n-                return null;\n-            symtab.put(signature, type);\n-        }\n-        return type;\n+        return symtab.computeIfAbsent(signature, s -> {\n+            var typeElement = elementUtils.getTypeElement(s);\n+            return typeElement == null ? null : typeElement.asType();\n+        });\n@@ -182,1 +175,3 @@\n-    public TypeMirror getThrowableType() { return getSymbol(\"java.lang.Throwable\"); }\n+    public TypeMirror getThrowableType() {\n+        return getSymbol(\"java.lang.Throwable\");\n+    }\n@@ -192,8 +187,0 @@\n-    public TypeMirror getIllegalArgumentExceptionType() {\n-        return getSymbol(\"java.lang.IllegalArgumentException\");\n-    }\n-\n-    public TypeMirror getNullPointerExceptionType() {\n-        return getSymbol(\"java.lang.NullPointerException\");\n-    }\n-\n@@ -208,16 +195,0 @@\n-    \/**\n-     * Return array of class members whose documentation is to be generated.\n-     * If the member is deprecated do not include such a member in the\n-     * returned array.\n-     *\n-     * @param  members    Array of members to choose from.\n-     * @return List       List of eligible members for whom\n-     *                    documentation is getting generated.\n-     *\/\n-    public List<Element> excludeDeprecatedMembers(List<? extends Element> members) {\n-        return members.stream()\n-                      .filter(member -> !isDeprecated(member))\n-                      .sorted(comparators.makeGeneralPurposeComparator())\n-                      .collect(Collectors.toCollection(ArrayList::new));\n-    }\n-\n@@ -244,3 +215,3 @@\n-     * @param t1 the candidate superclass.\n-     * @param t2 the target\n-     * @return true if t1 is a superclass of t2.\n+     * @param t1 the candidate subclass\n+     * @param t2 the candidate superclass\n+     * @return true if t1 is a superclass of t2\n@@ -264,2 +235,1 @@\n-                int j;\n-                for (j = 0 ; j < parameters1.size(); j++) {\n+                for (int j = 0; j < parameters1.size(); j++) {\n@@ -268,5 +238,2 @@\n-                    String t1 = getTypeName(v1.asType(), true);\n-                    String t2 = getTypeName(v2.asType(), true);\n-                    if (!(t1.equals(t2) ||\n-                            isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {\n-                        break;\n+                    if (!typeUtils.isSameType(v1.asType(), v2.asType())) {\n+                        return false;\n@@ -275,3 +242,1 @@\n-                if (j == parameters1.size()) {\n-                    return true;\n-                }\n+                return true;\n@@ -323,4 +288,0 @@\n-    public boolean isAnnotated(Element e) {\n-        return !e.getAnnotationMirrors().isEmpty();\n-    }\n-\n@@ -364,4 +325,0 @@\n-    boolean isEnumConstant(Element e) {\n-        return e.getKind() == ENUM_CONSTANT;\n-    }\n-\n@@ -514,22 +471,0 @@\n-    public boolean isPrimitive(TypeMirror t) {\n-        return new SimpleTypeVisitor14<Boolean, Void>() {\n-\n-            @Override\n-            public Boolean visitNoType(NoType t, Void p) {\n-                return t.getKind() == VOID;\n-            }\n-            @Override\n-            public Boolean visitPrimitive(PrimitiveType t, Void p) {\n-                return true;\n-            }\n-            @Override\n-            public Boolean visitArray(ArrayType t, Void p) {\n-                return visit(t.getComponentType());\n-            }\n-            @Override\n-            protected Boolean defaultAction(TypeMirror e, Void p) {\n-                return false;\n-            }\n-        }.visit(t);\n-    }\n-\n@@ -537,7 +472,4 @@\n-        ElementKind kind = e.getKind();\n-        switch (kind) {\n-            case CONSTRUCTOR: case METHOD: case INSTANCE_INIT:\n-                return true;\n-            default:\n-                return false;\n-        }\n+        return switch (e.getKind()) {\n+            case CONSTRUCTOR, METHOD, INSTANCE_INIT -> true;\n+            default -> false;\n+        };\n@@ -547,9 +479,5 @@\n-        ElementKind kind = e.getKind();\n-        switch(kind) {\n-              case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:\n-              case LOCAL_VARIABLE: case PARAMETER:\n-              case RESOURCE_VARIABLE:\n-                  return true;\n-              default:\n-                  return false;\n-        }\n+        return switch (e.getKind()) {\n+            case ENUM_CONSTANT, EXCEPTION_PARAMETER, FIELD, LOCAL_VARIABLE,\n+                    PARAMETER, RESOURCE_VARIABLE -> true;\n+            default -> false;\n+        };\n@@ -559,6 +487,4 @@\n-        switch (e.getKind()) {\n-            case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:\n-                return true;\n-            default:\n-                return false;\n-        }\n+        return switch (e.getKind()) {\n+            case CLASS, ENUM, INTERFACE, ANNOTATION_TYPE, RECORD -> true;\n+            default -> false;\n+        };\n@@ -696,8 +622,0 @@\n-    public boolean isErrorType(TypeMirror t) {\n-        return t.getKind() == ERROR;\n-    }\n-\n-    public boolean isIntersectionType(TypeMirror t) {\n-        return t.getKind() == INTERSECTION;\n-    }\n-\n@@ -716,4 +634,0 @@\n-    public boolean isWildCard(TypeMirror t) {\n-        return t.getKind() == WILDCARD;\n-    }\n-\n@@ -721,1 +635,1 @@\n-        return bound.equals(getObjectType()) && !isAnnotated(bound);\n+        return typeUtils.isSameType(bound, getObjectType()) && !isAnnotated(bound);\n@@ -786,3 +700,12 @@\n-    \/**\n-     * Return the type containing the method that this method overrides.\n-     * It may be a {@code TypeElement} or a {@code TypeParameterElement}.\n+    \/*\n+     * Returns the closest superclass (not the superinterface) that contains\n+     * a method that is both:\n+     *\n+     *   - overridden by the specified method, and\n+     *   - is not itself a *simple* override\n+     *\n+     * If no such class can be found, returns null.\n+     *\n+     * If the specified method belongs to an interface, the only considered\n+     * superclass is java.lang.Object no matter how many other interfaces\n+     * that interface extends.\n@@ -790,1 +713,1 @@\n-    public TypeMirror overriddenType(ExecutableElement method) {\n+    public DeclaredType overriddenType(ExecutableElement method) {\n@@ -803,14 +726,0 @@\n-    \/**\n-     * Return the class that originally defined the method that\n-     * is overridden by the current definition, or null if no\n-     * such class exists.\n-     *\n-     * @return a TypeElement representing the superclass that\n-     * originally defined this method, null if this method does\n-     * not override a definition in a superclass.\n-     *\/\n-    public TypeElement overriddenClass(ExecutableElement ee) {\n-        TypeMirror type = overriddenType(ee);\n-        return (type != null) ? asTypeElement(type) : null;\n-    }\n-\n@@ -823,2 +732,2 @@\n-                t.getKind() == DECLARED;\n-                t = getSuperType(asTypeElement(t))) {\n+             t.getKind() == DECLARED;\n+             t = getSuperType(asTypeElement(t))) {\n@@ -837,1 +746,1 @@\n-            if (t.equals(getObjectType()))\n+            if (typeUtils.isSameType(t, getObjectType()))\n@@ -919,1 +828,2 @@\n-        getAllInterfaces(te.asType(), results);\n+        addSuperInterfaces(te.asType(), results, new HashSet<>());\n+        assert noSameTypes(results);\n@@ -923,2 +833,35 @@\n-    private void getAllInterfaces(TypeMirror type, Set<TypeMirror> results) {\n-        List<? extends TypeMirror> intfacs = typeUtils.directSupertypes(type);\n+    private boolean noSameTypes(Set<TypeMirror> results) {\n+        for (TypeMirror t1 : results) {\n+            for (TypeMirror t2 : results) {\n+                if (t1 == t2) {\n+                    continue;\n+                }\n+                if (typeUtils.isSameType(t1, t2)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/*\n+     * Instances of TypeMirror should be compared using\n+     * Types.isSameType. However, there's no hash function\n+     * consistent with that method. This makes it problematic to\n+     * store TypeMirror in a collection that relies on hashing.\n+     *\n+     * To work around that, along with accumulating the resulting set of type\n+     * mirrors, we also maintain a set of elements that correspond to those\n+     * type mirrors. Element provides strong equals and hashCode. We only add\n+     * a type mirror into the result set if we don't already have an element\n+     * that corresponds to this type mirror in the set of seen elements.\n+     *\n+     * Although this might seem wrong, as an instance of Element corresponds\n+     * to multiple instances of TypeMirror (one-to-many), in an\n+     * inheritance hierarchy the correspondence is effectively one-to-one.\n+     * This is because it is NOT possible for a type to be a subtype\n+     * of different generic invocations of the same supertype; e.g.,\n+     *\n+     *     interface X extends G<A>, G<B>\n+     *\/\n+    private void addSuperInterfaces(TypeMirror type, Set<TypeMirror> results, Set<Element> visited) {\n@@ -926,2 +869,2 @@\n-        for (TypeMirror intfac : intfacs) {\n-            if (intfac == getObjectType())\n+        for (TypeMirror t : typeUtils.directSupertypes(type)) {\n+            if (typeUtils.isSameType(t, getObjectType()))\n@@ -929,1 +872,1 @@\n-            TypeElement e = asTypeElement(intfac);\n+            TypeElement e = asTypeElement(t);\n@@ -931,4 +874,7 @@\n-                if (isPublic(e) || isLinkable(e))\n-                    results.add(intfac);\n-\n-                getAllInterfaces(intfac, results);\n+                if (!visited.add(e)) {\n+                    continue; \/\/ seen it before\n+                }\n+                if (isPublic(e) || isLinkable(e)) {\n+                    results.add(t);\n+                }\n+                addSuperInterfaces(t, results, visited);\n@@ -936,0 +882,2 @@\n+                \/\/ there can be at most one superclass and it is not null\n+                assert superType == null && t != null : superType;\n@@ -937,1 +885,1 @@\n-                superType = intfac;\n+                superType = t;\n@@ -942,1 +890,1 @@\n-            getAllInterfaces(superType, results);\n+            addSuperInterfaces(superType, results, visited);\n@@ -998,7 +946,0 @@\n-    \/**\n-     * Enclose in quotes, used for paths and filenames that contains spaces\n-     *\/\n-    public String quote(String filepath) {\n-        return (\"\\\"\" + filepath + \"\\\"\");\n-    }\n-\n@@ -1179,2 +1120,1 @@\n-        if (isInterface(te) || isAnnotationType(te) ||\n-                te.asType().equals(getObjectType())) {\n+        if (checkType(te)) {\n@@ -1190,0 +1130,5 @@\n+    private boolean checkType(TypeElement te) {\n+        return isInterface(te) || typeUtils.isSameType(te.asType(), getObjectType())\n+                || isAnnotationType(te);\n+    }\n+\n@@ -1191,2 +1136,1 @@\n-        if (isAnnotationType(te) || isInterface(te) ||\n-                te.asType().equals(getObjectType())) {\n+        if (checkType(te)) {\n@@ -1205,1 +1149,0 @@\n-\n@@ -1216,1 +1159,1 @@\n-     *         be found..\n+     *         be found.\n@@ -1236,1 +1179,1 @@\n-        if (te.asType().equals(superType)) {\n+        if (typeUtils.isSameType(te.asType(), superType)) {\n@@ -1484,4 +1427,8 @@\n-    \/**\n-     * Returns true if the method has no comments, or a lone &commat;inheritDoc.\n-     * @param m a method\n-     * @return true if there are no comments, false otherwise\n+    \/*\n+     * Returns true if the passed method does not change the specification it\n+     * inherited.\n+     *\n+     * If the passed method is not deprecated and has either no comment or a\n+     * comment consisting of single {@inheritDoc} tag, the inherited\n+     * specification is deemed unchanged and this method returns true;\n+     * otherwise this method returns false.\n@@ -1565,13 +1512,0 @@\n-    \/**\n-     * A general purpose case sensitive String comparator, which\n-     * compares two Strings using a Collator strength of \"SECONDARY\".\n-     *\n-     * @param s1 first String to compare.\n-     * @param s2 second String to compare.\n-     * @return a negative integer, zero, or a positive integer as the first\n-     *         argument is less than, equal to, or greater than the second.\n-     *\/\n-    public int compareCaseCompare(String s1, String s2) {\n-        return compareStrings(false, s1, s2);\n-    }\n-\n@@ -1769,20 +1703,0 @@\n-    \/**\n-     * Returns the documented annotation interfaces in a package.\n-     *\n-     * @param pkg the package\n-     * @return the annotation interfaces\n-     *\/\n-    public List<TypeElement> getAnnotationTypes(PackageElement pkg) {\n-        return getDocumentedItems(pkg, ANNOTATION_TYPE, TypeElement.class);\n-    }\n-\n-    \/**\n-     * Returns the documented record classes in a package.\n-     *\n-     * @param pkg the package\n-     * @return the record classes\n-     *\/\n-    public List<TypeElement> getRecords(PackageElement pkg) {\n-        return getDocumentedItems(pkg, RECORD, TypeElement.class);\n-    }\n-\n@@ -1841,7 +1755,0 @@\n-    public int getOrdinalValue(VariableElement member) {\n-        if (member == null || member.getKind() != ENUM_CONSTANT) {\n-            throw new IllegalArgumentException(\"must be an enum constant: \" + member);\n-        }\n-        return member.getEnclosingElement().getEnclosedElements().indexOf(member);\n-    }\n-\n@@ -1919,10 +1826,0 @@\n-    \/**\n-     * Returns the documented interfaces in a package.\n-     *\n-     * @param pkg the package\n-     * @return the interfaces\n-     *\/\n-    public List<TypeElement> getInterfaces(PackageElement pkg)  {\n-        return getDocumentedItems(pkg, INTERFACE, TypeElement.class);\n-    }\n-\n@@ -1939,10 +1836,0 @@\n-    \/**\n-     * Returns the documented enum classes in a package.\n-     *\n-     * @param pkg the package\n-     * @return the interfaces\n-     *\/\n-    public List<TypeElement> getEnums(PackageElement pkg) {\n-        return getDocumentedItems(pkg, ENUM, TypeElement.class);\n-    }\n-\n@@ -2350,96 +2237,0 @@\n-    public boolean isAttribute(DocTree doctree) {\n-        return isKind(doctree, ATTRIBUTE);\n-    }\n-\n-    public boolean isAuthor(DocTree doctree) {\n-        return isKind(doctree, AUTHOR);\n-    }\n-\n-    public boolean isComment(DocTree doctree) {\n-        return isKind(doctree, COMMENT);\n-    }\n-\n-    public boolean isDeprecated(DocTree doctree) {\n-        return isKind(doctree, DEPRECATED);\n-    }\n-\n-    public boolean isDocComment(DocTree doctree) {\n-        return isKind(doctree, DOC_COMMENT);\n-    }\n-\n-    public boolean isDocRoot(DocTree doctree) {\n-        return isKind(doctree, DOC_ROOT);\n-    }\n-\n-    public boolean isEndElement(DocTree doctree) {\n-        return isKind(doctree, END_ELEMENT);\n-    }\n-\n-    public boolean isEntity(DocTree doctree) {\n-        return isKind(doctree, ENTITY);\n-    }\n-\n-    public boolean isErroneous(DocTree doctree) {\n-        return isKind(doctree, ERRONEOUS);\n-    }\n-\n-    public boolean isException(DocTree doctree) {\n-        return isKind(doctree, EXCEPTION);\n-    }\n-\n-    public boolean isIdentifier(DocTree doctree) {\n-        return isKind(doctree, IDENTIFIER);\n-    }\n-\n-    public boolean isInheritDoc(DocTree doctree) {\n-        return isKind(doctree, INHERIT_DOC);\n-    }\n-\n-    public boolean isLink(DocTree doctree) {\n-        return isKind(doctree, LINK);\n-    }\n-\n-    public boolean isLinkPlain(DocTree doctree) {\n-        return isKind(doctree, LINK_PLAIN);\n-    }\n-\n-    public boolean isLiteral(DocTree doctree) {\n-        return isKind(doctree, LITERAL);\n-    }\n-\n-    public boolean isOther(DocTree doctree) {\n-        return doctree.getKind() == DocTree.Kind.OTHER;\n-    }\n-\n-    public boolean isParam(DocTree doctree) {\n-        return isKind(doctree, PARAM);\n-    }\n-\n-    public boolean isReference(DocTree doctree) {\n-        return isKind(doctree, REFERENCE);\n-    }\n-\n-    public boolean isReturn(DocTree doctree) {\n-        return isKind(doctree, RETURN);\n-    }\n-\n-    public boolean isSee(DocTree doctree) {\n-        return isKind(doctree, SEE);\n-    }\n-\n-    public boolean isSerial(DocTree doctree) {\n-        return isKind(doctree, SERIAL);\n-    }\n-\n-    public boolean isSerialData(DocTree doctree) {\n-        return isKind(doctree, SERIAL_DATA);\n-    }\n-\n-    public boolean isSerialField(DocTree doctree) {\n-        return isKind(doctree, SERIAL_FIELD);\n-    }\n-\n-    public boolean isSince(DocTree doctree) {\n-        return isKind(doctree, SINCE);\n-    }\n-\n@@ -2454,20 +2245,0 @@\n-    public boolean isThrows(DocTree doctree) {\n-        return isKind(doctree, THROWS);\n-    }\n-\n-    public boolean isUnknownBlockTag(DocTree doctree) {\n-        return isKind(doctree, UNKNOWN_BLOCK_TAG);\n-    }\n-\n-    public boolean isUnknownInlineTag(DocTree doctree) {\n-        return isKind(doctree, UNKNOWN_INLINE_TAG);\n-    }\n-\n-    public boolean isValue(DocTree doctree) {\n-        return isKind(doctree, VALUE);\n-    }\n-\n-    public boolean isVersion(DocTree doctree) {\n-        return isKind(doctree, VERSION);\n-    }\n-\n@@ -2519,4 +2290,0 @@\n-    public List<? extends DocTree> getBlockTags(Element element, DocTree.Kind kind, DocTree.Kind altKind) {\n-        return getBlockTags(element, t -> t.getKind() == kind || t.getKind() == altKind);\n-    }\n-\n@@ -2595,1 +2362,1 @@\n-     * The entries may come from the AST and DocCommentParser, or may be autromatically\n+     * The entries may come from the AST and DocCommentParser, or may be automatically\n@@ -2798,13 +2565,0 @@\n-    public TypeElement getTopMostContainingTypeElement(Element e) {\n-        if (isPackage(e)) {\n-            return null;\n-        }\n-        TypeElement outer = getEnclosingTypeElement(e);\n-        if (outer == null)\n-            return (TypeElement)e;\n-        while (outer != null && outer.getNestingKind().isNested()) {\n-            outer = getEnclosingTypeElement(outer);\n-        }\n-        return outer;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":114,"deletions":360,"binary":false,"changes":474,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import java.util.Collection;\n@@ -66,1 +67,1 @@\n- * javax.lang.models view of what can be documented about a\n+ * javax.lang.model's view of what can be documented about a\n@@ -71,1 +72,1 @@\n- * Members: these are the members from jx.l.m's view but\n+ * Members: these are the members from j.l.m's view but\n@@ -149,2 +150,2 @@\n-    final TypeElement te;\n-    final TypeElement parent;\n+    private final TypeElement te;\n+    private final TypeElement parent;\n@@ -152,4 +153,4 @@\n-    final BaseConfiguration config;\n-    final BaseOptions options;\n-    final Utils utils;\n-    final VisibleMemberCache mcache;\n+    private final BaseConfiguration config;\n+    private final BaseOptions options;\n+    private final Utils utils;\n+    private final VisibleMemberCache mcache;\n@@ -161,1 +162,1 @@\n-    private Map<Kind, List<Element>> visibleMembers = null;\n+    private Map<Kind, List<Element>> visibleMembers;\n@@ -165,1 +166,1 @@\n-    Map<ExecutableElement, OverriddenMethodInfo> overriddenMethodTable\n+    private final Map<ExecutableElement, OverriddenMethodInfo> overriddenMethodTable\n@@ -181,1 +182,1 @@\n-    private synchronized void ensureInitialized() {\n+    private void ensureInitialized() {\n@@ -211,1 +212,1 @@\n-     * sole &commat;inheritDoc or devoid of any API comments.\n+     * sole {@code @inheritDoc} or devoid of any API comments.\n@@ -282,1 +283,1 @@\n-            return found.overridden;\n+            return found.overriddenMethod;\n@@ -288,1 +289,3 @@\n-     * Returns the simply overridden method.\n+     * {@return true if the specified method is NOT a simple override of some\n+     * other method, otherwise false}\n+     *\n@@ -290,1 +293,0 @@\n-     * @return the overridden method or null\n@@ -292,1 +294,1 @@\n-    public ExecutableElement getSimplyOverriddenMethod(ExecutableElement e) {\n+    public boolean isNotSimpleOverride(ExecutableElement e) {\n@@ -295,5 +297,2 @@\n-        OverriddenMethodInfo found = overriddenMethodTable.get(e);\n-        if (found != null && found.simpleOverride) {\n-            return found.overridden;\n-        }\n-        return null;\n+        var info = overriddenMethodTable.get(e);\n+        return info == null || !info.simpleOverride;\n@@ -309,1 +308,1 @@\n-     * @return the list of visible classes in this map.\n+     * @return the set of visible classes in this map\n@@ -530,4 +529,3 @@\n-            pvmt.overriddenMethodTable.entrySet().forEach(e -> {\n-                OverriddenMethodInfo p = e.getValue();\n-                if (!p.simpleOverride) { \/\/ consider only real overrides\n-                    List<ExecutableElement> list = overriddenByTable.computeIfAbsent(p.overridden,\n+            pvmt.overriddenMethodTable.forEach((method, methodInfo) -> {\n+                if (!methodInfo.simpleOverride) { \/\/ consider only real overrides\n+                    List<ExecutableElement> list = overriddenByTable.computeIfAbsent(methodInfo.overriddenMethod,\n@@ -535,1 +533,1 @@\n-                    list.add(e.getKey());\n+                    list.add(method);\n@@ -547,1 +545,1 @@\n-        \/\/ members of the overridenMethodTable field, so it must be\n+        \/\/ members of the overriddenMethodTable field, so it must be\n@@ -568,1 +566,1 @@\n-        List<Element> list = Stream.concat(localStream,inheritedMethodsList.stream())\n+        List<Element> list = Stream.concat(localStream, inheritedMethodsList.stream())\n@@ -578,1 +576,0 @@\n-        overriddenMethodTable = Collections.unmodifiableMap(overriddenMethodTable);\n@@ -853,1 +850,1 @@\n-                    .map(e -> clazz.cast(e))\n+                    .map(clazz::cast)\n@@ -970,1 +967,2 @@\n-    Map<ExecutableElement, SoftReference<ImplementedMethods>> implementMethodsFinders = new HashMap<>();\n+    private final Map<ExecutableElement, SoftReference<ImplementedMethods>>\n+            implementMethodsFinders = new HashMap<>();\n@@ -986,1 +984,1 @@\n-                .filter(m -> getSimplyOverriddenMethod(m) == null)\n+                .filter(this::isNotSimpleOverride)\n@@ -999,1 +997,1 @@\n-        private final List<ExecutableElement> methlist = new ArrayList<>();\n+        private final LinkedHashSet<ExecutableElement> methods = new LinkedHashSet<>();\n@@ -1002,1 +1000,3 @@\n-            TypeElement typeElement = utils.getEnclosingTypeElement(method);\n+            \/\/ ExecutableElement.getEnclosingElement() returns \"the class or\n+            \/\/ interface defining the executable\", which has to be TypeElement\n+            TypeElement typeElement = (TypeElement) method.getEnclosingElement();\n@@ -1004,7 +1004,0 @@\n-            \/*\n-             * Search for the method in the list of interfaces. If found check if it is\n-             * overridden by any other subinterface method which this class\n-             * implements. If it is not overridden, add it in the method list.\n-             * Do this recursively for all the extended interfaces for each interface\n-             * from the list.\n-             *\/\n@@ -1012,0 +1005,2 @@\n+                \/\/ TODO: this method also finds static methods which are pseudo-inherited;\n+                \/\/  this needs to be fixed\n@@ -1013,6 +1008,3 @@\n-                if (found != null) {\n-                    removeOverriddenMethod(found);\n-                    if (!overridingMethodFound(found)) {\n-                        methlist.add(found);\n-                        interfaces.put(found, interfaceType);\n-                    }\n+                if (found != null && !methods.contains(found)) {\n+                    methods.add(found);\n+                    interfaces.put(found, interfaceType);\n@@ -1024,1 +1016,1 @@\n-         * Return the list of interface methods which the method passed in the\n+         * Returns a collection of interface methods which the method passed in the\n@@ -1031,1 +1023,1 @@\n-         *<\/pre>\n+         * <\/pre>\n@@ -1033,1 +1025,1 @@\n-         * @return SortedSet<ExecutableElement> of implemented methods.\n+         * @return a collection of implemented methods\n@@ -1035,2 +1027,2 @@\n-        List<ExecutableElement> getImplementedMethods() {\n-            return methlist;\n+        Collection<ExecutableElement> getImplementedMethods() {\n+            return methods;\n@@ -1042,45 +1034,0 @@\n-\n-        \/**\n-         * Search in the method list and check if it contains a method which\n-         * is overridden by the method as parameter.  If found, remove the\n-         * overridden method from the method list.\n-         *\n-         * @param method Is this method overriding a method in the method list.\n-         *\/\n-        private void removeOverriddenMethod(ExecutableElement method) {\n-            TypeElement overriddenClass = utils.overriddenClass(method);\n-            if (overriddenClass != null) {\n-                for (int i = 0; i < methlist.size(); i++) {\n-                    TypeElement te = utils.getEnclosingTypeElement(methlist.get(i));\n-                    if (te == overriddenClass || utils.isSubclassOf(overriddenClass, te)) {\n-                        methlist.remove(i);  \/\/ remove overridden method\n-                        return;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Search in the already found methods' list and check if it contains\n-         * a method which is overriding the method parameter or is the method\n-         * parameter itself.\n-         *\n-         * @param method method to be searched\n-         *\/\n-        private boolean overridingMethodFound(ExecutableElement method) {\n-            TypeElement containingClass = utils.getEnclosingTypeElement(method);\n-            for (ExecutableElement listmethod : methlist) {\n-                if (containingClass == utils.getEnclosingTypeElement(listmethod)) {\n-                    \/\/ it's the same method.\n-                    return true;\n-                }\n-                TypeElement te = utils.overriddenClass(listmethod);\n-                if (te == null) {\n-                    continue;\n-                }\n-                if (te == containingClass || utils.isSubclassOf(te, containingClass)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n@@ -1089,17 +1036,2 @@\n-    \/**\n-     * A simple container to encapsulate an overridden method\n-     * and the type of override.\n-     *\/\n-    static class OverriddenMethodInfo {\n-        final ExecutableElement overridden;\n-        final boolean simpleOverride;\n-\n-        public OverriddenMethodInfo(ExecutableElement overridden, boolean simpleOverride) {\n-            this.overridden = overridden;\n-            this.simpleOverride = simpleOverride;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"OverriddenMethodInfo[\" + overridden + \",simple:\" + simpleOverride + \"]\";\n-        }\n+    private record OverriddenMethodInfo(ExecutableElement overriddenMethod,\n+                                        boolean simpleOverride) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":48,"deletions":116,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-                                    bound.equals(utils.getObjectType()) &&\n+                                    utils.typeUtils.isSameType(bound, utils.getObjectType()) &&\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/links\/LinkFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -988,2 +988,2 @@\n-            if (tree != dct.getFirstSentence().get(0)) {\n-                env.messages.warning(REFERENCE, tree, \"dc.return.not.first\");\n+            if (dct.getFirstSentence().isEmpty() || tree != dct.getFirstSentence().get(0)) {\n+                env.messages.warning(SYNTAX, tree, \"dc.return.not.first\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## jQuery v3.5.1\n+## jQuery v3.6.0\n@@ -5,2 +5,2 @@\n-jQuery v 3.5.1\n-Copyright JS Foundation and other contributors, https:\/\/js.foundation\/\n+jQuery v 3.6.0\n+Copyright OpenJS Foundation and other contributors, https:\/\/openjsf.org\/\n@@ -29,1 +29,1 @@\n-The jQuery JavaScript Library v3.5.1 also includes Sizzle.js\n+The jQuery JavaScript Library v3.6.0 also includes Sizzle.js\n","filename":"src\/jdk.javadoc\/share\/legal\/jquery.md","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-            position.type_index = cr.readUnsignedShort();;\n+            position.type_index = cr.readUnsignedShort();\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/TypeAnnotation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -504,1 +504,1 @@\n-            MessageOutput.println(\"Threadgroup name not specified.\");\n+            ThreadInfo.setThreadGroup(null); \/\/ reset to default (top level ThreadGroup)\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/Commands.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -996,0 +996,2 @@\n+            } else if (token.startsWith(\"-R\")) {\n+                javaArgs = addArgument(javaArgs, token.substring(2));\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTY.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,1 +315,0 @@\n-        {\"Threadgroup name not specified.\", \"Threadgroup name not specified.\"},\n@@ -357,1 +356,1 @@\n-             \"threads [threadgroup]     -- list threads\\n\" +\n+             \"threads [threadgroup]     -- list threads in threadgroup. Use current threadgroup if none specified.\\n\" +\n@@ -380,1 +379,2 @@\n-             \"threadgroup <name>        -- set current threadgroup\\n\" +\n+             \"threadgroup <name>        -- set current threadgroup to <name>\\n\" +\n+             \"threadgroup               -- set current threadgroup back to the top level threadgroup\\n\" +\n@@ -480,0 +480,1 @@\n+             \"    -R<option>        forward <option> to debuggee process if launched by jdb, otherwise ignored\\n\" +\n@@ -481,1 +482,1 @@\n-             \"options forwarded to debuggee process:\\n\" +\n+             \"options forwarded to debuggee process if lauched by jdb (shorthand instead of using -R):\\n\" +\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,1 +305,0 @@\n-        {\"Threadgroup name not specified.\", \"\\u30B9\\u30EC\\u30C3\\u30C9\\u30B0\\u30EB\\u30FC\\u30D7\\u540D\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\\u3002\"},\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources_ja.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,1 +305,0 @@\n-        {\"Threadgroup name not specified.\", \"\\u672A\\u6307\\u5B9A\\u7EBF\\u7A0B\\u7EC4\\u540D\\u3002\"},\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources_zh_CN.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 1995, 2018, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,2 +233,3 @@\n-Passes \\f[I]option\\f[R] to the JVM, where option is one of the options\n-described on the reference page for the Java application launcher.\n+Passes \\f[I]option\\f[R] to the JDB JVM, where option is one of the\n+options described on the reference page for the Java application\n+launcher.\n@@ -242,0 +243,9 @@\n+.B \\f[CB]\\-R\\f[R]\\f[I]option\\f[R]\n+Passes \\f[I]option\\f[R] to the debuggee JVM, where option is one of the\n+options described on the reference page for the Java application\n+launcher.\n+For example, \\f[CB]\\-R\\-Xms48m\\f[R] sets the startup memory to 48 MB.\n+See \\f[I]Overview of Java Options\\f[R] in \\f[B]java\\f[R].\n+.RS\n+.RE\n+.TP\n","filename":"src\/jdk.jdi\/share\/man\/jdb.1","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -113,0 +113,6 @@\n+    char* signature;\n+    error = classSignature(klass, &signature, NULL);\n+    if (error != JVMTI_ERROR_NONE) {\n+        EXIT_ERROR(error,\"signature\");\n+    }\n+\n@@ -114,1 +120,1 @@\n-        \/\/ Check this is not already tagged.\n+        \/\/ Check if already tagged.\n@@ -120,1 +126,7 @@\n-        JDI_ASSERT(tag == NOT_TAGGED);\n+        if (tag != NOT_TAGGED) {\n+            \/\/ If tagged, the old tag better be the same as the new.\n+            char* oldSignature = (char*)jlong_to_ptr(tag);\n+            JDI_ASSERT(strcmp(signature, oldSignature) == 0);\n+            jvmtiDeallocate(signature);\n+            return;\n+        }\n@@ -123,5 +135,0 @@\n-    char* signature;\n-    error = classSignature(klass, &signature, NULL);\n-    if (error != JVMTI_ERROR_NONE) {\n-        EXIT_ERROR(error,\"signature\");\n-    }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/classTrack.c","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -537,0 +537,56 @@\n+\/*\n+ * Run the event through each HandlerNode's filter, and if it passes, call the HandlerNode's\n+ * HandlerFunction for the event, and then report all accumulated events to the debugger.\n+ *\/\n+static void\n+filterAndHandleEvent(JNIEnv *env, EventInfo *evinfo, EventIndex ei,\n+                     struct bag *eventBag, jbyte eventSessionID)\n+{\n+    debugMonitorEnter(handlerLock);\n+    {\n+        HandlerNode *node;\n+        char        *classname;\n+\n+        \/* We must keep track of all classes prepared to know what's unloaded *\/\n+        if (evinfo->ei == EI_CLASS_PREPARE) {\n+            classTrack_addPreparedClass(env, evinfo->clazz);\n+        }\n+\n+        node = getHandlerChain(ei)->first;\n+        classname = getClassname(evinfo->clazz);\n+\n+        \/* Filter the event over each handler node. *\/\n+        while (node != NULL) {\n+            \/* Save next so handlers can remove themselves. *\/\n+            HandlerNode *next = NEXT(node);\n+            jboolean shouldDelete;\n+\n+            if (eventFilterRestricted_passesFilter(env, classname,\n+                                                   evinfo, node,\n+                                                   &shouldDelete)) {\n+                HandlerFunction func = HANDLER_FUNCTION(node);\n+                if (func == NULL) {\n+                    EXIT_ERROR(AGENT_ERROR_INTERNAL,\"handler function NULL\");\n+                }\n+                \/* Handle the event by calling the event handler. *\/\n+                (*func)(env, evinfo, node, eventBag);\n+            }\n+            if (shouldDelete) {\n+                \/* We can safely free the node now that we are done using it. *\/\n+                (void)freeHandler(node);\n+            }\n+            node = next;\n+        }\n+        jvmtiDeallocate(classname);\n+    }\n+    debugMonitorExit(handlerLock);\n+\n+    \/*\n+     * The events destined for the debugger were accumulated in eventBag. Report all these events.\n+     *\/\n+    if (eventBag != NULL) {\n+        reportEvents(env, eventSessionID, evinfo->thread, evinfo->ei,\n+                     evinfo->clazz, evinfo->method, evinfo->location, eventBag);\n+    }\n+}\n+\n@@ -637,45 +693,1 @@\n-    debugMonitorEnter(handlerLock);\n-    {\n-        HandlerNode *node;\n-        char        *classname;\n-\n-        \/* We must keep track of all classes prepared to know what's unloaded *\/\n-        if (evinfo->ei == EI_CLASS_PREPARE) {\n-            classTrack_addPreparedClass(env, evinfo->clazz);\n-        }\n-\n-        node = getHandlerChain(evinfo->ei)->first;\n-        classname = getClassname(evinfo->clazz);\n-\n-        while (node != NULL) {\n-            \/* save next so handlers can remove themselves *\/\n-            HandlerNode *next = NEXT(node);\n-            jboolean shouldDelete;\n-\n-            if (eventFilterRestricted_passesFilter(env, classname,\n-                                                   evinfo, node,\n-                                                   &shouldDelete)) {\n-                HandlerFunction func;\n-\n-                func = HANDLER_FUNCTION(node);\n-                if ( func == NULL ) {\n-                    EXIT_ERROR(AGENT_ERROR_INTERNAL,\"handler function NULL\");\n-                }\n-                (*func)(env, evinfo, node, eventBag);\n-            }\n-            if (shouldDelete) {\n-                \/* We can safely free the node now that we are done\n-                 * using it.\n-                 *\/\n-                (void)freeHandler(node);\n-            }\n-            node = next;\n-        }\n-        jvmtiDeallocate(classname);\n-    }\n-    debugMonitorExit(handlerLock);\n-\n-    if (eventBag != NULL) {\n-        reportEvents(env, eventSessionID, thread, evinfo->ei,\n-                evinfo->clazz, evinfo->method, evinfo->location, eventBag);\n-    }\n+    filterAndHandleEvent(env, evinfo, ei, eventBag, eventSessionID);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":58,"deletions":46,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -466,4 +466,9 @@\n-        if (    (!eventFilter_predictFiltering(step->stepHandlerNode,\n-                                               clazz, classname))\n-             && (   step->granularity != JDWP_STEP_SIZE(LINE)\n-                 || hasLineNumbers(method) ) ) {\n+        \/*\n+         * We need to figure out if we are entering a method that we want to resume\n+         * single stepping in. If the class of this method is being filtered out, then\n+         * we don't resume. Otherwise, if we are not line stepping then we resume, and\n+         * if we are line stepping we don't resume unless the method has LineNumbers.\n+         *\/\n+        jboolean filteredOut = eventFilter_predictFiltering(step->stepHandlerNode, clazz, classname);\n+        jboolean isStepLine = step->granularity == JDWP_STEP_SIZE(LINE);\n+        if (!filteredOut && (!isStepLine || hasLineNumbers(method))) {\n@@ -471,3 +476,2 @@\n-             * We've found a suitable method in which to stop. Step\n-             * until we reach the next safe location to complete the step->,\n-             * and we can get rid of the method entry handler.\n+             * We've found a suitable method in which to resume stepping.\n+             * We can also get rid of the method entry handler now.\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/stepControl.c","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    unsigned int isStarted : 1;        \/* THREAD_START or VIRTUAL_THREAD_SCHEDULED event received. *\/\n+    unsigned int isStarted : 1;        \/* THREAD_START event received. *\/\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,2 +115,2 @@\n-        Objects.requireNonNull(annotationType);\n-        Objects.requireNonNull(values);\n+        Objects.requireNonNull(annotationType, \"annotationType\");\n+        Objects.requireNonNull(values, \"values\");\n@@ -295,1 +295,1 @@\n-        Objects.requireNonNull(name);\n+        Objects.requireNonNull(name, \"name\");\n@@ -317,1 +317,1 @@\n-        Objects.requireNonNull(name);\n+        Objects.requireNonNull(name, \"name\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/AnnotationElement.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-        Objects.requireNonNull(path);\n+        Objects.requireNonNull(path, \"path\");\n@@ -159,1 +159,1 @@\n-        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(reader, \"reader\");\n@@ -180,0 +180,1 @@\n+        Objects.requireNonNull(name, \"name\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Configuration.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-        Objects.requireNonNull(fields);\n-        Objects.requireNonNull(annotationElements);\n+        Objects.requireNonNull(annotationElements, \"annotationElements\");\n+        Objects.requireNonNull(fields, \"fields\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -58,2 +59,4 @@\n-             delegate.with(name, value);\n-             return this;\n+            Objects.requireNonNull(name, \"name\");\n+            Objects.requireNonNull(value, \"value\");\n+            delegate.with(name, value);\n+            return this;\n@@ -114,0 +117,1 @@\n+        Objects.requireNonNull(duration, \"duration\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventSettings.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        Objects.requireNonNull(name);\n+        Objects.requireNonNull(name, \"name\");\n@@ -184,1 +184,1 @@\n-        Objects.requireNonNull(annotationClass);\n+        Objects.requireNonNull(annotationClass, \"annotationClass\");\n@@ -201,1 +201,1 @@\n-        Objects.requireNonNull(eventClass);\n+        Objects.requireNonNull(eventClass, \"eventClass\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-        Objects.requireNonNull(eventClass);\n+        Objects.requireNonNull(eventClass, \"eventClass\");\n@@ -145,1 +145,1 @@\n-        Objects.requireNonNull(eventClass);\n+        Objects.requireNonNull(eventClass, \"eventClass\");\n@@ -218,2 +218,2 @@\n-        Objects.requireNonNull(eventClass);\n-        Objects.requireNonNull(hook);\n+        Objects.requireNonNull(eventClass, \"eventClass\");\n+        Objects.requireNonNull(hook, \"hook\");\n@@ -240,1 +240,1 @@\n-        Objects.requireNonNull(hook);\n+        Objects.requireNonNull(hook, \"hook\");\n@@ -277,1 +277,1 @@\n-        Objects.requireNonNull(changeListener);\n+        Objects.requireNonNull(changeListener, \"changeListener\");\n@@ -301,1 +301,1 @@\n-        Objects.requireNonNull(changeListener);\n+        Objects.requireNonNull(changeListener, \"changeListener\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorder.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-        super(Objects.requireNonNull(name));\n+        super(Objects.requireNonNull(name, \"name\"));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorderPermission.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,2 @@\n-            Objects.requireNonNull(value);\n+            Objects.requireNonNull(name, \"name\");\n+            Objects.requireNonNull(value, \"value\");\n@@ -104,1 +105,1 @@\n-        Objects.requireNonNull(settings);\n+        Objects.requireNonNull(settings, \"settings\");\n@@ -158,1 +159,1 @@\n-        this(configuration.getSettings());\n+        this(Objects.requireNonNull(configuration, \"configuration\").getSettings());\n@@ -190,1 +191,1 @@\n-        Objects.requireNonNull(delay);\n+        Objects.requireNonNull(delay, \"delay\");\n@@ -321,1 +322,1 @@\n-        Objects.requireNonNull(settings);\n+        Objects.requireNonNull(settings, \"settings\");\n@@ -378,1 +379,1 @@\n-        Objects.requireNonNull(destination);\n+        Objects.requireNonNull(destination, \"destination\");\n@@ -512,1 +513,1 @@\n-        Objects.requireNonNull(name);\n+        Objects.requireNonNull(name, \"name\");\n@@ -622,1 +623,1 @@\n-        Objects.requireNonNull(name);\n+        Objects.requireNonNull(name, \"name\");\n@@ -643,1 +644,1 @@\n-        Objects.requireNonNull(name);\n+        Objects.requireNonNull(name, \"name\");\n@@ -660,1 +661,1 @@\n-        Objects.requireNonNull(eventClass);\n+        Objects.requireNonNull(eventClass, \"eventClass\");\n@@ -678,1 +679,1 @@\n-        Objects.requireNonNull(eventClass);\n+        Objects.requireNonNull(eventClass, \"eventClass\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Recording.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -142,1 +142,3 @@\n-        Objects.requireNonNull(annotations);\n+        Objects.requireNonNull(type, \"type\");\n+        Objects.requireNonNull(name, \"name\");\n+        Objects.requireNonNull(annotations, \"annotations\");\n@@ -274,1 +276,1 @@\n-        Objects.requireNonNull(annotationType);\n+        Objects.requireNonNull(annotationType, \"annotationType\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/ValueDescriptor.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-        Objects.requireNonNull(directory);\n+        Objects.requireNonNull(directory, \"directory\");\n@@ -182,0 +182,1 @@\n+        Objects.requireNonNull(file, \"file\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-        Objects.requireNonNull(name);\n+        Objects.requireNonNull(name, \"name\");\n@@ -332,1 +332,1 @@\n-        throw new IllegalArgumentException(\"\\\"Attempt to get unknown field \\\"\" + name + \"\\\"\");\n+        throw new IllegalArgumentException(\"Attempt to get unknown field \\\"\" + name + \"\\\"\");\n@@ -339,1 +339,1 @@\n-        Objects.requireNonNull(name);\n+        Objects.requireNonNull(name, \"name\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedObject.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,2 @@\n-\n+import java.util.Objects;\n+import java.util.function.Predicate;\n@@ -41,0 +42,2 @@\n+import jdk.jfr.internal.consumer.ChunkParser.ParserConfiguration;\n+import jdk.jfr.internal.consumer.ParserFilter;\n@@ -46,0 +49,1 @@\n+import jdk.jfr.internal.consumer.filter.ChunkWriter;\n@@ -59,0 +63,1 @@\n+    private final ChunkWriter chunkWriter;\n@@ -78,0 +83,1 @@\n+        Objects.requireNonNull(file, \"file\");\n@@ -80,0 +86,9 @@\n+        this.chunkWriter = null;\n+        findNext();\n+    }\n+\n+    \/\/ Only used by RecordingFile::write(Path, Predicate<RecordedEvent>)\n+    private RecordingFile(ChunkWriter chunkWriter) throws IOException {\n+        this.file = null; \/\/ not used\n+        this.input = chunkWriter.getInput();\n+        this.chunkWriter = chunkWriter;\n@@ -202,0 +217,28 @@\n+    \/**\n+     * Filter out events and write them to a new file.\n+     *\n+     * @param destination path where the new file should be written, not\n+     *                    {@code null}\n+     *\n+     * @param filter      filter that determines if an event should be included, not\n+     *                    {@code null}\n+     * @throws IOException       if an I\/O error occurred, it's not a Flight\n+     *                           Recorder file or a version of a JFR file that can't\n+     *                           be parsed\n+     *\n+     * @throws SecurityException if a security manager exists and its\n+     *                           {@code checkWrite} method denies write access to the\n+     *                           file\n+     *\/\n+    public void write(Path destination, Predicate<RecordedEvent> filter) throws IOException {\n+        Objects.requireNonNull(destination, \"destination\");\n+        Objects.requireNonNull(filter, \"filter\");\n+        try (ChunkWriter cw = new ChunkWriter(file.toPath(), destination, filter)) {\n+            try (RecordingFile rf = new RecordingFile(cw)) {\n+                while (rf.hasMoreEvents()) {\n+                    rf.readEvent();\n+                }\n+            }\n+        }\n+    }\n+\n@@ -240,1 +283,0 @@\n-\n@@ -245,1 +287,1 @@\n-                chunkParser = new ChunkParser(input, parserState);\n+                chunkParser = createChunkParser();\n@@ -247,1 +289,1 @@\n-                chunkParser = chunkParser.nextChunkParser();\n+                chunkParser = nextChunkParser();\n@@ -249,0 +291,1 @@\n+                endChunkParser();\n@@ -259,0 +302,30 @@\n+    private ChunkParser createChunkParser() throws IOException {\n+        if (chunkWriter != null) {\n+            boolean reuse = true;\n+            boolean ordered = false;\n+            ParserConfiguration pc = new ParserConfiguration(0, Long.MAX_VALUE, reuse, ordered, ParserFilter.ACCEPT_ALL, chunkWriter);\n+            ChunkParser chunkParser = new ChunkParser(chunkWriter.getInput(), pc, new ParserState());\n+            chunkWriter.beginChunk(chunkParser.getHeader());\n+            return chunkParser;\n+        } else {\n+            return new ChunkParser(input, parserState);\n+        }\n+    }\n+\n+    private void endChunkParser() throws IOException {\n+        if (chunkWriter != null) {\n+            chunkWriter.endChunk(chunkParser.getHeader());\n+        }\n+    }\n+\n+    private ChunkParser nextChunkParser() throws IOException {\n+        if (chunkWriter != null) {\n+            chunkWriter.endChunk(chunkParser.getHeader());\n+        }\n+        ChunkParser next = chunkParser.nextChunkParser();\n+        if (chunkWriter != null) {\n+            chunkWriter.beginChunk(next.getHeader());\n+        }\n+        return next;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingFile.java","additions":78,"deletions":5,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -100,0 +100,4 @@\n+        this(Map.of());\n+    }\n+\n+    private RecordingStream(Map<String, String> settings) {\n@@ -120,0 +124,3 @@\n+        if (!settings.isEmpty()) {\n+            recording.setSettings(settings);\n+        }\n@@ -151,2 +158,1 @@\n-        this();\n-        recording.setSettings(configuration.getSettings());\n+        this(Objects.requireNonNull(configuration, \"configuration\").getSettings());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-        Objects.requireNonNull(startTime);\n+        Objects.requireNonNull(startTime, \"startTime\");\n@@ -128,1 +128,1 @@\n-        Objects.requireNonNull(endTime);\n+        Objects.requireNonNull(endTime, \"endTime\");\n@@ -139,1 +139,1 @@\n-        Objects.requireNonNull(action);\n+        Objects.requireNonNull(action, \"action\");\n@@ -145,2 +145,2 @@\n-        Objects.requireNonNull(eventName);\n-        Objects.requireNonNull(action);\n+        Objects.requireNonNull(eventName, \"eventName\");\n+        Objects.requireNonNull(action, \"action\");\n@@ -152,1 +152,1 @@\n-        Objects.requireNonNull(action);\n+        Objects.requireNonNull(action, \"action\");\n@@ -158,1 +158,1 @@\n-        Objects.requireNonNull(action);\n+        Objects.requireNonNull(action, \"action\");\n@@ -164,1 +164,1 @@\n-        Objects.requireNonNull(action);\n+        Objects.requireNonNull(action, \"action\");\n@@ -170,1 +170,1 @@\n-        Objects.requireNonNull(action);\n+        Objects.requireNonNull(action, \"action\");\n@@ -181,1 +181,1 @@\n-        Objects.requireNonNull(timeout);\n+        Objects.requireNonNull(timeout, \"timeout\");\n@@ -301,1 +301,1 @@\n-        Objects.requireNonNull(action);\n+        Objects.requireNonNull(action, \"action\");\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    static final long HEADER_SIZE = 68;\n+    public static final long HEADER_SIZE = 68;\n@@ -39,1 +39,1 @@\n-    static final long CHUNK_SIZE_POSITION = 8;\n+    public static final long CHUNK_SIZE_POSITION = 8;\n@@ -95,4 +95,4 @@\n-        input.readRawLong(); \/\/ constant pool position\n-        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Chunk: constantPoolPosition=\" + constantPoolPosition);\n-        input.readRawLong(); \/\/ metadata position\n-        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Chunk: metadataPosition=\" + metadataPosition);\n+        long cp = input.readRawLong(); \/\/ constant pool position\n+        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Chunk: constantPoolPosition=\" + cp);\n+        long mp = input.readRawLong(); \/\/ metadata position\n+        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Chunk: metadataPosition=\" + mp);\n@@ -112,0 +112,10 @@\n+    private byte readFileState() throws IOException {\n+        byte fs;\n+        input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);\n+        while ((fs = input.readPhysicalByte()) == UPDATING_CHUNK_HEADER) {\n+            Utils.takeNap(1);\n+            input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);\n+        }\n+        return fs;\n+    }\n+\n@@ -114,6 +124,1 @@\n-            byte fileState1;\n-            input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);\n-            while ((fileState1 = input.readPhysicalByte()) == UPDATING_CHUNK_HEADER) {\n-                Utils.takeNap(1);\n-                input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);\n-            }\n+            byte fileState1 = readFileState();\n@@ -172,1 +177,0 @@\n-            input.positionPhysical(absoluteChunkStart + FILE_STATE_POSITION);\n@@ -174,2 +178,2 @@\n-                byte filestate = input.readPhysicalByte();\n-                if (filestate == 0) {\n+                byte fileState = readFileState();\n+                if (fileState == 0) {\n@@ -246,1 +250,1 @@\n-    public long getMetataPosition() {\n+    public long getMetadataPosition() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkHeader.java","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+import jdk.jfr.internal.consumer.filter.CheckpointEvent;\n+import jdk.jfr.internal.consumer.filter.ChunkWriter;\n@@ -51,1 +53,1 @@\n-    static final class ParserConfiguration {\n+    public static final class ParserConfiguration {\n@@ -55,0 +57,1 @@\n+        private final ChunkWriter chunkWriter;\n@@ -59,1 +62,1 @@\n-        ParserConfiguration(long filterStart, long filterEnd, boolean reuse, boolean ordered, ParserFilter filter) {\n+        public ParserConfiguration(long filterStart, long filterEnd, boolean reuse, boolean ordered, ParserFilter filter, ChunkWriter chunkWriter) {\n@@ -65,0 +68,1 @@\n+            this.chunkWriter = chunkWriter;\n@@ -68,1 +72,1 @@\n-            this(0, Long.MAX_VALUE, false, false, ParserFilter.ACCEPT_ALL);\n+            this(0, Long.MAX_VALUE, false, false, ParserFilter.ACCEPT_ALL, null);\n@@ -76,1 +80,1 @@\n-    private enum CheckPointType {\n+    private enum CheckpointType {\n@@ -86,1 +90,1 @@\n-        private CheckPointType(int mask) {\n+        private CheckpointType(int mask) {\n@@ -116,1 +120,1 @@\n-    ChunkParser(RecordingInput input, ParserConfiguration pc, ParserState ps) throws IOException {\n+    public ChunkParser(RecordingInput input, ParserConfiguration pc, ParserState ps) throws IOException {\n@@ -122,1 +126,1 @@\n-     }\n+    }\n@@ -202,1 +206,1 @@\n-        long metadataPosition = chunkHeader.getMetataPosition();\n+        long metadataPosition = chunkHeader.getMetadataPosition();\n@@ -211,1 +215,1 @@\n-        if (chunkHeader.getMetataPosition() != metadataPosition) {\n+        if (chunkHeader.getMetadataPosition() != metadataPosition) {\n@@ -250,0 +254,10 @@\n+                    ChunkWriter chunkWriter = configuration.chunkWriter;\n+                    if (chunkWriter != null) {\n+                        if (chunkWriter.accept(event)) {\n+                            chunkWriter.writeEvent(pos, input.position());\n+                            input.position(pos);\n+                            input.readInt(); \/\/ size\n+                            input.readLong(); \/\/ type\n+                            chunkWriter.touch(ep.parseReferences(input));\n+                        }\n+                    }\n@@ -256,1 +270,1 @@\n-                    if (CheckPointType.FLUSH.is(parseCheckpointType())) {\n+                    if (CheckpointType.FLUSH.is(parseCheckpointType())) {\n@@ -306,0 +320,4 @@\n+            CheckpointEvent cp = null;\n+            if (configuration.chunkWriter != null) {\n+                cp = configuration.chunkWriter.newCheckpointEvent(thisCP);\n+            }\n@@ -336,1 +354,1 @@\n-                    ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type.getName());\n+                    ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type);\n@@ -353,0 +371,1 @@\n+                        long position = input.position();\n@@ -364,0 +383,6 @@\n+                        if (cp != null) {\n+                            input.position(position);\n+                            input.readLong();\n+                            Object refs = parser.parseReferences(input);\n+                            cp.addEntry(type, key, position, input.position(), refs);\n+                        }\n@@ -439,1 +464,1 @@\n-    ChunkParser newChunkParser() throws IOException {\n+    public ChunkParser newChunkParser() throws IOException {\n@@ -491,0 +516,4 @@\n+\n+    public ChunkHeader getHeader() {\n+        return chunkHeader;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":42,"deletions":13,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+\n+public final class CompositeParser extends Parser {\n+    final Parser[] parsers;\n+\n+    public CompositeParser(Parser[] valueParsers) {\n+        this.parsers = valueParsers;\n+    }\n+\n+    @Override\n+    public Object parse(RecordingInput input) throws IOException {\n+        final Object[] values = new Object[parsers.length];\n+        for (int i = 0; i < values.length; i++) {\n+            values[i] = parsers[i].parse(input);\n+        }\n+        return values;\n+    }\n+\n+    @Override\n+    public void skip(RecordingInput input) throws IOException {\n+        for (int i = 0; i < parsers.length; i++) {\n+            parsers[i].skip(input);\n+        }\n+    }\n+\n+    @Override\n+    public Object parseReferences(RecordingInput input) throws IOException {\n+        return parseReferences(input, parsers);\n+    }\n+\n+    static Object parseReferences(RecordingInput input, Parser[] parsers) throws IOException {\n+        ArrayList<Object> refs = new ArrayList<>(parsers.length);\n+        for (int i = 0; i < parsers.length; i++) {\n+            Object ref = parsers[i].parseReferences(input);\n+            if (ref != null) {\n+                refs.add(ref);\n+            }\n+        }\n+        if (refs.isEmpty()) {\n+            return null;\n+        }\n+        if (refs.size() == 1) {\n+            return refs.get(0);\n+        }\n+        return refs.toArray();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/CompositeParser.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-    private final Type type;\n+    final Type type;\n@@ -50,1 +50,1 @@\n-        current = new ConstantMap(current.factory, current.name);\n+        current = new ConstantMap(current.factory, current.type);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ConstantLookup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jfr.internal.Type;\n@@ -41,1 +42,0 @@\n-\n@@ -46,23 +46,0 @@\n-    \/\/ A temporary placeholder, so objects can\n-    \/\/ reference themselves (directly, or indirectly),\n-    \/\/ when making a transition from numeric id references\n-    \/\/ to normal Java references.\n-    private static final class Reference {\n-        private final long key;\n-        private final ConstantMap pool;\n-\n-        Reference(ConstantMap pool, long key) {\n-            this.pool = pool;\n-            this.key = key;\n-        }\n-\n-        Object resolve() {\n-            return pool.get(key);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"ref: \" + pool.name + \"[\" + key + \"]\";\n-        }\n-    }\n-\n@@ -70,2 +47,1 @@\n-    final String name;\n-\n+    final Type type;\n@@ -73,1 +49,0 @@\n-\n@@ -78,1 +53,1 @@\n-        this(null, \"<empty>\");\n+        this(null, null);\n@@ -82,2 +57,2 @@\n-    ConstantMap(ObjectFactory<?> factory, String name) {\n-        this.name = name;\n+    ConstantMap(ObjectFactory<?> factory, Type type) {\n+        this.type = type;\n@@ -103,1 +78,1 @@\n-                Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Missing object id=\" + id + \" in pool \" + name + \". All ids should reference an object\");\n+                Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Missing object id=\" + id + \" in pool \" + getName() + \". All ids should reference an object\");\n@@ -177,1 +152,6 @@\n-        return name;\n+        return type == null ? \"<empty>\" : type.getName();\n+    }\n+\n+    \/\/ Can be null\n+    public Type getType() {\n+        return type;\n@@ -192,0 +172,4 @@\n+\n+    public LongMap<Object> getObjects() {\n+       return objects;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ConstantMap.java","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        this.parserConfiguration = new ParserConfiguration(0, Long.MAX_VALUE, c.reuse, c.ordered, buildFilter(dispatchers));\n+        this.parserConfiguration = new ParserConfiguration(0, Long.MAX_VALUE, c.reuse, c.ordered, buildFilter(dispatchers), null);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/Dispatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    public EventFileStream(@SuppressWarnings(\"removal\") AccessControlContext acc, Path path) throws IOException {\n+    public EventFileStream(@SuppressWarnings(\"removal\") AccessControlContext acc, Path file) throws IOException {\n@@ -51,2 +51,1 @@\n-        Objects.requireNonNull(path);\n-        this.input = new RecordingInput(path.toFile(), FileAccess.UNPRIVILEGED);\n+        this.input = new RecordingInput(file.toFile(), FileAccess.UNPRIVILEGED);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventFileStream.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.ArrayList;\n@@ -32,0 +33,1 @@\n+import java.util.function.Predicate;\n@@ -157,0 +159,5 @@\n+    @Override\n+    public Object parseReferences(RecordingInput input) throws IOException {\n+        return CompositeParser.parseReferences(input, parsers);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventParser.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-     * @return an object\n+     * @return an {@code Object}, an {@code Object[]}, or {@code null}\n@@ -44,0 +44,16 @@\n+    \/**\n+     * Parses data from a {@link RecordingInput} to find references to constants. If\n+     * data is not a reference, {@code null} is returned.\n+     * <p>\n+     * @implSpec The default implementation of this method skips data and returns\n+     * {@code Object}.\n+     *\n+     * @param input input to read from, not {@code null}\n+     * @return a {@code Reference}, a {@code Reference[]}, or {@code null}\n+     * @throws IOException if operation couldn't be completed due to I\/O problems\n+     *\/\n+    public Object parseReferences(RecordingInput input) throws IOException {\n+        skip(input);\n+        return null;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/Parser.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-                ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type.getName());\n+                ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type);\n@@ -143,1 +143,1 @@\n-            ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type.getName());\n+            ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type);\n@@ -307,1 +307,1 @@\n-        public void skip(RecordingInput input) throws IOException {\n+        public Object parseReferences(RecordingInput input) throws IOException {\n@@ -309,0 +309,1 @@\n+            final Object[] array = new Object[size];\n@@ -310,17 +311,1 @@\n-                elementParser.skip(input);\n-            }\n-        }\n-    }\n-\n-    private static final class CompositeParser extends Parser {\n-        private final Parser[] parsers;\n-\n-        public CompositeParser(Parser[] valueParsers) {\n-            this.parsers = valueParsers;\n-        }\n-\n-        @Override\n-        public Object parse(RecordingInput input) throws IOException {\n-            final Object[] values = new Object[parsers.length];\n-            for (int i = 0; i < values.length; i++) {\n-                values[i] = parsers[i].parse(input);\n+                array[i] = elementParser.parse(input);\n@@ -328,1 +313,1 @@\n-            return values;\n+            return array;\n@@ -333,2 +318,3 @@\n-            for (int i = 0; i < parsers.length; i++) {\n-                parsers[i].skip(input);\n+            final int size = input.readInt();\n+            for (int i = 0; i < size; i++) {\n+                elementParser.skip(input);\n@@ -343,0 +329,2 @@\n+        private Object lastReferenceValue;\n+        private long lastReferenceKey = -1;\n@@ -362,0 +350,11 @@\n+\n+        @Override\n+        public Object parseReferences(RecordingInput input) throws IOException {\n+            long key = input.readLong();\n+            if (key == lastReferenceKey) {\n+                return lastReferenceValue;\n+            }\n+            lastReferenceKey = key;\n+            lastReferenceValue = new Reference(lookup.getLatestPool(), key);\n+            return lastReferenceValue;\n+        }\n@@ -379,0 +378,5 @@\n+\n+        @Override\n+        public Object parseReferences(RecordingInput input) throws IOException {\n+            return new Reference(lookup.getLatestPool(), input.readLong());\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ParserFactory.java","additions":28,"deletions":24,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-final class ParserFilter {\n+public final class ParserFilter {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ParserFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.consumer;\n+\n+import jdk.jfr.internal.Type;\n+\n+\/**\n+ * A temporary placeholder, so objects can reference themselves (directly, or\n+ * indirectly), when making a transition from numeric id references to Java\n+ * object references.\n+ *\/\n+public record Reference(ConstantMap pool, long key) {\n+\n+    Object resolve() {\n+        return pool.get(key);\n+    }\n+\n+    public Type type() {\n+        return pool.getType();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ref: \" + pool.getName() + \"[\" + key + \"]\";\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/Reference.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,0 +223,27 @@\n+\n+    @Override\n+    public Object parseReferences(RecordingInput input) throws IOException {\n+        byte encoding = input.readByte();\n+        if (Encoding.CONSTANT_POOL.is(encoding)) {\n+            return new Reference(stringLookup.getLatestPool(), input.readLong());\n+        }\n+        if (Encoding.EMPTY_STRING.is(encoding)) {\n+            return null;\n+        }\n+        if (Encoding.NULL.is(encoding)) {\n+            return null;\n+        }\n+        if (Encoding.CHAR_ARRAY.is(encoding)) {\n+            charArrayParser.skip(input);\n+            return null;\n+        }\n+        if (Encoding.UT8_BYTE_ARRAY.is(encoding)) {\n+            utf8parser.skip(input);\n+            return null;\n+        }\n+        if (Encoding.LATIN1_BYTE_ARRAY.is(encoding)) {\n+            latin1parser.skip(input);\n+            return null;\n+        }\n+        throw new IOException(\"Unknown string encoding \" + encoding);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/StringParser.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.consumer.filter;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+\n+import jdk.jfr.internal.Type;\n+\n+\/**\n+ * Represents a checkpoint event.\n+ * <p>\n+ * All positional values are relative to file start, not the chunk.\n+ *\/\n+public final class CheckpointEvent {\n+    private final ChunkWriter chunkWriter;\n+    private final LinkedHashMap<Long, CheckpointPool> pools = new LinkedHashMap<>();\n+    private final long startPosition;\n+\n+    public CheckpointEvent(ChunkWriter chunkWriter, long startPosition) {\n+        this.chunkWriter = chunkWriter;\n+        this.startPosition = startPosition;\n+    }\n+\n+    public PoolEntry addEntry(Type type, long id, long startPosition, long endPosition, Object references) {\n+        long typeId = type.getId();\n+        PoolEntry pe = new PoolEntry(startPosition, endPosition, type, id, references);\n+        var cpp = pools.computeIfAbsent(typeId, k -> new CheckpointPool(typeId));\n+        cpp.add(pe);\n+        chunkWriter.getPool(type).add(id, pe);\n+        return pe;\n+    }\n+\n+    public long touchedPools() {\n+        int count = 0;\n+        for (CheckpointPool cpp : pools.values()) {\n+            if (cpp.isTouched()) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    public Collection<CheckpointPool> getPools() {\n+        return pools.values();\n+    }\n+\n+    public long getStartPosition() {\n+        return startPosition;\n+    }\n+\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        for (CheckpointPool p : pools.values()) {\n+            for (var e : p.getEntries()) {\n+                if (e.isTouched()) {\n+                    sb.append(e.getType().getName() + \" \" + e.getId() + \"\\n\");\n+                }\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/CheckpointEvent.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer.filter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\/**\n+ * Represents a constant pool in a checkpoint, both entries and type id\n+ *\/\n+final class CheckpointPool {\n+    private final List<PoolEntry> entries = new ArrayList<>();\n+    private final long typeId;\n+\n+    public CheckpointPool(long typeId) {\n+        this.typeId = typeId;\n+    }\n+\n+    public boolean isTouched() {\n+        for (var entry : entries) {\n+            if (entry.isTouched()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public long getTouchedCount() {\n+        int count = 0;\n+        for (var entry : entries) {\n+            if (entry.isTouched()) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    public void add(PoolEntry pe) {\n+        entries.add(pe);\n+    }\n+\n+    public long getTypeId() {\n+        return typeId;\n+    }\n+\n+    public List<PoolEntry> getEntries() {\n+        return entries;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/CheckpointPool.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer.filter;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.internal.LongMap;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.consumer.ChunkHeader;\n+import jdk.jfr.internal.consumer.FileAccess;\n+import jdk.jfr.internal.Logger;\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.consumer.RecordingInput;\n+import jdk.jfr.internal.consumer.Reference;\n+\n+\/**\n+ * Class that can filter out events and associated constants from a recording\n+ * file.\n+ * <p>\n+ * All positional values are relative to file start, not the chunk.\n+ *\/\n+public final class ChunkWriter implements Closeable {\n+    private LongMap<Constants> pools = new LongMap<>();\n+    private final Deque<CheckpointEvent> checkpoints = new ArrayDeque<>();\n+    private final Path destination;\n+    private final RecordingInput input;\n+    private final RecordingOutput output;\n+    private final Predicate<RecordedEvent> filter;\n+\n+    private long chunkStartPosition;\n+    private boolean chunkComplete;\n+    private long lastCheckpoint;\n+\n+    public ChunkWriter(Path source, Path destination, Predicate<RecordedEvent> filter) throws IOException {\n+        this.destination = destination;\n+        this.output = new RecordingOutput(destination.toFile());\n+        this.input = new RecordingInput(source.toFile(), FileAccess.UNPRIVILEGED);\n+        this.filter = filter;\n+    }\n+\n+    Constants getPool(Type type) {\n+        long typeId = type.getId();\n+        Constants pool = pools.get(typeId);\n+        if (pool == null) {\n+            pool = new Constants(type);\n+            pools.put(typeId, pool);\n+        }\n+        return pool;\n+    }\n+\n+    public CheckpointEvent newCheckpointEvent(long startPosition) {\n+        CheckpointEvent event = new CheckpointEvent(this, startPosition);\n+        checkpoints.add(event);\n+        return event;\n+    }\n+\n+    public boolean accept(RecordedEvent event) {\n+        return filter.test(event);\n+    }\n+\n+    public void touch(Object object) {\n+        if (object instanceof Object[] array) {\n+            for (int i = 0; i < array.length; i++) {\n+                touch(array[i]);\n+            }\n+            return;\n+        }\n+        if (object instanceof Reference ref) {\n+            touchRef(ref);\n+        }\n+    }\n+\n+    private void touchRef(Reference ref) {\n+        Constants pool = pools.get(ref.type().getId());\n+        if (pool == null) {\n+            String msg = \"Can't resolve \" + ref.type().getName() + \"[\" + ref.key() + \"]\";\n+            Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.DEBUG, msg);\n+            return;\n+        }\n+        PoolEntry entry = pool.get(ref.key());\n+        if (entry != null && !entry.isTouched()) {\n+            entry.touch();\n+            touch(entry.getReferences());\n+        }\n+    }\n+    public void writeEvent(long startPosition, long endPosition) throws IOException {\n+        writeCheckpointEvents(startPosition);\n+        write(startPosition, endPosition);\n+    }\n+\n+    \/\/ Write check point events before a position\n+    private void writeCheckpointEvents(long before) throws IOException {\n+        CheckpointEvent cp = checkpoints.peek();\n+        while (cp != null && cp.getStartPosition() < before) {\n+            checkpoints.poll();\n+            long delta = 0;\n+            if (lastCheckpoint != 0) {\n+                delta = lastCheckpoint - output.position();\n+            }\n+            lastCheckpoint = output.position();\n+            write(cp, delta);\n+            cp = checkpoints.peek();\n+        }\n+    }\n+\n+    public void write(long startPosition, long endPosition) throws IOException {\n+        if (endPosition < startPosition) {\n+            throw new IOException(\"Start position must come before end position, start=\" + startPosition + \", end=\" + endPosition);\n+        }\n+        long backup = input.position();\n+        input.position(startPosition);\n+        long n = endPosition - startPosition;\n+        for (long i = 0; i < n; i++) {\n+            output.writeByte(input.readByte());\n+        }\n+        input.position(backup);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        try {\n+            output.close();\n+        } finally {\n+            if (!chunkComplete) {\n+                \/\/ Error occurred, clean up\n+                if (Files.exists(destination)) {\n+                    Files.delete(destination);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void beginChunk(ChunkHeader header) throws IOException {\n+        this.chunkComplete = false;\n+        this.chunkStartPosition = output.position();\n+        input.position(header.getAbsoluteChunkStart());\n+        for (int i = 0; i < ChunkHeader.HEADER_SIZE; i++) {\n+            output.writeByte(input.readByte());\n+        }\n+    }\n+\n+    public void endChunk(ChunkHeader header) throws IOException {\n+        \/\/ write all outstanding checkpoints\n+        writeCheckpointEvents(Long.MAX_VALUE);\n+        long metadata = output.position();\n+        writeMetadataEvent(header);\n+        updateHeader(output.position(), lastCheckpoint, metadata);\n+        pools = new LongMap<>();\n+        chunkComplete = true;\n+        lastCheckpoint = 0;\n+    }\n+\n+    private void writeMetadataEvent(ChunkHeader header) throws IOException {\n+        long metadataposition = header.getMetadataPosition() + header.getAbsoluteChunkStart();\n+        input.position(metadataposition);\n+        long size = input.readLong();\n+        input.position(metadataposition);\n+        for (int i = 0; i < size; i++) {\n+            output.writeByte(input.readByte());\n+        }\n+    }\n+\n+    private void write(CheckpointEvent event, long delta) throws IOException {\n+        input.position(event.getStartPosition());\n+        long startPosition = output.position();\n+\n+        input.readLong(); \/\/ Read size\n+        output.writePaddedUnsignedInt(0); \/\/ Size, 4 bytes reserved\n+        output.writeLong(input.readLong()); \/\/ Constant pool id\n+        output.writeLong(input.readLong()); \/\/ Start time\n+        output.writeLong(input.readLong()); \/\/ Duration\n+        input.readLong(); \/\/ Read delta\n+        output.writeLong(delta); \/\/ Delta\n+        output.writeByte(input.readByte()); \/\/ flush marker\n+\n+        \/\/ Write even if touched pools are zero, checkpoint works as sync point\n+        output.writeLong(event.touchedPools()); \/\/ Pool count\n+        for (CheckpointPool pool : event.getPools()) {\n+            if (pool.isTouched()) {\n+                output.writeLong(pool.getTypeId());\n+                output.writeLong(pool.getTouchedCount());\n+                for (PoolEntry pe : pool.getEntries()) {\n+                    if (pe.isTouched()) {\n+                        write(pe.getStartPosition(), pe.getEndPosition()); \/\/ key + value\n+                    }\n+                }\n+            }\n+        }\n+        long endPosition = output.position();\n+        long size = endPosition - startPosition;\n+        output.position(startPosition);\n+        output.writePaddedUnsignedInt(size);\n+        output.position(endPosition);\n+    }\n+\n+    private void updateHeader(long size, long constantPosition, long metadataPosition) throws IOException {\n+        long backup = output.position();\n+        output.position(ChunkHeader.CHUNK_SIZE_POSITION + chunkStartPosition);\n+        \/\/ Write chunk relative values\n+        output.writeRawLong(size - chunkStartPosition);\n+        output.writeRawLong(constantPosition - chunkStartPosition);\n+        output.writeRawLong(metadataPosition - chunkStartPosition);\n+        output.position(backup);\n+    }\n+\n+    public RecordingInput getInput() {\n+        return input;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/ChunkWriter.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer.filter;\n+\n+import jdk.jfr.internal.LongMap;\n+import jdk.jfr.internal.Type;\n+\n+\/**\n+ * Holds the chunk global state of constants\n+ *\/\n+final class Constants {\n+    private final LongMap<PoolEntry> table = new LongMap<>();\n+    private final Type type;\n+\n+    public Constants(Type type) {\n+        this.type = type;\n+    }\n+\n+    public void add(long key, PoolEntry entry) {\n+        table.put(key, entry);\n+    }\n+\n+    public PoolEntry get(long key) {\n+        return table.get(key);\n+    }\n+\n+    public String toString() {\n+        return \"Pool: \" + type.getName() + \" size = \" + table.size();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/Constants.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer.filter;\n+\n+import jdk.jfr.internal.Type;\n+\n+\/**\n+ * Represents the binary content of constant pool, both key and value.\n+ * <p>\n+ * All positional values are relative to file start, not the chunk.\n+ *\/\n+final class PoolEntry {\n+    private final long startPosition;\n+    private final long endPosition;\n+    private final Type type;\n+    private final long keyId;\n+    private final Object references;\n+\n+    private boolean touched;\n+\n+    PoolEntry(long startPosition, long endPosition, Type type, long keyId, Object references) {\n+        this.startPosition = startPosition;\n+        this.endPosition = endPosition;\n+        this.type = type;\n+        this.keyId = keyId;\n+        this.references = references;\n+    }\n+\n+    public void touch() {\n+        this.touched = true;\n+    }\n+\n+    public boolean isTouched() {\n+        return touched;\n+    }\n+\n+    public Object getReferences() {\n+        return references;\n+    }\n+\n+    public long getStartPosition() {\n+        return startPosition;\n+    }\n+\n+    public long getEndPosition() {\n+        return endPosition;\n+    }\n+\n+    public Type getType() {\n+        return type;\n+    }\n+\n+    public long getId() {\n+        return keyId;\n+    }\n+\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"start: \").append(startPosition).append(\"\\n\");\n+        sb.append(\"end: \").append(endPosition).append(\"\\n\");\n+        sb.append(\"type: \").append(type).append(\" (\").append(type.getId()).append(\")\\n\");\n+        sb.append(\"key: \").append(keyId).append(\"\\n\");\n+        sb.append(\"object: \").append(references).append(\"\\n\");\n+        return sb.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/PoolEntry.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.consumer.filter;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+\n+\/**\n+ * Write cache and LEB128 encoder\n+ *\/\n+final class RecordingOutput implements Closeable {\n+    private final RandomAccessFile file;\n+    private final byte[] buffer = new byte[16384];\n+    private int bufferPosition;\n+    private long position;\n+\n+    public RecordingOutput(File file) throws IOException {\n+        this.file = new RandomAccessFile(file, \"rw\");\n+    }\n+\n+    public void writeByte(byte value) throws IOException {\n+        if (!(bufferPosition < buffer.length)) {\n+            flush();\n+        }\n+        buffer[bufferPosition++] = value;\n+        position++;\n+    }\n+\n+    public void writeRawLong(long v) throws IOException {\n+        writeByte((byte) ((v >> 56) & 0xff));\n+        writeByte((byte) ((v >> 48) & 0xff));\n+        writeByte((byte) ((v >> 40) & 0xff));\n+        writeByte((byte) ((v >> 32) & 0xff));\n+        writeByte((byte) ((v >> 24) & 0xff));\n+        writeByte((byte) ((v >> 16) & 0xff));\n+        writeByte((byte) ((v >> 8) & 0xff));\n+        writeByte((byte) ((v) & 0xff));\n+    }\n+\n+    public void writePaddedUnsignedInt(long value) throws IOException {\n+        if (value < 0) {\n+            throw new IOException(\"Padded value can't be negative\");\n+        }\n+        if (value >= 1 << 28) {\n+            throw new IOException(\"Padded value must fit four bytes\");\n+        }\n+        byte b0 = (byte) (value | 0x80);\n+        byte b1 = (byte) (value >> 7 | 0x80);\n+        byte b2 = (byte) (value >> 14 | 0x80);\n+        byte b3 = (byte) (value >> 21);\n+        writeByte(b0);\n+        writeByte(b1);\n+        writeByte(b2);\n+        writeByte(b3);\n+    }\n+\n+    \/\/ Essentially copied from EventWriter#putLong\n+    public void writeLong(long v) throws IOException {\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 0-6\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 0-6\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 7-13\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 7-13\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 14-20\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 14-20\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 21-27\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 21-27\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 28-34\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 28-34\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 35-41\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 35-41\n+        v >>>= 7;\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 42-48\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 42-48\n+        v >>>= 7;\n+\n+        if ((v & ~0x7FL) == 0L) {\n+            writeByte((byte) v); \/\/ 49-55\n+            return;\n+        }\n+        writeByte((byte) (v | 0x80L)); \/\/ 49-55\n+        writeByte((byte) (v >>> 7)); \/\/ 56-63, last byte as is.\n+    }\n+\n+    public void position(long pos) throws IOException {\n+        flush();\n+        position = pos;\n+        file.seek(position);\n+    }\n+\n+    public long position() throws IOException {\n+        return position;\n+    }\n+\n+    public void flush() throws IOException {\n+        file.write(buffer, 0, bufferPosition);\n+        bufferPosition = 0;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        flush();\n+        file.close();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/filter\/RecordingOutput.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -55,1 +55,1 @@\n-            start = EventHandler.timestamp();;\n+            start = EventHandler.timestamp();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/SocketChannelImplInstrumentor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.util.HashMap;\n@@ -43,5 +42,0 @@\n-import java.util.Map;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-\n-import jdk.jfr.EventType;\n@@ -59,0 +53,1 @@\n+        commands.add(new Scrub());\n@@ -290,0 +285,4 @@\n+    protected static char quoteCharacter() {\n+        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n+    }\n+\n@@ -302,0 +301,6 @@\n+    public static void checkCommonError(Deque<String> options, String typo, String correct) throws UserSyntaxException {\n+        if (typo.equals(options.peek())) {\n+            throw new UserSyntaxException(\"unknown option \" + typo + \", did you mean \" + correct + \"?\");\n+        }\n+    }\n+\n@@ -322,103 +327,0 @@\n-    public static void checkCommonError(Deque<String> options, String typo, String correct) throws UserSyntaxException {\n-        if (typo.equals(options.peek())) {\n-            throw new UserSyntaxException(\"unknown option \" + typo + \", did you mean \" + correct + \"?\");\n-        }\n-    }\n-\n-    protected static final char quoteCharacter() {\n-        return File.pathSeparatorChar == ';' ? '\"' : '\\'';\n-    }\n-\n-    private static <T> Predicate<T> recurseIfPossible(Predicate<T> filter) {\n-        return x -> filter != null && filter.test(x);\n-    }\n-\n-    private static String acronomify(String multipleWords) {\n-        boolean newWord = true;\n-        String acronym = \"\";\n-        for (char c : multipleWords.toCharArray()) {\n-            if (newWord) {\n-                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n-                    acronym += c;\n-                }\n-            }\n-            newWord = Character.isWhitespace(c);\n-        }\n-        return acronym;\n-    }\n-\n-    private static boolean match(String text, String filter) {\n-        if (filter.length() == 0) {\n-            \/\/ empty filter string matches if string is empty\n-            return text.length() == 0;\n-        }\n-        if (filter.charAt(0) == '*') { \/\/ recursive check\n-            filter = filter.substring(1);\n-            for (int n = 0; n <= text.length(); n++) {\n-                if (match(text.substring(n), filter))\n-                    return true;\n-            }\n-        } else if (text.length() == 0) {\n-            \/\/ empty string and non-empty filter does not match\n-            return false;\n-        } else if (filter.charAt(0) == '?') {\n-            \/\/ eat any char and move on\n-            return match(text.substring(1), filter.substring(1));\n-        } else if (filter.charAt(0) == text.charAt(0)) {\n-            \/\/ eat chars and move on\n-            return match(text.substring(1), filter.substring(1));\n-        }\n-        return false;\n-    }\n-\n-    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n-        List<String> list = new ArrayList<>();\n-        for (String s : filter.split(\",\")) {\n-            s = s.trim();\n-            if (!s.isEmpty()) {\n-                list.add(s);\n-            }\n-        }\n-        return list;\n-    }\n-\n-    protected static final Predicate<EventType> addCategoryFilter(String filterText, Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String category : eventType.getCategoryNames()) {\n-                for (String filter : filters) {\n-                    if (match(category, filter)) {\n-                        return true;\n-                    }\n-                    if (category.contains(\" \") && acronomify(category).equals(filter)) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    protected static final Predicate<EventType> addEventFilter(String filterText, final Predicate<EventType> eventFilter) throws UserSyntaxException {\n-        List<String> filters = explodeFilter(filterText);\n-        Predicate<EventType> newFilter = recurseIfPossible(eventType -> {\n-            for (String filter : filters) {\n-                String fullEventName = eventType.getName();\n-                if (match(fullEventName, filter)) {\n-                    return true;\n-                }\n-                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n-                if (match(eventName, filter)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        });\n-        return eventFilter == null ? newFilter : eventFilter.or(newFilter);\n-    }\n-\n-    protected static final <T, X> Predicate<T> addCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n-        Map<X, Boolean> cache = new HashMap<>();\n-        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Command.java","additions":12,"deletions":110,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tool;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.EventType;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordedEvent;\n+\n+\/**\n+ * Helper class for creating filters.\n+ *\/\n+public class Filters {\n+    private static final Predicate<RecordedThread> FALSE_THREAD_PREDICATE = e -> false;\n+\n+    static Predicate<EventType> createCategoryFilter(String filterText) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<EventType> f = eventType -> {\n+            for (String category : eventType.getCategoryNames()) {\n+                for (String filter : filters) {\n+                    if (match(category, filter)) {\n+                        return true;\n+                    }\n+                    if (category.contains(\" \") && acronymify(category).equals(filter)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        };\n+        return createCache(f, EventType::getId);\n+    }\n+\n+    static Predicate<EventType> createEventTypeFilter(String filterText) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        Predicate<EventType> f = eventType -> {\n+            for (String filter : filters) {\n+                String fullEventName = eventType.getName();\n+                if (match(fullEventName, filter)) {\n+                    return true;\n+                }\n+                String eventName = fullEventName.substring(fullEventName.lastIndexOf(\".\") + 1);\n+                if (match(eventName, filter)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        };\n+        return createCache(f, EventType::getId);\n+    }\n+\n+    public static <T> Predicate<T> matchAny(List<Predicate<T>> filters) {\n+        if (filters.isEmpty()) {\n+            return t -> true;\n+        }\n+        if (filters.size() == 1) {\n+            return filters.get(0);\n+        }\n+        return t -> {\n+            for (Predicate<T> p : filters) {\n+                if (!p.test(t)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+    }\n+\n+    static Predicate<RecordedEvent> fromEventType(Predicate<EventType> filter) {\n+        return e -> filter.test(e.getEventType());\n+    }\n+\n+    static Predicate<RecordedEvent> fromRecordedThread(Predicate<RecordedThread> filter) {\n+        Predicate<RecordedThread> cachePredicate = createCache(filter, RecordedThread::getId);\n+        return event -> {\n+            RecordedThread t = event.getThread();\n+            if (t == null || t.getJavaName() == null) {\n+                return false;\n+            }\n+            return cachePredicate.test(t);\n+        };\n+    }\n+\n+    static Predicate<RecordedThread> createThreadFilter(String filterText) throws UserSyntaxException {\n+        List<String> filters = explodeFilter(filterText);\n+        return thread -> {\n+            String threadName = thread.getJavaName();\n+            for (String filter : filters) {\n+                if (match(threadName, filter)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        };\n+    }\n+\n+    private static final <T, X> Predicate<T> createCache(final Predicate<T> filter, Function<T, X> cacheFunction) {\n+        Map<X, Boolean> cache = new HashMap<>();\n+        return t -> cache.computeIfAbsent(cacheFunction.apply(t), x -> filter.test(t));\n+    }\n+\n+    private static String acronymify(String multipleWords) {\n+        boolean newWord = true;\n+        String acronym = \"\";\n+        for (char c : multipleWords.toCharArray()) {\n+            if (newWord) {\n+                if (Character.isAlphabetic(c) && Character.isUpperCase(c)) {\n+                    acronym += c;\n+                }\n+            }\n+            newWord = Character.isWhitespace(c);\n+        }\n+        return acronym;\n+    }\n+\n+    private static boolean match(String text, String filter) {\n+        if (filter.length() == 0) {\n+            \/\/ empty filter string matches if string is empty\n+            return text.length() == 0;\n+        }\n+        if (filter.charAt(0) == '*') { \/\/ recursive check\n+            filter = filter.substring(1);\n+            for (int n = 0; n <= text.length(); n++) {\n+                if (match(text.substring(n), filter))\n+                    return true;\n+            }\n+        } else if (text.length() == 0) {\n+            \/\/ empty string and non-empty filter does not match\n+            return false;\n+        } else if (filter.charAt(0) == '?') {\n+            \/\/ eat any char and move on\n+            return match(text.substring(1), filter.substring(1));\n+        } else if (filter.charAt(0) == text.charAt(0)) {\n+            \/\/ eat chars and move on\n+            return match(text.substring(1), filter.substring(1));\n+        }\n+        return false;\n+    }\n+\n+    private static List<String> explodeFilter(String filter) throws UserSyntaxException {\n+        List<String> list = new ArrayList<>();\n+        for (String s : filter.split(\",\")) {\n+            s = s.trim();\n+            if (!s.isEmpty()) {\n+                list.add(s);\n+            }\n+        }\n+        return list;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Filters.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -66,1 +66,1 @@\n-        printArrayEnd();;\n+        printArrayEnd();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/JSONWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-            char q = Print.quoteCharacter();\n+            char q = Command.quoteCharacter();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,0 +166,1 @@\n+        List<Predicate<EventType>> filters = new ArrayList<>();\n@@ -180,1 +181,1 @@\n-                filter = addEventFilter(filterStr, filter);\n+                filters.add(Filters.createEventTypeFilter(filterStr));\n@@ -189,1 +190,1 @@\n-                filter = addCategoryFilter(filterStr, filter);\n+                filters.add(Filters.createCategoryFilter(filterStr));\n@@ -203,2 +204,2 @@\n-            if (filter != null) {\n-                filter = addCache(filter, type -> type.getId());\n+            if (!filters.isEmpty()) {\n+                filter =  Filters.matchAny(filters);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Metadata.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-        Predicate<EventType> eventFilter = null;\n+        List<Predicate<EventType>> eventFilters = new ArrayList<>();\n@@ -119,1 +119,1 @@\n-                eventFilter = addEventFilter(filter, eventFilter);\n+                eventFilters.add(Filters.createEventTypeFilter(filter));\n@@ -128,1 +128,1 @@\n-                eventFilter = addCategoryFilter(filter, eventFilter);\n+                eventFilters.add(Filters.createCategoryFilter(filter));\n@@ -159,3 +159,2 @@\n-        if (eventFilter != null) {\n-            eventFilter = addCache(eventFilter, eventType -> eventType.getId());\n-            eventWriter.setEventFilter(eventFilter);\n+        if (!eventFilters.isEmpty()) {\n+            eventWriter.setEventFilter(Filters.matchAny(eventFilters));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Print.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.tool;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+final class Scrub extends Command {\n+\n+    @Override\n+    public String getName() {\n+        return \"scrub\";\n+    }\n+\n+    @Override\n+    public List<String> getOptionSyntax() {\n+        List<String> list = new ArrayList<>();\n+        list.add(\"[--include-events <filter>]\");\n+        list.add(\"[--exclude-events <filter>]\");\n+        list.add(\"[--include-categories <filter>]\");\n+        list.add(\"[--exclude-categories <filter>]\");\n+        list.add(\"[--include-threads <filter>]\");\n+        list.add(\"[--exclude-threads <filter>]\");\n+        list.add(\"<input-file>\");\n+        list.add(\"[<output-file>]\");\n+        return list;\n+    }\n+\n+    @Override\n+    protected String getTitle() {\n+        return \"Scrub contents of a recording file\";\n+    }\n+\n+    @Override\n+    public String getDescription() {\n+        return getTitle() + \". See 'jfr help scrub' for details.\";\n+    }\n+\n+    @Override\n+    public void displayOptionUsage(PrintStream stream) {\n+        \/\/ 01234567890123456789012345678901234567890123467890123456789012345678901234567890\n+        stream.println(\"  --include-events <filter>       Select events matching an event name\");\n+        stream.println();\n+        stream.println(\"  --exclude-events <filter>       Exclude events matching an event name\");\n+        stream.println();\n+        stream.println(\"  --include-categories <filter>   Select events matching a category name\");\n+        stream.println();\n+        stream.println(\"  --exclude-categories <filter>   Exclude events matching a category name\");\n+        stream.println();\n+        stream.println(\"  --include-threads <filter>      Select events matching a thread name\");\n+        stream.println();\n+        stream.println(\"  --exclude-threads <filter>      Exclude events matching a thread name\");\n+        stream.println();\n+        stream.println(\"  <input-file>                    The input file to read events from\");\n+        stream.println();\n+        stream.println(\"  <output-file>                   The output file to write filter events to. \");\n+        stream.println(\"                                  If no file is specified, it will be written to\");\n+        stream.println(\"                                  the same  path as the input file, but with\");\n+        stream.println(\"                                  \\\"-scrubbed\\\" appended to the filename\");\n+        stream.println();\n+        stream.println(\"  The filter is a comma-separated list of names, simple and\/or qualified,\");\n+        stream.println(\"  and\/or quoted glob patterns. If multiple filters are used, they \");\n+        stream.println(\"  are applied in the specified order\");\n+        stream.println();\n+        stream.println(\"Example usage:\");\n+        stream.println();\n+        stream.println(\" jfr scrub --include-events 'jdk.Socket*' recording.jfr socket-only.jfr\");\n+        stream.println();\n+        stream.println(\" jfr scrub --exclude-events InitialEnvironmentVariable recording.jfr no-psw.jfr\");\n+        stream.println();\n+        stream.println(\" jfr scrub --include-threads main recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr scrub --exclude-threads 'Foo*' recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr scrub --include-categories 'My App' recording.jfr\");\n+        stream.println();\n+        stream.println(\" jfr scrub --exclude-categories JVM,OS recording.jfr\");\n+    }\n+\n+    @Override\n+    public void execute(Deque<String> options) throws UserSyntaxException, UserDataException {\n+        ensureMinArgumentCount(options, 1);\n+\n+        Path last = Path.of(options.pollLast());\n+        ensureFileExtension(last, \".jfr\");\n+        Path output = null;\n+        Path input = null;\n+        String peek = options.peekLast();\n+        if (peek != null && peek.endsWith(\".jfr\")) {\n+            \/\/ Both source and destination specified\n+            input =  Path.of(options.pollLast());\n+            output = last;\n+        } else {\n+            \/\/ Only source file specified\n+            Path file = last.getFileName();\n+            Path dir = last.getParent();\n+            String filename = file.toString();\n+            int index = filename.lastIndexOf(\".\");\n+            String s = filename.substring(0, index);\n+            String t = s + \"-scrubbed.jfr\";\n+            input = last;\n+            output = dir == null ? Path.of(t) : dir.resolve(t);\n+        }\n+        ensureFileDoesNotExist(output);\n+\n+        List<Predicate<RecordedEvent>> filters = new ArrayList<>();\n+        int optionCount = options.size();\n+        while (optionCount > 0) {\n+            if (acceptFilterOption(options, \"--include-events\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--include-events\", filter);\n+                var f = Filters.createEventTypeFilter(filter);\n+                filters.add(Filters.fromEventType(f));\n+            }\n+            if (acceptFilterOption(options, \"--exclude-events\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--exclude-events\", filter);\n+                var f = Filters.createEventTypeFilter(filter);\n+                filters.add(Filters.fromEventType(f.negate()));\n+            }\n+            if (acceptFilterOption(options, \"--include-categories\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--include-categories\", filter);\n+                var f = Filters.createCategoryFilter(filter);\n+                filters.add(Filters.fromEventType(f));\n+            }\n+            if (acceptFilterOption(options, \"--exclude-categories\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--exclude-categories\", filter);\n+                var f = Filters.createCategoryFilter(filter);\n+                filters.add(Filters.fromEventType(f.negate()));\n+            }\n+            if (acceptFilterOption(options, \"--include-threads\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--include-threads\", filter);\n+                var f = Filters.createThreadFilter(filter);\n+                filters.add(Filters.fromRecordedThread(f));\n+            }\n+            if (acceptFilterOption(options, \"--exclude-threads\")) {\n+                String filter = options.remove();\n+                warnForWildcardExpansion(\"--exclude-threads\", filter);\n+                var f = Filters.createThreadFilter(filter);\n+                filters.add(Filters.fromRecordedThread(f).negate());\n+            }\n+            if (optionCount == options.size()) {\n+                \/\/ No progress made\n+                checkCommonError(options, \"--include-event\", \"--include-events\");\n+                checkCommonError(options, \"--include-category\", \"--include-categories\");\n+                checkCommonError(options, \"--include-thread\", \"--include-threads\");\n+                throw new UserSyntaxException(\"unknown option \" + options.peek());\n+            }\n+            optionCount = options.size();\n+        }\n+\n+        try (RecordingFile rf = new RecordingFile(input)) {\n+            rf.write(output, Filters.matchAny(filters));\n+        } catch (IOException ioe) {\n+            couldNotReadError(input, ioe);\n+        }\n+        println(\"Scrubbed recording file written to:\");\n+        println(output.toAbsolutePath().toString());\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Scrub.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -103,1 +103,1 @@\n-            stats.put(1L, new Statistics(eventPrefix + \"CheckPoint\"));\n+            stats.put(1L, new Statistics(eventPrefix + \"Checkpoint\"));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Summary.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-message.dmg-cannot-be-overwritten=Dmg file exists ({0} and can not be removed.\n+message.dmg-cannot-be-overwritten=Dmg file exists [{0}] and can not be removed.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-message.dmg-cannot-be-overwritten=Dmg\\u30D5\\u30A1\\u30A4\\u30EB\\u306F\\u5B58\\u5728\\u3057({0}\\u3001\\u524A\\u9664\\u3067\\u304D\\u307E\\u305B\\u3093\\u3002\n+message.dmg-cannot-be-overwritten=Dmg\\u30D5\\u30A1\\u30A4\\u30EB\\u306F\\u5B58\\u5728\\u3057[{0}]\\u3001\\u524A\\u9664\\u3067\\u304D\\u307E\\u305B\\u3093\\u3002\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_ja.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-message.dmg-cannot-be-overwritten=Dmg \\u6587\\u4EF6\\u5DF2\\u5B58\\u5728 ({0}) \\u4E14\\u65E0\\u6CD5\\u5220\\u9664\\u3002\n+message.dmg-cannot-be-overwritten=Dmg \\u6587\\u4EF6\\u5DF2\\u5B58\\u5728 [{0}] \\u4E14\\u65E0\\u6CD5\\u5220\\u9664\\u3002\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_zh_CN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+ * description\n@@ -114,0 +115,3 @@\n+        Arguments.putUnlessNull(bundleParams, CLIOptions.DESCRIPTION.getId(),\n+                getOptionValue(CLIOptions.DESCRIPTION));\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AddLauncherArguments.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-\\          The keys \"module\", \"main-jar\", \"main-class\",\\n\\\n+\\          The keys \"module\", \"main-jar\", \"main-class\", \"description\",\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-\\          The keys \"module\", \"main-jar\", \"main-class\",\\n\\\n+\\          The keys \"module\", \"main-jar\", \"main-class\", \"description\",\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources_ja.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-\\          The keys \"module\", \"main-jar\", \"main-class\",\\n\\\n+\\          The keys \"module\", \"main-jar\", \"main-class\", \"description\",\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources_zh_CN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                TEXT(\"\"), &cchSize);\n+                (LPTSTR)TEXT(\"\"), &cchSize);\n","filename":"src\/jdk.jpackage\/windows\/native\/libwixhelper\/libwixhelper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-            this.all = EnumSet.allOf(FormatCase.class);;\n+            this.all = EnumSet.allOf(FormatCase.class);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/Selector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-                processCheckPointHeader();\n+                processCheckpointHeader();\n@@ -289,1 +289,1 @@\n-    private void processCheckPointHeader() throws IOException {\n+    private void processCheckpointHeader() throws IOException {\n@@ -292,1 +292,1 @@\n-            writeCheckPointHeader();\n+            writeCheckpointHeader();\n@@ -324,1 +324,1 @@\n-    private void writeCheckPointHeader() throws IOException {\n+    private void writeCheckpointHeader() throws IOException {\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DiskRepository.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -218,2 +218,2 @@\n-    public void setRecordingSettings(long recording, Map<String, String> values) throws IllegalArgumentException {\n-        Objects.requireNonNull(values);\n+    public void setRecordingSettings(long recording, Map<String, String> settings) throws IllegalArgumentException {\n+        Objects.requireNonNull(settings, \"settings\");\n@@ -221,1 +221,1 @@\n-        getExistingRecording(recording).setSettings(values);\n+        getExistingRecording(recording).setSettings(settings);\n@@ -244,2 +244,2 @@\n-    public void setConfiguration(long recording, String configuration) throws IllegalArgumentException {\n-        Objects.requireNonNull(configuration);\n+    public void setConfiguration(long recording, String contents) throws IllegalArgumentException {\n+        Objects.requireNonNull(contents, \"contents\");\n@@ -248,1 +248,1 @@\n-            Configuration c = Configuration.create(new StringReader(configuration));\n+            Configuration c = Configuration.create(new StringReader(contents));\n@@ -257,1 +257,1 @@\n-        Objects.requireNonNull(configurationName);\n+        Objects.requireNonNull(configurationName, \"configurationName\");\n@@ -270,2 +270,2 @@\n-    public void copyTo(long recording, String path) throws IOException {\n-        Objects.requireNonNull(path);\n+    public void copyTo(long recording, String outputFile) throws IOException {\n+        Objects.requireNonNull(outputFile, \"outputFile\");\n@@ -273,1 +273,1 @@\n-        getExistingRecording(recording).dump(Paths.get(path));\n+        getExistingRecording(recording).dump(Paths.get(outputFile));\n@@ -278,1 +278,1 @@\n-        Objects.requireNonNull(options);\n+        Objects.requireNonNull(options, \"options\");\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FlightRecorderMXBeanImpl.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -158,0 +158,2 @@\n+        this.x0 = x0;\n+        this.x1 = x1;\n","filename":"src\/jdk.random\/share\/classes\/jdk\/random\/L32X64MixRandom.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -976,1 +976,1 @@\n-            String arguments = atts.getValue(\"arguments\");;\n+            String arguments = atts.getValue(\"arguments\");\n","filename":"src\/utils\/LogCompilation\/src\/main\/java\/com\/sun\/hotspot\/tools\/compiler\/LogParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+The Universal Permissive License (UPL), Version 1.0\n+\n+Subject to the condition set forth below, permission is hereby granted to\n+any person obtaining a copy of this software, associated documentation\n+and\/or data (collectively the \"Software\"), free of charge and under any\n+and all copyright rights in the Software, and any and all patent rights\n+owned or freely licensable by each licensor hereunder covering either (i)\n+the unmodified Software as contributed to or provided by such licensor,\n+or (ii) the Larger Works (as defined below), to deal in both\n+\n+(a) the Software, and\n+\n+(b) any piece of software and\/or hardware listed in the lrgrwrks.txt file\n+if one is included with the Software (each a \"Larger Work\" to which the\n+Software is contributed by such licensors),\n+\n+without restriction, including without limitation the rights to copy,\n+create derivative works of, display, perform, and distribute the Software\n+and make, use, sell, offer for sale, import, export, have made, and have\n+sold the Software and the Larger Work(s), and to sublicense the foregoing\n+rights on either these or other terms.\n+\n+This license is subject to the following condition:\n+\n+The above copyright notice and either this complete permission notice or\n+at a minimum a reference to the UPL must be included in all copies or\n+substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n+NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+USE OR OTHER DEALINGS IN THE SOFTWARE.\n","filename":"src\/utils\/hsdis\/hsdis-license.txt","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -212,0 +212,1 @@\n+        self.isPostfixException = False\n@@ -214,1 +215,3 @@\n-        if (self._name.endswith(\"wi\")):\n+        if self.isPostfixException:\n+            return self._name\n+        elif (self._name.endswith(\"wi\")):\n@@ -216,0 +219,2 @@\n+        elif (self._name.endswith(\"i\") | self._name.endswith(\"w\")):\n+            return self._name[:len(self._name)-1]\n@@ -217,4 +222,1 @@\n-            if (self._name.endswith(\"i\") | self._name.endswith(\"w\")):\n-                return self._name[:len(self._name)-1]\n-            else:\n-                return self._name\n+            return self._name\n@@ -351,0 +353,6 @@\n+class PostfixExceptionOneRegOp(OneRegOp):\n+\n+    def __init__(self, op):\n+        OneRegOp.__init__(self, op)\n+        self.isPostfixException=True\n+\n@@ -600,0 +608,7 @@\n+\n+class PostfixExceptionOp(Op):\n+\n+    def __init__(self, op):\n+        Op.__init__(self, op)\n+        self.isPostfixException=True\n+\n@@ -1338,1 +1353,7 @@\n-generate (Op, [\"nop\", \"eret\", \"drps\", \"isb\"])\n+generate (Op, [\"nop\", \"yield\", \"wfe\", \"sev\", \"sevl\",\n+               \"autia1716\", \"autiasp\", \"autiaz\", \"autib1716\", \"autibsp\", \"autibz\",\n+               \"pacia1716\", \"paciasp\", \"paciaz\", \"pacib1716\", \"pacibsp\", \"pacibz\",\n+               \"eret\", \"drps\", \"isb\",])\n+\n+# Ensure the \"i\" is not stripped off the end of the instruction\n+generate (PostfixExceptionOp, [\"wfi\", \"xpaclri\"])\n@@ -1345,1 +1366,7 @@\n-generate (OneRegOp, [\"br\", \"blr\"])\n+generate (OneRegOp, [\"br\", \"blr\",\n+                     \"paciza\", \"pacizb\", \"pacdza\", \"pacdzb\",\n+                     \"autiza\", \"autizb\", \"autdza\", \"autdzb\", \"xpacd\",\n+                     \"braaz\", \"brabz\", \"blraaz\", \"blrabz\"])\n+\n+# Ensure the \"i\" is not stripped off the end of the instruction\n+generate (PostfixExceptionOneRegOp, [\"xpaci\"])\n@@ -1390,1 +1417,4 @@\n-          \"rev16\", \"rev32\", \"rev\", \"clz\", \"cls\"])\n+          \"rev16\", \"rev32\", \"rev\", \"clz\", \"cls\",\n+          \"pacia\",  \"pacib\", \"pacda\", \"pacdb\", \"autia\", \"autib\", \"autda\", \"autdb\",\n+          \"braa\", \"brab\", \"blraa\", \"blrab\"])\n+\n@@ -1850,2 +1880,2 @@\n-# compile for sve with 8.2 and sha3 because of SHA3 crypto extension.\n-subprocess.check_call([AARCH64_AS, \"-march=armv8.2-a+sha3+sve\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n+# compile for sve with 8.3 and sha3 because of SHA3 crypto extension.\n+subprocess.check_call([AARCH64_AS, \"-march=armv8.3-a+sha3+sve\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":40,"deletions":10,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -171,0 +171,16 @@\n+    __ yield();                                        \/\/       yield\n+    __ wfe();                                          \/\/       wfe\n+    __ sev();                                          \/\/       sev\n+    __ sevl();                                         \/\/       sevl\n+    __ autia1716();                                    \/\/       autia1716\n+    __ autiasp();                                      \/\/       autiasp\n+    __ autiaz();                                       \/\/       autiaz\n+    __ autib1716();                                    \/\/       autib1716\n+    __ autibsp();                                      \/\/       autibsp\n+    __ autibz();                                       \/\/       autibz\n+    __ pacia1716();                                    \/\/       pacia1716\n+    __ paciasp();                                      \/\/       paciasp\n+    __ paciaz();                                       \/\/       paciaz\n+    __ pacib1716();                                    \/\/       pacib1716\n+    __ pacibsp();                                      \/\/       pacibsp\n+    __ pacibz();                                       \/\/       pacibz\n@@ -175,0 +191,4 @@\n+\/\/ PostfixExceptionOp\n+    __ wfi();                                          \/\/       wfi\n+    __ xpaclri();                                      \/\/       xpaclri\n+\n@@ -182,0 +202,16 @@\n+    __ paciza(r10);                                    \/\/       paciza  x10\n+    __ pacizb(r27);                                    \/\/       pacizb  x27\n+    __ pacdza(r8);                                     \/\/       pacdza  x8\n+    __ pacdzb(r0);                                     \/\/       pacdzb  x0\n+    __ autiza(r1);                                     \/\/       autiza  x1\n+    __ autizb(r21);                                    \/\/       autizb  x21\n+    __ autdza(r17);                                    \/\/       autdza  x17\n+    __ autdzb(r29);                                    \/\/       autdzb  x29\n+    __ xpacd(r29);                                     \/\/       xpacd   x29\n+    __ braaz(r28);                                     \/\/       braaz   x28\n+    __ brabz(r1);                                      \/\/       brabz   x1\n+    __ blraaz(r23);                                    \/\/       blraaz  x23\n+    __ blrabz(r21);                                    \/\/       blrabz  x21\n+\n+\/\/ PostfixExceptionOneRegOp\n+    __ xpaci(r20);                                     \/\/       xpaci   x20\n@@ -184,6 +220,6 @@\n-    __ stxr(r10, r27, r8);                             \/\/       stxr    w10, x27, [x8]\n-    __ stlxr(r0, r1, r21);                             \/\/       stlxr   w0, x1, [x21]\n-    __ ldxr(r17, r29);                                 \/\/       ldxr    x17, [x29]\n-    __ ldaxr(r29, r28);                                \/\/       ldaxr   x29, [x28]\n-    __ stlr(r1, r23);                                  \/\/       stlr    x1, [x23]\n-    __ ldar(r21, r20);                                 \/\/       ldar    x21, [x20]\n+    __ stxr(r22, r27, r19);                            \/\/       stxr    w22, x27, [x19]\n+    __ stlxr(r11, r16, r6);                            \/\/       stlxr   w11, x16, [x6]\n+    __ ldxr(r17, r0);                                  \/\/       ldxr    x17, [x0]\n+    __ ldaxr(r4, r10);                                 \/\/       ldaxr   x4, [x10]\n+    __ stlr(r24, r22);                                 \/\/       stlr    x24, [x22]\n+    __ ldar(r10, r19);                                 \/\/       ldar    x10, [x19]\n@@ -192,6 +228,6 @@\n-    __ stxrw(r22, r27, r19);                           \/\/       stxr    w22, w27, [x19]\n-    __ stlxrw(r11, r16, r6);                           \/\/       stlxr   w11, w16, [x6]\n-    __ ldxrw(r17, r0);                                 \/\/       ldxr    w17, [x0]\n-    __ ldaxrw(r4, r10);                                \/\/       ldaxr   w4, [x10]\n-    __ stlrw(r24, r22);                                \/\/       stlr    w24, [x22]\n-    __ ldarw(r10, r19);                                \/\/       ldar    w10, [x19]\n+    __ stxrw(r1, r5, r30);                             \/\/       stxr    w1, w5, [x30]\n+    __ stlxrw(r8, r12, r17);                           \/\/       stlxr   w8, w12, [x17]\n+    __ ldxrw(r9, r14);                                 \/\/       ldxr    w9, [x14]\n+    __ ldaxrw(r7, r1);                                 \/\/       ldaxr   w7, [x1]\n+    __ stlrw(r5, r16);                                 \/\/       stlr    w5, [x16]\n+    __ ldarw(r2, r12);                                 \/\/       ldar    w2, [x12]\n@@ -200,6 +236,6 @@\n-    __ stxrh(r1, r5, r30);                             \/\/       stxrh   w1, w5, [x30]\n-    __ stlxrh(r8, r12, r17);                           \/\/       stlxrh  w8, w12, [x17]\n-    __ ldxrh(r9, r14);                                 \/\/       ldxrh   w9, [x14]\n-    __ ldaxrh(r7, r1);                                 \/\/       ldaxrh  w7, [x1]\n-    __ stlrh(r5, r16);                                 \/\/       stlrh   w5, [x16]\n-    __ ldarh(r2, r12);                                 \/\/       ldarh   w2, [x12]\n+    __ stxrh(r10, r12, r3);                            \/\/       stxrh   w10, w12, [x3]\n+    __ stlxrh(r28, r14, r26);                          \/\/       stlxrh  w28, w14, [x26]\n+    __ ldxrh(r30, r10);                                \/\/       ldxrh   w30, [x10]\n+    __ ldaxrh(r14, r21);                               \/\/       ldaxrh  w14, [x21]\n+    __ stlrh(r13, r9);                                 \/\/       stlrh   w13, [x9]\n+    __ ldarh(r22, r27);                                \/\/       ldarh   w22, [x27]\n@@ -208,6 +244,6 @@\n-    __ stxrb(r10, r12, r3);                            \/\/       stxrb   w10, w12, [x3]\n-    __ stlxrb(r28, r14, r26);                          \/\/       stlxrb  w28, w14, [x26]\n-    __ ldxrb(r30, r10);                                \/\/       ldxrb   w30, [x10]\n-    __ ldaxrb(r14, r21);                               \/\/       ldaxrb  w14, [x21]\n-    __ stlrb(r13, r9);                                 \/\/       stlrb   w13, [x9]\n-    __ ldarb(r22, r27);                                \/\/       ldarb   w22, [x27]\n+    __ stxrb(r28, r19, r11);                           \/\/       stxrb   w28, w19, [x11]\n+    __ stlxrb(r30, r19, r2);                           \/\/       stlxrb  w30, w19, [x2]\n+    __ ldxrb(r2, r23);                                 \/\/       ldxrb   w2, [x23]\n+    __ ldaxrb(r1, r0);                                 \/\/       ldaxrb  w1, [x0]\n+    __ stlrb(r12, r16);                                \/\/       stlrb   w12, [x16]\n+    __ ldarb(r13, r15);                                \/\/       ldarb   w13, [x15]\n@@ -216,4 +252,4 @@\n-    __ ldxp(r28, r19, r11);                            \/\/       ldxp    x28, x19, [x11]\n-    __ ldaxp(r30, r19, r2);                            \/\/       ldaxp   x30, x19, [x2]\n-    __ stxp(r2, r23, r1, r0);                          \/\/       stxp    w2, x23, x1, [x0]\n-    __ stlxp(r12, r16, r13, r15);                      \/\/       stlxp   w12, x16, x13, [x15]\n+    __ ldxp(r17, r21, r13);                            \/\/       ldxp    x17, x21, [x13]\n+    __ ldaxp(r11, r30, r8);                            \/\/       ldaxp   x11, x30, [x8]\n+    __ stxp(r24, r13, r11, r1);                        \/\/       stxp    w24, x13, x11, [x1]\n+    __ stlxp(r26, r21, r27, r13);                      \/\/       stlxp   w26, x21, x27, [x13]\n@@ -222,4 +258,4 @@\n-    __ ldxpw(r17, r21, r13);                           \/\/       ldxp    w17, w21, [x13]\n-    __ ldaxpw(r11, r30, r8);                           \/\/       ldaxp   w11, w30, [x8]\n-    __ stxpw(r24, r13, r11, r1);                       \/\/       stxp    w24, w13, w11, [x1]\n-    __ stlxpw(r26, r21, r27, r13);                     \/\/       stlxp   w26, w21, w27, [x13]\n+    __ ldxpw(r20, r3, r12);                            \/\/       ldxp    w20, w3, [x12]\n+    __ ldaxpw(r6, r1, r29);                            \/\/       ldaxp   w6, w1, [x29]\n+    __ stxpw(r6, r4, r11, r16);                        \/\/       stxp    w6, w4, w11, [x16]\n+    __ stlxpw(r4, r30, r12, r21);                      \/\/       stlxp   w4, w30, w12, [x21]\n@@ -229,16 +265,16 @@\n-    __ str(r11, Address(r20, -103));                   \/\/       str     x11, [x20, -103]\n-    __ strw(r28, Address(r16, 62));                    \/\/       str     w28, [x16, 62]\n-    __ strb(r27, Address(r9, -9));                     \/\/       strb    w27, [x9, -9]\n-    __ strh(r2, Address(r25, -50));                    \/\/       strh    w2, [x25, -50]\n-    __ ldr(r4, Address(r2, -241));                     \/\/       ldr     x4, [x2, -241]\n-    __ ldrw(r30, Address(r20, -31));                   \/\/       ldr     w30, [x20, -31]\n-    __ ldrb(r17, Address(r23, -23));                   \/\/       ldrb    w17, [x23, -23]\n-    __ ldrh(r29, Address(r26, -1));                    \/\/       ldrh    w29, [x26, -1]\n-    __ ldrsb(r1, Address(r9, 6));                      \/\/       ldrsb   x1, [x9, 6]\n-    __ ldrsh(r11, Address(r12, 19));                   \/\/       ldrsh   x11, [x12, 19]\n-    __ ldrshw(r11, Address(r1, -50));                  \/\/       ldrsh   w11, [x1, -50]\n-    __ ldrsw(r19, Address(r24, 41));                   \/\/       ldrsw   x19, [x24, 41]\n-    __ ldrd(v24, Address(r24, 95));                    \/\/       ldr     d24, [x24, 95]\n-    __ ldrs(v15, Address(r5, -43));                    \/\/       ldr     s15, [x5, -43]\n-    __ strd(v21, Address(r27, 1));                     \/\/       str     d21, [x27, 1]\n-    __ strs(v23, Address(r13, -107));                  \/\/       str     s23, [x13, -107]\n+    __ str(r6, Address(r27, 97));                      \/\/       str     x6, [x27, 97]\n+    __ strw(r17, Address(r10, 45));                    \/\/       str     w17, [x10, 45]\n+    __ strb(r26, Address(r22, -29));                   \/\/       strb    w26, [x22, -29]\n+    __ strh(r21, Address(r10, -50));                   \/\/       strh    w21, [x10, -50]\n+    __ ldr(r14, Address(r24, 125));                    \/\/       ldr     x14, [x24, 125]\n+    __ ldrw(r7, Address(r24, -16));                    \/\/       ldr     w7, [x24, -16]\n+    __ ldrb(r8, Address(r2, 13));                      \/\/       ldrb    w8, [x2, 13]\n+    __ ldrh(r30, Address(r25, -61));                   \/\/       ldrh    w30, [x25, -61]\n+    __ ldrsb(r3, Address(r12, -14));                   \/\/       ldrsb   x3, [x12, -14]\n+    __ ldrsh(r10, Address(r17, -28));                  \/\/       ldrsh   x10, [x17, -28]\n+    __ ldrshw(r21, Address(r3, -5));                   \/\/       ldrsh   w21, [x3, -5]\n+    __ ldrsw(r2, Address(r25, 23));                    \/\/       ldrsw   x2, [x25, 23]\n+    __ ldrd(v25, Address(r1, -69));                    \/\/       ldr     d25, [x1, -69]\n+    __ ldrs(v29, Address(r27, 6));                     \/\/       ldr     s29, [x27, 6]\n+    __ strd(v29, Address(r12, 41));                    \/\/       str     d29, [x12, 41]\n+    __ strs(v2, Address(r22, -115));                   \/\/       str     s2, [x22, -115]\n@@ -248,16 +284,16 @@\n-    __ str(r10, Address(__ pre(r0, 8)));               \/\/       str     x10, [x0, 8]!\n-    __ strw(r3, Address(__ pre(r0, 29)));              \/\/       str     w3, [x0, 29]!\n-    __ strb(r10, Address(__ pre(r14, 9)));             \/\/       strb    w10, [x14, 9]!\n-    __ strh(r29, Address(__ pre(r25, -3)));            \/\/       strh    w29, [x25, -3]!\n-    __ ldr(r12, Address(__ pre(r16, -144)));           \/\/       ldr     x12, [x16, -144]!\n-    __ ldrw(r12, Address(__ pre(r22, -6)));            \/\/       ldr     w12, [x22, -6]!\n-    __ ldrb(r13, Address(__ pre(r11, -10)));           \/\/       ldrb    w13, [x11, -10]!\n-    __ ldrh(r0, Address(__ pre(r21, -21)));            \/\/       ldrh    w0, [x21, -21]!\n-    __ ldrsb(r23, Address(__ pre(r6, 4)));             \/\/       ldrsb   x23, [x6, 4]!\n-    __ ldrsh(r3, Address(__ pre(r7, -53)));            \/\/       ldrsh   x3, [x7, -53]!\n-    __ ldrshw(r28, Address(__ pre(r4, -7)));           \/\/       ldrsh   w28, [x4, -7]!\n-    __ ldrsw(r24, Address(__ pre(r8, -18)));           \/\/       ldrsw   x24, [x8, -18]!\n-    __ ldrd(v14, Address(__ pre(r11, 12)));            \/\/       ldr     d14, [x11, 12]!\n-    __ ldrs(v19, Address(__ pre(r12, -67)));           \/\/       ldr     s19, [x12, -67]!\n-    __ strd(v20, Address(__ pre(r0, -253)));           \/\/       str     d20, [x0, -253]!\n-    __ strs(v8, Address(__ pre(r0, 64)));              \/\/       str     s8, [x0, 64]!\n+    __ str(r26, Address(__ pre(r5, 3)));               \/\/       str     x26, [x5, 3]!\n+    __ strw(r20, Address(__ pre(r5, -103)));           \/\/       str     w20, [x5, -103]!\n+    __ strb(r8, Address(__ pre(r12, -25)));            \/\/       strb    w8, [x12, -25]!\n+    __ strh(r20, Address(__ pre(r2, -57)));            \/\/       strh    w20, [x2, -57]!\n+    __ ldr(r14, Address(__ pre(r29, -234)));           \/\/       ldr     x14, [x29, -234]!\n+    __ ldrw(r13, Address(__ pre(r29, 4)));             \/\/       ldr     w13, [x29, 4]!\n+    __ ldrb(r24, Address(__ pre(r19, -9)));            \/\/       ldrb    w24, [x19, -9]!\n+    __ ldrh(r3, Address(__ pre(r27, -19)));            \/\/       ldrh    w3, [x27, -19]!\n+    __ ldrsb(r17, Address(__ pre(r1, -5)));            \/\/       ldrsb   x17, [x1, -5]!\n+    __ ldrsh(r17, Address(__ pre(r19, -13)));          \/\/       ldrsh   x17, [x19, -13]!\n+    __ ldrshw(r21, Address(__ pre(r11, -26)));         \/\/       ldrsh   w21, [x11, -26]!\n+    __ ldrsw(r1, Address(__ pre(r9, -60)));            \/\/       ldrsw   x1, [x9, -60]!\n+    __ ldrd(v26, Address(__ pre(r23, -247)));          \/\/       ldr     d26, [x23, -247]!\n+    __ ldrs(v22, Address(__ pre(r21, -127)));          \/\/       ldr     s22, [x21, -127]!\n+    __ strd(v13, Address(__ pre(r7, -216)));           \/\/       str     d13, [x7, -216]!\n+    __ strs(v12, Address(__ pre(r13, -104)));          \/\/       str     s12, [x13, -104]!\n@@ -267,16 +303,16 @@\n-    __ str(r3, Address(__ post(r28, -94)));            \/\/       str     x3, [x28], -94\n-    __ strw(r11, Address(__ post(r7, -54)));           \/\/       str     w11, [x7], -54\n-    __ strb(r27, Address(__ post(r10, -24)));          \/\/       strb    w27, [x10], -24\n-    __ strh(r6, Address(__ post(r7, 27)));             \/\/       strh    w6, [x7], 27\n-    __ ldr(r13, Address(__ post(r10, -202)));          \/\/       ldr     x13, [x10], -202\n-    __ ldrw(r15, Address(__ post(r5, -41)));           \/\/       ldr     w15, [x5], -41\n-    __ ldrb(r2, Address(__ post(r13, 9)));             \/\/       ldrb    w2, [x13], 9\n-    __ ldrh(r28, Address(__ post(r13, -20)));          \/\/       ldrh    w28, [x13], -20\n-    __ ldrsb(r9, Address(__ post(r13, -31)));          \/\/       ldrsb   x9, [x13], -31\n-    __ ldrsh(r3, Address(__ post(r24, -36)));          \/\/       ldrsh   x3, [x24], -36\n-    __ ldrshw(r20, Address(__ post(r3, 6)));           \/\/       ldrsh   w20, [x3], 6\n-    __ ldrsw(r7, Address(__ post(r19, -1)));           \/\/       ldrsw   x7, [x19], -1\n-    __ ldrd(v30, Address(__ post(r8, -130)));          \/\/       ldr     d30, [x8], -130\n-    __ ldrs(v25, Address(__ post(r15, 21)));           \/\/       ldr     s25, [x15], 21\n-    __ strd(v14, Address(__ post(r23, 90)));           \/\/       str     d14, [x23], 90\n-    __ strs(v8, Address(__ post(r0, -33)));            \/\/       str     s8, [x0], -33\n+    __ str(r20, Address(__ post(r5, -237)));           \/\/       str     x20, [x5], -237\n+    __ strw(r29, Address(__ post(r28, -74)));          \/\/       str     w29, [x28], -74\n+    __ strb(r4, Address(__ post(r24, -22)));           \/\/       strb    w4, [x24], -22\n+    __ strh(r13, Address(__ post(r9, -21)));           \/\/       strh    w13, [x9], -21\n+    __ ldr(r26, Address(__ post(r7, -55)));            \/\/       ldr     x26, [x7], -55\n+    __ ldrw(r13, Address(__ post(r3, -115)));          \/\/       ldr     w13, [x3], -115\n+    __ ldrb(r1, Address(__ post(r5, 12)));             \/\/       ldrb    w1, [x5], 12\n+    __ ldrh(r8, Address(__ post(r13, -34)));           \/\/       ldrh    w8, [x13], -34\n+    __ ldrsb(r23, Address(__ post(r20, -27)));         \/\/       ldrsb   x23, [x20], -27\n+    __ ldrsh(r20, Address(__ post(r6, -2)));           \/\/       ldrsh   x20, [x6], -2\n+    __ ldrshw(r9, Address(__ post(r17, -42)));         \/\/       ldrsh   w9, [x17], -42\n+    __ ldrsw(r21, Address(__ post(r6, -30)));          \/\/       ldrsw   x21, [x6], -30\n+    __ ldrd(v16, Address(__ post(r22, -29)));          \/\/       ldr     d16, [x22], -29\n+    __ ldrs(v9, Address(__ post(r11, -3)));            \/\/       ldr     s9, [x11], -3\n+    __ strd(v22, Address(__ post(r26, 60)));           \/\/       str     d22, [x26], 60\n+    __ strs(v16, Address(__ post(r29, -2)));           \/\/       str     s16, [x29], -2\n@@ -286,16 +322,16 @@\n-    __ str(r10, Address(r17, r21, Address::sxtw(3)));  \/\/       str     x10, [x17, w21, sxtw #3]\n-    __ strw(r4, Address(r13, r22, Address::sxtw(2)));  \/\/       str     w4, [x13, w22, sxtw #2]\n-    __ strb(r13, Address(r0, r19, Address::uxtw(0)));  \/\/       strb    w13, [x0, w19, uxtw #0]\n-    __ strh(r12, Address(r27, r6, Address::sxtw(0)));  \/\/       strh    w12, [x27, w6, sxtw #0]\n-    __ ldr(r0, Address(r8, r16, Address::lsl(0)));     \/\/       ldr     x0, [x8, x16, lsl #0]\n-    __ ldrw(r0, Address(r4, r26, Address::sxtx(0)));   \/\/       ldr     w0, [x4, x26, sxtx #0]\n-    __ ldrb(r14, Address(r25, r5, Address::sxtw(0)));  \/\/       ldrb    w14, [x25, w5, sxtw #0]\n-    __ ldrh(r9, Address(r4, r17, Address::uxtw(0)));   \/\/       ldrh    w9, [x4, w17, uxtw #0]\n-    __ ldrsb(r27, Address(r4, r7, Address::lsl(0)));   \/\/       ldrsb   x27, [x4, x7, lsl #0]\n-    __ ldrsh(r15, Address(r17, r30, Address::sxtw(0))); \/\/      ldrsh   x15, [x17, w30, sxtw #0]\n-    __ ldrshw(r16, Address(r0, r22, Address::sxtw(0))); \/\/      ldrsh   w16, [x0, w22, sxtw #0]\n-    __ ldrsw(r22, Address(r10, r30, Address::sxtx(2))); \/\/      ldrsw   x22, [x10, x30, sxtx #2]\n-    __ ldrd(v29, Address(r21, r10, Address::sxtx(3))); \/\/       ldr     d29, [x21, x10, sxtx #3]\n-    __ ldrs(v3, Address(r11, r19, Address::uxtw(0)));  \/\/       ldr     s3, [x11, w19, uxtw #0]\n-    __ strd(v13, Address(r28, r29, Address::uxtw(3))); \/\/       str     d13, [x28, w29, uxtw #3]\n-    __ strs(v23, Address(r29, r5, Address::sxtx(2)));  \/\/       str     s23, [x29, x5, sxtx #2]\n+    __ str(r1, Address(r22, r4, Address::sxtw(0)));    \/\/       str     x1, [x22, w4, sxtw #0]\n+    __ strw(r23, Address(r30, r13, Address::lsl(2)));  \/\/       str     w23, [x30, x13, lsl #2]\n+    __ strb(r12, Address(r11, r12, Address::uxtw(0))); \/\/       strb    w12, [x11, w12, uxtw #0]\n+    __ strh(r25, Address(r12, r0, Address::lsl(1)));   \/\/       strh    w25, [x12, x0, lsl #1]\n+    __ ldr(r17, Address(r7, r0, Address::uxtw(3)));    \/\/       ldr     x17, [x7, w0, uxtw #3]\n+    __ ldrw(r1, Address(r19, r14, Address::uxtw(2)));  \/\/       ldr     w1, [x19, w14, uxtw #2]\n+    __ ldrb(r12, Address(r2, r9, Address::lsl(0)));    \/\/       ldrb    w12, [x2, x9, lsl #0]\n+    __ ldrh(r22, Address(r9, r27, Address::sxtw(0)));  \/\/       ldrh    w22, [x9, w27, sxtw #0]\n+    __ ldrsb(r21, Address(r12, r15, Address::sxtx(0))); \/\/      ldrsb   x21, [x12, x15, sxtx #0]\n+    __ ldrsh(r28, Address(r6, r16, Address::lsl(1)));  \/\/       ldrsh   x28, [x6, x16, lsl #1]\n+    __ ldrshw(r25, Address(r17, r22, Address::sxtw(0))); \/\/     ldrsh   w25, [x17, w22, sxtw #0]\n+    __ ldrsw(r4, Address(r17, r29, Address::sxtx(0))); \/\/       ldrsw   x4, [x17, x29, sxtx #0]\n+    __ ldrd(v5, Address(r1, r3, Address::sxtx(3)));    \/\/       ldr     d5, [x1, x3, sxtx #3]\n+    __ ldrs(v24, Address(r17, r13, Address::uxtw(2))); \/\/       ldr     s24, [x17, w13, uxtw #2]\n+    __ strd(v17, Address(r17, r23, Address::sxtx(3))); \/\/       str     d17, [x17, x23, sxtx #3]\n+    __ strs(v17, Address(r30, r5, Address::sxtw(2)));  \/\/       str     s17, [x30, w5, sxtw #2]\n@@ -305,16 +341,16 @@\n-    __ str(r5, Address(r8, 12600));                    \/\/       str     x5, [x8, 12600]\n-    __ strw(r29, Address(r24, 7880));                  \/\/       str     w29, [x24, 7880]\n-    __ strb(r19, Address(r17, 1566));                  \/\/       strb    w19, [x17, 1566]\n-    __ strh(r13, Address(r19, 3984));                  \/\/       strh    w13, [x19, 3984]\n-    __ ldr(r19, Address(r23, 13632));                  \/\/       ldr     x19, [x23, 13632]\n-    __ ldrw(r23, Address(r29, 6264));                  \/\/       ldr     w23, [x29, 6264]\n-    __ ldrb(r22, Address(r11, 2012));                  \/\/       ldrb    w22, [x11, 2012]\n-    __ ldrh(r3, Address(r10, 3784));                   \/\/       ldrh    w3, [x10, 3784]\n-    __ ldrsb(r8, Address(r16, 1951));                  \/\/       ldrsb   x8, [x16, 1951]\n-    __ ldrsh(r23, Address(r20, 3346));                 \/\/       ldrsh   x23, [x20, 3346]\n-    __ ldrshw(r2, Address(r1, 3994));                  \/\/       ldrsh   w2, [x1, 3994]\n-    __ ldrsw(r4, Address(r17, 7204));                  \/\/       ldrsw   x4, [x17, 7204]\n-    __ ldrd(v20, Address(r27, 14400));                 \/\/       ldr     d20, [x27, 14400]\n-    __ ldrs(v25, Address(r14, 8096));                  \/\/       ldr     s25, [x14, 8096]\n-    __ strd(v26, Address(r10, 15024));                 \/\/       str     d26, [x10, 15024]\n-    __ strs(v9, Address(r3, 6936));                    \/\/       str     s9, [x3, 6936]\n+    __ str(r29, Address(r11, 14160));                  \/\/       str     x29, [x11, 14160]\n+    __ strw(r28, Address(r21, 7752));                  \/\/       str     w28, [x21, 7752]\n+    __ strb(r28, Address(r2, 1746));                   \/\/       strb    w28, [x2, 1746]\n+    __ strh(r0, Address(r28, 3296));                   \/\/       strh    w0, [x28, 3296]\n+    __ ldr(r25, Address(r7, 15408));                   \/\/       ldr     x25, [x7, 15408]\n+    __ ldrw(r0, Address(r3, 6312));                    \/\/       ldr     w0, [x3, 6312]\n+    __ ldrb(r30, Address(r5, 1992));                   \/\/       ldrb    w30, [x5, 1992]\n+    __ ldrh(r14, Address(r23, 3194));                  \/\/       ldrh    w14, [x23, 3194]\n+    __ ldrsb(r10, Address(r19, 1786));                 \/\/       ldrsb   x10, [x19, 1786]\n+    __ ldrsh(r29, Address(r17, 3482));                 \/\/       ldrsh   x29, [x17, 3482]\n+    __ ldrshw(r25, Address(r30, 3362));                \/\/       ldrsh   w25, [x30, 3362]\n+    __ ldrsw(r17, Address(r2, 7512));                  \/\/       ldrsw   x17, [x2, 7512]\n+    __ ldrd(v15, Address(r16, 15176));                 \/\/       ldr     d15, [x16, 15176]\n+    __ ldrs(v12, Address(r30, 6220));                  \/\/       ldr     s12, [x30, 6220]\n+    __ strd(v1, Address(r1, 15216));                   \/\/       str     d1, [x1, 15216]\n+    __ strs(v5, Address(r11, 7832));                   \/\/       str     s5, [x11, 7832]\n@@ -324,2 +360,2 @@\n-    __ ldr(r27, forth);                                \/\/       ldr     x27, forth\n-    __ ldrw(r11, __ pc());                             \/\/       ldr     w11, .\n+    __ ldr(r17, back);                                 \/\/       ldr     x17, back\n+    __ ldrw(r2, back);                                 \/\/       ldr     w2, back\n@@ -328,1 +364,1 @@\n-    __ prfm(Address(r3, -187));                        \/\/       prfm    PLDL1KEEP, [x3, -187]\n+    __ prfm(Address(r25, 111));                        \/\/       prfm    PLDL1KEEP, [x25, 111]\n@@ -331,1 +367,1 @@\n-    __ prfm(__ pc());                                  \/\/       prfm    PLDL1KEEP, .\n+    __ prfm(back);                                     \/\/       prfm    PLDL1KEEP, back\n@@ -334,1 +370,1 @@\n-    __ prfm(Address(r29, r14, Address::lsl(0)));       \/\/       prfm    PLDL1KEEP, [x29, x14, lsl #0]\n+    __ prfm(Address(r14, r27, Address::uxtw(0)));      \/\/       prfm    PLDL1KEEP, [x14, w27, uxtw #0]\n@@ -337,1 +373,1 @@\n-    __ prfm(Address(r4, 13312));                       \/\/       prfm    PLDL1KEEP, [x4, 13312]\n+    __ prfm(Address(r14, 12328));                      \/\/       prfm    PLDL1KEEP, [x14, 12328]\n@@ -340,8 +376,8 @@\n-    __ adcw(r21, r1, r7);                              \/\/       adc     w21, w1, w7\n-    __ adcsw(r8, r5, r7);                              \/\/       adcs    w8, w5, w7\n-    __ sbcw(r7, r27, r14);                             \/\/       sbc     w7, w27, w14\n-    __ sbcsw(r27, r4, r17);                            \/\/       sbcs    w27, w4, w17\n-    __ adc(r0, r28, r0);                               \/\/       adc     x0, x28, x0\n-    __ adcs(r12, r24, r30);                            \/\/       adcs    x12, x24, x30\n-    __ sbc(r0, r25, r15);                              \/\/       sbc     x0, x25, x15\n-    __ sbcs(r1, r24, r3);                              \/\/       sbcs    x1, x24, x3\n+    __ adcw(r0, r25, r15);                             \/\/       adc     w0, w25, w15\n+    __ adcsw(r1, r24, r3);                             \/\/       adcs    w1, w24, w3\n+    __ sbcw(r17, r24, r20);                            \/\/       sbc     w17, w24, w20\n+    __ sbcsw(r11, r0, r13);                            \/\/       sbcs    w11, w0, w13\n+    __ adc(r28, r10, r7);                              \/\/       adc     x28, x10, x7\n+    __ adcs(r4, r15, r16);                             \/\/       adcs    x4, x15, x16\n+    __ sbc(r2, r12, r20);                              \/\/       sbc     x2, x12, x20\n+    __ sbcs(r29, r13, r13);                            \/\/       sbcs    x29, x13, x13\n@@ -350,8 +386,8 @@\n-    __ addw(r17, r24, r20, ext::uxtb, 2);              \/\/       add     w17, w24, w20, uxtb #2\n-    __ addsw(r13, r28, r10, ext::uxth, 1);             \/\/       adds    w13, w28, w10, uxth #1\n-    __ sub(r15, r16, r2, ext::sxth, 2);                \/\/       sub     x15, x16, x2, sxth #2\n-    __ subsw(r29, r13, r13, ext::uxth, 2);             \/\/       subs    w29, w13, w13, uxth #2\n-    __ add(r12, r20, r12, ext::sxtw, 3);               \/\/       add     x12, x20, x12, sxtw #3\n-    __ adds(r30, r27, r11, ext::sxtb, 1);              \/\/       adds    x30, x27, x11, sxtb #1\n-    __ sub(r14, r7, r1, ext::sxtw, 2);                 \/\/       sub     x14, x7, x1, sxtw #2\n-    __ subs(r29, r3, r27, ext::sxth, 1);               \/\/       subs    x29, x3, x27, sxth #1\n+    __ addw(r14, r6, r12, ext::uxtx, 3);               \/\/       add     w14, w6, w12, uxtx #3\n+    __ addsw(r17, r25, r30, ext::uxtw, 4);             \/\/       adds    w17, w25, w30, uxtw #4\n+    __ sub(r0, r17, r14, ext::uxtb, 1);                \/\/       sub     x0, x17, x14, uxtb #1\n+    __ subsw(r9, r24, r29, ext::sxtx, 1);              \/\/       subs    w9, w24, w29, sxtx #1\n+    __ add(r1, r22, r0, ext::sxtw, 2);                 \/\/       add     x1, x22, x0, sxtw #2\n+    __ adds(r12, r28, r22, ext::uxth, 3);              \/\/       adds    x12, x28, x22, uxth #3\n+    __ sub(r10, r12, r17, ext::uxtw, 4);               \/\/       sub     x10, x12, x17, uxtw #4\n+    __ subs(r15, r28, r10, ext::sxtw, 3);              \/\/       subs    x15, x28, x10, sxtw #3\n@@ -360,4 +396,4 @@\n-    __ ccmnw(r0, r13, 14u, Assembler::MI);             \/\/       ccmn    w0, w13, #14, MI\n-    __ ccmpw(r22, r17, 6u, Assembler::CC);             \/\/       ccmp    w22, w17, #6, CC\n-    __ ccmn(r17, r30, 14u, Assembler::VS);             \/\/       ccmn    x17, x30, #14, VS\n-    __ ccmp(r10, r19, 12u, Assembler::HI);             \/\/       ccmp    x10, x19, #12, HI\n+    __ ccmnw(r19, r23, 2u, Assembler::LE);             \/\/       ccmn    w19, w23, #2, LE\n+    __ ccmpw(r17, r9, 6u, Assembler::LO);              \/\/       ccmp    w17, w9, #6, LO\n+    __ ccmn(r21, r8, 2u, Assembler::CC);               \/\/       ccmn    x21, x8, #2, CC\n+    __ ccmp(r19, r5, 1u, Assembler::MI);               \/\/       ccmp    x19, x5, #1, MI\n@@ -366,4 +402,4 @@\n-    __ ccmnw(r6, 18, 2, Assembler::LE);                \/\/       ccmn    w6, #18, #2, LE\n-    __ ccmpw(r9, 13, 4, Assembler::HI);                \/\/       ccmp    w9, #13, #4, HI\n-    __ ccmn(r21, 11, 11, Assembler::LO);               \/\/       ccmn    x21, #11, #11, LO\n-    __ ccmp(r4, 13, 2, Assembler::VC);                 \/\/       ccmp    x4, #13, #2, VC\n+    __ ccmnw(r22, 17, 12, Assembler::HI);              \/\/       ccmn    w22, #17, #12, HI\n+    __ ccmpw(r17, 7, 3, Assembler::HS);                \/\/       ccmp    w17, #7, #3, HS\n+    __ ccmn(r16, 28, 5, Assembler::LT);                \/\/       ccmn    x16, #28, #5, LT\n+    __ ccmp(r22, 3, 5, Assembler::LS);                 \/\/       ccmp    x22, #3, #5, LS\n@@ -372,8 +408,8 @@\n-    __ cselw(r12, r2, r22, Assembler::HI);             \/\/       csel    w12, w2, w22, HI\n-    __ csincw(r24, r16, r17, Assembler::HS);           \/\/       csinc   w24, w16, w17, HS\n-    __ csinvw(r6, r7, r16, Assembler::LT);             \/\/       csinv   w6, w7, w16, LT\n-    __ csnegw(r11, r27, r22, Assembler::LS);           \/\/       csneg   w11, w27, w22, LS\n-    __ csel(r10, r3, r29, Assembler::LT);              \/\/       csel    x10, x3, x29, LT\n-    __ csinc(r12, r26, r27, Assembler::CC);            \/\/       csinc   x12, x26, x27, CC\n-    __ csinv(r15, r10, r21, Assembler::GT);            \/\/       csinv   x15, x10, x21, GT\n-    __ csneg(r30, r23, r9, Assembler::GT);             \/\/       csneg   x30, x23, x9, GT\n+    __ cselw(r29, r26, r12, Assembler::LT);            \/\/       csel    w29, w26, w12, LT\n+    __ csincw(r27, r10, r15, Assembler::CC);           \/\/       csinc   w27, w10, w15, CC\n+    __ csinvw(r21, r28, r30, Assembler::LS);           \/\/       csinv   w21, w28, w30, LS\n+    __ csnegw(r9, r27, r30, Assembler::CC);            \/\/       csneg   w9, w27, w30, CC\n+    __ csel(r29, r15, r29, Assembler::LE);             \/\/       csel    x29, x15, x29, LE\n+    __ csinc(r25, r21, r4, Assembler::EQ);             \/\/       csinc   x25, x21, x4, EQ\n+    __ csinv(r17, r21, r29, Assembler::VS);            \/\/       csinv   x17, x21, x29, VS\n+    __ csneg(r21, r20, r6, Assembler::HI);             \/\/       csneg   x21, x20, x6, HI\n@@ -382,11 +418,23 @@\n-    __ rbitw(r30, r10);                                \/\/       rbit    w30, w10\n-    __ rev16w(r29, r15);                               \/\/       rev16   w29, w15\n-    __ revw(r29, r30);                                 \/\/       rev     w29, w30\n-    __ clzw(r25, r21);                                 \/\/       clz     w25, w21\n-    __ clsw(r4, r0);                                   \/\/       cls     w4, w0\n-    __ rbit(r17, r21);                                 \/\/       rbit    x17, x21\n-    __ rev16(r29, r16);                                \/\/       rev16   x29, x16\n-    __ rev32(r21, r20);                                \/\/       rev32   x21, x20\n-    __ rev(r6, r19);                                   \/\/       rev     x6, x19\n-    __ clz(r30, r3);                                   \/\/       clz     x30, x3\n-    __ cls(r21, r19);                                  \/\/       cls     x21, x19\n+    __ rbitw(r30, r3);                                 \/\/       rbit    w30, w3\n+    __ rev16w(r21, r19);                               \/\/       rev16   w21, w19\n+    __ revw(r11, r24);                                 \/\/       rev     w11, w24\n+    __ clzw(r0, r27);                                  \/\/       clz     w0, w27\n+    __ clsw(r25, r14);                                 \/\/       cls     w25, w14\n+    __ rbit(r3, r14);                                  \/\/       rbit    x3, x14\n+    __ rev16(r17, r7);                                 \/\/       rev16   x17, x7\n+    __ rev32(r15, r24);                                \/\/       rev32   x15, x24\n+    __ rev(r28, r17);                                  \/\/       rev     x28, x17\n+    __ clz(r25, r2);                                   \/\/       clz     x25, x2\n+    __ cls(r26, r28);                                  \/\/       cls     x26, x28\n+    __ pacia(r5, r25);                                 \/\/       pacia   x5, x25\n+    __ pacib(r26, r27);                                \/\/       pacib   x26, x27\n+    __ pacda(r16, r17);                                \/\/       pacda   x16, x17\n+    __ pacdb(r6, r21);                                 \/\/       pacdb   x6, x21\n+    __ autia(r12, r0);                                 \/\/       autia   x12, x0\n+    __ autib(r4, r12);                                 \/\/       autib   x4, x12\n+    __ autda(r27, r17);                                \/\/       autda   x27, x17\n+    __ autdb(r28, r28);                                \/\/       autdb   x28, x28\n+    __ braa(r2, r17);                                  \/\/       braa    x2, x17\n+    __ brab(r10, r15);                                 \/\/       brab    x10, x15\n+    __ blraa(r14, r14);                                \/\/       blraa   x14, x14\n+    __ blrab(r3, r25);                                 \/\/       blrab   x3, x25\n@@ -395,14 +443,14 @@\n-    __ udivw(r11, r24, r0);                            \/\/       udiv    w11, w24, w0\n-    __ sdivw(r27, r25, r14);                           \/\/       sdiv    w27, w25, w14\n-    __ lslvw(r3, r14, r17);                            \/\/       lslv    w3, w14, w17\n-    __ lsrvw(r7, r15, r24);                            \/\/       lsrv    w7, w15, w24\n-    __ asrvw(r28, r17, r25);                           \/\/       asrv    w28, w17, w25\n-    __ rorvw(r2, r26, r28);                            \/\/       rorv    w2, w26, w28\n-    __ udiv(r5, r25, r26);                             \/\/       udiv    x5, x25, x26\n-    __ sdiv(r27, r16, r17);                            \/\/       sdiv    x27, x16, x17\n-    __ lslv(r6, r21, r12);                             \/\/       lslv    x6, x21, x12\n-    __ lsrv(r0, r4, r12);                              \/\/       lsrv    x0, x4, x12\n-    __ asrv(r27, r17, r28);                            \/\/       asrv    x27, x17, x28\n-    __ rorv(r28, r2, r17);                             \/\/       rorv    x28, x2, x17\n-    __ umulh(r10, r15, r14);                           \/\/       umulh   x10, x15, x14\n-    __ smulh(r14, r3, r25);                            \/\/       smulh   x14, x3, x25\n+    __ udivw(r15, r19, r14);                           \/\/       udiv    w15, w19, w14\n+    __ sdivw(r5, r16, r4);                             \/\/       sdiv    w5, w16, w4\n+    __ lslvw(r26, r25, r4);                            \/\/       lslv    w26, w25, w4\n+    __ lsrvw(r2, r2, r12);                             \/\/       lsrv    w2, w2, w12\n+    __ asrvw(r29, r17, r8);                            \/\/       asrv    w29, w17, w8\n+    __ rorvw(r7, r3, r4);                              \/\/       rorv    w7, w3, w4\n+    __ udiv(r25, r4, r26);                             \/\/       udiv    x25, x4, x26\n+    __ sdiv(r25, r4, r17);                             \/\/       sdiv    x25, x4, x17\n+    __ lslv(r0, r26, r17);                             \/\/       lslv    x0, x26, x17\n+    __ lsrv(r23, r15, r21);                            \/\/       lsrv    x23, x15, x21\n+    __ asrv(r28, r17, r27);                            \/\/       asrv    x28, x17, x27\n+    __ rorv(r10, r3, r0);                              \/\/       rorv    x10, x3, x0\n+    __ umulh(r7, r25, r9);                             \/\/       umulh   x7, x25, x9\n+    __ smulh(r6, r15, r29);                            \/\/       smulh   x6, x15, x29\n@@ -411,8 +459,8 @@\n-    __ maddw(r15, r19, r14, r5);                       \/\/       madd    w15, w19, w14, w5\n-    __ msubw(r16, r4, r26, r25);                       \/\/       msub    w16, w4, w26, w25\n-    __ madd(r4, r2, r2, r12);                          \/\/       madd    x4, x2, x2, x12\n-    __ msub(r29, r17, r8, r7);                         \/\/       msub    x29, x17, x8, x7\n-    __ smaddl(r3, r4, r25, r4);                        \/\/       smaddl  x3, w4, w25, x4\n-    __ smsubl(r26, r25, r4, r17);                      \/\/       smsubl  x26, w25, w4, x17\n-    __ umaddl(r0, r26, r17, r23);                      \/\/       umaddl  x0, w26, w17, x23\n-    __ umsubl(r15, r21, r28, r17);                     \/\/       umsubl  x15, w21, w28, x17\n+    __ maddw(r15, r10, r2, r17);                       \/\/       madd    w15, w10, w2, w17\n+    __ msubw(r7, r11, r11, r23);                       \/\/       msub    w7, w11, w11, w23\n+    __ madd(r7, r29, r23, r14);                        \/\/       madd    x7, x29, x23, x14\n+    __ msub(r27, r11, r11, r4);                        \/\/       msub    x27, x11, x11, x4\n+    __ smaddl(r24, r12, r15, r14);                     \/\/       smaddl  x24, w12, w15, x14\n+    __ smsubl(r20, r11, r28, r13);                     \/\/       smsubl  x20, w11, w28, x13\n+    __ umaddl(r11, r12, r23, r30);                     \/\/       umaddl  x11, w12, w23, x30\n+    __ umsubl(r26, r14, r9, r13);                      \/\/       umsubl  x26, w14, w9, x13\n@@ -421,10 +469,10 @@\n-    __ fabds(v27, v10, v3);                            \/\/       fabd    s27, s10, s3\n-    __ fmuls(v0, v7, v25);                             \/\/       fmul    s0, s7, s25\n-    __ fdivs(v9, v6, v15);                             \/\/       fdiv    s9, s6, s15\n-    __ fadds(v29, v15, v10);                           \/\/       fadd    s29, s15, s10\n-    __ fsubs(v2, v17, v7);                             \/\/       fsub    s2, s17, s7\n-    __ fabdd(v11, v11, v23);                           \/\/       fabd    d11, d11, d23\n-    __ fmuld(v7, v29, v23);                            \/\/       fmul    d7, d29, d23\n-    __ fdivd(v14, v27, v11);                           \/\/       fdiv    d14, d27, d11\n-    __ faddd(v11, v4, v24);                            \/\/       fadd    d11, d4, d24\n-    __ fsubd(v12, v15, v14);                           \/\/       fsub    d12, d15, d14\n+    __ fabds(v10, v7, v5);                             \/\/       fabd    s10, s7, s5\n+    __ fmuls(v29, v15, v3);                            \/\/       fmul    s29, s15, s3\n+    __ fdivs(v11, v12, v15);                           \/\/       fdiv    s11, s12, s15\n+    __ fadds(v30, v30, v17);                           \/\/       fadd    s30, s30, s17\n+    __ fsubs(v19, v20, v15);                           \/\/       fsub    s19, s20, s15\n+    __ fabdd(v15, v9, v21);                            \/\/       fabd    d15, d9, d21\n+    __ fmuld(v2, v9, v27);                             \/\/       fmul    d2, d9, d27\n+    __ fdivd(v7, v29, v30);                            \/\/       fdiv    d7, d29, d30\n+    __ faddd(v17, v1, v2);                             \/\/       fadd    d17, d1, d2\n+    __ fsubd(v6, v10, v3);                             \/\/       fsub    d6, d10, d3\n@@ -433,8 +481,8 @@\n-    __ fmadds(v20, v11, v28, v13);                     \/\/       fmadd   s20, s11, s28, s13\n-    __ fmsubs(v11, v12, v23, v30);                     \/\/       fmsub   s11, s12, s23, s30\n-    __ fnmadds(v26, v14, v9, v13);                     \/\/       fnmadd  s26, s14, s9, s13\n-    __ fnmadds(v10, v7, v5, v29);                      \/\/       fnmadd  s10, s7, s5, s29\n-    __ fmaddd(v15, v3, v11, v12);                      \/\/       fmadd   d15, d3, d11, d12\n-    __ fmsubd(v15, v30, v30, v17);                     \/\/       fmsub   d15, d30, d30, d17\n-    __ fnmaddd(v19, v20, v15, v15);                    \/\/       fnmadd  d19, d20, d15, d15\n-    __ fnmaddd(v9, v21, v2, v9);                       \/\/       fnmadd  d9, d21, d2, d9\n+    __ fmadds(v24, v11, v7, v1);                       \/\/       fmadd   s24, s11, s7, s1\n+    __ fmsubs(v11, v0, v3, v17);                       \/\/       fmsub   s11, s0, s3, s17\n+    __ fnmadds(v28, v6, v22, v6);                      \/\/       fnmadd  s28, s6, s22, s6\n+    __ fnmadds(v0, v27, v26, v2);                      \/\/       fnmadd  s0, s27, s26, s2\n+    __ fmaddd(v5, v7, v28, v11);                       \/\/       fmadd   d5, d7, d28, d11\n+    __ fmsubd(v25, v13, v11, v23);                     \/\/       fmsub   d25, d13, d11, d23\n+    __ fnmaddd(v19, v8, v17, v21);                     \/\/       fnmadd  d19, d8, d17, d21\n+    __ fnmaddd(v25, v20, v19, v17);                    \/\/       fnmadd  d25, d20, d19, d17\n@@ -443,10 +491,10 @@\n-    __ fmovs(v27, v7);                                 \/\/       fmov    s27, s7\n-    __ fabss(v29, v30);                                \/\/       fabs    s29, s30\n-    __ fnegs(v17, v1);                                 \/\/       fneg    s17, s1\n-    __ fsqrts(v2, v6);                                 \/\/       fsqrt   s2, s6\n-    __ fcvts(v10, v3);                                 \/\/       fcvt    d10, s3\n-    __ fmovd(v24, v11);                                \/\/       fmov    d24, d11\n-    __ fabsd(v7, v1);                                  \/\/       fabs    d7, d1\n-    __ fnegd(v11, v0);                                 \/\/       fneg    d11, d0\n-    __ fsqrtd(v3, v17);                                \/\/       fsqrt   d3, d17\n-    __ fcvtd(v28, v6);                                 \/\/       fcvt    s28, d6\n+    __ fmovs(v2, v29);                                 \/\/       fmov    s2, s29\n+    __ fabss(v22, v8);                                 \/\/       fabs    s22, s8\n+    __ fnegs(v21, v19);                                \/\/       fneg    s21, s19\n+    __ fsqrts(v20, v11);                               \/\/       fsqrt   s20, s11\n+    __ fcvts(v17, v20);                                \/\/       fcvt    d17, s20\n+    __ fmovd(v6, v15);                                 \/\/       fmov    d6, d15\n+    __ fabsd(v3, v3);                                  \/\/       fabs    d3, d3\n+    __ fnegd(v28, v3);                                 \/\/       fneg    d28, d3\n+    __ fsqrtd(v27, v14);                               \/\/       fsqrt   d27, d14\n+    __ fcvtd(v14, v10);                                \/\/       fcvt    s14, d10\n@@ -455,12 +503,12 @@\n-    __ fcvtzsw(r22, v6);                               \/\/       fcvtzs  w22, s6\n-    __ fcvtzs(r0, v27);                                \/\/       fcvtzs  x0, s27\n-    __ fcvtzdw(r26, v2);                               \/\/       fcvtzs  w26, d2\n-    __ fcvtzd(r5, v7);                                 \/\/       fcvtzs  x5, d7\n-    __ scvtfws(v28, r11);                              \/\/       scvtf   s28, w11\n-    __ scvtfs(v25, r13);                               \/\/       scvtf   s25, x13\n-    __ scvtfwd(v11, r23);                              \/\/       scvtf   d11, w23\n-    __ scvtfd(v19, r8);                                \/\/       scvtf   d19, x8\n-    __ fmovs(r17, v21);                                \/\/       fmov    w17, s21\n-    __ fmovd(r25, v20);                                \/\/       fmov    x25, d20\n-    __ fmovs(v19, r17);                                \/\/       fmov    s19, w17\n-    __ fmovd(v2, r29);                                 \/\/       fmov    d2, x29\n+    __ fcvtzsw(r12, v11);                              \/\/       fcvtzs  w12, s11\n+    __ fcvtzs(r17, v10);                               \/\/       fcvtzs  x17, s10\n+    __ fcvtzdw(r25, v7);                               \/\/       fcvtzs  w25, d7\n+    __ fcvtzd(r7, v14);                                \/\/       fcvtzs  x7, d14\n+    __ scvtfws(v28, r0);                               \/\/       scvtf   s28, w0\n+    __ scvtfs(v22, r0);                                \/\/       scvtf   s22, x0\n+    __ scvtfwd(v12, r23);                              \/\/       scvtf   d12, w23\n+    __ scvtfd(v13, r13);                               \/\/       scvtf   d13, x13\n+    __ fmovs(r7, v14);                                 \/\/       fmov    w7, s14\n+    __ fmovd(r7, v8);                                  \/\/       fmov    x7, d8\n+    __ fmovs(v20, r17);                                \/\/       fmov    s20, w17\n+    __ fmovd(v28, r30);                                \/\/       fmov    d28, x30\n@@ -469,2 +517,2 @@\n-    __ fcmps(v22, v8);                                 \/\/       fcmp    s22, s8\n-    __ fcmpd(v21, v19);                                \/\/       fcmp    d21, d19\n+    __ fcmps(v16, v2);                                 \/\/       fcmp    s16, s2\n+    __ fcmpd(v9, v16);                                 \/\/       fcmp    d9, d16\n@@ -472,1 +520,1 @@\n-    __ fcmpd(v11, 0.0);                                \/\/       fcmp    d11, #0.0\n+    __ fcmpd(v29, 0.0);                                \/\/       fcmp    d29, #0.0\n@@ -475,5 +523,5 @@\n-    __ stpw(r20, r6, Address(r15, -32));               \/\/       stp     w20, w6, [x15, #-32]\n-    __ ldpw(r27, r14, Address(r3, -208));              \/\/       ldp     w27, w14, [x3, #-208]\n-    __ ldpsw(r16, r10, Address(r11, -80));             \/\/       ldpsw   x16, x10, [x11, #-80]\n-    __ stp(r7, r7, Address(r14, 64));                  \/\/       stp     x7, x7, [x14, #64]\n-    __ ldp(r12, r23, Address(r0, 112));                \/\/       ldp     x12, x23, [x0, #112]\n+    __ stpw(r1, r26, Address(r24, -208));              \/\/       stp     w1, w26, [x24, #-208]\n+    __ ldpw(r5, r11, Address(r12, 48));                \/\/       ldp     w5, w11, [x12, #48]\n+    __ ldpsw(r21, r15, Address(r27, 48));              \/\/       ldpsw   x21, x15, [x27, #48]\n+    __ stp(r5, r28, Address(r22, 32));                 \/\/       stp     x5, x28, [x22, #32]\n+    __ ldp(r27, r17, Address(r19, -32));               \/\/       ldp     x27, x17, [x19, #-32]\n@@ -482,5 +530,5 @@\n-    __ stpw(r13, r7, Address(__ pre(r6, -80)));        \/\/       stp     w13, w7, [x6, #-80]!\n-    __ ldpw(r30, r15, Address(__ pre(r2, -144)));      \/\/       ldp     w30, w15, [x2, #-144]!\n-    __ ldpsw(r4, r1, Address(__ pre(r27, -144)));      \/\/       ldpsw   x4, x1, [x27, #-144]!\n-    __ stp(r23, r14, Address(__ pre(r11, 64)));        \/\/       stp     x23, x14, [x11, #64]!\n-    __ ldp(r29, r27, Address(__ pre(r21, -192)));      \/\/       ldp     x29, x27, [x21, #-192]!\n+    __ stpw(r13, r7, Address(__ pre(r26, -176)));      \/\/       stp     w13, w7, [x26, #-176]!\n+    __ ldpw(r13, r21, Address(__ pre(r6, -48)));       \/\/       ldp     w13, w21, [x6, #-48]!\n+    __ ldpsw(r20, r30, Address(__ pre(r27, 16)));      \/\/       ldpsw   x20, x30, [x27, #16]!\n+    __ stp(r21, r5, Address(__ pre(r10, -128)));       \/\/       stp     x21, x5, [x10, #-128]!\n+    __ ldp(r14, r4, Address(__ pre(r23, -96)));        \/\/       ldp     x14, x4, [x23, #-96]!\n@@ -489,5 +537,5 @@\n-    __ stpw(r22, r5, Address(__ post(r21, -48)));      \/\/       stp     w22, w5, [x21], #-48\n-    __ ldpw(r27, r17, Address(__ post(r6, -32)));      \/\/       ldp     w27, w17, [x6], #-32\n-    __ ldpsw(r16, r5, Address(__ post(r1, -80)));      \/\/       ldpsw   x16, x5, [x1], #-80\n-    __ stp(r13, r20, Address(__ post(r22, -208)));     \/\/       stp     x13, x20, [x22], #-208\n-    __ ldp(r30, r27, Address(__ post(r10, 80)));       \/\/       ldp     x30, x27, [x10], #80\n+    __ stpw(r29, r12, Address(__ post(r16, 32)));      \/\/       stp     w29, w12, [x16], #32\n+    __ ldpw(r26, r17, Address(__ post(r27, 96)));      \/\/       ldp     w26, w17, [x27], #96\n+    __ ldpsw(r4, r20, Address(__ post(r14, -96)));     \/\/       ldpsw   x4, x20, [x14], #-96\n+    __ stp(r16, r2, Address(__ post(r14, -112)));      \/\/       stp     x16, x2, [x14], #-112\n+    __ ldp(r23, r24, Address(__ post(r7, -256)));      \/\/       ldp     x23, x24, [x7], #-256\n@@ -496,4 +544,4 @@\n-    __ stnpw(r5, r17, Address(r11, 16));               \/\/       stnp    w5, w17, [x11, #16]\n-    __ ldnpw(r14, r4, Address(r26, -96));              \/\/       ldnp    w14, w4, [x26, #-96]\n-    __ stnp(r23, r29, Address(r12, 32));               \/\/       stnp    x23, x29, [x12, #32]\n-    __ ldnp(r0, r6, Address(r21, -80));                \/\/       ldnp    x0, x6, [x21, #-80]\n+    __ stnpw(r0, r26, Address(r15, 128));              \/\/       stnp    w0, w26, [x15, #128]\n+    __ ldnpw(r26, r6, Address(r8, -208));              \/\/       ldnp    w26, w6, [x8, #-208]\n+    __ stnp(r15, r10, Address(r25, -112));             \/\/       stnp    x15, x10, [x25, #-112]\n+    __ ldnp(r16, r1, Address(r19, -160));              \/\/       ldnp    x16, x1, [x19, #-160]\n@@ -502,22 +550,22 @@\n-    __ ld1(v15, __ T8B, Address(r26));                 \/\/       ld1     {v15.8B}, [x26]\n-    __ ld1(v23, v24, __ T16B, Address(__ post(r11, 32))); \/\/    ld1     {v23.16B, v24.16B}, [x11], 32\n-    __ ld1(v8, v9, v10, __ T1D, Address(__ post(r23, r7))); \/\/  ld1     {v8.1D, v9.1D, v10.1D}, [x23], x7\n-    __ ld1(v19, v20, v21, v22, __ T8H, Address(__ post(r25, 64))); \/\/   ld1     {v19.8H, v20.8H, v21.8H, v22.8H}, [x25], 64\n-    __ ld1r(v29, __ T8B, Address(r17));                \/\/       ld1r    {v29.8B}, [x17]\n-    __ ld1r(v24, __ T4S, Address(__ post(r23, 4)));    \/\/       ld1r    {v24.4S}, [x23], 4\n-    __ ld1r(v10, __ T1D, Address(__ post(r5, r25)));   \/\/       ld1r    {v10.1D}, [x5], x25\n-    __ ld2(v17, v18, __ T2D, Address(r10));            \/\/       ld2     {v17.2D, v18.2D}, [x10]\n-    __ ld2(v12, v13, __ T4H, Address(__ post(r15, 16))); \/\/     ld2     {v12.4H, v13.4H}, [x15], 16\n-    __ ld2r(v25, v26, __ T16B, Address(r17));          \/\/       ld2r    {v25.16B, v26.16B}, [x17]\n-    __ ld2r(v1, v2, __ T2S, Address(__ post(r30, 8))); \/\/       ld2r    {v1.2S, v2.2S}, [x30], 8\n-    __ ld2r(v16, v17, __ T2D, Address(__ post(r17, r9))); \/\/    ld2r    {v16.2D, v17.2D}, [x17], x9\n-    __ ld3(v25, v26, v27, __ T4S, Address(__ post(r12, r2))); \/\/        ld3     {v25.4S, v26.4S, v27.4S}, [x12], x2\n-    __ ld3(v26, v27, v28, __ T2S, Address(r19));       \/\/       ld3     {v26.2S, v27.2S, v28.2S}, [x19]\n-    __ ld3r(v15, v16, v17, __ T8H, Address(r21));      \/\/       ld3r    {v15.8H, v16.8H, v17.8H}, [x21]\n-    __ ld3r(v25, v26, v27, __ T4S, Address(__ post(r13, 12))); \/\/       ld3r    {v25.4S, v26.4S, v27.4S}, [x13], 12\n-    __ ld3r(v14, v15, v16, __ T1D, Address(__ post(r28, r29))); \/\/      ld3r    {v14.1D, v15.1D, v16.1D}, [x28], x29\n-    __ ld4(v17, v18, v19, v20, __ T8H, Address(__ post(r29, 64))); \/\/   ld4     {v17.8H, v18.8H, v19.8H, v20.8H}, [x29], 64\n-    __ ld4(v27, v28, v29, v30, __ T8B, Address(__ post(r7, r0))); \/\/    ld4     {v27.8B, v28.8B, v29.8B, v30.8B}, [x7], x0\n-    __ ld4r(v24, v25, v26, v27, __ T8B, Address(r17)); \/\/       ld4r    {v24.8B, v25.8B, v26.8B, v27.8B}, [x17]\n-    __ ld4r(v0, v1, v2, v3, __ T4H, Address(__ post(r26, 8))); \/\/       ld4r    {v0.4H, v1.4H, v2.4H, v3.4H}, [x26], 8\n-    __ ld4r(v12, v13, v14, v15, __ T2S, Address(__ post(r25, r2))); \/\/  ld4r    {v12.2S, v13.2S, v14.2S, v15.2S}, [x25], x2\n+    __ ld1(v27, __ T8B, Address(r30));                 \/\/       ld1     {v27.8B}, [x30]\n+    __ ld1(v25, v26, __ T16B, Address(__ post(r3, 32))); \/\/     ld1     {v25.16B, v26.16B}, [x3], 32\n+    __ ld1(v30, v31, v0, __ T1D, Address(__ post(r16, r10))); \/\/        ld1     {v30.1D, v31.1D, v0.1D}, [x16], x10\n+    __ ld1(v16, v17, v18, v19, __ T8H, Address(__ post(r19, 64))); \/\/   ld1     {v16.8H, v17.8H, v18.8H, v19.8H}, [x19], 64\n+    __ ld1r(v23, __ T8B, Address(r24));                \/\/       ld1r    {v23.8B}, [x24]\n+    __ ld1r(v8, __ T4S, Address(__ post(r10, 4)));     \/\/       ld1r    {v8.4S}, [x10], 4\n+    __ ld1r(v9, __ T1D, Address(__ post(r20, r23)));   \/\/       ld1r    {v9.1D}, [x20], x23\n+    __ ld2(v2, v3, __ T2D, Address(r3));               \/\/       ld2     {v2.2D, v3.2D}, [x3]\n+    __ ld2(v8, v9, __ T4H, Address(__ post(r30, 16))); \/\/       ld2     {v8.4H, v9.4H}, [x30], 16\n+    __ ld2r(v4, v5, __ T16B, Address(r26));            \/\/       ld2r    {v4.16B, v5.16B}, [x26]\n+    __ ld2r(v3, v4, __ T2S, Address(__ post(r17, 8))); \/\/       ld2r    {v3.2S, v4.2S}, [x17], 8\n+    __ ld2r(v29, v30, __ T2D, Address(__ post(r11, r16))); \/\/   ld2r    {v29.2D, v30.2D}, [x11], x16\n+    __ ld3(v1, v2, v3, __ T4S, Address(__ post(r0, r23))); \/\/   ld3     {v1.4S, v2.4S, v3.4S}, [x0], x23\n+    __ ld3(v0, v1, v2, __ T2S, Address(r21));          \/\/       ld3     {v0.2S, v1.2S, v2.2S}, [x21]\n+    __ ld3r(v5, v6, v7, __ T8H, Address(r7));          \/\/       ld3r    {v5.8H, v6.8H, v7.8H}, [x7]\n+    __ ld3r(v1, v2, v3, __ T4S, Address(__ post(r7, 12))); \/\/   ld3r    {v1.4S, v2.4S, v3.4S}, [x7], 12\n+    __ ld3r(v2, v3, v4, __ T1D, Address(__ post(r5, r15))); \/\/  ld3r    {v2.1D, v3.1D, v4.1D}, [x5], x15\n+    __ ld4(v27, v28, v29, v30, __ T8H, Address(__ post(r29, 64))); \/\/   ld4     {v27.8H, v28.8H, v29.8H, v30.8H}, [x29], 64\n+    __ ld4(v24, v25, v26, v27, __ T8B, Address(__ post(r4, r7))); \/\/    ld4     {v24.8B, v25.8B, v26.8B, v27.8B}, [x4], x7\n+    __ ld4r(v15, v16, v17, v18, __ T8B, Address(r23)); \/\/       ld4r    {v15.8B, v16.8B, v17.8B, v18.8B}, [x23]\n+    __ ld4r(v14, v15, v16, v17, __ T4H, Address(__ post(r21, 8))); \/\/   ld4r    {v14.4H, v15.4H, v16.4H, v17.4H}, [x21], 8\n+    __ ld4r(v20, v21, v22, v23, __ T2S, Address(__ post(r9, r25))); \/\/  ld4r    {v20.2S, v21.2S, v22.2S, v23.2S}, [x9], x25\n@@ -526,26 +574,26 @@\n-    __ addv(v22, __ T8B, v23);                         \/\/       addv    b22, v23.8B\n-    __ addv(v27, __ T16B, v28);                        \/\/       addv    b27, v28.16B\n-    __ addv(v4, __ T4H, v5);                           \/\/       addv    h4, v5.4H\n-    __ addv(v7, __ T8H, v8);                           \/\/       addv    h7, v8.8H\n-    __ addv(v6, __ T4S, v7);                           \/\/       addv    s6, v7.4S\n-    __ smaxv(v1, __ T8B, v2);                          \/\/       smaxv   b1, v2.8B\n-    __ smaxv(v26, __ T16B, v27);                       \/\/       smaxv   b26, v27.16B\n-    __ smaxv(v15, __ T4H, v16);                        \/\/       smaxv   h15, v16.4H\n-    __ smaxv(v2, __ T8H, v3);                          \/\/       smaxv   h2, v3.8H\n-    __ smaxv(v13, __ T4S, v14);                        \/\/       smaxv   s13, v14.4S\n-    __ fmaxv(v13, __ T4S, v14);                        \/\/       fmaxv   s13, v14.4S\n-    __ sminv(v24, __ T8B, v25);                        \/\/       sminv   b24, v25.8B\n-    __ uminv(v23, __ T8B, v24);                        \/\/       uminv   b23, v24.8B\n-    __ sminv(v4, __ T16B, v5);                         \/\/       sminv   b4, v5.16B\n-    __ uminv(v19, __ T16B, v20);                       \/\/       uminv   b19, v20.16B\n-    __ sminv(v15, __ T4H, v16);                        \/\/       sminv   h15, v16.4H\n-    __ uminv(v0, __ T4H, v1);                          \/\/       uminv   h0, v1.4H\n-    __ sminv(v4, __ T8H, v5);                          \/\/       sminv   h4, v5.8H\n-    __ uminv(v20, __ T8H, v21);                        \/\/       uminv   h20, v21.8H\n-    __ sminv(v11, __ T4S, v12);                        \/\/       sminv   s11, v12.4S\n-    __ uminv(v29, __ T4S, v30);                        \/\/       uminv   s29, v30.4S\n-    __ fminv(v15, __ T4S, v16);                        \/\/       fminv   s15, v16.4S\n-    __ fmaxp(v21, v22, __ S);                          \/\/       fmaxp   s21, v22.2S\n-    __ fmaxp(v4, v5, __ D);                            \/\/       fmaxp   d4, v5.2D\n-    __ fminp(v14, v15, __ S);                          \/\/       fminp   s14, v15.2S\n-    __ fminp(v22, v23, __ D);                          \/\/       fminp   d22, v23.2D\n+    __ addv(v23, __ T8B, v24);                         \/\/       addv    b23, v24.8B\n+    __ addv(v26, __ T16B, v27);                        \/\/       addv    b26, v27.16B\n+    __ addv(v5, __ T4H, v6);                           \/\/       addv    h5, v6.4H\n+    __ addv(v6, __ T8H, v7);                           \/\/       addv    h6, v7.8H\n+    __ addv(v15, __ T4S, v16);                         \/\/       addv    s15, v16.4S\n+    __ smaxv(v15, __ T8B, v16);                        \/\/       smaxv   b15, v16.8B\n+    __ smaxv(v25, __ T16B, v26);                       \/\/       smaxv   b25, v26.16B\n+    __ smaxv(v16, __ T4H, v17);                        \/\/       smaxv   h16, v17.4H\n+    __ smaxv(v27, __ T8H, v28);                        \/\/       smaxv   h27, v28.8H\n+    __ smaxv(v24, __ T4S, v25);                        \/\/       smaxv   s24, v25.4S\n+    __ fmaxv(v15, __ T4S, v16);                        \/\/       fmaxv   s15, v16.4S\n+    __ sminv(v25, __ T8B, v26);                        \/\/       sminv   b25, v26.8B\n+    __ uminv(v14, __ T8B, v15);                        \/\/       uminv   b14, v15.8B\n+    __ sminv(v10, __ T16B, v11);                       \/\/       sminv   b10, v11.16B\n+    __ uminv(v13, __ T16B, v14);                       \/\/       uminv   b13, v14.16B\n+    __ sminv(v14, __ T4H, v15);                        \/\/       sminv   h14, v15.4H\n+    __ uminv(v20, __ T4H, v21);                        \/\/       uminv   h20, v21.4H\n+    __ sminv(v1, __ T8H, v2);                          \/\/       sminv   h1, v2.8H\n+    __ uminv(v22, __ T8H, v23);                        \/\/       uminv   h22, v23.8H\n+    __ sminv(v30, __ T4S, v31);                        \/\/       sminv   s30, v31.4S\n+    __ uminv(v14, __ T4S, v15);                        \/\/       uminv   s14, v15.4S\n+    __ fminv(v2, __ T4S, v3);                          \/\/       fminv   s2, v3.4S\n+    __ fmaxp(v6, v7, __ S);                            \/\/       fmaxp   s6, v7.2S\n+    __ fmaxp(v3, v4, __ D);                            \/\/       fmaxp   d3, v4.2D\n+    __ fminp(v7, v8, __ S);                            \/\/       fminp   s7, v8.2S\n+    __ fminp(v24, v25, __ D);                          \/\/       fminp   d24, v25.2D\n@@ -554,7 +602,7 @@\n-    __ absr(v25, __ T8B, v26);                         \/\/       abs     v25.8B, v26.8B\n-    __ absr(v6, __ T16B, v7);                          \/\/       abs     v6.16B, v7.16B\n-    __ absr(v12, __ T4H, v13);                         \/\/       abs     v12.4H, v13.4H\n-    __ absr(v14, __ T8H, v15);                         \/\/       abs     v14.8H, v15.8H\n-    __ absr(v13, __ T2S, v14);                         \/\/       abs     v13.2S, v14.2S\n-    __ absr(v14, __ T4S, v15);                         \/\/       abs     v14.4S, v15.4S\n-    __ absr(v9, __ T2D, v10);                          \/\/       abs     v9.2D, v10.2D\n+    __ absr(v0, __ T8B, v1);                           \/\/       abs     v0.8B, v1.8B\n+    __ absr(v27, __ T16B, v28);                        \/\/       abs     v27.16B, v28.16B\n+    __ absr(v29, __ T4H, v30);                         \/\/       abs     v29.4H, v30.4H\n+    __ absr(v5, __ T8H, v6);                           \/\/       abs     v5.8H, v6.8H\n+    __ absr(v5, __ T2S, v6);                           \/\/       abs     v5.2S, v6.2S\n+    __ absr(v29, __ T4S, v30);                         \/\/       abs     v29.4S, v30.4S\n+    __ absr(v11, __ T2D, v12);                         \/\/       abs     v11.2D, v12.2D\n@@ -562,10 +610,10 @@\n-    __ fabs(v28, __ T4S, v29);                         \/\/       fabs    v28.4S, v29.4S\n-    __ fabs(v10, __ T2D, v11);                         \/\/       fabs    v10.2D, v11.2D\n-    __ fneg(v19, __ T2S, v20);                         \/\/       fneg    v19.2S, v20.2S\n-    __ fneg(v11, __ T4S, v12);                         \/\/       fneg    v11.4S, v12.4S\n-    __ fneg(v17, __ T2D, v18);                         \/\/       fneg    v17.2D, v18.2D\n-    __ fsqrt(v21, __ T2S, v22);                        \/\/       fsqrt   v21.2S, v22.2S\n-    __ fsqrt(v15, __ T4S, v16);                        \/\/       fsqrt   v15.4S, v16.4S\n-    __ fsqrt(v20, __ T2D, v21);                        \/\/       fsqrt   v20.2D, v21.2D\n-    __ notr(v23, __ T8B, v24);                         \/\/       not     v23.8B, v24.8B\n-    __ notr(v26, __ T16B, v27);                        \/\/       not     v26.16B, v27.16B\n+    __ fabs(v0, __ T4S, v1);                           \/\/       fabs    v0.4S, v1.4S\n+    __ fabs(v30, __ T2D, v31);                         \/\/       fabs    v30.2D, v31.2D\n+    __ fneg(v0, __ T2S, v1);                           \/\/       fneg    v0.2S, v1.2S\n+    __ fneg(v17, __ T4S, v18);                         \/\/       fneg    v17.4S, v18.4S\n+    __ fneg(v28, __ T2D, v29);                         \/\/       fneg    v28.2D, v29.2D\n+    __ fsqrt(v25, __ T2S, v26);                        \/\/       fsqrt   v25.2S, v26.2S\n+    __ fsqrt(v9, __ T4S, v10);                         \/\/       fsqrt   v9.4S, v10.4S\n+    __ fsqrt(v25, __ T2D, v26);                        \/\/       fsqrt   v25.2D, v26.2D\n+    __ notr(v12, __ T8B, v13);                         \/\/       not     v12.8B, v13.8B\n+    __ notr(v15, __ T16B, v16);                        \/\/       not     v15.16B, v16.16B\n@@ -574,14 +622,14 @@\n-    __ andr(v5, __ T8B, v6, v7);                       \/\/       and     v5.8B, v6.8B, v7.8B\n-    __ andr(v6, __ T16B, v7, v8);                      \/\/       and     v6.16B, v7.16B, v8.16B\n-    __ orr(v15, __ T8B, v16, v17);                     \/\/       orr     v15.8B, v16.8B, v17.8B\n-    __ orr(v15, __ T16B, v16, v17);                    \/\/       orr     v15.16B, v16.16B, v17.16B\n-    __ eor(v25, __ T8B, v26, v27);                     \/\/       eor     v25.8B, v26.8B, v27.8B\n-    __ eor(v16, __ T16B, v17, v18);                    \/\/       eor     v16.16B, v17.16B, v18.16B\n-    __ addv(v27, __ T8B, v28, v29);                    \/\/       add     v27.8B, v28.8B, v29.8B\n-    __ addv(v24, __ T16B, v25, v26);                   \/\/       add     v24.16B, v25.16B, v26.16B\n-    __ addv(v15, __ T4H, v16, v17);                    \/\/       add     v15.4H, v16.4H, v17.4H\n-    __ addv(v25, __ T8H, v26, v27);                    \/\/       add     v25.8H, v26.8H, v27.8H\n-    __ addv(v14, __ T2S, v15, v16);                    \/\/       add     v14.2S, v15.2S, v16.2S\n-    __ addv(v10, __ T4S, v11, v12);                    \/\/       add     v10.4S, v11.4S, v12.4S\n-    __ addv(v13, __ T2D, v14, v15);                    \/\/       add     v13.2D, v14.2D, v15.2D\n-    __ fadd(v14, __ T2S, v15, v16);                    \/\/       fadd    v14.2S, v15.2S, v16.2S\n+    __ andr(v11, __ T8B, v12, v13);                    \/\/       and     v11.8B, v12.8B, v13.8B\n+    __ andr(v10, __ T16B, v11, v12);                   \/\/       and     v10.16B, v11.16B, v12.16B\n+    __ orr(v17, __ T8B, v18, v19);                     \/\/       orr     v17.8B, v18.8B, v19.8B\n+    __ orr(v24, __ T16B, v25, v26);                    \/\/       orr     v24.16B, v25.16B, v26.16B\n+    __ eor(v21, __ T8B, v22, v23);                     \/\/       eor     v21.8B, v22.8B, v23.8B\n+    __ eor(v23, __ T16B, v24, v25);                    \/\/       eor     v23.16B, v24.16B, v25.16B\n+    __ addv(v0, __ T8B, v1, v2);                       \/\/       add     v0.8B, v1.8B, v2.8B\n+    __ addv(v16, __ T16B, v17, v18);                   \/\/       add     v16.16B, v17.16B, v18.16B\n+    __ addv(v10, __ T4H, v11, v12);                    \/\/       add     v10.4H, v11.4H, v12.4H\n+    __ addv(v6, __ T8H, v7, v8);                       \/\/       add     v6.8H, v7.8H, v8.8H\n+    __ addv(v28, __ T2S, v29, v30);                    \/\/       add     v28.2S, v29.2S, v30.2S\n+    __ addv(v6, __ T4S, v7, v8);                       \/\/       add     v6.4S, v7.4S, v8.4S\n+    __ addv(v5, __ T2D, v6, v7);                       \/\/       add     v5.2D, v6.2D, v7.2D\n+    __ fadd(v5, __ T2S, v6, v7);                       \/\/       fadd    v5.2S, v6.2S, v7.2S\n@@ -589,75 +637,75 @@\n-    __ fadd(v1, __ T2D, v2, v3);                       \/\/       fadd    v1.2D, v2.2D, v3.2D\n-    __ subv(v22, __ T8B, v23, v24);                    \/\/       sub     v22.8B, v23.8B, v24.8B\n-    __ subv(v30, __ T16B, v31, v0);                    \/\/       sub     v30.16B, v31.16B, v0.16B\n-    __ subv(v14, __ T4H, v15, v16);                    \/\/       sub     v14.4H, v15.4H, v16.4H\n-    __ subv(v2, __ T8H, v3, v4);                       \/\/       sub     v2.8H, v3.8H, v4.8H\n-    __ subv(v6, __ T2S, v7, v8);                       \/\/       sub     v6.2S, v7.2S, v8.2S\n-    __ subv(v3, __ T4S, v4, v5);                       \/\/       sub     v3.4S, v4.4S, v5.4S\n-    __ subv(v7, __ T2D, v8, v9);                       \/\/       sub     v7.2D, v8.2D, v9.2D\n-    __ fsub(v24, __ T2S, v25, v26);                    \/\/       fsub    v24.2S, v25.2S, v26.2S\n-    __ fsub(v0, __ T4S, v1, v2);                       \/\/       fsub    v0.4S, v1.4S, v2.4S\n-    __ fsub(v27, __ T2D, v28, v29);                    \/\/       fsub    v27.2D, v28.2D, v29.2D\n-    __ mulv(v29, __ T8B, v30, v31);                    \/\/       mul     v29.8B, v30.8B, v31.8B\n-    __ mulv(v5, __ T16B, v6, v7);                      \/\/       mul     v5.16B, v6.16B, v7.16B\n-    __ mulv(v5, __ T4H, v6, v7);                       \/\/       mul     v5.4H, v6.4H, v7.4H\n-    __ mulv(v29, __ T8H, v30, v31);                    \/\/       mul     v29.8H, v30.8H, v31.8H\n-    __ mulv(v11, __ T2S, v12, v13);                    \/\/       mul     v11.2S, v12.2S, v13.2S\n-    __ mulv(v25, __ T4S, v26, v27);                    \/\/       mul     v25.4S, v26.4S, v27.4S\n-    __ fabd(v0, __ T2S, v1, v2);                       \/\/       fabd    v0.2S, v1.2S, v2.2S\n-    __ fabd(v30, __ T4S, v31, v0);                     \/\/       fabd    v30.4S, v31.4S, v0.4S\n-    __ fabd(v0, __ T2D, v1, v2);                       \/\/       fabd    v0.2D, v1.2D, v2.2D\n-    __ fmul(v17, __ T2S, v18, v19);                    \/\/       fmul    v17.2S, v18.2S, v19.2S\n-    __ fmul(v28, __ T4S, v29, v30);                    \/\/       fmul    v28.4S, v29.4S, v30.4S\n-    __ fmul(v25, __ T2D, v26, v27);                    \/\/       fmul    v25.2D, v26.2D, v27.2D\n-    __ mlav(v9, __ T4H, v10, v11);                     \/\/       mla     v9.4H, v10.4H, v11.4H\n-    __ mlav(v25, __ T8H, v26, v27);                    \/\/       mla     v25.8H, v26.8H, v27.8H\n-    __ mlav(v12, __ T2S, v13, v14);                    \/\/       mla     v12.2S, v13.2S, v14.2S\n-    __ mlav(v15, __ T4S, v16, v17);                    \/\/       mla     v15.4S, v16.4S, v17.4S\n-    __ fmla(v11, __ T2S, v12, v13);                    \/\/       fmla    v11.2S, v12.2S, v13.2S\n-    __ fmla(v10, __ T4S, v11, v12);                    \/\/       fmla    v10.4S, v11.4S, v12.4S\n-    __ fmla(v17, __ T2D, v18, v19);                    \/\/       fmla    v17.2D, v18.2D, v19.2D\n-    __ mlsv(v24, __ T4H, v25, v26);                    \/\/       mls     v24.4H, v25.4H, v26.4H\n-    __ mlsv(v21, __ T8H, v22, v23);                    \/\/       mls     v21.8H, v22.8H, v23.8H\n-    __ mlsv(v23, __ T2S, v24, v25);                    \/\/       mls     v23.2S, v24.2S, v25.2S\n-    __ mlsv(v0, __ T4S, v1, v2);                       \/\/       mls     v0.4S, v1.4S, v2.4S\n-    __ fmls(v16, __ T2S, v17, v18);                    \/\/       fmls    v16.2S, v17.2S, v18.2S\n-    __ fmls(v10, __ T4S, v11, v12);                    \/\/       fmls    v10.4S, v11.4S, v12.4S\n-    __ fmls(v6, __ T2D, v7, v8);                       \/\/       fmls    v6.2D, v7.2D, v8.2D\n-    __ fdiv(v28, __ T2S, v29, v30);                    \/\/       fdiv    v28.2S, v29.2S, v30.2S\n-    __ fdiv(v6, __ T4S, v7, v8);                       \/\/       fdiv    v6.4S, v7.4S, v8.4S\n-    __ fdiv(v5, __ T2D, v6, v7);                       \/\/       fdiv    v5.2D, v6.2D, v7.2D\n-    __ maxv(v5, __ T8B, v6, v7);                       \/\/       smax    v5.8B, v6.8B, v7.8B\n-    __ maxv(v20, __ T16B, v21, v22);                   \/\/       smax    v20.16B, v21.16B, v22.16B\n-    __ maxv(v17, __ T4H, v18, v19);                    \/\/       smax    v17.4H, v18.4H, v19.4H\n-    __ maxv(v15, __ T8H, v16, v17);                    \/\/       smax    v15.8H, v16.8H, v17.8H\n-    __ maxv(v17, __ T2S, v18, v19);                    \/\/       smax    v17.2S, v18.2S, v19.2S\n-    __ maxv(v29, __ T4S, v30, v31);                    \/\/       smax    v29.4S, v30.4S, v31.4S\n-    __ smaxp(v26, __ T8B, v27, v28);                   \/\/       smaxp   v26.8B, v27.8B, v28.8B\n-    __ smaxp(v28, __ T16B, v29, v30);                  \/\/       smaxp   v28.16B, v29.16B, v30.16B\n-    __ smaxp(v1, __ T4H, v2, v3);                      \/\/       smaxp   v1.4H, v2.4H, v3.4H\n-    __ smaxp(v27, __ T8H, v28, v29);                   \/\/       smaxp   v27.8H, v28.8H, v29.8H\n-    __ smaxp(v0, __ T2S, v1, v2);                      \/\/       smaxp   v0.2S, v1.2S, v2.2S\n-    __ smaxp(v20, __ T4S, v21, v22);                   \/\/       smaxp   v20.4S, v21.4S, v22.4S\n-    __ fmax(v28, __ T2S, v29, v30);                    \/\/       fmax    v28.2S, v29.2S, v30.2S\n-    __ fmax(v15, __ T4S, v16, v17);                    \/\/       fmax    v15.4S, v16.4S, v17.4S\n-    __ fmax(v12, __ T2D, v13, v14);                    \/\/       fmax    v12.2D, v13.2D, v14.2D\n-    __ minv(v10, __ T8B, v11, v12);                    \/\/       smin    v10.8B, v11.8B, v12.8B\n-    __ minv(v28, __ T16B, v29, v30);                   \/\/       smin    v28.16B, v29.16B, v30.16B\n-    __ minv(v28, __ T4H, v29, v30);                    \/\/       smin    v28.4H, v29.4H, v30.4H\n-    __ minv(v19, __ T8H, v20, v21);                    \/\/       smin    v19.8H, v20.8H, v21.8H\n-    __ minv(v22, __ T2S, v23, v24);                    \/\/       smin    v22.2S, v23.2S, v24.2S\n-    __ minv(v10, __ T4S, v11, v12);                    \/\/       smin    v10.4S, v11.4S, v12.4S\n-    __ sminp(v4, __ T8B, v5, v6);                      \/\/       sminp   v4.8B, v5.8B, v6.8B\n-    __ sminp(v30, __ T16B, v31, v0);                   \/\/       sminp   v30.16B, v31.16B, v0.16B\n-    __ sminp(v20, __ T4H, v21, v22);                   \/\/       sminp   v20.4H, v21.4H, v22.4H\n-    __ sminp(v8, __ T8H, v9, v10);                     \/\/       sminp   v8.8H, v9.8H, v10.8H\n-    __ sminp(v30, __ T2S, v31, v0);                    \/\/       sminp   v30.2S, v31.2S, v0.2S\n-    __ sminp(v17, __ T4S, v18, v19);                   \/\/       sminp   v17.4S, v18.4S, v19.4S\n-    __ fmin(v10, __ T2S, v11, v12);                    \/\/       fmin    v10.2S, v11.2S, v12.2S\n-    __ fmin(v27, __ T4S, v28, v29);                    \/\/       fmin    v27.4S, v28.4S, v29.4S\n-    __ fmin(v2, __ T2D, v3, v4);                       \/\/       fmin    v2.2D, v3.2D, v4.2D\n-    __ cmeq(v24, __ T8B, v25, v26);                    \/\/       cmeq    v24.8B, v25.8B, v26.8B\n-    __ cmeq(v4, __ T16B, v5, v6);                      \/\/       cmeq    v4.16B, v5.16B, v6.16B\n-    __ cmeq(v3, __ T4H, v4, v5);                       \/\/       cmeq    v3.4H, v4.4H, v5.4H\n-    __ cmeq(v8, __ T8H, v9, v10);                      \/\/       cmeq    v8.8H, v9.8H, v10.8H\n-    __ cmeq(v22, __ T2S, v23, v24);                    \/\/       cmeq    v22.2S, v23.2S, v24.2S\n+    __ fadd(v17, __ T2D, v18, v19);                    \/\/       fadd    v17.2D, v18.2D, v19.2D\n+    __ subv(v15, __ T8B, v16, v17);                    \/\/       sub     v15.8B, v16.8B, v17.8B\n+    __ subv(v17, __ T16B, v18, v19);                   \/\/       sub     v17.16B, v18.16B, v19.16B\n+    __ subv(v29, __ T4H, v30, v31);                    \/\/       sub     v29.4H, v30.4H, v31.4H\n+    __ subv(v26, __ T8H, v27, v28);                    \/\/       sub     v26.8H, v27.8H, v28.8H\n+    __ subv(v28, __ T2S, v29, v30);                    \/\/       sub     v28.2S, v29.2S, v30.2S\n+    __ subv(v1, __ T4S, v2, v3);                       \/\/       sub     v1.4S, v2.4S, v3.4S\n+    __ subv(v27, __ T2D, v28, v29);                    \/\/       sub     v27.2D, v28.2D, v29.2D\n+    __ fsub(v0, __ T2S, v1, v2);                       \/\/       fsub    v0.2S, v1.2S, v2.2S\n+    __ fsub(v20, __ T4S, v21, v22);                    \/\/       fsub    v20.4S, v21.4S, v22.4S\n+    __ fsub(v28, __ T2D, v29, v30);                    \/\/       fsub    v28.2D, v29.2D, v30.2D\n+    __ mulv(v15, __ T8B, v16, v17);                    \/\/       mul     v15.8B, v16.8B, v17.8B\n+    __ mulv(v12, __ T16B, v13, v14);                   \/\/       mul     v12.16B, v13.16B, v14.16B\n+    __ mulv(v10, __ T4H, v11, v12);                    \/\/       mul     v10.4H, v11.4H, v12.4H\n+    __ mulv(v28, __ T8H, v29, v30);                    \/\/       mul     v28.8H, v29.8H, v30.8H\n+    __ mulv(v28, __ T2S, v29, v30);                    \/\/       mul     v28.2S, v29.2S, v30.2S\n+    __ mulv(v19, __ T4S, v20, v21);                    \/\/       mul     v19.4S, v20.4S, v21.4S\n+    __ fabd(v22, __ T2S, v23, v24);                    \/\/       fabd    v22.2S, v23.2S, v24.2S\n+    __ fabd(v10, __ T4S, v11, v12);                    \/\/       fabd    v10.4S, v11.4S, v12.4S\n+    __ fabd(v4, __ T2D, v5, v6);                       \/\/       fabd    v4.2D, v5.2D, v6.2D\n+    __ fmul(v30, __ T2S, v31, v0);                     \/\/       fmul    v30.2S, v31.2S, v0.2S\n+    __ fmul(v20, __ T4S, v21, v22);                    \/\/       fmul    v20.4S, v21.4S, v22.4S\n+    __ fmul(v8, __ T2D, v9, v10);                      \/\/       fmul    v8.2D, v9.2D, v10.2D\n+    __ mlav(v30, __ T4H, v31, v0);                     \/\/       mla     v30.4H, v31.4H, v0.4H\n+    __ mlav(v17, __ T8H, v18, v19);                    \/\/       mla     v17.8H, v18.8H, v19.8H\n+    __ mlav(v10, __ T2S, v11, v12);                    \/\/       mla     v10.2S, v11.2S, v12.2S\n+    __ mlav(v27, __ T4S, v28, v29);                    \/\/       mla     v27.4S, v28.4S, v29.4S\n+    __ fmla(v2, __ T2S, v3, v4);                       \/\/       fmla    v2.2S, v3.2S, v4.2S\n+    __ fmla(v24, __ T4S, v25, v26);                    \/\/       fmla    v24.4S, v25.4S, v26.4S\n+    __ fmla(v4, __ T2D, v5, v6);                       \/\/       fmla    v4.2D, v5.2D, v6.2D\n+    __ mlsv(v3, __ T4H, v4, v5);                       \/\/       mls     v3.4H, v4.4H, v5.4H\n+    __ mlsv(v8, __ T8H, v9, v10);                      \/\/       mls     v8.8H, v9.8H, v10.8H\n+    __ mlsv(v22, __ T2S, v23, v24);                    \/\/       mls     v22.2S, v23.2S, v24.2S\n+    __ mlsv(v17, __ T4S, v18, v19);                    \/\/       mls     v17.4S, v18.4S, v19.4S\n+    __ fmls(v13, __ T2S, v14, v15);                    \/\/       fmls    v13.2S, v14.2S, v15.2S\n+    __ fmls(v4, __ T4S, v5, v6);                       \/\/       fmls    v4.4S, v5.4S, v6.4S\n+    __ fmls(v28, __ T2D, v29, v30);                    \/\/       fmls    v28.2D, v29.2D, v30.2D\n+    __ fdiv(v23, __ T2S, v24, v25);                    \/\/       fdiv    v23.2S, v24.2S, v25.2S\n+    __ fdiv(v21, __ T4S, v22, v23);                    \/\/       fdiv    v21.4S, v22.4S, v23.4S\n+    __ fdiv(v25, __ T2D, v26, v27);                    \/\/       fdiv    v25.2D, v26.2D, v27.2D\n+    __ maxv(v24, __ T8B, v25, v26);                    \/\/       smax    v24.8B, v25.8B, v26.8B\n+    __ maxv(v3, __ T16B, v4, v5);                      \/\/       smax    v3.16B, v4.16B, v5.16B\n+    __ maxv(v23, __ T4H, v24, v25);                    \/\/       smax    v23.4H, v24.4H, v25.4H\n+    __ maxv(v26, __ T8H, v27, v28);                    \/\/       smax    v26.8H, v27.8H, v28.8H\n+    __ maxv(v23, __ T2S, v24, v25);                    \/\/       smax    v23.2S, v24.2S, v25.2S\n+    __ maxv(v14, __ T4S, v15, v16);                    \/\/       smax    v14.4S, v15.4S, v16.4S\n+    __ smaxp(v21, __ T8B, v22, v23);                   \/\/       smaxp   v21.8B, v22.8B, v23.8B\n+    __ smaxp(v3, __ T16B, v4, v5);                     \/\/       smaxp   v3.16B, v4.16B, v5.16B\n+    __ smaxp(v23, __ T4H, v24, v25);                   \/\/       smaxp   v23.4H, v24.4H, v25.4H\n+    __ smaxp(v8, __ T8H, v9, v10);                     \/\/       smaxp   v8.8H, v9.8H, v10.8H\n+    __ smaxp(v24, __ T2S, v25, v26);                   \/\/       smaxp   v24.2S, v25.2S, v26.2S\n+    __ smaxp(v19, __ T4S, v20, v21);                   \/\/       smaxp   v19.4S, v20.4S, v21.4S\n+    __ fmax(v15, __ T2S, v16, v17);                    \/\/       fmax    v15.2S, v16.2S, v17.2S\n+    __ fmax(v16, __ T4S, v17, v18);                    \/\/       fmax    v16.4S, v17.4S, v18.4S\n+    __ fmax(v2, __ T2D, v3, v4);                       \/\/       fmax    v2.2D, v3.2D, v4.2D\n+    __ minv(v1, __ T8B, v2, v3);                       \/\/       smin    v1.8B, v2.8B, v3.8B\n+    __ minv(v0, __ T16B, v1, v2);                      \/\/       smin    v0.16B, v1.16B, v2.16B\n+    __ minv(v24, __ T4H, v25, v26);                    \/\/       smin    v24.4H, v25.4H, v26.4H\n+    __ minv(v4, __ T8H, v5, v6);                       \/\/       smin    v4.8H, v5.8H, v6.8H\n+    __ minv(v3, __ T2S, v4, v5);                       \/\/       smin    v3.2S, v4.2S, v5.2S\n+    __ minv(v11, __ T4S, v12, v13);                    \/\/       smin    v11.4S, v12.4S, v13.4S\n+    __ sminp(v30, __ T8B, v31, v0);                    \/\/       sminp   v30.8B, v31.8B, v0.8B\n+    __ sminp(v27, __ T16B, v28, v29);                  \/\/       sminp   v27.16B, v28.16B, v29.16B\n+    __ sminp(v9, __ T4H, v10, v11);                    \/\/       sminp   v9.4H, v10.4H, v11.4H\n+    __ sminp(v25, __ T8H, v26, v27);                   \/\/       sminp   v25.8H, v26.8H, v27.8H\n+    __ sminp(v2, __ T2S, v3, v4);                      \/\/       sminp   v2.2S, v3.2S, v4.2S\n+    __ sminp(v12, __ T4S, v13, v14);                   \/\/       sminp   v12.4S, v13.4S, v14.4S\n+    __ fmin(v17, __ T2S, v18, v19);                    \/\/       fmin    v17.2S, v18.2S, v19.2S\n+    __ fmin(v30, __ T4S, v31, v0);                     \/\/       fmin    v30.4S, v31.4S, v0.4S\n+    __ fmin(v1, __ T2D, v2, v3);                       \/\/       fmin    v1.2D, v2.2D, v3.2D\n+    __ cmeq(v12, __ T8B, v13, v14);                    \/\/       cmeq    v12.8B, v13.8B, v14.8B\n+    __ cmeq(v28, __ T16B, v29, v30);                   \/\/       cmeq    v28.16B, v29.16B, v30.16B\n+    __ cmeq(v0, __ T4H, v1, v2);                       \/\/       cmeq    v0.4H, v1.4H, v2.4H\n+    __ cmeq(v17, __ T8H, v18, v19);                    \/\/       cmeq    v17.8H, v18.8H, v19.8H\n+    __ cmeq(v12, __ T2S, v13, v14);                    \/\/       cmeq    v12.2S, v13.2S, v14.2S\n@@ -665,15 +713,15 @@\n-    __ cmeq(v13, __ T2D, v14, v15);                    \/\/       cmeq    v13.2D, v14.2D, v15.2D\n-    __ fcmeq(v4, __ T2S, v5, v6);                      \/\/       fcmeq   v4.2S, v5.2S, v6.2S\n-    __ fcmeq(v28, __ T4S, v29, v30);                   \/\/       fcmeq   v28.4S, v29.4S, v30.4S\n-    __ fcmeq(v23, __ T2D, v24, v25);                   \/\/       fcmeq   v23.2D, v24.2D, v25.2D\n-    __ cmgt(v21, __ T8B, v22, v23);                    \/\/       cmgt    v21.8B, v22.8B, v23.8B\n-    __ cmgt(v25, __ T16B, v26, v27);                   \/\/       cmgt    v25.16B, v26.16B, v27.16B\n-    __ cmgt(v24, __ T4H, v25, v26);                    \/\/       cmgt    v24.4H, v25.4H, v26.4H\n-    __ cmgt(v3, __ T8H, v4, v5);                       \/\/       cmgt    v3.8H, v4.8H, v5.8H\n-    __ cmgt(v23, __ T2S, v24, v25);                    \/\/       cmgt    v23.2S, v24.2S, v25.2S\n-    __ cmgt(v26, __ T4S, v27, v28);                    \/\/       cmgt    v26.4S, v27.4S, v28.4S\n-    __ cmgt(v23, __ T2D, v24, v25);                    \/\/       cmgt    v23.2D, v24.2D, v25.2D\n-    __ cmhi(v14, __ T8B, v15, v16);                    \/\/       cmhi    v14.8B, v15.8B, v16.8B\n-    __ cmhi(v21, __ T16B, v22, v23);                   \/\/       cmhi    v21.16B, v22.16B, v23.16B\n-    __ cmhi(v3, __ T4H, v4, v5);                       \/\/       cmhi    v3.4H, v4.4H, v5.4H\n-    __ cmhi(v23, __ T8H, v24, v25);                    \/\/       cmhi    v23.8H, v24.8H, v25.8H\n+    __ cmeq(v21, __ T2D, v22, v23);                    \/\/       cmeq    v21.2D, v22.2D, v23.2D\n+    __ fcmeq(v12, __ T2S, v13, v14);                   \/\/       fcmeq   v12.2S, v13.2S, v14.2S\n+    __ fcmeq(v27, __ T4S, v28, v29);                   \/\/       fcmeq   v27.4S, v28.4S, v29.4S\n+    __ fcmeq(v29, __ T2D, v30, v31);                   \/\/       fcmeq   v29.2D, v30.2D, v31.2D\n+    __ cmgt(v30, __ T8B, v31, v0);                     \/\/       cmgt    v30.8B, v31.8B, v0.8B\n+    __ cmgt(v1, __ T16B, v2, v3);                      \/\/       cmgt    v1.16B, v2.16B, v3.16B\n+    __ cmgt(v25, __ T4H, v26, v27);                    \/\/       cmgt    v25.4H, v26.4H, v27.4H\n+    __ cmgt(v27, __ T8H, v28, v29);                    \/\/       cmgt    v27.8H, v28.8H, v29.8H\n+    __ cmgt(v4, __ T2S, v5, v6);                       \/\/       cmgt    v4.2S, v5.2S, v6.2S\n+    __ cmgt(v29, __ T4S, v30, v31);                    \/\/       cmgt    v29.4S, v30.4S, v31.4S\n+    __ cmgt(v3, __ T2D, v4, v5);                       \/\/       cmgt    v3.2D, v4.2D, v5.2D\n+    __ cmhi(v6, __ T8B, v7, v8);                       \/\/       cmhi    v6.8B, v7.8B, v8.8B\n+    __ cmhi(v29, __ T16B, v30, v31);                   \/\/       cmhi    v29.16B, v30.16B, v31.16B\n+    __ cmhi(v25, __ T4H, v26, v27);                    \/\/       cmhi    v25.4H, v26.4H, v27.4H\n+    __ cmhi(v17, __ T8H, v18, v19);                    \/\/       cmhi    v17.8H, v18.8H, v19.8H\n@@ -681,19 +729,19 @@\n-    __ cmhi(v24, __ T4S, v25, v26);                    \/\/       cmhi    v24.4S, v25.4S, v26.4S\n-    __ cmhi(v19, __ T2D, v20, v21);                    \/\/       cmhi    v19.2D, v20.2D, v21.2D\n-    __ cmhs(v15, __ T8B, v16, v17);                    \/\/       cmhs    v15.8B, v16.8B, v17.8B\n-    __ cmhs(v16, __ T16B, v17, v18);                   \/\/       cmhs    v16.16B, v17.16B, v18.16B\n-    __ cmhs(v2, __ T4H, v3, v4);                       \/\/       cmhs    v2.4H, v3.4H, v4.4H\n-    __ cmhs(v1, __ T8H, v2, v3);                       \/\/       cmhs    v1.8H, v2.8H, v3.8H\n-    __ cmhs(v0, __ T2S, v1, v2);                       \/\/       cmhs    v0.2S, v1.2S, v2.2S\n-    __ cmhs(v24, __ T4S, v25, v26);                    \/\/       cmhs    v24.4S, v25.4S, v26.4S\n-    __ cmhs(v4, __ T2D, v5, v6);                       \/\/       cmhs    v4.2D, v5.2D, v6.2D\n-    __ fcmgt(v3, __ T2S, v4, v5);                      \/\/       fcmgt   v3.2S, v4.2S, v5.2S\n-    __ fcmgt(v11, __ T4S, v12, v13);                   \/\/       fcmgt   v11.4S, v12.4S, v13.4S\n-    __ fcmgt(v30, __ T2D, v31, v0);                    \/\/       fcmgt   v30.2D, v31.2D, v0.2D\n-    __ cmge(v27, __ T8B, v28, v29);                    \/\/       cmge    v27.8B, v28.8B, v29.8B\n-    __ cmge(v9, __ T16B, v10, v11);                    \/\/       cmge    v9.16B, v10.16B, v11.16B\n-    __ cmge(v25, __ T4H, v26, v27);                    \/\/       cmge    v25.4H, v26.4H, v27.4H\n-    __ cmge(v2, __ T8H, v3, v4);                       \/\/       cmge    v2.8H, v3.8H, v4.8H\n-    __ cmge(v12, __ T2S, v13, v14);                    \/\/       cmge    v12.2S, v13.2S, v14.2S\n-    __ cmge(v17, __ T4S, v18, v19);                    \/\/       cmge    v17.4S, v18.4S, v19.4S\n-    __ cmge(v30, __ T2D, v31, v0);                     \/\/       cmge    v30.2D, v31.2D, v0.2D\n+    __ cmhi(v7, __ T4S, v8, v9);                       \/\/       cmhi    v7.4S, v8.4S, v9.4S\n+    __ cmhi(v12, __ T2D, v13, v14);                    \/\/       cmhi    v12.2D, v13.2D, v14.2D\n+    __ cmhs(v0, __ T8B, v1, v2);                       \/\/       cmhs    v0.8B, v1.8B, v2.8B\n+    __ cmhs(v19, __ T16B, v20, v21);                   \/\/       cmhs    v19.16B, v20.16B, v21.16B\n+    __ cmhs(v1, __ T4H, v2, v3);                       \/\/       cmhs    v1.4H, v2.4H, v3.4H\n+    __ cmhs(v23, __ T8H, v24, v25);                    \/\/       cmhs    v23.8H, v24.8H, v25.8H\n+    __ cmhs(v2, __ T2S, v3, v4);                       \/\/       cmhs    v2.2S, v3.2S, v4.2S\n+    __ cmhs(v0, __ T4S, v1, v2);                       \/\/       cmhs    v0.4S, v1.4S, v2.4S\n+    __ cmhs(v8, __ T2D, v9, v10);                      \/\/       cmhs    v8.2D, v9.2D, v10.2D\n+    __ fcmgt(v23, __ T2S, v24, v25);                   \/\/       fcmgt   v23.2S, v24.2S, v25.2S\n+    __ fcmgt(v25, __ T4S, v26, v27);                   \/\/       fcmgt   v25.4S, v26.4S, v27.4S\n+    __ fcmgt(v15, __ T2D, v16, v17);                   \/\/       fcmgt   v15.2D, v16.2D, v17.2D\n+    __ cmge(v29, __ T8B, v30, v31);                    \/\/       cmge    v29.8B, v30.8B, v31.8B\n+    __ cmge(v3, __ T16B, v4, v5);                      \/\/       cmge    v3.16B, v4.16B, v5.16B\n+    __ cmge(v10, __ T4H, v11, v12);                    \/\/       cmge    v10.4H, v11.4H, v12.4H\n+    __ cmge(v22, __ T8H, v23, v24);                    \/\/       cmge    v22.8H, v23.8H, v24.8H\n+    __ cmge(v10, __ T2S, v11, v12);                    \/\/       cmge    v10.2S, v11.2S, v12.2S\n+    __ cmge(v4, __ T4S, v5, v6);                       \/\/       cmge    v4.4S, v5.4S, v6.4S\n+    __ cmge(v17, __ T2D, v18, v19);                    \/\/       cmge    v17.2D, v18.2D, v19.2D\n@@ -701,2 +749,2 @@\n-    __ fcmge(v12, __ T4S, v13, v14);                   \/\/       fcmge   v12.4S, v13.4S, v14.4S\n-    __ fcmge(v28, __ T2D, v29, v30);                   \/\/       fcmge   v28.2D, v29.2D, v30.2D\n+    __ fcmge(v11, __ T4S, v12, v13);                   \/\/       fcmge   v11.4S, v12.4S, v13.4S\n+    __ fcmge(v7, __ T2D, v8, v9);                      \/\/       fcmge   v7.2D, v8.2D, v9.2D\n@@ -936,9 +984,9 @@\n-    __ swp(Assembler::xword, r0, r19, r12);            \/\/       swp     x0, x19, [x12]\n-    __ ldadd(Assembler::xword, r17, r22, r13);         \/\/       ldadd   x17, x22, [x13]\n-    __ ldbic(Assembler::xword, r28, r30, sp);          \/\/       ldclr   x28, x30, [sp]\n-    __ ldeor(Assembler::xword, r1, r26, r28);          \/\/       ldeor   x1, x26, [x28]\n-    __ ldorr(Assembler::xword, r4, r30, r4);           \/\/       ldset   x4, x30, [x4]\n-    __ ldsmin(Assembler::xword, r6, r30, r26);         \/\/       ldsmin  x6, x30, [x26]\n-    __ ldsmax(Assembler::xword, r16, r9, r8);          \/\/       ldsmax  x16, x9, [x8]\n-    __ ldumin(Assembler::xword, r12, r0, r20);         \/\/       ldumin  x12, x0, [x20]\n-    __ ldumax(Assembler::xword, r1, r24, r2);          \/\/       ldumax  x1, x24, [x2]\n+    __ swp(Assembler::xword, r10, r15, r17);           \/\/       swp     x10, x15, [x17]\n+    __ ldadd(Assembler::xword, r2, r10, r12);          \/\/       ldadd   x2, x10, [x12]\n+    __ ldbic(Assembler::xword, r12, r15, r13);         \/\/       ldclr   x12, x15, [x13]\n+    __ ldeor(Assembler::xword, r2, r7, r20);           \/\/       ldeor   x2, x7, [x20]\n+    __ ldorr(Assembler::xword, r26, r16, r4);          \/\/       ldset   x26, x16, [x4]\n+    __ ldsmin(Assembler::xword, r2, r4, r12);          \/\/       ldsmin  x2, x4, [x12]\n+    __ ldsmax(Assembler::xword, r16, r21, r16);        \/\/       ldsmax  x16, x21, [x16]\n+    __ ldumin(Assembler::xword, r16, r11, r21);        \/\/       ldumin  x16, x11, [x21]\n+    __ ldumax(Assembler::xword, r23, r12, r26);        \/\/       ldumax  x23, x12, [x26]\n@@ -947,9 +995,9 @@\n-    __ swpa(Assembler::xword, r0, r9, r24);            \/\/       swpa    x0, x9, [x24]\n-    __ ldadda(Assembler::xword, r26, r16, r30);        \/\/       ldadda  x26, x16, [x30]\n-    __ ldbica(Assembler::xword, r3, r10, r23);         \/\/       ldclra  x3, x10, [x23]\n-    __ ldeora(Assembler::xword, r10, r4, r15);         \/\/       ldeora  x10, x4, [x15]\n-    __ ldorra(Assembler::xword, r2, r11, r8);          \/\/       ldseta  x2, x11, [x8]\n-    __ ldsmina(Assembler::xword, r10, r15, r17);       \/\/       ldsmina x10, x15, [x17]\n-    __ ldsmaxa(Assembler::xword, r2, r10, r12);        \/\/       ldsmaxa x2, x10, [x12]\n-    __ ldumina(Assembler::xword, r12, r15, r13);       \/\/       ldumina x12, x15, [x13]\n-    __ ldumaxa(Assembler::xword, r2, r7, r20);         \/\/       ldumaxa x2, x7, [x20]\n+    __ swpa(Assembler::xword, r23, r28, r14);          \/\/       swpa    x23, x28, [x14]\n+    __ ldadda(Assembler::xword, r11, r24, r1);         \/\/       ldadda  x11, x24, [x1]\n+    __ ldbica(Assembler::xword, r12, zr, r10);         \/\/       ldclra  x12, xzr, [x10]\n+    __ ldeora(Assembler::xword, r16, r7, r2);          \/\/       ldeora  x16, x7, [x2]\n+    __ ldorra(Assembler::xword, r3, r13, r19);         \/\/       ldseta  x3, x13, [x19]\n+    __ ldsmina(Assembler::xword, r17, r16, r3);        \/\/       ldsmina x17, x16, [x3]\n+    __ ldsmaxa(Assembler::xword, r1, r11, r30);        \/\/       ldsmaxa x1, x11, [x30]\n+    __ ldumina(Assembler::xword, r5, r8, r15);         \/\/       ldumina x5, x8, [x15]\n+    __ ldumaxa(Assembler::xword, r29, r30, r0);        \/\/       ldumaxa x29, x30, [x0]\n@@ -958,9 +1006,9 @@\n-    __ swpal(Assembler::xword, r26, r16, r4);          \/\/       swpal   x26, x16, [x4]\n-    __ ldaddal(Assembler::xword, r2, r4, r12);         \/\/       ldaddal x2, x4, [x12]\n-    __ ldbical(Assembler::xword, r16, r21, r16);       \/\/       ldclral x16, x21, [x16]\n-    __ ldeoral(Assembler::xword, r16, r11, r21);       \/\/       ldeoral x16, x11, [x21]\n-    __ ldorral(Assembler::xword, r23, r12, r26);       \/\/       ldsetal x23, x12, [x26]\n-    __ ldsminal(Assembler::xword, r23, r28, r14);      \/\/       ldsminal        x23, x28, [x14]\n-    __ ldsmaxal(Assembler::xword, r11, r24, r1);       \/\/       ldsmaxal        x11, x24, [x1]\n-    __ lduminal(Assembler::xword, r12, zr, r10);       \/\/       lduminal        x12, xzr, [x10]\n-    __ ldumaxal(Assembler::xword, r16, r7, r2);        \/\/       ldumaxal        x16, x7, [x2]\n+    __ swpal(Assembler::xword, r20, r7, r20);          \/\/       swpal   x20, x7, [x20]\n+    __ ldaddal(Assembler::xword, r23, r28, r21);       \/\/       ldaddal x23, x28, [x21]\n+    __ ldbical(Assembler::xword, r27, r25, r5);        \/\/       ldclral x27, x25, [x5]\n+    __ ldeoral(Assembler::xword, r1, r23, r16);        \/\/       ldeoral x1, x23, [x16]\n+    __ ldorral(Assembler::xword, zr, r5, r12);         \/\/       ldsetal xzr, x5, [x12]\n+    __ ldsminal(Assembler::xword, r9, r28, r15);       \/\/       ldsminal        x9, x28, [x15]\n+    __ ldsmaxal(Assembler::xword, r29, r22, sp);       \/\/       ldsmaxal        x29, x22, [sp]\n+    __ lduminal(Assembler::xword, r19, zr, r5);        \/\/       lduminal        x19, xzr, [x5]\n+    __ ldumaxal(Assembler::xword, r14, r16, sp);       \/\/       ldumaxal        x14, x16, [sp]\n@@ -969,9 +1017,9 @@\n-    __ swpl(Assembler::xword, r3, r13, r19);           \/\/       swpl    x3, x13, [x19]\n-    __ ldaddl(Assembler::xword, r17, r16, r3);         \/\/       ldaddl  x17, x16, [x3]\n-    __ ldbicl(Assembler::xword, r1, r11, r30);         \/\/       ldclrl  x1, x11, [x30]\n-    __ ldeorl(Assembler::xword, r5, r8, r15);          \/\/       ldeorl  x5, x8, [x15]\n-    __ ldorrl(Assembler::xword, r29, r30, r0);         \/\/       ldsetl  x29, x30, [x0]\n-    __ ldsminl(Assembler::xword, r20, r7, r20);        \/\/       ldsminl x20, x7, [x20]\n-    __ ldsmaxl(Assembler::xword, r23, r28, r21);       \/\/       ldsmaxl x23, x28, [x21]\n-    __ lduminl(Assembler::xword, r27, r25, r5);        \/\/       lduminl x27, x25, [x5]\n-    __ ldumaxl(Assembler::xword, r1, r23, r16);        \/\/       ldumaxl x1, x23, [x16]\n+    __ swpl(Assembler::xword, r16, r27, r20);          \/\/       swpl    x16, x27, [x20]\n+    __ ldaddl(Assembler::xword, r16, r12, r11);        \/\/       ldaddl  x16, x12, [x11]\n+    __ ldbicl(Assembler::xword, r9, r6, r30);          \/\/       ldclrl  x9, x6, [x30]\n+    __ ldeorl(Assembler::xword, r17, r27, r28);        \/\/       ldeorl  x17, x27, [x28]\n+    __ ldorrl(Assembler::xword, r30, r7, r10);         \/\/       ldsetl  x30, x7, [x10]\n+    __ ldsminl(Assembler::xword, r20, r10, r4);        \/\/       ldsminl x20, x10, [x4]\n+    __ ldsmaxl(Assembler::xword, r24, r17, r17);       \/\/       ldsmaxl x24, x17, [x17]\n+    __ lduminl(Assembler::xword, r22, r3, r29);        \/\/       lduminl x22, x3, [x29]\n+    __ ldumaxl(Assembler::xword, r15, r22, r19);       \/\/       ldumaxl x15, x22, [x19]\n@@ -980,9 +1028,9 @@\n-    __ swp(Assembler::word, zr, r5, r12);              \/\/       swp     wzr, w5, [x12]\n-    __ ldadd(Assembler::word, r9, r28, r15);           \/\/       ldadd   w9, w28, [x15]\n-    __ ldbic(Assembler::word, r29, r22, sp);           \/\/       ldclr   w29, w22, [sp]\n-    __ ldeor(Assembler::word, r19, zr, r5);            \/\/       ldeor   w19, wzr, [x5]\n-    __ ldorr(Assembler::word, r14, r16, sp);           \/\/       ldset   w14, w16, [sp]\n-    __ ldsmin(Assembler::word, r16, r27, r20);         \/\/       ldsmin  w16, w27, [x20]\n-    __ ldsmax(Assembler::word, r16, r12, r11);         \/\/       ldsmax  w16, w12, [x11]\n-    __ ldumin(Assembler::word, r9, r6, r30);           \/\/       ldumin  w9, w6, [x30]\n-    __ ldumax(Assembler::word, r17, r27, r28);         \/\/       ldumax  w17, w27, [x28]\n+    __ swp(Assembler::word, r19, r22, r2);             \/\/       swp     w19, w22, [x2]\n+    __ ldadd(Assembler::word, r15, r6, r12);           \/\/       ldadd   w15, w6, [x12]\n+    __ ldbic(Assembler::word, r16, r11, r13);          \/\/       ldclr   w16, w11, [x13]\n+    __ ldeor(Assembler::word, r23, r1, r30);           \/\/       ldeor   w23, w1, [x30]\n+    __ ldorr(Assembler::word, r19, r5, r17);           \/\/       ldset   w19, w5, [x17]\n+    __ ldsmin(Assembler::word, r2, r16, r22);          \/\/       ldsmin  w2, w16, [x22]\n+    __ ldsmax(Assembler::word, r13, r10, r21);         \/\/       ldsmax  w13, w10, [x21]\n+    __ ldumin(Assembler::word, r29, r27, r12);         \/\/       ldumin  w29, w27, [x12]\n+    __ ldumax(Assembler::word, r27, r3, r1);           \/\/       ldumax  w27, w3, [x1]\n@@ -991,9 +1039,9 @@\n-    __ swpa(Assembler::word, r30, r7, r10);            \/\/       swpa    w30, w7, [x10]\n-    __ ldadda(Assembler::word, r20, r10, r4);          \/\/       ldadda  w20, w10, [x4]\n-    __ ldbica(Assembler::word, r24, r17, r17);         \/\/       ldclra  w24, w17, [x17]\n-    __ ldeora(Assembler::word, r22, r3, r29);          \/\/       ldeora  w22, w3, [x29]\n-    __ ldorra(Assembler::word, r15, r22, r19);         \/\/       ldseta  w15, w22, [x19]\n-    __ ldsmina(Assembler::word, r19, r22, r2);         \/\/       ldsmina w19, w22, [x2]\n-    __ ldsmaxa(Assembler::word, r15, r6, r12);         \/\/       ldsmaxa w15, w6, [x12]\n-    __ ldumina(Assembler::word, r16, r11, r13);        \/\/       ldumina w16, w11, [x13]\n-    __ ldumaxa(Assembler::word, r23, r1, r30);         \/\/       ldumaxa w23, w1, [x30]\n+    __ swpa(Assembler::word, zr, r24, r19);            \/\/       swpa    wzr, w24, [x19]\n+    __ ldadda(Assembler::word, r17, r9, r28);          \/\/       ldadda  w17, w9, [x28]\n+    __ ldbica(Assembler::word, r27, r15, r7);          \/\/       ldclra  w27, w15, [x7]\n+    __ ldeora(Assembler::word, r21, r23, sp);          \/\/       ldeora  w21, w23, [sp]\n+    __ ldorra(Assembler::word, r25, r2, sp);           \/\/       ldseta  w25, w2, [sp]\n+    __ ldsmina(Assembler::word, r27, r16, r10);        \/\/       ldsmina w27, w16, [x10]\n+    __ ldsmaxa(Assembler::word, r23, r19, r3);         \/\/       ldsmaxa w23, w19, [x3]\n+    __ ldumina(Assembler::word, r16, r0, r25);         \/\/       ldumina w16, w0, [x25]\n+    __ ldumaxa(Assembler::word, r26, r23, r2);         \/\/       ldumaxa w26, w23, [x2]\n@@ -1002,9 +1050,9 @@\n-    __ swpal(Assembler::word, r19, r5, r17);           \/\/       swpal   w19, w5, [x17]\n-    __ ldaddal(Assembler::word, r2, r16, r22);         \/\/       ldaddal w2, w16, [x22]\n-    __ ldbical(Assembler::word, r13, r10, r21);        \/\/       ldclral w13, w10, [x21]\n-    __ ldeoral(Assembler::word, r29, r27, r12);        \/\/       ldeoral w29, w27, [x12]\n-    __ ldorral(Assembler::word, r27, r3, r1);          \/\/       ldsetal w27, w3, [x1]\n-    __ ldsminal(Assembler::word, zr, r24, r19);        \/\/       ldsminal        wzr, w24, [x19]\n-    __ ldsmaxal(Assembler::word, r17, r9, r28);        \/\/       ldsmaxal        w17, w9, [x28]\n-    __ lduminal(Assembler::word, r27, r15, r7);        \/\/       lduminal        w27, w15, [x7]\n-    __ ldumaxal(Assembler::word, r21, r23, sp);        \/\/       ldumaxal        w21, w23, [sp]\n+    __ swpal(Assembler::word, r16, r12, r4);           \/\/       swpal   w16, w12, [x4]\n+    __ ldaddal(Assembler::word, r28, r30, r29);        \/\/       ldaddal w28, w30, [x29]\n+    __ ldbical(Assembler::word, r16, r27, r6);         \/\/       ldclral w16, w27, [x6]\n+    __ ldeoral(Assembler::word, r9, r29, r15);         \/\/       ldeoral w9, w29, [x15]\n+    __ ldorral(Assembler::word, r7, r4, r7);           \/\/       ldsetal w7, w4, [x7]\n+    __ ldsminal(Assembler::word, r15, r9, r23);        \/\/       ldsminal        w15, w9, [x23]\n+    __ ldsmaxal(Assembler::word, r8, r2, r28);         \/\/       ldsmaxal        w8, w2, [x28]\n+    __ lduminal(Assembler::word, r21, zr, r5);         \/\/       lduminal        w21, wzr, [x5]\n+    __ ldumaxal(Assembler::word, r27, r0, r17);        \/\/       ldumaxal        w27, w0, [x17]\n@@ -1013,9 +1061,9 @@\n-    __ swpl(Assembler::word, r25, r2, sp);             \/\/       swpl    w25, w2, [sp]\n-    __ ldaddl(Assembler::word, r27, r16, r10);         \/\/       ldaddl  w27, w16, [x10]\n-    __ ldbicl(Assembler::word, r23, r19, r3);          \/\/       ldclrl  w23, w19, [x3]\n-    __ ldeorl(Assembler::word, r16, r0, r25);          \/\/       ldeorl  w16, w0, [x25]\n-    __ ldorrl(Assembler::word, r26, r23, r2);          \/\/       ldsetl  w26, w23, [x2]\n-    __ ldsminl(Assembler::word, r16, r12, r4);         \/\/       ldsminl w16, w12, [x4]\n-    __ ldsmaxl(Assembler::word, r28, r30, r29);        \/\/       ldsmaxl w28, w30, [x29]\n-    __ lduminl(Assembler::word, r16, r27, r6);         \/\/       lduminl w16, w27, [x6]\n-    __ ldumaxl(Assembler::word, r9, r29, r15);         \/\/       ldumaxl w9, w29, [x15]\n+    __ swpl(Assembler::word, r15, r4, r26);            \/\/       swpl    w15, w4, [x26]\n+    __ ldaddl(Assembler::word, r8, r28, r22);          \/\/       ldaddl  w8, w28, [x22]\n+    __ ldbicl(Assembler::word, r27, r27, r25);         \/\/       ldclrl  w27, w27, [x25]\n+    __ ldeorl(Assembler::word, r23, r0, r4);           \/\/       ldeorl  w23, w0, [x4]\n+    __ ldorrl(Assembler::word, r6, r16, r0);           \/\/       ldsetl  w6, w16, [x0]\n+    __ ldsminl(Assembler::word, r4, r15, r1);          \/\/       ldsminl w4, w15, [x1]\n+    __ ldsmaxl(Assembler::word, r10, r7, r5);          \/\/       ldsmaxl w10, w7, [x5]\n+    __ lduminl(Assembler::word, r10, r28, r7);         \/\/       lduminl w10, w28, [x7]\n+    __ ldumaxl(Assembler::word, r20, r23, r21);        \/\/       ldumaxl w20, w23, [x21]\n@@ -1024,4 +1072,4 @@\n-    __ bcax(v7, __ T16B, v4, v7, v15);                 \/\/       bcax            v7.16B, v4.16B, v7.16B, v15.16B\n-    __ eor3(v9, __ T16B, v22, v8, v2);                 \/\/       eor3            v9.16B, v22.16B, v8.16B, v2.16B\n-    __ rax1(v27, __ T2D, v20, v30);                    \/\/       rax1            v27.2D, v20.2D, v30.2D\n-    __ xar(v5, __ T2D, v26, v0, 34);                   \/\/       xar             v5.2D, v26.2D, v0.2D, #34\n+    __ bcax(v5, __ T16B, v10, v8, v16);                \/\/       bcax            v5.16B, v10.16B, v8.16B, v16.16B\n+    __ eor3(v30, __ T16B, v6, v17, v2);                \/\/       eor3            v30.16B, v6.16B, v17.16B, v2.16B\n+    __ rax1(v11, __ T2D, v29, v28);                    \/\/       rax1            v11.2D, v29.2D, v28.2D\n+    __ xar(v2, __ T2D, v26, v22, 58);                  \/\/       xar             v2.2D, v26.2D, v22.2D, #58\n@@ -1030,4 +1078,4 @@\n-    __ sha512h(v14, __ T2D, v3, v25);                  \/\/       sha512h         q14, q3, v25.2D\n-    __ sha512h2(v8, __ T2D, v27, v21);                 \/\/       sha512h2                q8, q27, v21.2D\n-    __ sha512su0(v26, __ T2D, v26);                    \/\/       sha512su0               v26.2D, v26.2D\n-    __ sha512su1(v24, __ T2D, v22, v0);                \/\/       sha512su1               v24.2D, v22.2D, v0.2D\n+    __ sha512h(v14, __ T2D, v13, v27);                 \/\/       sha512h         q14, q13, v27.2D\n+    __ sha512h2(v16, __ T2D, v23, v5);                 \/\/       sha512h2                q16, q23, v5.2D\n+    __ sha512su0(v2, __ T2D, v13);                     \/\/       sha512su0               v2.2D, v13.2D\n+    __ sha512su1(v10, __ T2D, v15, v10);               \/\/       sha512su1               v10.2D, v15.2D, v10.2D\n@@ -1036,5 +1084,5 @@\n-    __ sve_add(z4, __ B, 147u);                        \/\/       add     z4.b, z4.b, #0x93\n-    __ sve_sub(z0, __ B, 124u);                        \/\/       sub     z0.b, z0.b, #0x7c\n-    __ sve_and(z1, __ H, 508u);                        \/\/       and     z1.h, z1.h, #0x1fc\n-    __ sve_eor(z9, __ D, 18374686479671656447u);       \/\/       eor     z9.d, z9.d, #0xff00000000007fff\n-    __ sve_orr(z22, __ S, 251662080u);                 \/\/       orr     z22.s, z22.s, #0xf000f00\n+    __ sve_add(z26, __ S, 98u);                        \/\/       add     z26.s, z26.s, #0x62\n+    __ sve_sub(z3, __ S, 138u);                        \/\/       sub     z3.s, z3.s, #0x8a\n+    __ sve_and(z4, __ B, 131u);                        \/\/       and     z4.b, z4.b, #0x83\n+    __ sve_eor(z17, __ H, 16368u);                     \/\/       eor     z17.h, z17.h, #0x3ff0\n+    __ sve_orr(z2, __ S, 4164941887u);                 \/\/       orr     z2.s, z2.s, #0xf83ff83f\n@@ -1043,5 +1091,5 @@\n-    __ sve_add(z8, __ S, 248u);                        \/\/       add     z8.s, z8.s, #0xf8\n-    __ sve_sub(z6, __ S, 16u);                         \/\/       sub     z6.s, z6.s, #0x10\n-    __ sve_and(z11, __ D, 4160749568u);                \/\/       and     z11.d, z11.d, #0xf8000000\n-    __ sve_eor(z26, __ S, 1610637312u);                \/\/       eor     z26.s, z26.s, #0x60006000\n-    __ sve_orr(z13, __ D, 18446181398634037247u);      \/\/       orr     z13.d, z13.d, #0xfffe003fffffffff\n+    __ sve_add(z23, __ B, 51u);                        \/\/       add     z23.b, z23.b, #0x33\n+    __ sve_sub(z7, __ S, 104u);                        \/\/       sub     z7.s, z7.s, #0x68\n+    __ sve_and(z27, __ S, 7864320u);                   \/\/       and     z27.s, z27.s, #0x780000\n+    __ sve_eor(z2, __ D, 68719476224u);                \/\/       eor     z2.d, z2.d, #0xffffffe00\n+    __ sve_orr(z6, __ S, 1056980736u);                 \/\/       orr     z6.s, z6.s, #0x3f003f00\n@@ -1050,5 +1098,5 @@\n-    __ sve_add(z5, __ B, 112u);                        \/\/       add     z5.b, z5.b, #0x70\n-    __ sve_sub(z10, __ S, 88u);                        \/\/       sub     z10.s, z10.s, #0x58\n-    __ sve_and(z26, __ S, 253952u);                    \/\/       and     z26.s, z26.s, #0x3e000\n-    __ sve_eor(z22, __ S, 496u);                       \/\/       eor     z22.s, z22.s, #0x1f0\n-    __ sve_orr(z19, __ S, 536870910u);                 \/\/       orr     z19.s, z19.s, #0x1ffffffe\n+    __ sve_add(z12, __ S, 67u);                        \/\/       add     z12.s, z12.s, #0x43\n+    __ sve_sub(z24, __ S, 154u);                       \/\/       sub     z24.s, z24.s, #0x9a\n+    __ sve_and(z0, __ H, 511u);                        \/\/       and     z0.h, z0.h, #0x1ff\n+    __ sve_eor(z19, __ D, 9241386433220968447u);       \/\/       eor     z19.d, z19.d, #0x803fffff803fffff\n+    __ sve_orr(z6, __ B, 128u);                        \/\/       orr     z6.b, z6.b, #0x80\n@@ -1057,5 +1105,5 @@\n-    __ sve_add(z14, __ H, 22u);                        \/\/       add     z14.h, z14.h, #0x16\n-    __ sve_sub(z16, __ B, 172u);                       \/\/       sub     z16.b, z16.b, #0xac\n-    __ sve_and(z23, __ B, 62u);                        \/\/       and     z23.b, z23.b, #0x3e\n-    __ sve_eor(z17, __ H, 33279u);                     \/\/       eor     z17.h, z17.h, #0x81ff\n-    __ sve_orr(z16, __ B, 254u);                       \/\/       orr     z16.b, z16.b, #0xfe\n+    __ sve_add(z17, __ D, 74u);                        \/\/       add     z17.d, z17.d, #0x4a\n+    __ sve_sub(z10, __ S, 170u);                       \/\/       sub     z10.s, z10.s, #0xaa\n+    __ sve_and(z22, __ D, 17179852800u);               \/\/       and     z22.d, z22.d, #0x3ffffc000\n+    __ sve_eor(z15, __ S, 8388600u);                   \/\/       eor     z15.s, z15.s, #0x7ffff8\n+    __ sve_orr(z4, __ D, 8064u);                       \/\/       orr     z4.d, z4.d, #0x1f80\n@@ -1064,5 +1112,5 @@\n-    __ sve_add(z3, __ B, 49u);                         \/\/       add     z3.b, z3.b, #0x31\n-    __ sve_sub(z17, __ S, 110u);                       \/\/       sub     z17.s, z17.s, #0x6e\n-    __ sve_and(z12, __ S, 4290777087u);                \/\/       and     z12.s, z12.s, #0xffc00fff\n-    __ sve_eor(z19, __ S, 134217216u);                 \/\/       eor     z19.s, z19.s, #0x7fffe00\n-    __ sve_orr(z23, __ B, 254u);                       \/\/       orr     z23.b, z23.b, #0xfe\n+    __ sve_add(z8, __ S, 162u);                        \/\/       add     z8.s, z8.s, #0xa2\n+    __ sve_sub(z22, __ B, 130u);                       \/\/       sub     z22.b, z22.b, #0x82\n+    __ sve_and(z9, __ S, 4292870159u);                 \/\/       and     z9.s, z9.s, #0xffe0000f\n+    __ sve_eor(z5, __ D, 1150687262887383032u);        \/\/       eor     z5.d, z5.d, #0xff80ff80ff80ff8\n+    __ sve_orr(z22, __ H, 32256u);                     \/\/       orr     z22.h, z22.h, #0x7e00\n@@ -1071,5 +1119,5 @@\n-    __ sve_add(z13, __ S, 54u);                        \/\/       add     z13.s, z13.s, #0x36\n-    __ sve_sub(z0, __ B, 120u);                        \/\/       sub     z0.b, z0.b, #0x78\n-    __ sve_and(z17, __ D, 18014398509481728u);         \/\/       and     z17.d, z17.d, #0x3fffffffffff00\n-    __ sve_eor(z22, __ S, 4294709247u);                \/\/       eor     z22.s, z22.s, #0xfffc0fff\n-    __ sve_orr(z2, __ B, 225u);                        \/\/       orr     z2.b, z2.b, #0xe1\n+    __ sve_add(z8, __ S, 134u);                        \/\/       add     z8.s, z8.s, #0x86\n+    __ sve_sub(z25, __ H, 39u);                        \/\/       sub     z25.h, z25.h, #0x27\n+    __ sve_and(z4, __ S, 4186112u);                    \/\/       and     z4.s, z4.s, #0x3fe000\n+    __ sve_eor(z29, __ B, 131u);                       \/\/       eor     z29.b, z29.b, #0x83\n+    __ sve_orr(z29, __ D, 4611685469745315712u);       \/\/       orr     z29.d, z29.d, #0x3fffff803fffff80\n@@ -1078,48 +1126,48 @@\n-    __ sve_add(z20, __ D, z7, z4);                     \/\/       add     z20.d, z7.d, z4.d\n-    __ sve_sub(z7, __ S, z0, z8);                      \/\/       sub     z7.s, z0.s, z8.s\n-    __ sve_fadd(z19, __ D, z22, z4);                   \/\/       fadd    z19.d, z22.d, z4.d\n-    __ sve_fmul(z9, __ D, z22, z11);                   \/\/       fmul    z9.d, z22.d, z11.d\n-    __ sve_fsub(z5, __ S, z30, z16);                   \/\/       fsub    z5.s, z30.s, z16.s\n-    __ sve_abs(z22, __ H, p3, z1);                     \/\/       abs     z22.h, p3\/m, z1.h\n-    __ sve_add(z8, __ D, p5, z16);                     \/\/       add     z8.d, p5\/m, z8.d, z16.d\n-    __ sve_and(z15, __ S, p1, z4);                     \/\/       and     z15.s, p1\/m, z15.s, z4.s\n-    __ sve_asr(z8, __ B, p1, z29);                     \/\/       asr     z8.b, p1\/m, z8.b, z29.b\n-    __ sve_bic(z28, __ D, p4, z29);                    \/\/       bic     z28.d, p4\/m, z28.d, z29.d\n-    __ sve_clz(z9, __ H, p3, z2);                      \/\/       clz     z9.h, p3\/m, z2.h\n-    __ sve_cnt(z28, __ B, p0, z7);                     \/\/       cnt     z28.b, p0\/m, z7.b\n-    __ sve_eor(z26, __ H, p5, z17);                    \/\/       eor     z26.h, p5\/m, z26.h, z17.h\n-    __ sve_lsl(z8, __ D, p4, z21);                     \/\/       lsl     z8.d, p4\/m, z8.d, z21.d\n-    __ sve_lsr(z5, __ S, p5, z21);                     \/\/       lsr     z5.s, p5\/m, z5.s, z21.s\n-    __ sve_mul(z22, __ S, p4, z29);                    \/\/       mul     z22.s, p4\/m, z22.s, z29.s\n-    __ sve_neg(z19, __ S, p0, z4);                     \/\/       neg     z19.s, p0\/m, z4.s\n-    __ sve_not(z23, __ B, p1, z19);                    \/\/       not     z23.b, p1\/m, z19.b\n-    __ sve_orr(z23, __ B, p6, z19);                    \/\/       orr     z23.b, p6\/m, z23.b, z19.b\n-    __ sve_rbit(z8, __ D, p2, z14);                    \/\/       rbit    z8.d, p2\/m, z14.d\n-    __ sve_smax(z17, __ B, p7, z21);                   \/\/       smax    z17.b, p7\/m, z17.b, z21.b\n-    __ sve_smin(z30, __ S, p0, z10);                   \/\/       smin    z30.s, p0\/m, z30.s, z10.s\n-    __ sve_sub(z12, __ B, p0, z9);                     \/\/       sub     z12.b, p0\/m, z12.b, z9.b\n-    __ sve_fabs(z24, __ D, p4, z4);                    \/\/       fabs    z24.d, p4\/m, z4.d\n-    __ sve_fadd(z6, __ D, p2, z27);                    \/\/       fadd    z6.d, p2\/m, z6.d, z27.d\n-    __ sve_fdiv(z13, __ D, p4, z30);                   \/\/       fdiv    z13.d, p4\/m, z13.d, z30.d\n-    __ sve_fmax(z22, __ D, p5, z30);                   \/\/       fmax    z22.d, p5\/m, z22.d, z30.d\n-    __ sve_fmin(z9, __ S, p3, z19);                    \/\/       fmin    z9.s, p3\/m, z9.s, z19.s\n-    __ sve_fmul(z20, __ S, p7, z9);                    \/\/       fmul    z20.s, p7\/m, z20.s, z9.s\n-    __ sve_fneg(z13, __ S, p3, z19);                   \/\/       fneg    z13.s, p3\/m, z19.s\n-    __ sve_frintm(z24, __ S, p2, z19);                 \/\/       frintm  z24.s, p2\/m, z19.s\n-    __ sve_frintn(z17, __ S, p4, z16);                 \/\/       frintn  z17.s, p4\/m, z16.s\n-    __ sve_frintp(z0, __ S, p0, z11);                  \/\/       frintp  z0.s, p0\/m, z11.s\n-    __ sve_fsqrt(z15, __ S, p3, z15);                  \/\/       fsqrt   z15.s, p3\/m, z15.s\n-    __ sve_fsub(z15, __ S, p7, z5);                    \/\/       fsub    z15.s, p7\/m, z15.s, z5.s\n-    __ sve_fmad(z10, __ S, p5, z26, z3);               \/\/       fmad    z10.s, p5\/m, z26.s, z3.s\n-    __ sve_fmla(z9, __ D, p4, z28, z10);               \/\/       fmla    z9.d, p4\/m, z28.d, z10.d\n-    __ sve_fmls(z3, __ D, p5, z7, z23);                \/\/       fmls    z3.d, p5\/m, z7.d, z23.d\n-    __ sve_fnmla(z13, __ S, p5, z10, z26);             \/\/       fnmla   z13.s, p5\/m, z10.s, z26.s\n-    __ sve_fnmls(z17, __ S, p7, z17, z14);             \/\/       fnmls   z17.s, p7\/m, z17.s, z14.s\n-    __ sve_mla(z29, __ B, p4, z21, z20);               \/\/       mla     z29.b, p4\/m, z21.b, z20.b\n-    __ sve_mls(z19, __ S, p0, z1, z26);                \/\/       mls     z19.s, p0\/m, z1.s, z26.s\n-    __ sve_and(z9, z16, z17);                          \/\/       and     z9.d, z16.d, z17.d\n-    __ sve_eor(z0, z4, z2);                            \/\/       eor     z0.d, z4.d, z2.d\n-    __ sve_orr(z14, z6, z11);                          \/\/       orr     z14.d, z6.d, z11.d\n-    __ sve_bic(z14, z16, z29);                         \/\/       bic     z14.d, z16.d, z29.d\n-    __ sve_uzp1(z3, __ H, z3, z22);                    \/\/       uzp1    z3.h, z3.h, z22.h\n-    __ sve_uzp2(z3, __ B, z24, z27);                   \/\/       uzp2    z3.b, z24.b, z27.b\n+    __ sve_add(z2, __ B, z11, z28);                    \/\/       add     z2.b, z11.b, z28.b\n+    __ sve_sub(z7, __ S, z1, z26);                     \/\/       sub     z7.s, z1.s, z26.s\n+    __ sve_fadd(z17, __ D, z14, z8);                   \/\/       fadd    z17.d, z14.d, z8.d\n+    __ sve_fmul(z21, __ D, z24, z5);                   \/\/       fmul    z21.d, z24.d, z5.d\n+    __ sve_fsub(z21, __ D, z17, z22);                  \/\/       fsub    z21.d, z17.d, z22.d\n+    __ sve_abs(z29, __ B, p5, z19);                    \/\/       abs     z29.b, p5\/m, z19.b\n+    __ sve_add(z4, __ B, p4, z23);                     \/\/       add     z4.b, p4\/m, z4.b, z23.b\n+    __ sve_and(z19, __ D, p1, z23);                    \/\/       and     z19.d, p1\/m, z19.d, z23.d\n+    __ sve_asr(z19, __ H, p0, z8);                     \/\/       asr     z19.h, p0\/m, z19.h, z8.h\n+    __ sve_bic(z14, __ D, p6, z17);                    \/\/       bic     z14.d, p6\/m, z14.d, z17.d\n+    __ sve_clz(z21, __ B, p1, z30);                    \/\/       clz     z21.b, p1\/m, z30.b\n+    __ sve_cnt(z10, __ B, p5, z12);                    \/\/       cnt     z10.b, p5\/m, z12.b\n+    __ sve_eor(z9, __ S, p1, z24);                     \/\/       eor     z9.s, p1\/m, z9.s, z24.s\n+    __ sve_lsl(z4, __ H, p6, z6);                      \/\/       lsl     z4.h, p6\/m, z4.h, z6.h\n+    __ sve_lsr(z27, __ S, p6, z13);                    \/\/       lsr     z27.s, p6\/m, z27.s, z13.s\n+    __ sve_mul(z30, __ S, p5, z22);                    \/\/       mul     z30.s, p5\/m, z30.s, z22.s\n+    __ sve_neg(z30, __ H, p7, z9);                     \/\/       neg     z30.h, p7\/m, z9.h\n+    __ sve_not(z19, __ D, p1, z20);                    \/\/       not     z19.d, p1\/m, z20.d\n+    __ sve_orr(z9, __ H, p2, z13);                     \/\/       orr     z9.h, p2\/m, z9.h, z13.h\n+    __ sve_rbit(z19, __ H, p0, z24);                   \/\/       rbit    z19.h, p0\/m, z24.h\n+    __ sve_smax(z19, __ S, p3, z17);                   \/\/       smax    z19.s, p3\/m, z19.s, z17.s\n+    __ sve_smin(z16, __ B, p1, z0);                    \/\/       smin    z16.b, p1\/m, z16.b, z0.b\n+    __ sve_sub(z11, __ H, p2, z15);                    \/\/       sub     z11.h, p2\/m, z11.h, z15.h\n+    __ sve_fabs(z15, __ D, p1, z15);                   \/\/       fabs    z15.d, p1\/m, z15.d\n+    __ sve_fadd(z5, __ D, p0, z10);                    \/\/       fadd    z5.d, p0\/m, z5.d, z10.d\n+    __ sve_fdiv(z26, __ S, p0, z0);                    \/\/       fdiv    z26.s, p0\/m, z26.s, z0.s\n+    __ sve_fmax(z19, __ D, p7, z10);                   \/\/       fmax    z19.d, p7\/m, z19.d, z10.d\n+    __ sve_fmin(z3, __ D, p5, z7);                     \/\/       fmin    z3.d, p5\/m, z3.d, z7.d\n+    __ sve_fmul(z28, __ S, p3, z21);                   \/\/       fmul    z28.s, p3\/m, z28.s, z21.s\n+    __ sve_fneg(z26, __ D, p3, z17);                   \/\/       fneg    z26.d, p3\/m, z17.d\n+    __ sve_frintm(z17, __ D, p3, z2);                  \/\/       frintm  z17.d, p3\/m, z2.d\n+    __ sve_frintn(z16, __ S, p5, z20);                 \/\/       frintn  z16.s, p5\/m, z20.s\n+    __ sve_frintp(z19, __ D, p0, z1);                  \/\/       frintp  z19.d, p0\/m, z1.d\n+    __ sve_fsqrt(z17, __ D, p2, z16);                  \/\/       fsqrt   z17.d, p2\/m, z16.d\n+    __ sve_fsub(z21, __ S, p0, z4);                    \/\/       fsub    z21.s, p0\/m, z21.s, z4.s\n+    __ sve_fmad(z23, __ D, p3, z6, z11);               \/\/       fmad    z23.d, p3\/m, z6.d, z11.d\n+    __ sve_fmla(z14, __ S, p4, z29, z12);              \/\/       fmla    z14.s, p4\/m, z29.s, z12.s\n+    __ sve_fmls(z3, __ D, p5, z9, z3);                 \/\/       fmls    z3.d, p5\/m, z9.d, z3.d\n+    __ sve_fnmla(z27, __ S, p0, z19, z22);             \/\/       fnmla   z27.s, p0\/m, z19.s, z22.s\n+    __ sve_fnmls(z25, __ S, p5, z13, z5);              \/\/       fnmls   z25.s, p5\/m, z13.s, z5.s\n+    __ sve_mla(z25, __ S, p1, z21, z17);               \/\/       mla     z25.s, p1\/m, z21.s, z17.s\n+    __ sve_mls(z0, __ H, p0, z9, z19);                 \/\/       mls     z0.h, p0\/m, z9.h, z19.h\n+    __ sve_and(z7, z11, z14);                          \/\/       and     z7.d, z11.d, z14.d\n+    __ sve_eor(z17, z11, z13);                         \/\/       eor     z17.d, z11.d, z13.d\n+    __ sve_orr(z17, z30, z17);                         \/\/       orr     z17.d, z30.d, z17.d\n+    __ sve_bic(z15, z14, z26);                         \/\/       bic     z15.d, z14.d, z26.d\n+    __ sve_uzp1(z27, __ H, z22, z7);                   \/\/       uzp1    z27.h, z22.h, z7.h\n+    __ sve_uzp2(z5, __ H, z27, z27);                   \/\/       uzp2    z5.h, z27.h, z27.h\n@@ -1128,9 +1176,9 @@\n-    __ sve_andv(v19, __ D, p5, z7);                    \/\/       andv d19, p5, z7.d\n-    __ sve_orv(v21, __ H, p3, z5);                     \/\/       orv h21, p3, z5.h\n-    __ sve_eorv(v25, __ S, p1, z21);                   \/\/       eorv s25, p1, z21.s\n-    __ sve_smaxv(v17, __ H, p0, z3);                   \/\/       smaxv h17, p0, z3.h\n-    __ sve_sminv(v19, __ H, p3, z7);                   \/\/       sminv h19, p3, z7.h\n-    __ sve_fminv(v14, __ S, p4, z17);                  \/\/       fminv s14, p4, z17.s\n-    __ sve_fmaxv(v13, __ D, p6, z17);                  \/\/       fmaxv d13, p6, z17.d\n-    __ sve_fadda(v17, __ S, p2, z15);                  \/\/       fadda s17, p2, s17, z15.s\n-    __ sve_uaddv(v26, __ S, p5, z27);                  \/\/       uaddv d26, p5, z27.s\n+    __ sve_andv(v0, __ S, p3, z24);                    \/\/       andv s0, p3, z24.s\n+    __ sve_orv(v20, __ S, p0, z3);                     \/\/       orv s20, p0, z3.s\n+    __ sve_eorv(v25, __ D, p1, z25);                   \/\/       eorv d25, p1, z25.d\n+    __ sve_smaxv(v17, __ H, p4, z1);                   \/\/       smaxv h17, p4, z1.h\n+    __ sve_sminv(v14, __ B, p7, z13);                  \/\/       sminv b14, p7, z13.b\n+    __ sve_fminv(v17, __ D, p0, z30);                  \/\/       fminv d17, p0, z30.d\n+    __ sve_fmaxv(v22, __ S, p5, z29);                  \/\/       fmaxv s22, p5, z29.s\n+    __ sve_fadda(v8, __ S, p0, z0);                    \/\/       fadda s8, p0, s8, z0.s\n+    __ sve_uaddv(v23, __ S, p5, z0);                   \/\/       uaddv d23, p5, z0.s\n@@ -1155,7 +1203,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003ae,     0x94000000,\n-    0x97ffffd4,     0x940003ab,     0x3400000a,     0x34fffa2a,\n-    0x3400750a,     0x35000008,     0x35fff9c8,     0x350074a8,\n-    0xb400000b,     0xb4fff96b,     0xb400744b,     0xb500001d,\n-    0xb5fff91d,     0xb50073fd,     0x10000013,     0x10fff8b3,\n-    0x10007393,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36307316,     0x3758000c,     0x375ff7cc,     0x375872ac,\n+    0x14000000,     0x17ffffd7,     0x140003da,     0x94000000,\n+    0x97ffffd4,     0x940003d7,     0x3400000a,     0x34fffa2a,\n+    0x34007a8a,     0x35000008,     0x35fff9c8,     0x35007a28,\n+    0xb400000b,     0xb4fff96b,     0xb40079cb,     0xb500001d,\n+    0xb5fff91d,     0xb500797d,     0x10000013,     0x10fff8b3,\n+    0x10007913,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307896,     0x3758000c,     0x375ff7cc,     0x3758782c,\n@@ -1166,13 +1214,13 @@\n-    0x54007080,     0x54000001,     0x54fff541,     0x54007021,\n-    0x54000002,     0x54fff4e2,     0x54006fc2,     0x54000002,\n-    0x54fff482,     0x54006f62,     0x54000003,     0x54fff423,\n-    0x54006f03,     0x54000003,     0x54fff3c3,     0x54006ea3,\n-    0x54000004,     0x54fff364,     0x54006e44,     0x54000005,\n-    0x54fff305,     0x54006de5,     0x54000006,     0x54fff2a6,\n-    0x54006d86,     0x54000007,     0x54fff247,     0x54006d27,\n-    0x54000008,     0x54fff1e8,     0x54006cc8,     0x54000009,\n-    0x54fff189,     0x54006c69,     0x5400000a,     0x54fff12a,\n-    0x54006c0a,     0x5400000b,     0x54fff0cb,     0x54006bab,\n-    0x5400000c,     0x54fff06c,     0x54006b4c,     0x5400000d,\n-    0x54fff00d,     0x54006aed,     0x5400000e,     0x54ffefae,\n-    0x54006a8e,     0x5400000f,     0x54ffef4f,     0x54006a2f,\n+    0x54007600,     0x54000001,     0x54fff541,     0x540075a1,\n+    0x54000002,     0x54fff4e2,     0x54007542,     0x54000002,\n+    0x54fff482,     0x540074e2,     0x54000003,     0x54fff423,\n+    0x54007483,     0x54000003,     0x54fff3c3,     0x54007423,\n+    0x54000004,     0x54fff364,     0x540073c4,     0x54000005,\n+    0x54fff305,     0x54007365,     0x54000006,     0x54fff2a6,\n+    0x54007306,     0x54000007,     0x54fff247,     0x540072a7,\n+    0x54000008,     0x54fff1e8,     0x54007248,     0x54000009,\n+    0x54fff189,     0x540071e9,     0x5400000a,     0x54fff12a,\n+    0x5400718a,     0x5400000b,     0x54fff0cb,     0x5400712b,\n+    0x5400000c,     0x54fff06c,     0x540070cc,     0x5400000d,\n+    0x54fff00d,     0x5400706d,     0x5400000e,     0x54ffefae,\n+    0x5400700e,     0x5400000f,     0x54ffef4f,     0x54006faf,\n@@ -1180,113 +1228,124 @@\n-    0xd44cad80,     0xd503201f,     0xd69f03e0,     0xd6bf03e0,\n-    0xd5033fdf,     0xd5033e9f,     0xd50332bf,     0xd61f0200,\n-    0xd63f0280,     0xc80a7d1b,     0xc800fea1,     0xc85f7fb1,\n-    0xc85fff9d,     0xc89ffee1,     0xc8dffe95,     0x88167e7b,\n-    0x880bfcd0,     0x885f7c11,     0x885ffd44,     0x889ffed8,\n-    0x88dffe6a,     0x48017fc5,     0x4808fe2c,     0x485f7dc9,\n-    0x485ffc27,     0x489ffe05,     0x48dffd82,     0x080a7c6c,\n-    0x081cff4e,     0x085f7d5e,     0x085ffeae,     0x089ffd2d,\n-    0x08dfff76,     0xc87f4d7c,     0xc87fcc5e,     0xc8220417,\n-    0xc82cb5f0,     0x887f55b1,     0x887ff90b,     0x88382c2d,\n-    0x883aedb5,     0xf819928b,     0xb803e21c,     0x381f713b,\n-    0x781ce322,     0xf850f044,     0xb85e129e,     0x385e92f1,\n-    0x785ff35d,     0x39801921,     0x7881318b,     0x78dce02b,\n-    0xb8829313,     0xfc45f318,     0xbc5d50af,     0xfc001375,\n-    0xbc1951b7,     0xf8008c0a,     0xb801dc03,     0x38009dca,\n-    0x781fdf3d,     0xf8570e0c,     0xb85faecc,     0x385f6d6d,\n-    0x785ebea0,     0x38804cd7,     0x789cbce3,     0x78df9c9c,\n-    0xb89eed18,     0xfc40cd6e,     0xbc5bdd93,     0xfc103c14,\n-    0xbc040c08,     0xf81a2783,     0xb81ca4eb,     0x381e855b,\n-    0x7801b4e6,     0xf853654d,     0xb85d74af,     0x384095a2,\n-    0x785ec5bc,     0x389e15a9,     0x789dc703,     0x78c06474,\n-    0xb89ff667,     0xfc57e51e,     0xbc4155f9,     0xfc05a6ee,\n-    0xbc1df408,     0xf835da2a,     0xb836d9a4,     0x3833580d,\n-    0x7826cb6c,     0xf8706900,     0xb87ae880,     0x3865db2e,\n-    0x78714889,     0x38a7789b,     0x78beca2f,     0x78f6c810,\n-    0xb8bef956,     0xfc6afabd,     0xbc734963,     0xfc3d5b8d,\n-    0xbc25fbb7,     0xf9189d05,     0xb91ecb1d,     0x39187a33,\n-    0x791f226d,     0xf95aa2f3,     0xb9587bb7,     0x395f7176,\n-    0x795d9143,     0x399e7e08,     0x799a2697,     0x79df3422,\n-    0xb99c2624,     0xfd5c2374,     0xbd5fa1d9,     0xfd1d595a,\n-    0xbd1b1869,     0x58005a7b,     0x1800000b,     0xf8945060,\n-    0xd8000000,     0xf8ae6ba0,     0xf99a0080,     0x1a070035,\n-    0x3a0700a8,     0x5a0e0367,     0x7a11009b,     0x9a000380,\n-    0xba1e030c,     0xda0f0320,     0xfa030301,     0x0b340b11,\n-    0x2b2a278d,     0xcb22aa0f,     0x6b2d29bd,     0x8b2cce8c,\n-    0xab2b877e,     0xcb21c8ee,     0xeb3ba47d,     0x3a4d400e,\n-    0x7a5132c6,     0xba5e622e,     0xfa53814c,     0x3a52d8c2,\n-    0x7a4d8924,     0xba4b3aab,     0xfa4d7882,     0x1a96804c,\n-    0x1a912618,     0x5a90b0e6,     0x5a96976b,     0x9a9db06a,\n-    0x9a9b374c,     0xda95c14f,     0xda89c6fe,     0x5ac0015e,\n-    0x5ac005fd,     0x5ac00bdd,     0x5ac012b9,     0x5ac01404,\n-    0xdac002b1,     0xdac0061d,     0xdac00a95,     0xdac00e66,\n-    0xdac0107e,     0xdac01675,     0x1ac00b0b,     0x1ace0f3b,\n-    0x1ad121c3,     0x1ad825e7,     0x1ad92a3c,     0x1adc2f42,\n-    0x9ada0b25,     0x9ad10e1b,     0x9acc22a6,     0x9acc2480,\n-    0x9adc2a3b,     0x9ad12c5c,     0x9bce7dea,     0x9b597c6e,\n-    0x1b0e166f,     0x1b1ae490,     0x9b023044,     0x9b089e3d,\n-    0x9b391083,     0x9b24c73a,     0x9bb15f40,     0x9bbcc6af,\n-    0x7ea3d55b,     0x1e3908e0,     0x1e2f18c9,     0x1e2a29fd,\n-    0x1e273a22,     0x7ef7d56b,     0x1e770ba7,     0x1e6b1b6e,\n-    0x1e78288b,     0x1e6e39ec,     0x1f1c3574,     0x1f17f98b,\n-    0x1f2935da,     0x1f2574ea,     0x1f4b306f,     0x1f5ec7cf,\n-    0x1f6f3e93,     0x1f6226a9,     0x1e2040fb,     0x1e20c3dd,\n-    0x1e214031,     0x1e21c0c2,     0x1e22c06a,     0x1e604178,\n-    0x1e60c027,     0x1e61400b,     0x1e61c223,     0x1e6240dc,\n-    0x1e3800d6,     0x9e380360,     0x1e78005a,     0x9e7800e5,\n-    0x1e22017c,     0x9e2201b9,     0x1e6202eb,     0x9e620113,\n-    0x1e2602b1,     0x9e660299,     0x1e270233,     0x9e6703a2,\n-    0x1e2822c0,     0x1e7322a0,     0x1e202288,     0x1e602168,\n-    0x293c19f4,     0x2966387b,     0x69762970,     0xa9041dc7,\n-    0xa9475c0c,     0x29b61ccd,     0x29ee3c5e,     0x69ee0764,\n-    0xa9843977,     0xa9f46ebd,     0x28ba16b6,     0x28fc44db,\n-    0x68f61430,     0xa8b352cd,     0xa8c56d5e,     0x28024565,\n-    0x2874134e,     0xa8027597,     0xa87b1aa0,     0x0c40734f,\n-    0x4cdfa177,     0x0cc76ee8,     0x4cdf2733,     0x0d40c23d,\n-    0x4ddfcaf8,     0x0dd9ccaa,     0x4c408d51,     0x0cdf85ec,\n-    0x4d60c239,     0x0dffcbc1,     0x4de9ce30,     0x4cc24999,\n-    0x0c404a7a,     0x4d40e6af,     0x4ddfe9b9,     0x0dddef8e,\n-    0x4cdf07b1,     0x0cc000fb,     0x0d60e238,     0x0dffe740,\n-    0x0de2eb2c,     0x0e31baf6,     0x4e31bb9b,     0x0e71b8a4,\n-    0x4e71b907,     0x4eb1b8e6,     0x0e30a841,     0x4e30ab7a,\n-    0x0e70aa0f,     0x4e70a862,     0x4eb0a9cd,     0x6e30f9cd,\n-    0x0e31ab38,     0x2e31ab17,     0x4e31a8a4,     0x6e31aa93,\n-    0x0e71aa0f,     0x2e71a820,     0x4e71a8a4,     0x6e71aab4,\n-    0x4eb1a98b,     0x6eb1abdd,     0x6eb0fa0f,     0x7e30fad5,\n-    0x7e70f8a4,     0x7eb0f9ee,     0x7ef0faf6,     0x0e20bb59,\n-    0x4e20b8e6,     0x0e60b9ac,     0x4e60b9ee,     0x0ea0b9cd,\n-    0x4ea0b9ee,     0x4ee0b949,     0x0ea0fb59,     0x4ea0fbbc,\n-    0x4ee0f96a,     0x2ea0fa93,     0x6ea0f98b,     0x6ee0fa51,\n-    0x2ea1fad5,     0x6ea1fa0f,     0x6ee1fab4,     0x2e205b17,\n-    0x6e205b7a,     0x0e271cc5,     0x4e281ce6,     0x0eb11e0f,\n-    0x4eb11e0f,     0x2e3b1f59,     0x6e321e30,     0x0e3d879b,\n-    0x4e3a8738,     0x0e71860f,     0x4e7b8759,     0x0eb085ee,\n-    0x4eac856a,     0x4eef85cd,     0x0e30d5ee,     0x4e36d6b4,\n-    0x4e63d441,     0x2e3886f6,     0x6e2087fe,     0x2e7085ee,\n-    0x6e648462,     0x2ea884e6,     0x6ea58483,     0x6ee98507,\n-    0x0ebad738,     0x4ea2d420,     0x4efdd79b,     0x0e3f9fdd,\n-    0x4e279cc5,     0x0e679cc5,     0x4e7f9fdd,     0x0ead9d8b,\n-    0x4ebb9f59,     0x2ea2d420,     0x6ea0d7fe,     0x6ee2d420,\n-    0x2e33de51,     0x6e3edfbc,     0x6e7bdf59,     0x0e6b9549,\n-    0x4e7b9759,     0x0eae95ac,     0x4eb1960f,     0x0e2dcd8b,\n-    0x4e2ccd6a,     0x4e73ce51,     0x2e7a9738,     0x6e7796d5,\n-    0x2eb99717,     0x6ea29420,     0x0eb2ce30,     0x4eaccd6a,\n-    0x4ee8cce6,     0x2e3effbc,     0x6e28fce6,     0x6e67fcc5,\n-    0x0e2764c5,     0x4e3666b4,     0x0e736651,     0x4e71660f,\n-    0x0eb36651,     0x4ebf67dd,     0x0e3ca77a,     0x4e3ea7bc,\n-    0x0e63a441,     0x4e7da79b,     0x0ea2a420,     0x4eb6a6b4,\n-    0x0e3ef7bc,     0x4e31f60f,     0x4e6ef5ac,     0x0e2c6d6a,\n-    0x4e3e6fbc,     0x0e7e6fbc,     0x4e756e93,     0x0eb86ef6,\n-    0x4eac6d6a,     0x0e26aca4,     0x4e20affe,     0x0e76aeb4,\n-    0x4e6aad28,     0x0ea0affe,     0x4eb3ae51,     0x0eacf56a,\n-    0x4ebdf79b,     0x4ee4f462,     0x2e3a8f38,     0x6e268ca4,\n-    0x2e658c83,     0x6e6a8d28,     0x2eb88ef6,     0x6eb38e51,\n-    0x6eef8dcd,     0x0e26e4a4,     0x4e3ee7bc,     0x4e79e717,\n-    0x0e3736d5,     0x4e3b3759,     0x0e7a3738,     0x4e653483,\n-    0x0eb93717,     0x4ebc377a,     0x4ef93717,     0x2e3035ee,\n-    0x6e3736d5,     0x2e653483,     0x6e793717,     0x2eaa3528,\n-    0x6eba3738,     0x6ef53693,     0x2e313e0f,     0x6e323e30,\n-    0x2e643c62,     0x6e633c41,     0x2ea23c20,     0x6eba3f38,\n-    0x6ee63ca4,     0x2ea5e483,     0x6eade58b,     0x6ee0e7fe,\n-    0x0e3d3f9b,     0x4e2b3d49,     0x0e7b3f59,     0x4e643c62,\n-    0x0eae3dac,     0x4eb33e51,     0x4ee03ffe,     0x2e23e441,\n-    0x6e2ee5ac,     0x6e7ee7bc,     0xba5fd3e3,     0x3a5f03e5,\n+    0xd44cad80,     0xd503201f,     0xd503203f,     0xd503205f,\n+    0xd503209f,     0xd50320bf,     0xd503219f,     0xd50323bf,\n+    0xd503239f,     0xd50321df,     0xd50323ff,     0xd50323df,\n+    0xd503211f,     0xd503233f,     0xd503231f,     0xd503215f,\n+    0xd503237f,     0xd503235f,     0xd69f03e0,     0xd6bf03e0,\n+    0xd5033fdf,     0xd503207f,     0xd50320ff,     0xd5033e9f,\n+    0xd50332bf,     0xd61f0200,     0xd63f0280,     0xdac123ea,\n+    0xdac127fb,     0xdac12be8,     0xdac12fe0,     0xdac133e1,\n+    0xdac137f5,     0xdac13bf1,     0xdac13ffd,     0xdac147fd,\n+    0xd61f0b9f,     0xd61f0c3f,     0xd63f0aff,     0xd63f0ebf,\n+    0xdac143f4,     0xc8167e7b,     0xc80bfcd0,     0xc85f7c11,\n+    0xc85ffd44,     0xc89ffed8,     0xc8dffe6a,     0x88017fc5,\n+    0x8808fe2c,     0x885f7dc9,     0x885ffc27,     0x889ffe05,\n+    0x88dffd82,     0x480a7c6c,     0x481cff4e,     0x485f7d5e,\n+    0x485ffeae,     0x489ffd2d,     0x48dfff76,     0x081c7d73,\n+    0x081efc53,     0x085f7ee2,     0x085ffc01,     0x089ffe0c,\n+    0x08dffded,     0xc87f55b1,     0xc87ff90b,     0xc8382c2d,\n+    0xc83aedb5,     0x887f0d94,     0x887f87a6,     0x88262e04,\n+    0x8824b2be,     0xf8061366,     0xb802d151,     0x381e32da,\n+    0x781ce155,     0xf847d30e,     0xb85f0307,     0x39403448,\n+    0x785c333e,     0x389f2183,     0x789e422a,     0x78dfb075,\n+    0xb8817322,     0xfc5bb039,     0xbc40637d,     0xfc02919d,\n+    0xbc18d2c2,     0xf8003cba,     0xb8199cb4,     0x381e7d88,\n+    0x781c7c54,     0xf8516fae,     0xb8404fad,     0x385f7e78,\n+    0x785edf63,     0x389fbc31,     0x789f3e71,     0x78de6d75,\n+    0xb89c4d21,     0xfc509efa,     0xbc581eb6,     0xfc128ced,\n+    0xbc198dac,     0xf81134b4,     0xb81b679d,     0x381ea704,\n+    0x781eb52d,     0xf85c94fa,     0xb858d46d,     0x3840c4a1,\n+    0x785de5a8,     0x389e5697,     0x789fe4d4,     0x78dd6629,\n+    0xb89e24d5,     0xfc5e36d0,     0xbc5fd569,     0xfc03c756,\n+    0xbc1fe7b0,     0xf824cac1,     0xb82d7bd7,     0x382c596c,\n+    0x78207999,     0xf86058f1,     0xb86e5a61,     0x3869784c,\n+    0x787bc936,     0x38aff995,     0x78b078dc,     0x78f6ca39,\n+    0xb8bdea24,     0xfc63f825,     0xbc6d5a38,     0xfc37fa31,\n+    0xbc25dbd1,     0xf91ba97d,     0xb91e4abc,     0x391b485c,\n+    0x7919c380,     0xf95e18f9,     0xb958a860,     0x395f20be,\n+    0x7958f6ee,     0x399bea6a,     0x799b363d,     0x79da47d9,\n+    0xb99d5851,     0xfd5da60f,     0xbd584fcc,     0xfd1db821,\n+    0xbd1e9965,     0x58ffdb71,     0x18ffdb42,     0xf886f320,\n+    0xd8ffdb00,     0xf8bb49c0,     0xf99815c0,     0x1a0f0320,\n+    0x3a030301,     0x5a140311,     0x7a0d000b,     0x9a07015c,\n+    0xba1001e4,     0xda140182,     0xfa0d01bd,     0x0b2c6cce,\n+    0x2b3e5331,     0xcb2e0620,     0x6b3de709,     0x8b20cac1,\n+    0xab362f8c,     0xcb31518a,     0xeb2acf8f,     0x3a57d262,\n+    0x7a493226,     0xba4832a2,     0xfa454261,     0x3a518acc,\n+    0x7a472a23,     0xba5cba05,     0xfa439ac5,     0x1a8cb35d,\n+    0x1a8f355b,     0x5a9e9395,     0x5a9e3769,     0x9a9dd1fd,\n+    0x9a8406b9,     0xda9d62b1,     0xda868695,     0x5ac0007e,\n+    0x5ac00675,     0x5ac00b0b,     0x5ac01360,     0x5ac015d9,\n+    0xdac001c3,     0xdac004f1,     0xdac00b0f,     0xdac00e3c,\n+    0xdac01059,     0xdac0179a,     0xdac10325,     0xdac1077a,\n+    0xdac10a30,     0xdac10ea6,     0xdac1100c,     0xdac11584,\n+    0xdac11a3b,     0xdac11f9c,     0xd71f0851,     0xd71f0d4f,\n+    0xd73f09ce,     0xd73f0c79,     0x1ace0a6f,     0x1ac40e05,\n+    0x1ac4233a,     0x1acc2442,     0x1ac82a3d,     0x1ac42c67,\n+    0x9ada0899,     0x9ad10c99,     0x9ad12340,     0x9ad525f7,\n+    0x9adb2a3c,     0x9ac02c6a,     0x9bc97f27,     0x9b5d7de6,\n+    0x1b02454f,     0x1b0bdd67,     0x9b173ba7,     0x9b0b917b,\n+    0x9b2f3998,     0x9b3cb574,     0x9bb7798b,     0x9ba9b5da,\n+    0x7ea5d4ea,     0x1e2309fd,     0x1e2f198b,     0x1e312bde,\n+    0x1e2f3a93,     0x7ef5d52f,     0x1e7b0922,     0x1e7e1ba7,\n+    0x1e622831,     0x1e633946,     0x1f070578,     0x1f03c40b,\n+    0x1f3618dc,     0x1f3a0b60,     0x1f5c2ce5,     0x1f4bddb9,\n+    0x1f715513,     0x1f734699,     0x1e2043a2,     0x1e20c116,\n+    0x1e214275,     0x1e21c174,     0x1e22c291,     0x1e6041e6,\n+    0x1e60c063,     0x1e61407c,     0x1e61c1db,     0x1e62414e,\n+    0x1e38016c,     0x9e380151,     0x1e7800f9,     0x9e7801c7,\n+    0x1e22001c,     0x9e220016,     0x1e6202ec,     0x9e6201ad,\n+    0x1e2601c7,     0x9e660107,     0x1e270234,     0x9e6703dc,\n+    0x1e222200,     0x1e702120,     0x1e202288,     0x1e6023a8,\n+    0x29266b01,     0x29462d85,     0x69463f75,     0xa90272c5,\n+    0xa97e467b,     0x29aa1f4d,     0x29fa54cd,     0x69c27b74,\n+    0xa9b81555,     0xa9fa12ee,     0x2884321d,     0x28cc477a,\n+    0x68f451c4,     0xa8b909d0,     0xa8f060f7,     0x281069e0,\n+    0x2866191a,     0xa8392b2f,     0xa8760670,     0x0c4073db,\n+    0x4cdfa079,     0x0cca6e1e,     0x4cdf2670,     0x0d40c317,\n+    0x4ddfc948,     0x0dd7ce89,     0x4c408c62,     0x0cdf87c8,\n+    0x4d60c344,     0x0dffca23,     0x4df0cd7d,     0x4cd74801,\n+    0x0c404aa0,     0x4d40e4e5,     0x4ddfe8e1,     0x0dcfeca2,\n+    0x4cdf07bb,     0x0cc70098,     0x0d60e2ef,     0x0dffe6ae,\n+    0x0df9e934,     0x0e31bb17,     0x4e31bb7a,     0x0e71b8c5,\n+    0x4e71b8e6,     0x4eb1ba0f,     0x0e30aa0f,     0x4e30ab59,\n+    0x0e70aa30,     0x4e70ab9b,     0x4eb0ab38,     0x6e30fa0f,\n+    0x0e31ab59,     0x2e31a9ee,     0x4e31a96a,     0x6e31a9cd,\n+    0x0e71a9ee,     0x2e71aab4,     0x4e71a841,     0x6e71aaf6,\n+    0x4eb1abfe,     0x6eb1a9ee,     0x6eb0f862,     0x7e30f8e6,\n+    0x7e70f883,     0x7eb0f907,     0x7ef0fb38,     0x0e20b820,\n+    0x4e20bb9b,     0x0e60bbdd,     0x4e60b8c5,     0x0ea0b8c5,\n+    0x4ea0bbdd,     0x4ee0b98b,     0x0ea0fb59,     0x4ea0f820,\n+    0x4ee0fbfe,     0x2ea0f820,     0x6ea0fa51,     0x6ee0fbbc,\n+    0x2ea1fb59,     0x6ea1f949,     0x6ee1fb59,     0x2e2059ac,\n+    0x6e205a0f,     0x0e2d1d8b,     0x4e2c1d6a,     0x0eb31e51,\n+    0x4eba1f38,     0x2e371ed5,     0x6e391f17,     0x0e228420,\n+    0x4e328630,     0x0e6c856a,     0x4e6884e6,     0x0ebe87bc,\n+    0x4ea884e6,     0x4ee784c5,     0x0e27d4c5,     0x4e36d6b4,\n+    0x4e73d651,     0x2e31860f,     0x6e338651,     0x2e7f87dd,\n+    0x6e7c877a,     0x2ebe87bc,     0x6ea38441,     0x6efd879b,\n+    0x0ea2d420,     0x4eb6d6b4,     0x4efed7bc,     0x0e319e0f,\n+    0x4e2e9dac,     0x0e6c9d6a,     0x4e7e9fbc,     0x0ebe9fbc,\n+    0x4eb59e93,     0x2eb8d6f6,     0x6eacd56a,     0x6ee6d4a4,\n+    0x2e20dffe,     0x6e36deb4,     0x6e6add28,     0x0e6097fe,\n+    0x4e739651,     0x0eac956a,     0x4ebd979b,     0x0e24cc62,\n+    0x4e3acf38,     0x4e66cca4,     0x2e659483,     0x6e6a9528,\n+    0x2eb896f6,     0x6eb39651,     0x0eafcdcd,     0x4ea6cca4,\n+    0x4efecfbc,     0x2e39ff17,     0x6e37fed5,     0x6e7bff59,\n+    0x0e3a6738,     0x4e256483,     0x0e796717,     0x4e7c677a,\n+    0x0eb96717,     0x4eb065ee,     0x0e37a6d5,     0x4e25a483,\n+    0x0e79a717,     0x4e6aa528,     0x0ebaa738,     0x4eb5a693,\n+    0x0e31f60f,     0x4e32f630,     0x4e64f462,     0x0e236c41,\n+    0x4e226c20,     0x0e7a6f38,     0x4e666ca4,     0x0ea56c83,\n+    0x4ead6d8b,     0x0e20affe,     0x4e3daf9b,     0x0e6bad49,\n+    0x4e7baf59,     0x0ea4ac62,     0x4eaeadac,     0x0eb3f651,\n+    0x4ea0f7fe,     0x4ee3f441,     0x2e2e8dac,     0x6e3e8fbc,\n+    0x2e628c20,     0x6e738e51,     0x2eae8dac,     0x6eb38e51,\n+    0x6ef78ed5,     0x0e2ee5ac,     0x4e3de79b,     0x4e7fe7dd,\n+    0x0e2037fe,     0x4e233441,     0x0e7b3759,     0x4e7d379b,\n+    0x0ea634a4,     0x4ebf37dd,     0x4ee53483,     0x2e2834e6,\n+    0x6e3f37dd,     0x2e7b3759,     0x6e733651,     0x2eaa3528,\n+    0x6ea93507,     0x6eee35ac,     0x2e223c20,     0x6e353e93,\n+    0x2e633c41,     0x6e793f17,     0x2ea43c62,     0x6ea23c20,\n+    0x6eea3d28,     0x2eb9e717,     0x6ebbe759,     0x6ef1e60f,\n+    0x0e3f3fdd,     0x4e253c83,     0x0e6c3d6a,     0x4e783ef6,\n+    0x0eac3d6a,     0x4ea63ca4,     0x4ef33e51,     0x2e23e441,\n+    0x6e2de58b,     0x6e69e507,     0xba5fd3e3,     0x3a5f03e5,\n@@ -1349,42 +1408,42 @@\n-    0x1e7e3000,     0xf8208193,     0xf83101b6,     0xf83c13fe,\n-    0xf821239a,     0xf824309e,     0xf826535e,     0xf8304109,\n-    0xf82c7280,     0xf8216058,     0xf8a08309,     0xf8ba03d0,\n-    0xf8a312ea,     0xf8aa21e4,     0xf8a2310b,     0xf8aa522f,\n-    0xf8a2418a,     0xf8ac71af,     0xf8a26287,     0xf8fa8090,\n-    0xf8e20184,     0xf8f01215,     0xf8f022ab,     0xf8f7334c,\n-    0xf8f751dc,     0xf8eb4038,     0xf8ec715f,     0xf8f06047,\n-    0xf863826d,     0xf8710070,     0xf86113cb,     0xf86521e8,\n-    0xf87d301e,     0xf8745287,     0xf87742bc,     0xf87b70b9,\n-    0xf8616217,     0xb83f8185,     0xb82901fc,     0xb83d13f6,\n-    0xb83320bf,     0xb82e33f0,     0xb830529b,     0xb830416c,\n-    0xb82973c6,     0xb831639b,     0xb8be8147,     0xb8b4008a,\n-    0xb8b81231,     0xb8b623a3,     0xb8af3276,     0xb8b35056,\n-    0xb8af4186,     0xb8b071ab,     0xb8b763c1,     0xb8f38225,\n-    0xb8e202d0,     0xb8ed12aa,     0xb8fd219b,     0xb8fb3023,\n-    0xb8ff5278,     0xb8f14389,     0xb8fb70ef,     0xb8f563f7,\n-    0xb87983e2,     0xb87b0150,     0xb8771073,     0xb8702320,\n-    0xb87a3057,     0xb870508c,     0xb87c43be,     0xb87070db,\n-    0xb86961fd,     0xce273c87,     0xce080ac9,     0xce7e8e9b,\n-    0xce808b45,     0xce79806e,     0xce758768,     0xcec0835a,\n-    0xce608ad8,     0x2520d264,     0x2521cf80,     0x058074c1,\n-    0x054242c9,     0x05004476,     0x25a0df08,     0x25a1c206,\n-    0x0583288b,     0x05401c3a,     0x05027e8d,     0x2520ce05,\n-    0x25a1cb0a,     0x0580989a,     0x0540e096,     0x0500fb73,\n-    0x2560c2ce,     0x2521d590,     0x05803e97,     0x05400d31,\n-    0x05003ed0,     0x2520c623,     0x25a1cdd1,     0x058052ac,\n-    0x0540ba33,     0x05003ed7,     0x25a0c6cd,     0x2521cf00,\n-    0x0583c5b1,     0x05407336,     0x05001e62,     0x04e400f4,\n-    0x04a80407,     0x65c402d3,     0x65cb0ac9,     0x659007c5,\n-    0x0456ac36,     0x04c01608,     0x049a048f,     0x041087a8,\n-    0x04db13bc,     0x0459ac49,     0x041aa0fc,     0x0459163a,\n-    0x04d392a8,     0x049196a5,     0x049013b6,     0x0497a093,\n-    0x041ea677,     0x04181a77,     0x05e789c8,     0x04081eb1,\n-    0x048a015e,     0x0401012c,     0x04dcb098,     0x65c08b66,\n-    0x65cd93cd,     0x65c697d6,     0x65878e69,     0x65829d34,\n-    0x049dae6d,     0x6582aa78,     0x6580b211,     0x6581a160,\n-    0x658dadef,     0x65819caf,     0x65a3974a,     0x65ea1389,\n-    0x65f734e3,     0x65ba554d,     0x65ae7e31,     0x041452bd,\n-    0x049a6033,     0x04313209,     0x04a23080,     0x046b30ce,\n-    0x04fd320e,     0x05766863,     0x053b6f03,     0x04da34f3,\n-    0x04582cb5,     0x049926b9,     0x04482071,     0x044a2cf3,\n-    0x6587322e,     0x65c63a2d,     0x659829f1,     0x0481377a,\n+    0x1e7e3000,     0xf82a822f,     0xf822018a,     0xf82c11af,\n+    0xf8222287,     0xf83a3090,     0xf8225184,     0xf8304215,\n+    0xf83072ab,     0xf837634c,     0xf8b781dc,     0xf8ab0038,\n+    0xf8ac115f,     0xf8b02047,     0xf8a3326d,     0xf8b15070,\n+    0xf8a143cb,     0xf8a571e8,     0xf8bd601e,     0xf8f48287,\n+    0xf8f702bc,     0xf8fb10b9,     0xf8e12217,     0xf8ff3185,\n+    0xf8e951fc,     0xf8fd43f6,     0xf8f370bf,     0xf8ee63f0,\n+    0xf870829b,     0xf870016c,     0xf86913c6,     0xf871239b,\n+    0xf87e3147,     0xf874508a,     0xf8784231,     0xf87673a3,\n+    0xf86f6276,     0xb8338056,     0xb82f0186,     0xb83011ab,\n+    0xb83723c1,     0xb8333225,     0xb82252d0,     0xb82d42aa,\n+    0xb83d719b,     0xb83b6023,     0xb8bf8278,     0xb8b10389,\n+    0xb8bb10ef,     0xb8b523f7,     0xb8b933e2,     0xb8bb5150,\n+    0xb8b74073,     0xb8b07320,     0xb8ba6057,     0xb8f0808c,\n+    0xb8fc03be,     0xb8f010db,     0xb8e921fd,     0xb8e730e4,\n+    0xb8ef52e9,     0xb8e84382,     0xb8f570bf,     0xb8fb6220,\n+    0xb86f8344,     0xb86802dc,     0xb87b133b,     0xb8772080,\n+    0xb8663010,     0xb864502f,     0xb86a40a7,     0xb86a70fc,\n+    0xb87462b7,     0xce284145,     0xce1108de,     0xce7c8fab,\n+    0xce96eb42,     0xce7b81ae,     0xce6586f0,     0xcec081a2,\n+    0xce6a89ea,     0x25a0cc5a,     0x25a1d143,     0x05800e44,\n+    0x05406531,     0x05002d42,     0x2520c677,     0x25a1cd07,\n+    0x0580687b,     0x0543bb42,     0x050044a6,     0x25a0c86c,\n+    0x25a1d358,     0x05800500,     0x05400ad3,     0x05000e06,\n+    0x25e0c951,     0x25a1d54a,     0x05839276,     0x0540ea6f,\n+    0x0503c8a4,     0x25a0d448,     0x2521d056,     0x058059c9,\n+    0x05406d05,     0x05003cb6,     0x25a0d0c8,     0x2561c4f9,\n+    0x05809904,     0x05400e5d,     0x0500cadd,     0x043c0162,\n+    0x04ba0427,     0x65c801d1,     0x65c50b15,     0x65d60635,\n+    0x0416b67d,     0x040012e4,     0x04da06f3,     0x04508113,\n+    0x04db1a2e,     0x0419a7d5,     0x041ab58a,     0x04990709,\n+    0x045398c4,     0x049199bb,     0x049016de,     0x0457bd3e,\n+    0x04dea693,     0x045809a9,     0x05678313,     0x04880e33,\n+    0x040a0410,     0x044109eb,     0x04dca5ef,     0x65c08145,\n+    0x658d801a,     0x65c69d53,     0x65c794e3,     0x65828ebc,\n+    0x04ddae3a,     0x65c2ac51,     0x6580b690,     0x65c1a033,\n+    0x65cdaa11,     0x65818095,     0x65eb8cd7,     0x65ac13ae,\n+    0x65e33523,     0x65b6427b,     0x65a575b9,     0x049146b9,\n+    0x04536120,     0x042e3167,     0x04ad3171,     0x047133d1,\n+    0x04fa31cf,     0x05676adb,     0x057b6f65,     0x049a2f00,\n+    0x04982074,     0x04d92739,     0x04483031,     0x040a3dae,\n+    0x65c723d1,     0x658637b6,     0x65982008,     0x04813417,\n@@ -1394,0 +1453,1 @@\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":837,"deletions":777,"binary":false,"changes":1614,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-class G1CountCardsOccupied : public G1CardSet::CardSetPtrClosure {\n+class G1CountCardsOccupied : public G1CardSet::ContainerPtrClosure {\n@@ -174,1 +174,1 @@\n-  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+  void do_containerptr(uint region_idx, size_t num_occupied, G1CardSet::ContainerPtr container) override {\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  G1CardSet::CardSetPtr value = G1CardSetInlinePtr();\n+  G1CardSet::ContainerPtr value = G1CardSetInlinePtr();\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSetContainers.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    return allocator->try_transfer_pending();\n+    return allocator->flush_free_list();\n@@ -74,7 +74,0 @@\n-  for (size_t i = 0; i < node_count; ++i) {\n-    if (i == 0) {\n-      ASSERT_EQ((BufferNode*)NULL, nodes[i]->next());\n-    } else {\n-      ASSERT_EQ(nodes[i - 1], nodes[i]->next());\n-    }\n-  }\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_ptrQueueBufferAllocator.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"oops\/method.hpp\"\n@@ -65,0 +68,18 @@\n+\n+#ifndef PRODUCT\n+\/\/ This class is friends with Method.\n+class MethodTest : public ::testing::Test{\n+ public:\n+  static void compare_names(Method* method, Symbol* name) {\n+    ASSERT_EQ(method->_name, name) << \"Method name field isn't set\";\n+  }\n+};\n+\n+TEST_VM(Method, method_name) {\n+  InstanceKlass* ik = vmClasses::Object_klass();\n+  Symbol* tostring = SymbolTable::new_symbol(\"toString\");\n+  Method* method = ik->find_method(tostring, vmSymbols::void_string_signature());\n+  ASSERT_TRUE(method != nullptr) << \"Object must have toString\";\n+  MethodTest::compare_names(method, tostring);\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/oops\/test_instanceKlass.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n@@ -44,0 +45,10 @@\n+\n+  static bool parse_argument(const char* name, const char* value) {\n+    char buf[1024];\n+    int ret = jio_snprintf(buf, sizeof(buf), \"%s=%s\", name, value);\n+    if (ret > 0) {\n+      return Arguments::parse_argument(buf, JVMFlagOrigin::COMMAND_LINE);\n+    } else {\n+      return false;\n+    }\n+  }\n@@ -204,0 +215,353 @@\n+\n+struct Dummy {};\n+static Dummy BAD;\n+\n+template <typename T>\n+struct NumericArgument {\n+  bool bad;\n+  const char* str;\n+  T expected_value;\n+\n+  NumericArgument(const char* s, T v) :           bad(false), str(s), expected_value(v) {}\n+  NumericArgument(const char* s, Dummy & dummy) : bad(true),  str(s), expected_value(0) {}\n+};\n+\n+static void check_invalid_numeric_string(JVMFlag* flag,  const char** invalid_strings) {\n+  for (uint i = 0; ; i++) {\n+    const char* str = invalid_strings[i];\n+    if (str == NULL) {\n+      return;\n+    }\n+    ASSERT_FALSE(ArgumentsTest::parse_argument(flag->name(), str))\n+        << \"Invalid string '\" << str\n+        << \"' parsed without error for type \" << flag->type_string() << \".\";\n+  }\n+}\n+\n+template <typename T>\n+void check_numeric_flag(JVMFlag* flag, T getvalue(JVMFlag* flag),\n+                        NumericArgument<T>* valid_args, size_t n,\n+                        bool is_double = false) {\n+  for (size_t i = 0; i < n; i++) {\n+    NumericArgument<T>* info = &valid_args[i];\n+    const char* str = info->str;\n+    if (info->bad) {\n+      ASSERT_FALSE(ArgumentsTest::parse_argument(flag->name(), str))\n+        << \"Invalid string '\" << str\n+        << \"' parsed without error for type \" << flag->type_string() << \".\";\n+    } else {\n+      ASSERT_TRUE(ArgumentsTest::parse_argument(flag->name(), str))\n+        << \"Valid string '\" <<\n+        str << \"' did not parse for type \" << flag->type_string() << \".\";\n+      ASSERT_EQ(getvalue(flag), info->expected_value)\n+        << \"Valid string '\" << str\n+        << \"' did not parse to the correct value for type \"\n+        << flag->type_string() << \".\";\n+    }\n+  }\n+\n+  {\n+    \/\/ Invalid strings for *any* type of integer VM arguments\n+    const char* invalid_strings[] = {\n+      \"\", \" 1\", \"2 \", \"3 2\",\n+      \"0x\", \"0x0x1\" \"e\"\n+      \"K\", \"M\", \"G\", \"1MB\", \"1KM\", \"AA\", \"0B\",\n+      \"18446744073709551615K\", \"17179869184G\",\n+      \"999999999999999999999999999999\",\n+      \"0x10000000000000000\", \"18446744073709551616\",\n+      \"-0x10000000000000000\", \"-18446744073709551616\",\n+      \"-0x8000000000000001\", \"-9223372036854775809\",\n+      \"0x8000000t\", \"0x800000000g\",\n+      \"0x800000000000m\", \"0x800000000000000k\",\n+      \"-0x8000000t\", \"-0x800000000g\",\n+      \"-0x800000000000m\", \"-0x800000000000000k\",\n+      NULL,\n+    };\n+    check_invalid_numeric_string(flag, invalid_strings);\n+  }\n+\n+  if (!is_double) {\n+    const char* invalid_strings_for_integers[] = {\n+      \"1.0\", \"0x4.5\", \"0.001\", \"4e10\",\n+      NULL,\n+    };\n+    check_invalid_numeric_string(flag, invalid_strings_for_integers);\n+  }\n+}\n+\n+#define INTEGER_TEST_TABLE(f) \\\n+  \/*input                      i32           u32           i64                      u64 *\/ \\\n+  f(\"0\",                       0,            0,            0,                       0                        ) \\\n+  f(\"-0\",                      0,            BAD,          0,                       BAD                      ) \\\n+  f(\"-1\",                     -1,            BAD,         -1,                       BAD                      ) \\\n+  f(\"0x1\",                     1,            1,            1,                       1                        ) \\\n+  f(\"-0x1\",                   -1,            BAD,         -1,                       BAD                      ) \\\n+  f(\"4711\",                    4711,         4711,         4711,                    4711                     ) \\\n+  f(\"1K\",                      1024,         1024,         1024,                    1024                     ) \\\n+  f(\"1k\",                      1024,         1024,         1024,                    1024                     ) \\\n+  f(\"2M\",                      2097152,      2097152,      2097152,                 2097152                  ) \\\n+  f(\"2m\",                      2097152,      2097152,      2097152,                 2097152                  ) \\\n+  f(\"1G\",                      1073741824,   1073741824,   1073741824,              1073741824               ) \\\n+  f(\"2G\",                      BAD,          0x80000000,   2147483648LL,            2147483648ULL            ) \\\n+  f(\"1T\",                      BAD,          BAD,          1099511627776LL,         1099511627776ULL         ) \\\n+  f(\"1t\",                      BAD,          BAD,          1099511627776LL,         1099511627776ULL         ) \\\n+  f(\"-1K\",                    -1024,         BAD,         -1024,                    BAD                      ) \\\n+  f(\"0x1K\",                    1024,         1024,         1024,                    1024                     ) \\\n+  f(\"-0x1K\",                  -1024,         BAD,         -1024,                    BAD                      ) \\\n+  f(\"0K\",                      0,            0,            0,                       0                        ) \\\n+  f(\"0x1000000k\",              BAD,          BAD,          17179869184LL,           17179869184ULL           ) \\\n+  f(\"0x800000m\",               BAD,          BAD,          0x80000000000LL,         0x80000000000ULL         ) \\\n+  f(\"0x8000g\",                 BAD,          BAD,          0x200000000000LL,        0x200000000000ULL        ) \\\n+  f(\"0x8000t\",                 BAD,          BAD,          0x80000000000000LL,      0x80000000000000ULL      ) \\\n+  f(\"-0x1000000k\",             BAD,          BAD,         -17179869184LL,           BAD                      ) \\\n+  f(\"-0x800000m\",              BAD,          BAD,         -0x80000000000LL,         BAD                      ) \\\n+  f(\"-0x8000g\",                BAD,          BAD,         -0x200000000000LL,        BAD                      ) \\\n+  f(\"-0x8000t\",                BAD,          BAD,         -0x80000000000000LL,      BAD                      ) \\\n+  f(\"0x7fffffff\",              0x7fffffff,   0x7fffffff,   0x7fffffff,              0x7fffffff               ) \\\n+  f(\"0xffffffff\",              BAD,          0xffffffff,   0xffffffff,              0xffffffff               ) \\\n+  f(\"0x80000000\",              BAD,          0x80000000,   0x80000000,              0x80000000               ) \\\n+  f(\"-0x7fffffff\",            -2147483647,   BAD,         -2147483647LL,            BAD                      ) \\\n+  f(\"-0x80000000\",            -2147483648,   BAD,         -2147483648LL,            BAD                      ) \\\n+  f(\"-0x80000001\",             BAD,          BAD,         -2147483649LL,            BAD                      ) \\\n+  f(\"0x100000000\",             BAD,          BAD,          0x100000000LL,           0x100000000ULL           ) \\\n+  f(\"0xcafebabe\",              BAD,          0xcafebabe,   0xcafebabe,              0xcafebabe               ) \\\n+  f(\"0XCAFEBABE\",              BAD,          0xcafebabe,   0xcafebabe,              0xcafebabe               ) \\\n+  f(\"0XCAFEbabe\",              BAD,          0xcafebabe,   0xcafebabe,              0xcafebabe               ) \\\n+  f(\"0xcafebabe1\",             BAD,          BAD,          0xcafebabe1,             0xcafebabe1              ) \\\n+  f(\"0x7fffffffffffffff\",      BAD,          BAD,          max_jlong,               9223372036854775807ULL   ) \\\n+  f(\"0x8000000000000000\",      BAD,          BAD,          BAD,                     9223372036854775808ULL   ) \\\n+  f(\"0xffffffffffffffff\",      BAD,          BAD,          BAD,                     max_julong               ) \\\n+  f(\"9223372036854775807\",     BAD,          BAD,          9223372036854775807LL,   9223372036854775807ULL   ) \\\n+  f(\"9223372036854775808\",     BAD,          BAD,          BAD,                     9223372036854775808ULL   ) \\\n+  f(\"-9223372036854775808\",    BAD,          BAD,          min_jlong,               BAD                      ) \\\n+  f(\"18446744073709551615\",    BAD,          BAD,          BAD,                     max_julong               ) \\\n+                                                                                                               \\\n+  \/* All edge cases without a k\/m\/g\/t suffix *\/                                                                \\\n+  f(\"0x7ffffffe\",              max_jint-1,   0x7ffffffe,   0x7ffffffeLL,            0x7ffffffeULL            ) \\\n+  f(\"0x7fffffff\",              max_jint,     0x7fffffff,   0x7fffffffLL,            0x7fffffffULL            ) \\\n+  f(\"0x80000000\",              BAD,          0x80000000,   0x80000000LL,            0x80000000ULL            ) \\\n+  f(\"0xfffffffe\",              BAD,          max_juint-1,  0xfffffffeLL,            0xfffffffeULL            ) \\\n+  f(\"0xffffffff\",              BAD,          max_juint,    0xffffffffLL,            0xffffffffULL            ) \\\n+  f(\"0x100000000\",             BAD,          BAD,          0x100000000LL,           0x100000000ULL           ) \\\n+  f(\"-0x7fffffff\",             min_jint+1,   BAD,         -0x7fffffffLL,            BAD                      ) \\\n+  f(\"-0x80000000\",             min_jint,     BAD,         -0x80000000LL,            BAD                      ) \\\n+  f(\"-0x80000001\",             BAD,          BAD,         -0x80000001LL,            BAD                      ) \\\n+                                                                                                               \\\n+  f(\"0x7ffffffffffffffe\",      BAD,          BAD,          max_jlong-1,             0x7ffffffffffffffeULL    ) \\\n+  f(\"0x7fffffffffffffff\",      BAD,          BAD,          max_jlong,               0x7fffffffffffffffULL    ) \\\n+  f(\"0x8000000000000000\",      BAD,          BAD,          BAD,                     0x8000000000000000ULL    ) \\\n+  f(\"0xfffffffffffffffe\",      BAD,          BAD,          BAD,                     max_julong-1             ) \\\n+  f(\"0xffffffffffffffff\",      BAD,          BAD,          BAD,                     max_julong               ) \\\n+  f(\"0x10000000000000000\",     BAD,          BAD,          BAD,                     BAD                      ) \\\n+  f(\"-0x7fffffffffffffff\",     BAD,          BAD,          min_jlong+1,             BAD                      ) \\\n+  f(\"-0x8000000000000000\",     BAD,          BAD,          min_jlong,               BAD                      ) \\\n+  f(\"-0x8000000000000001\",     BAD,          BAD,          BAD,                     BAD                      ) \\\n+                                                                                                               \\\n+  \/* edge cases for suffix: K *\/                                                                               \\\n+  f(\"0x1ffffek\",               0x1ffffe * k, 0x1ffffeU * k,0x1ffffeLL * k,          0x1ffffeULL * k          ) \\\n+  f(\"0x1fffffk\",               0x1fffff * k, 0x1fffffU * k,0x1fffffLL * k,          0x1fffffULL * k          ) \\\n+  f(\"0x200000k\",               BAD,          0x200000U * k,0x200000LL * k,          0x200000ULL * k          ) \\\n+  f(\"0x3ffffek\",               BAD,          0x3ffffeU * k,0x3ffffeLL * k,          0x3ffffeULL * k          ) \\\n+  f(\"0x3fffffk\",               BAD,          0x3fffffU * k,0x3fffffLL * k,          0x3fffffULL * k          ) \\\n+  f(\"0x400000k\",               BAD,          BAD,          0x400000LL * k,          0x400000ULL * k          ) \\\n+  f(\"-0x1fffffk\",             -0x1fffff * k, BAD,         -0x1fffffLL * k,          BAD                      ) \\\n+  f(\"-0x200000k\",             -0x200000 * k, BAD,         -0x200000LL * k,          BAD                      ) \\\n+  f(\"-0x200001k\",              BAD,          BAD,         -0x200001LL * k,          BAD                      ) \\\n+                                                                                                               \\\n+  f(\"0x1ffffffffffffek\",       BAD,          BAD,          0x1ffffffffffffeLL * k,  0x1ffffffffffffeULL * k  ) \\\n+  f(\"0x1fffffffffffffk\",       BAD,          BAD,          0x1fffffffffffffLL * k,  0x1fffffffffffffULL * k  ) \\\n+  f(\"0x20000000000000k\",       BAD,          BAD,          BAD,                     0x20000000000000ULL * k  ) \\\n+  f(\"0x3ffffffffffffek\",       BAD,          BAD,          BAD,                     0x3ffffffffffffeULL * k  ) \\\n+  f(\"0x3fffffffffffffk\",       BAD,          BAD,          BAD,                     0x3fffffffffffffULL * k  ) \\\n+  f(\"0x40000000000000k\",       BAD,          BAD,          BAD,                     BAD                      ) \\\n+  f(\"-0x1fffffffffffffk\",      BAD,          BAD,         -0x1fffffffffffffLL * k,  BAD                      ) \\\n+  f(\"-0x20000000000000k\",      BAD,          BAD,         -0x20000000000000LL * k,  BAD                      ) \\\n+  f(\"-0x20000000000001k\",      BAD,          BAD,          BAD,                     BAD                      ) \\\n+                                                                                                               \\\n+  \/* edge cases for suffix: M *\/                                                                               \\\n+  f(\"0x7fem\",                  0x7fe * m,    0x7feU * m,   0x7feLL * m,             0x7feULL * m             ) \\\n+  f(\"0x7ffm\",                  0x7ff * m,    0x7ffU * m,   0x7ffLL * m,             0x7ffULL * m             ) \\\n+  f(\"0x800m\",                  BAD,          0x800U * m,   0x800LL * m,             0x800ULL * m             ) \\\n+  f(\"0xffem\",                  BAD,          0xffeU * m,   0xffeLL * m,             0xffeULL * m             ) \\\n+  f(\"0xfffm\",                  BAD,          0xfffU * m,   0xfffLL * m,             0xfffULL * m             ) \\\n+  f(\"0x1000m\",                 BAD,          BAD,          0x1000LL * m,            0x1000ULL * m            ) \\\n+  f(\"-0x7ffm\",                -0x7ff * m,    BAD,         -0x7ffLL * m,             BAD                      ) \\\n+  f(\"-0x800m\",                -0x800 * m,    BAD,         -0x800LL * m,             BAD                      ) \\\n+  f(\"-0x801m\",                 BAD,          BAD,         -0x801LL * m,             BAD                      ) \\\n+                                                                                                               \\\n+  f(\"0x7fffffffffem\",          BAD,          BAD,          0x7fffffffffeLL * m,     0x7fffffffffeULL * m     ) \\\n+  f(\"0x7ffffffffffm\",          BAD,          BAD,          0x7ffffffffffLL * m,     0x7ffffffffffULL * m     ) \\\n+  f(\"0x80000000000m\",          BAD,          BAD,          BAD,                     0x80000000000ULL * m     ) \\\n+  f(\"0xffffffffffem\",          BAD,          BAD,          BAD,                     0xffffffffffeULL * m     ) \\\n+  f(\"0xfffffffffffm\",          BAD,          BAD,          BAD,                     0xfffffffffffULL * m     ) \\\n+  f(\"0x100000000000m\",         BAD,          BAD,          BAD,                     BAD                      ) \\\n+  f(\"-0x7ffffffffffm\",         BAD,          BAD,         -0x7ffffffffffLL * m,     BAD                      ) \\\n+  f(\"-0x80000000000m\",         BAD,          BAD,         -0x80000000000LL * m,     BAD                      ) \\\n+  f(\"-0x80000000001m\",         BAD,          BAD,          BAD,                     BAD                      ) \\\n+                                                                                                               \\\n+  \/* edge cases for suffix: G *\/                                                                               \\\n+  f(\"0x0g\",                    0x0 * g,      0x0U * g,     0x0LL * g,               0x0ULL * g               ) \\\n+  f(\"0x1g\",                    0x1 * g,      0x1U * g,     0x1LL * g,               0x1ULL * g               ) \\\n+  f(\"0x2g\",                    BAD,          0x2U * g,     0x2LL * g,               0x2ULL * g               ) \\\n+  f(\"0x3g\",                    BAD,          0x3U * g,     0x3LL * g,               0x3ULL * g               ) \\\n+  f(\"0x4g\",                    BAD,          BAD,          0x4LL * g,               0x4ULL * g               ) \\\n+  f(\"-0x1g\",                  -0x1 * g,      BAD,         -0x1LL * g,               BAD                      ) \\\n+  f(\"-0x2g\",                  -0x2 * g,      BAD,         -0x2LL * g,               BAD                      ) \\\n+  f(\"-0x3g\",                   BAD,          BAD,         -0x3LL * g,               BAD                      ) \\\n+                                                                                                               \\\n+  f(\"0x1fffffffeg\",            BAD,          BAD,          0x1fffffffeLL * g,       0x1fffffffeULL * g       ) \\\n+  f(\"0x1ffffffffg\",            BAD,          BAD,          0x1ffffffffLL * g,       0x1ffffffffULL * g       ) \\\n+  f(\"0x200000000g\",            BAD,          BAD,          BAD,                     0x200000000ULL * g       ) \\\n+  f(\"0x3fffffffeg\",            BAD,          BAD,          BAD,                     0x3fffffffeULL * g       ) \\\n+  f(\"0x3ffffffffg\",            BAD,          BAD,          BAD,                     0x3ffffffffULL * g       ) \\\n+  f(\"0x400000000g\",            BAD,          BAD,          BAD,                     BAD                      ) \\\n+  f(\"-0x1ffffffffg\",           BAD,          BAD,         -0x1ffffffffLL * g,       BAD                      ) \\\n+  f(\"-0x200000000g\",           BAD,          BAD,         -0x200000000LL * g,       BAD                      ) \\\n+  f(\"-0x200000001g\",           BAD,          BAD,          BAD,                     BAD                      ) \\\n+                                                                                                               \\\n+  \/* edge cases for suffix: T *\/                                                                               \\\n+  f(\"0x7ffffet\",               BAD,          BAD,          0x7ffffeLL * t,          0x7ffffeULL * t          ) \\\n+  f(\"0x7ffffft\",               BAD,          BAD,          0x7fffffLL * t,          0x7fffffULL * t          ) \\\n+  f(\"0x800000t\",               BAD,          BAD,          BAD,                     0x800000ULL * t          ) \\\n+  f(\"0xfffffet\",               BAD,          BAD,          BAD,                     0xfffffeULL * t          ) \\\n+  f(\"0xfffffft\",               BAD,          BAD,          BAD,                     0xffffffULL * t          ) \\\n+  f(\"0x1000000t\",              BAD,          BAD,          BAD,                     BAD                      ) \\\n+  f(\"-0x7ffffft\",              BAD,          BAD,         -0x7fffffLL * t,          BAD                      ) \\\n+  f(\"-0x800000t\",              BAD,          BAD,         -0x800000LL * t,          BAD                      ) \\\n+  f(\"-0x800001t\",              BAD,          BAD,          BAD,                     BAD                      )\n+\n+#define INTEGER_TEST_i32(s, i32, u32, i64, u64) NumericArgument<T>(s, i32),\n+#define INTEGER_TEST_u32(s, i32, u32, i64, u64) NumericArgument<T>(s, u32),\n+#define INTEGER_TEST_i64(s, i32, u32, i64, u64) NumericArgument<T>(s, i64),\n+#define INTEGER_TEST_u64(s, i32, u32, i64, u64) NumericArgument<T>(s, u64),\n+\n+\/\/ signed 32-bit\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)>\n+void check_flag(const char* f, T getvalue(JVMFlag* flag)) {\n+  JVMFlag* flag = JVMFlag::find_flag(f);\n+  if (flag == NULL) { \/\/ not available in product builds\n+    return;\n+  }\n+\n+  T k = static_cast<T>(K);\n+  T m = static_cast<T>(M);\n+  T g = static_cast<T>(G);\n+  NumericArgument<T> valid_strings[] = { INTEGER_TEST_TABLE(INTEGER_TEST_i32) };\n+  check_numeric_flag(flag, getvalue, valid_strings, ARRAY_SIZE(valid_strings));\n+}\n+\n+\/\/ unsigned 32-bit\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)>\n+void check_flag(const char* f, T getvalue(JVMFlag* flag)) {\n+  JVMFlag* flag = JVMFlag::find_flag(f);\n+  if (flag == NULL) { \/\/ not available in product builds\n+    return;\n+  }\n+\n+  T k = static_cast<T>(K);\n+  T m = static_cast<T>(M);\n+  T g = static_cast<T>(G);\n+  NumericArgument<T> valid_strings[] = { INTEGER_TEST_TABLE(INTEGER_TEST_u32) };\n+  check_numeric_flag(flag, getvalue, valid_strings, ARRAY_SIZE(valid_strings));\n+}\n+\n+\/\/ signed 64-bit\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)>\n+void check_flag(const char* f, T getvalue(JVMFlag* flag)) {\n+  JVMFlag* flag = JVMFlag::find_flag(f);\n+  if (flag == NULL) { \/\/ not available in product builds\n+    return;\n+  }\n+\n+  T k = static_cast<T>(K);\n+  T m = static_cast<T>(M);\n+  T g = static_cast<T>(G);\n+  T t = static_cast<T>(G) * k;\n+  NumericArgument<T> valid_strings[] = { INTEGER_TEST_TABLE(INTEGER_TEST_i64) };\n+  check_numeric_flag(flag, getvalue, valid_strings, ARRAY_SIZE(valid_strings));\n+}\n+\n+\/\/ unsigned 64-bit\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)>\n+void check_flag(const char* f, T getvalue(JVMFlag* flag)) {\n+  JVMFlag* flag = JVMFlag::find_flag(f);\n+  if (flag == NULL) { \/\/ not available in product builds\n+    return;\n+  }\n+\n+  T k = static_cast<T>(K);\n+  T m = static_cast<T>(M);\n+  T g = static_cast<T>(G);\n+  T t = static_cast<T>(G) * k;\n+  NumericArgument<T> valid_strings[] = { INTEGER_TEST_TABLE(INTEGER_TEST_u64) };\n+  check_numeric_flag(flag, getvalue, valid_strings, ARRAY_SIZE(valid_strings));\n+}\n+\n+\/\/ Testing the parsing of -XX:<SomeFlag>=<an integer value>\n+\/\/\n+\/\/ All of the integral types that can be used for command line options:\n+\/\/   int, uint, intx, uintx, uint64_t, size_t\n+\/\/\n+\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n+\/\/    {signed, unsigned} x {32-bit, 64-bit}\n+\/\/\n+\/\/ We use SFINAE to pick the correct column in the INTEGER_TEST_TABLE for each type.\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_int) {\n+  check_flag<int>(\"TestFlagFor_int\", [] (JVMFlag* flag) {\n+    return flag->get_int();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_uint) {\n+  check_flag<uint>(\"TestFlagFor_uint\", [] (JVMFlag* flag) {\n+    return flag->get_uint();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_intx) {\n+  check_flag<intx>(\"TestFlagFor_intx\", [] (JVMFlag* flag) {\n+    return flag->get_intx();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_uintx) {\n+  check_flag<uintx>(\"TestFlagFor_uintx\", [] (JVMFlag* flag) {\n+    return flag->get_uintx();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_uint64_t) {\n+  check_flag<uint64_t>(\"TestFlagFor_uint64_t\", [] (JVMFlag* flag) {\n+    return flag->get_uint64_t();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_size_t) {\n+  check_flag<size_t>(\"TestFlagFor_size_t\", [] (JVMFlag* flag) {\n+    return flag->get_size_t();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_double) {\n+  JVMFlag* flag = JVMFlag::find_flag(\"TestFlagFor_double\");\n+  if (flag == NULL) { \/\/ not available in product builds\n+    return;\n+  }\n+\n+  \/\/ TODO -- JDK-8282774\n+  \/\/ Need to add more test input that have a fractional part like \"4.2\".\n+  NumericArgument<double> valid_strings[] = {\n+    NumericArgument<double>(\"0\",   0.0),\n+    NumericArgument<double>(\"1\",   1.0),\n+    NumericArgument<double>(\"-0\", -0.0),\n+    NumericArgument<double>(\"-1\", -1.0),\n+  };\n+\n+  auto getvalue = [] (JVMFlag* flag) {\n+    return flag->get_double();\n+  };\n+\n+  check_numeric_flag<double>(flag, getvalue, valid_strings,\n+                             ARRAY_SIZE(valid_strings), \/*is_double=*\/true);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_arguments.cpp","additions":365,"deletions":1,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-static bool convert_to_cstring(char* c_str, size_t size, wchar_t* w_str) {\n+static bool convert_to_cstring(char* c_str, size_t size, const wchar_t* w_str) {\n@@ -310,1 +310,1 @@\n-static void check_file_not_present_impl(wchar_t* path) {\n+static void check_file_not_present_impl(const wchar_t* path) {\n@@ -364,1 +364,1 @@\n-static void check_file_not_present(wchar_t* path) {\n+static void check_file_not_present(const wchar_t* path) {\n@@ -458,1 +458,1 @@\n-static void print_attr_result_for_path(wchar_t* path) {\n+static void print_attr_result_for_path(const wchar_t* path) {\n@@ -479,1 +479,1 @@\n-static void print_attr_result(wchar_t* format, ...) {\n+static void print_attr_result(const wchar_t* format, ...) {\n@@ -516,4 +516,4 @@\n-  wchar_t* dir_prefix = L\"os_windows_long_paths_dir_\";\n-  wchar_t* empty_dir_name = L\"empty_directory_with_long_path\";\n-  wchar_t* not_empty_dir_name = L\"not_empty_directory_with_long_path\";\n-  wchar_t* file_name = L\"file\";\n+  const wchar_t* dir_prefix = L\"os_windows_long_paths_dir_\";\n+  const wchar_t* empty_dir_name = L\"empty_directory_with_long_path\";\n+  const wchar_t* not_empty_dir_name = L\"not_empty_directory_with_long_path\";\n+  const wchar_t* file_name = L\"file\";\n@@ -686,1 +686,1 @@\n-      wchar_t* other_letter = dir_letter == L'D' ? L\"C\" : L\"D\";\n+      const wchar_t* other_letter = dir_letter == L'D' ? L\"C\" : L\"D\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-runtime\/cds\/DeterministicDump.java 8253495 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+ -runtime\/cds\/appcds\/TestParallelGCWithCDS.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +30,1 @@\n+ * @requires vm.debug\n@@ -75,0 +77,7 @@\n+        for (int align = 256; align <= 1024; align *= 2) {\n+            shouldPass(\n+                \"-XX:+UnlockExperimentalVMOptions\",\n+                \"-XX:CodeCacheSegmentSize=\" + align,\n+                \"-XX:CodeEntryAlignment=\" + align\n+            );\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestCodeEntryAlignment.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n@@ -30,0 +31,1 @@\n+ * @requires vm.bits == 64\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6865031\/Test.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,250 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of AddINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.AddINodeIdealizationTests\n+ *\/\n+public class AddINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"additions\", \"xMinusX\", \"test1\",\n+                 \"test2\", \"test3\", \"test4\",\n+                 \"test5\", \"test6\", \"test7\",\n+                 \"test8\", \"test9\", \"test10\",\n+                 \"test11\", \"test12\", \"test13\",\n+                 \"test14\", \"test15\", \"test16\",\n+                 \"test17\", \"test18\", \"test19\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+        int c = RunInfo.getRandom().nextInt();\n+        int d = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, 0, 0);\n+        assertResult(a, b, c, d);\n+        assertResult(min, min, min, min);\n+        assertResult(max, max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, int c, int d) {\n+        Asserts.assertEQ(((a+a) + (a+a))  , additions(a));\n+        Asserts.assertEQ(0                , xMinusX(a));\n+        Asserts.assertEQ(a + 1 + 2        , test1(a));\n+        Asserts.assertEQ((a + 2021) + b   , test2(a, b));\n+        Asserts.assertEQ(a + (b + 2021)   , test3(a, b));\n+        Asserts.assertEQ((1 - a) + 2      , test4(a));\n+        Asserts.assertEQ((a - b) + (c - d), test5(a, b, c, d));\n+        Asserts.assertEQ((a - b) + (b + c), test6(a, b, c));\n+        Asserts.assertEQ((a - b) + (c + b), test7(a, b, c));\n+        Asserts.assertEQ((a - b) + (b - c), test8(a, b, c));\n+        Asserts.assertEQ((a - b) + (c - a), test9(a, b, c));\n+        Asserts.assertEQ(a + (0 - b)      , test10(a, b));\n+        Asserts.assertEQ((0 - b) + a      , test11(a, b));\n+        Asserts.assertEQ((a - b) + b      , test12(a, b));\n+        Asserts.assertEQ(b + (a - b)      , test13(a, b));\n+        Asserts.assertEQ(a + 0            , test14(a));\n+        Asserts.assertEQ(0 + a            , test15(a));\n+        Asserts.assertEQ(a*b + a*c        , test16(a, b, c));\n+        Asserts.assertEQ(a*b + b*c        , test17(a, b, c));\n+        Asserts.assertEQ(a*c + b*c        , test18(a, b, c));\n+        Asserts.assertEQ(a*b + c*a        , test19(a, b, c));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    public int additions(int x) {\n+        return (x + x) + (x + x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - x) + (x - x) => 0\n+    public int xMinusX(int x) {\n+        return (x - x) + (x - x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n+    public int test1(int x) {\n+        return (x + 1) + 2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + c1) + y => (x + y) + c1\n+    public int test2(int x, int y) {\n+        return (x + 2021) + y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks x + (y + c1) => (x + y) + c1\n+    public int test3(int x, int y) {\n+        return x + (y + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n+    public int test4(int x) {\n+        return (1 - x) + 2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"2\",\n+                 })\n+    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n+    public int test5(int a, int b, int c, int d) {\n+        return (a - b) + (c - d);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (b + c) => (a + c)\n+    public int test6(int a, int b, int c) {\n+        return (a - b) + (b + c);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (c + b) => (a + c)\n+    public int test7(int a, int b, int c) {\n+        return (a - b) + (c + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (b - c) => (a - c)\n+    public int test8(int a, int b, int c) {\n+        return (a - b) + (b - c);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (c - a) => (c - b)\n+    public int test9(int a, int b, int c) {\n+        return (a - b) + (c - a);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x + (0 - y) => (x - y)\n+    public int test10(int x, int y) {\n+        return x + (0 - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (0 - y) + x => (x - y)\n+    public int test11(int x, int y) {\n+        return (0 - y) + x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - y) + y => x\n+    public int test12(int x, int y) {\n+        return (x - y) + y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks y + (x - y) => x\n+    public int test13(int x, int y) {\n+        return y + (x - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Checks x + 0 => x\n+    public int test14(int x) {\n+        return x + 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Checks 0 + x => x\n+    public int test15(int x) {\n+        return 0 + x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks \"a*b + a*c => a*(b+c)\n+    public int test16(int a, int b, int c) {\n+        return a*b + a*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*b + b*c => b*(a+c)\n+    public int test17(int a, int b, int c) {\n+        return a*b + b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*c + b*c => (a+b)*c\n+    public int test18(int a, int b, int c) {\n+        return a*c + b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*b + c*a => a*(b+c)\n+    public int test19(int a, int b, int c) {\n+        return a*b + c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddINodeIdealizationTests.java","additions":250,"deletions":0,"binary":false,"changes":250,"status":"added"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of AddLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.AddLNodeIdealizationTests\n+ *\/\n+public class AddLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"additions\", \"xMinusX\", \"test1\",\n+                 \"test2\", \"test3\", \"test4\",\n+                 \"test5\", \"test6\", \"test7\",\n+                 \"test8\", \"test9\", \"test10\",\n+                 \"test11\", \"test12\", \"test13\",\n+                 \"test14\", \"test15\", \"test16\",\n+                 \"test17\", \"test18\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+        long c = RunInfo.getRandom().nextLong();\n+        long d = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, 0, 0);\n+        assertResult(a, b, c, d);\n+        assertResult(min, min, min, min);\n+        assertResult(max, max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, long c, long d) {\n+        Asserts.assertEQ(((a+a) + (a+a))  , additions(a));\n+        Asserts.assertEQ(0L               , xMinusX(a));\n+        Asserts.assertEQ(a + 1 + 2        , test1(a));\n+        Asserts.assertEQ((a + 2021) + b   , test2(a, b));\n+        Asserts.assertEQ(a + (b + 2021)   , test3(a, b));\n+        Asserts.assertEQ((1 - a) + 2      , test4(a));\n+        Asserts.assertEQ((a - b) + (c - d), test5(a, b, c, d));\n+        Asserts.assertEQ((a - b) + (b + c), test6(a, b, c));\n+        Asserts.assertEQ((a - b) + (c + b), test7(a, b, c));\n+        Asserts.assertEQ((a - b) + (c - a), test8(a, b, c));\n+        Asserts.assertEQ(a + (0 - b)      , test9(a, b));\n+        Asserts.assertEQ((0 - b) + a      , test10(a, b));\n+        Asserts.assertEQ((a - b) + b      , test11(a, b));\n+        Asserts.assertEQ(b + (a - b)      , test12(a, b));\n+        Asserts.assertEQ(a + 0            , test13(a));\n+        Asserts.assertEQ(0 + a            , test14(a));\n+        Asserts.assertEQ(a*b + a*c        , test15(a, b, c));\n+        Asserts.assertEQ(a*b + b*c        , test16(a, b, c));\n+        Asserts.assertEQ(a*c + b*c        , test17(a, b, c));\n+        Asserts.assertEQ(a*b + c*a        , test18(a, b, c));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + x) + (x + x) => a=(x + x); r=a+a\n+    public long additions(long x) {\n+        return (x + x) + (x + x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - x) => 0 and 0 - 0 => 0\n+    public long xMinusX(long x) {\n+        return (x - x) + (x - x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x + c1) + c2 => x + c3 where c3 = c1 + c2\n+    public long test1(long x) {\n+        return (x + 1) + 2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks (x + c1) + y => (x + y) + c1\n+    public long test2(long x, long y) {\n+        return (x + 2021) + y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"2\"})\n+    \/\/ Checks x + (y + c1) => (x + y) + c1\n+    public long test3(long x, long y) {\n+        return x + (y + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (c1 - x) + c2 => c3 - x where c3 = c1 + c2\n+    public long test4(long x) {\n+        return (1 - x) + 2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"2\",\n+                 })\n+    \/\/ Checks (a - b) + (c - d) => (a + c) - (b + d)\n+    public long test5(long a, long b, long c, long d) {\n+        return (a - b) + (c - d);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (b + c) => (a + c)\n+    public long test6(long a, long b, long c) {\n+        return (a - b) + (b + c);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (a - b) + (c + b) => (a + c)\n+    public long test7(long a, long b, long c) {\n+        return (a - b) + (c + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a - b) + (c - a) => (c - b)\n+    public long test8(long a, long b, long c) {\n+        return (a - b) + (c - a);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x + (0 - y) => (x - y)\n+    public long test9(long x, long y) {\n+        return x + (0 - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (0 - y) + x => (x - y)\n+    public long test10(long x, long y) {\n+        return (0 - y) + x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks (x - y) + y => x\n+    public long test11(long x, long y) {\n+        return (x - y) + y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.SUB})\n+    \/\/ Checks y + (x - y) => x\n+    public long test12(long x, long y) {\n+        return y + (x - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Checks x + 0 => x\n+    public long test13(long x) {\n+        return x + 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    \/\/ Checks 0 + x => x\n+    public long test14(long x) {\n+        return 0 + x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks \"a*b + a*c => a*(b+c)\n+    public long test15(long a, long b, long c) {\n+        return a*b + a*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*b + b*c => b*(a+c)\n+    public long test16(long a, long b, long c) {\n+        return a*b + b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*c + b*c => (a+b)*c\n+    public long test17(long a, long b, long c) {\n+        return a*c + b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a*b + c*a => a*(b+c)\n+    public long test18(long a, long b, long c) {\n+        return a*b + c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AddLNodeIdealizationTests.java","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of DivINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.DivINodeIdealizationTests\n+ *\/\n+public class DivINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByNegOne\", \"divByPow2And\",\n+                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\",\n+                 \"magicDiv\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+            a = (a == 0) ? 1 : a;\n+        int b = RunInfo.getRandom().nextInt();\n+            b = (b == 0) ? 1 : b;\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(a \/ a, constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a \/ (b \/ b), identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ((a * b) \/ b, retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a \/ 1        , identity(a));\n+        Asserts.assertEQ(a \/ (13 \/ 13), identityAgain(a));\n+        Asserts.assertEQ(a \/ -1       , divByNegOne(a));\n+        Asserts.assertEQ((a & -4) \/ 2 , divByPow2And(a));\n+        Asserts.assertEQ((a & -2) \/ 2 , divByPow2And1(a));\n+        Asserts.assertEQ(a \/ 8        , divByPow2(a));\n+        Asserts.assertEQ(a \/ -8       , divByNegPow2(a));\n+        Asserts.assertEQ(a \/ 13       , magicDiv(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public int constant(int x) {\n+        return x \/ x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ 1 => x\n+    public int identity(int x) {\n+        return x \/ 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public int identityAgain(int x) {\n+        return x \/ (13 \/ 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public int identityThird(int x, int y) {\n+        return x \/ (y \/ y);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.DIV, \"1\",\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public int retainDenominator(int x, int y) {\n+        return (x * y) \/ y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    \/\/ Checks x \/ -1 => 0 - x\n+    public int divByNegOne(int x) {\n+        return x \/ -1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.AND, \"1\",\n+                  IRNode.RSHIFT, \"1\",\n+                 })\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| \"AND\" c3 = 2^c0 >> c1\n+    \/\/ Having a large enough and in the dividend removes the need to account for rounding when converting to shifts and multiplies as in divByPow2()\n+    public int divByPow2And(int x) {\n+        return (x & -4) \/ 2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.AND})\n+    @IR(counts = {IRNode.RSHIFT, \"1\"})\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n+    \/\/ If the negative of the constant within the & equals the divisor then the and can be removed as it only affects bits that will be shifted off\n+    public int divByPow2And1(int x) {\n+        return (x & -2) \/ 2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD_I, \"1\",\n+                 })\n+    \/\/ Checks x \/ 2^c0 => x + ((x >> (32-1)) >>> (32 - c0)) >> c0 => x + ((x >> 31) >>> c1) >> c0 where c1 = 32 - c0\n+    \/\/ An additional (dividend - 1) needs to be added to the shift to account for rounding when dealing with negative numbers.\n+    \/\/ Since x may be negative in this method, an additional add, logical right shift, and signed shift are needed to account for rounding.\n+    public int divByPow2(int x) {\n+        return x \/ 8;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD_I, \"1\",\n+                  IRNode.SUB_I, \"1\",\n+                 })\n+    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n+    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n+    \/\/ After the transformations, 0 is subtracted by the whole expression\n+    \/\/ to account for the negative.\n+    public int divByNegPow2(int x) {\n+        return x \/ -8;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.MUL, \"1\",\n+                  IRNode.CONV_I2L, \"1\",\n+                  IRNode.CONV_L2I, \"1\",\n+                 })\n+    \/\/ Checks magic int division occurs in general when dividing by a non power of 2.\n+    \/\/ More tests can be made to cover the specific cases for differences in the\n+    \/\/ graph that depend upon different values for the \"magic constant\" and the\n+    \/\/ \"shift constant\"\n+    public int magicDiv(int x) {\n+        return x \/ 13;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivINodeIdealizationTests.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of DivLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.DivLNodeIdealizationTests\n+ *\/\n+public class DivLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"constant\", \"identity\", \"identityAgain\", \"identityThird\",\n+                 \"retainDenominator\", \"divByNegOne\", \"divByPow2And\",\n+                 \"divByPow2And1\",  \"divByPow2\", \"divByNegPow2\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+             a = (a == 0) ? 1 : a;\n+        long b = RunInfo.getRandom().nextLong();\n+             b = (b == 0) ? 1 : b;\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, true);\n+        assertResult(a, b, false);\n+        assertResult(min, min, false);\n+        assertResult(max, max, false);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, boolean shouldThrow) {\n+        try {\n+            Asserts.assertEQ(a \/ a, constant(a));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ((a * b) \/ b, retainDenominator(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        try {\n+            Asserts.assertEQ(a \/ (b \/ b), identityThird(a, b));\n+            Asserts.assertFalse(shouldThrow, \"Expected an exception to be thrown.\");\n+        }\n+        catch (ArithmeticException e) {\n+            Asserts.assertTrue(shouldThrow, \"Did not expected an exception to be thrown.\");\n+        }\n+\n+        Asserts.assertEQ(a \/ 1        , identity(a));\n+        Asserts.assertEQ(a \/ (13 \/ 13), identityAgain(a));\n+        Asserts.assertEQ(a \/ -1       , divByNegOne(a));\n+        Asserts.assertEQ((a & -4) \/ 2 , divByPow2And(a));\n+        Asserts.assertEQ((a & -2) \/ 2 , divByPow2And1(a));\n+        Asserts.assertEQ(a \/ 8        , divByPow2(a));\n+        Asserts.assertEQ(a \/ -8       , divByNegPow2(a));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ x => 1\n+    public long constant(long x) {\n+        return x \/ x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ 1 => x\n+    public long identity(long x) {\n+        return x \/ 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    \/\/ Checks x \/ (c \/ c) => x\n+    public long identityAgain(long x) {\n+        return x \/ (13L \/ 13L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.DIV_BY_ZERO_TRAP, \"1\"})\n+    \/\/ Checks x \/ (y \/ y) => x\n+    public long identityThird(long x, long y) {\n+        return x \/ (y \/ y);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_L, \"1\",\n+                  IRNode.DIV_L, \"1\",\n+                  IRNode.DIV_BY_ZERO_TRAP, \"1\"\n+                 })\n+    \/\/ Hotspot should keep the division because it may cause a division by zero trap\n+    public long retainDenominator(long x, long y) {\n+        return (x * y) \/ y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x \/ -1 => 0 - x\n+    public long divByNegOne(long x) {\n+        return x \/ -1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.AND, \"1\",\n+                  IRNode.RSHIFT, \"1\",\n+                 })\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c1 => (x >> c1) & (2^c0 >> c1) => (x >> c1) & c3 where 2^c0 > |2^c1| \"and\" c3 = 2^c0 >> c1\n+    \/\/ Having a large enough and in the dividend removes the need to account for\n+    \/\/ rounding when converting to shifts and multiplies as in divByPow2()\n+    public long divByPow2And(long x) {\n+        return (x & -4L) \/ 2L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.AND})\n+    @IR(counts = {IRNode.RSHIFT, \"1\"})\n+    \/\/ Checks (x & -(2^c0)) \/ 2^c0 => x >> c0\n+    \/\/ If the negative of the constant within the & equals the divisor then\n+    \/\/ the and can be removed as it only affects bits that will be shifted off\n+    public long divByPow2And1(long x) {\n+        return (x & -2L) \/ 2L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x \/ 2^c0 => x + ((x >>)ith negative numbers. Since x may be negative\n+    \/\/ in this method, an additional add, logical right shift, and signed shift\n+    \/\/ are needed to account for rounding.\n+    public long divByPow2(long x) {\n+        return x \/ 8L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV})\n+    @IR(counts = {IRNode.URSHIFT, \"1\",\n+                  IRNode.RSHIFT, \"2\",\n+                  IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x \/ -(2^c0) =>0 - (x + ((x >> (32-1)) >>> (32 - c0)) >> c0) => 0 -  (x + ((x >> 31) >>> c1) >> c0) where c1 = 32 - c0\n+    \/\/ Similar to divByPow2() except a negative divisor turns positive.\n+    \/\/ After the transformations, 0 is subtracted by the whole expression\n+    \/\/ to account for the negative.\n+    public long divByNegPow2(long x) {\n+        return x \/ -8L;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/DivLNodeIdealizationTests.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of MulINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.MulINodeIdealizationTests\n+ *\/\n+public class MulINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"combineConstants\", \"moveConstants\", \"moveConstantsAgain\",\n+                 \"multiplyZero\", \"multiplyZeroAgain\", \"distribute\",\n+                 \"identity\",  \"identityAgain\", \"powerTwo\",\n+                 \"powerTwoAgain\", \"powerTwoPlusOne\", \"powerTwoMinusOne\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b) {\n+        Asserts.assertEQ((a * 13) * 14 , combineConstants(a));\n+        Asserts.assertEQ((a * 13) * b  , moveConstants(a, b));\n+        Asserts.assertEQ(a * (b * 13)  , moveConstantsAgain(a, b));\n+        Asserts.assertEQ(0 * a         , multiplyZero(a));\n+        Asserts.assertEQ(a * 0         , multiplyZeroAgain(a));\n+        Asserts.assertEQ((13 + a) * 14 , distribute(a));\n+        Asserts.assertEQ(1 * a         , identity(a));\n+        Asserts.assertEQ(a * 1         , identityAgain(a));\n+        Asserts.assertEQ(a * 64        , powerTwo(a));\n+        Asserts.assertEQ(a * (1025 - 1), powerTwoAgain(a));\n+        Asserts.assertEQ(a * (64 + 1)  , powerTwoPlusOne(a));\n+        Asserts.assertEQ(a * (64 - 1)  , powerTwoMinusOne(a));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks (x * c1) * c2 => x * c3 where c3 = c1 * c2\n+    public int combineConstants(int x){\n+        return (x * 13) * 14;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks (x * c1) * y => (x * y) * c1\n+    public int moveConstants(int x, int y) {\n+        return (x * 13) * y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks x * (y * c1) => (x * y) * c1\n+    public int moveConstantsAgain(int x, int y) {\n+        return x * (y * 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks 0 * x => 0\n+    public int multiplyZero(int x) {\n+        return 0 * x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks x * 0 => 0\n+    public int multiplyZeroAgain(int x) {\n+        return x * 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks (c1 + x) * c2 => x * c2 + c3 where c3 = c1 * c2\n+    public int distribute(int x) {\n+        return (13 + x) * 14;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks 1 * x => x\n+    public int identity(int x) {\n+        return 1 * x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks x * 1 => x\n+    public int identityAgain(int x) {\n+        return x * 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public int powerTwo(int x) {\n+        return x * 64;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public int powerTwoAgain(int x) {\n+        return x * (1025 - 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n + 1) => (x << n) + x\n+    public int powerTwoPlusOne(int x) {\n+        return x * (64 + 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n - 1) => (x << n) - x\n+    public int powerTwoMinusOne(int x) {\n+        return x * (64 - 1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulINodeIdealizationTests.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of MulLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.MulLNodeIdealizationTests\n+ *\/\n+public class MulLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"combineConstants\", \"moveConstants\", \"moveConstantsAgain\",\n+                 \"multiplyZero\", \"multiplyZeroAgain\", \"distribute\",\n+                 \"identity\",  \"identityAgain\", \"powerTwo\",\n+                 \"powerTwoAgain\", \"powerTwoPlusOne\", \"powerTwoMinusOne\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b) {\n+        Asserts.assertEQ((a * 13) * 14 * 15, combineConstants(a));\n+        Asserts.assertEQ((a * 13) * b      , moveConstants(a, b));\n+        Asserts.assertEQ(a * (b * 13)      , moveConstantsAgain(a, b));\n+        Asserts.assertEQ(0 * a             , multiplyZero(a));\n+        Asserts.assertEQ(a * 0             , multiplyZeroAgain(a));\n+        Asserts.assertEQ((13 + a) * 14     , distribute(a));\n+        Asserts.assertEQ(1 * a             , identity(a));\n+        Asserts.assertEQ(a * 1             , identityAgain(a));\n+        Asserts.assertEQ(a * 64            , powerTwo(a));\n+        Asserts.assertEQ(a * (1025 - 1)    , powerTwoAgain(a));\n+        Asserts.assertEQ(a * (64 + 1)      , powerTwoPlusOne(a));\n+        Asserts.assertEQ(a * (64 - 1)      , powerTwoMinusOne(a));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\"})\n+    \/\/Checks (x * c1) * c2 => x * c3 where c3 = c1 * c2\n+    public long combineConstants(long x){\n+        return (x * 13) * 14 * 15;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks (x * c1) * y => (x * y) * c1\n+    public long moveConstants(long x, long y) {\n+        return (x * 13) * y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"2\"})\n+    \/\/ Checks x * (y * c1) => (x * y) * c1\n+    public long moveConstantsAgain(long x, long y) {\n+        return x * (y * 13);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks 0 * x => 0\n+    public long multiplyZero(long x) {\n+        return 0 * x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks x * 0 => 0\n+    public long multiplyZeroAgain(long x) {\n+        return x * 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks (c1 + x) * c2 => x * c2 + c3 where c3 = c1 * c2\n+    public long distribute(long x) {\n+        return (13 + x) * 14;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks 1 * x => x\n+    public long identity(long x) {\n+        return 1 * x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    \/\/ Checks x * 1 => x\n+    public long identityAgain(long x) {\n+        return x * 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public long powerTwo(long x) {\n+        return x * 64;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x * 2^n => x << n\n+    public long powerTwoAgain(long x) {\n+        return x * (1025 - 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n + 1) => (x << n) + x\n+    public long powerTwoPlusOne(long x) {\n+        return x * (64 + 1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\",\n+                  IRNode.SUB, \"1\",\n+                 })\n+    \/\/ Checks x * (2^n - 1) => (x << n) - x\n+    public long powerTwoMinusOne(long x) {\n+        return x * (64 - 1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulLNodeIdealizationTests.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of SubINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.SubINodeIdealizationTests\n+ *\/\n+public class SubINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\", \"test5\", \"test6\",\n+                 \"test7\", \"test8\", \"test9\",\n+                 \"test10\", \"test11\", \"test12\",\n+                 \"test13\", \"test14\", \"test15\",\n+                 \"test16\", \"test17\", \"test18\",\n+                 \"test19\", \"test20\", \"test21\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+        int c = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0, 0);\n+        assertResult(a, b, c);\n+        assertResult(min, min, min);\n+        assertResult(max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a, int b, int c) {\n+        Asserts.assertEQ(a - 1            , test1(a));\n+        Asserts.assertEQ((a + 1) - b      , test2(a, b));\n+        Asserts.assertEQ(a - (b + 2021)   , test3(a, b));\n+        Asserts.assertEQ(a - (a + b)      , test4(a, b));\n+        Asserts.assertEQ((a - b) - a      , test5(a, b));\n+        Asserts.assertEQ(a - (b + a)      , test6(a, b));\n+        Asserts.assertEQ(0 - (a - b)      , test7(a, b));\n+        Asserts.assertEQ(0 - (a + 2021)   , test8(a));\n+        Asserts.assertEQ((a + b) - (a + c), test9(a, b, c));\n+        Asserts.assertEQ((b + a) - (c + a), test10(a, b, c));\n+        Asserts.assertEQ((b + a) - (a + c), test11(a, b, c));\n+        Asserts.assertEQ((a + b) - (c + a), test12(a, b, c));\n+        Asserts.assertEQ(a - (b - c)      , test13(a, b, c));\n+        Asserts.assertEQ(0 - (a >> 31)    , test14(a));\n+        Asserts.assertEQ(0 - (0 - a)      , test15(a));\n+        Asserts.assertEQ((a + b) - b      , test16(a, b));\n+        Asserts.assertEQ((a + b) - a      , test17(a, b));\n+        Asserts.assertEQ(a*b - a*c        , test18(a, b, c));\n+        Asserts.assertEQ(a*b - b*c        , test19(a, b, c));\n+        Asserts.assertEQ(a*c - b*c        , test20(a, b, c));\n+        Asserts.assertEQ(a*b - c*a        , test21(a, b, c));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x - c0) => x + (-c0)\n+    public int test1(int x) {\n+        return (x - 1);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\"\n+                 })\n+    \/\/ Checks (x + c0) - y => (x - y) + c0\n+    public int test2(int x, int y) {\n+        return (x + 1) - y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n+    public int test3(int x, int y) {\n+        return x - (y + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (x + y) => 0 - y\n+    public int test4(int x, int y) {\n+        return x - (x + y);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x - y) - x => 0 - y\n+    public int test5(int x, int y) {\n+        return (x - y) - x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (y + x) => 0 - y\n+    public int test6(int x, int y) {\n+        return x - (y + x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x - y) => y - x\n+    public int test7(int x, int y) {\n+        return 0 - (x - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x + 2021) => -2021 - x\n+    public int test8(int x) {\n+        return 0 - (x + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (x + b) => a - b;\n+    public int test9(int x, int a, int b) {\n+        return (x + a) - (x + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (b + x) => a - b\n+    public int test10(int x, int a, int b) {\n+        return (a + x) - (b + x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (x + b) => a - b\n+    public int test11(int x, int a, int b) {\n+        return (a + x) - (x + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (b + x) => a - b\n+    public int test12(int x, int a, int b) {\n+        return (x + a) - (b + x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a - (b - c) => (a + c) - b\n+    public int test13(int a, int b, int c) {\n+        return a - (b - c);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.RSHIFT_I})\n+    @IR(counts = {IRNode.URSHIFT_I, \"1\"})\n+    \/\/ Checks 0 - (a >> 31) => a >>> 31\n+    \/\/        signed ^^          ^^^ unsigned\n+    public int test14(int a) {\n+        return 0 - (a >> 31);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    \/\/ Checks 0 - (0 - x) => x\n+    public int test15(int x) {\n+        return 0 - (0 - x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - y => x\n+    public int test16(int x, int y) {\n+        return (x + y) - y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - x => y\n+    public int test17(int x, int y) {\n+        return (x + y) - x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks \"a*b-a*c => a*(b-c)\n+    public int test18(int a, int b, int c) {\n+        return a*b - a*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*b-b*c => b*(a-c)\n+    public int test19(int a, int b, int c) {\n+        return a*b - b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*c-b*c => (a-b)*c\n+    public int test20(int a, int b, int c) {\n+        return a*c - b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*b-c*a => a*(b-c)\n+    public int test21(int a, int b, int c) {\n+        return a*b - c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/SubINodeIdealizationTests.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265 8272735\n+ * @summary Test that Ideal transformations of SubLNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.SubLNodeIdealizationTests\n+ *\/\n+public class SubLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\",\n+                 \"test4\", \"test5\", \"test6\",\n+                 \"test7\", \"test8\", \"test9\",\n+                 \"test10\", \"test11\", \"test12\",\n+                 \"test13\", \"test14\", \"test15\",\n+                 \"test16\", \"test17\", \"test18\",\n+                 \"test19\", \"test20\", \"test21\"})\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+        long c = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0, 0);\n+        assertResult(a, b, c);\n+        assertResult(min, min, min);\n+        assertResult(max, max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long a, long b, long c) {\n+        Asserts.assertEQ(a - 1            , test1(a));\n+        Asserts.assertEQ((a + 1) - b      , test2(a, b));\n+        Asserts.assertEQ(a - (b + 2021)   , test3(a, b));\n+        Asserts.assertEQ(a - (a + b)      , test4(a, b));\n+        Asserts.assertEQ((a - b) - a      , test5(a, b));\n+        Asserts.assertEQ(a - (b + a)      , test6(a, b));\n+        Asserts.assertEQ(0 - (a - b)      , test7(a, b));\n+        Asserts.assertEQ(0 - (a + 2021)   , test8(a, b));\n+        Asserts.assertEQ((a + b) - (a + c), test9(a, b, c));\n+        Asserts.assertEQ((b + a) - (c + a), test10(a, b, c));\n+        Asserts.assertEQ((b + a) - (a + c), test11(a, b, c));\n+        Asserts.assertEQ((a + b) - (c + a), test12(a, b, c));\n+        Asserts.assertEQ(a - (b - c)      , test13(a, b, c));\n+        Asserts.assertEQ(0 - (a >> 63)    , test14(a));\n+        Asserts.assertEQ(0 - (0 - a)      , test15(a));\n+        Asserts.assertEQ((a + b) - b      , test16(a, b));\n+        Asserts.assertEQ((a + b) - a      , test17(a, b));\n+        Asserts.assertEQ(a*b - a*c        , test18(a, b, c));\n+        Asserts.assertEQ(a*b - b*c        , test19(a, b, c));\n+        Asserts.assertEQ(a*c - b*c        , test20(a, b, c));\n+        Asserts.assertEQ(a*b - c*a        , test21(a, b, c));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    \/\/ Checks (x - c0) => x + (-c0)\n+    public long test1(long x) {\n+        return (x - 1);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD, \"1\",\n+                  IRNode.SUB, \"1\"\n+                 })\n+    \/\/ Checks (x + c0) - y => (x - y) + c0\n+    public long test2(long x, long y) {\n+        return (x + 1) - y;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks x - (y + c0) => (x - y) + (-c0)\n+    public long test3(long x, long y) {\n+        return x - (y + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (x + y) => 0 - y\n+    public long test4(long x, long y) {\n+        return x - (x + y);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x - y) - x => 0 - y\n+    public long test5(long x, long y) {\n+        return (x - y) - x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks x - (y + x) => 0 - y\n+    public long test6(long x, long y) {\n+        return x - (y + x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x - y) => y - x\n+    public long test7(long x, long y) {\n+        return 0 - (x - y);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks 0 - (x + 2021) => -2021 - x\n+    public long test8(long x, long y) {\n+        return 0 - (x + 2021);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (x + b) => a - b;\n+    public long test9(long x, long a, long b) {\n+        return (x + a) - (x + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (b + x) => a - b\n+    public long test10(long x, long a, long b) {\n+        return (a + x) - (b + x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (a + x) - (x + b) => a - b\n+    public long test11(long x, long a, long b) {\n+        return (a + x) - (x + b);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(counts = {IRNode.SUB, \"1\"})\n+    \/\/ Checks (x + a) - (b + x) => a - b\n+    public long test12(long x, long a, long b) {\n+        return (x + a) - (b + x);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SUB, \"1\",\n+                  IRNode.ADD, \"1\"\n+                 })\n+    \/\/ Checks a - (b - c) => (a + c) - b\n+    public long test13(long a, long b, long c) {\n+        return a - (b - c);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.RSHIFT_L})\n+    @IR(counts = {IRNode.URSHIFT_L, \"1\"})\n+    \/\/ Checks 0 - (a >> 63) => a >>> 63\n+    \/\/        signed ^^          ^^^ unsigned\n+    public long test14(long a) {\n+        return 0 - (a >> 63);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB})\n+    \/\/ Checks 0 - (0 - x) => x\n+    public long test15(long x) {\n+        return 0 - (0 - x);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - y => x\n+    public long test16(long x, long y) {\n+        return (x + y) - y;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SUB, IRNode.ADD})\n+    \/\/ Checks (x + y) - x => y\n+    public long test17(long x, long y) {\n+        return (x + y) - x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks \"a*b-a*c => a*(b-c)\n+    public long test18(long a, long b, long c) {\n+        return a*b - a*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*b-b*c => b*(a-c)\n+    public long test19(long a, long b, long c) {\n+        return a*b - b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*c-b*c => (a-b)*c\n+    public long test20(long a, long b, long c) {\n+        return a*c - b*c;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL, \"1\",\n+                  IRNode.SUB, \"1\"})\n+    \/\/ Checks a*b-c*a => a*(b-c)\n+    public long test21(long a, long b, long c) {\n+        return a*b - c*a;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/SubLNodeIdealizationTests.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * bug 8281322\n+ * @summary check counted loop is properly constructed with\/without safepoint\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestCountedLoopSafepoint\n+ *\/\n+\n+public class TestCountedLoopSafepoint {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=1\", \"-XX:-UseCountedLoopSafepoints\");\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=1\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1\");\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=1\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\");\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTEDLOOP, \"1\" })\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"0\" }, failOn = { IRNode.SAFEPOINT, IRNode.OUTERSTRIPMINEDLOOP })\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"1\" }, counts = { IRNode.SAFEPOINT, \"1\" }, failOn = { IRNode.OUTERSTRIPMINEDLOOP })\n+    @IR(applyIf = { \"LoopStripMiningIter\", \"> 1\" }, counts = { IRNode.SAFEPOINT, \"1\", IRNode.OUTERSTRIPMINEDLOOP, \"1\" })\n+    public static float test(int start, int stop) {\n+        float v = 1;\n+        for (int i = start; i < stop; i++) {\n+            v *= 2;\n+        }\n+        return v;\n+    }\n+\n+    @Run(test = \"test\")\n+    private void testRunner() {\n+        test(0, 100);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestCountedLoopSafepoint.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -39,1 +39,3 @@\n-        TestFramework.run();\n+        TestFramework.runWithFlags(\"-XX:-UseCountedLoopSafepoints\");\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1\");\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\");\n@@ -99,0 +101,146 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStrideNegScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNeg\")\n+    private void testStrideNegScaleNeg_runner() {\n+        testStrideNegScaleNeg(0, 100, 100, 100);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScaleNegInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = -2;\n+        final int stride = 1;\n+\n+        for (int i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNegInIntLoop1\")\n+    private void testStrideNegScaleNegInIntLoop1_runner() {\n+        testStrideNegScaleNegInIntLoop1(0, 100, 200, 200);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScaleNegInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = -2;\n+        final int stride = 1;\n+\n+        for (int i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNegInIntLoop2\")\n+    private void testStrideNegScaleNegInIntLoop2_runner() {\n+        testStrideNegScaleNegInIntLoop2(0, 100, 200, 200);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStrideNegScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePos\")\n+    private void testStrideNegScalePos_runner() {\n+        testStrideNegScalePos(0, 100, 100, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScalePosInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = 2;\n+        final int stride = 1;\n+        for (int i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePosInIntLoop1\")\n+    private void testStrideNegScalePosInIntLoop1_runner() {\n+        testStrideNegScalePosInIntLoop1(0, 100, 200, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScalePosInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = 2;\n+        final int stride = 1;\n+        for (int i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePosInIntLoop2\")\n+    private void testStrideNegScalePosInIntLoop2_runner() {\n+        testStrideNegScalePosInIntLoop1(0, 100, 200, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNeg\")\n+    private void testStridePosScaleNeg_runner() {\n+        testStridePosScaleNeg(0, 100, 100, 99);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNegInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = -2;\n+        final int stride = 1;\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNegInIntLoop1\")\n+    private void testStridePosScaleNegInIntLoop1_runner() {\n+        testStridePosScaleNegInIntLoop1(0, 100, 200, 198);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNegInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = -2;\n+        final int stride = 1;\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNegInIntLoop2\")\n+    private void testStridePosScaleNegInIntLoop2_runner() {\n+        testStridePosScaleNegInIntLoop1(0, 100, 200, 198);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":149,"deletions":1,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8282045\n+ * @summary When loop strip mining fails, safepoints are removed from loop anyway\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestStripMiningDropsSafepoint\n+ *\/\n+\n+public class TestStripMiningDropsSafepoint {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopMaxUnroll=1\", \"-XX:-RangeCheckElimination\");\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopMaxUnroll=1\", \"-XX:-RangeCheckElimination\", \"-XX:-PartialPeelLoop\");\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = { IRNode.COUNTEDLOOP, \"1\",  IRNode.OUTERSTRIPMINEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    private static void test1(int[] dst, int[] src) {\n+        \/\/ Partial peel is applied. No side effect between exit and\n+        \/\/ safepoint.\n+        for (int i = 0; ; ) {\n+            \/\/ prevent ciTypeFlow from cloning head\n+            synchronized (new Object()) {}\n+            i++;\n+            if (i >= src.length) {\n+                break;\n+            }\n+            dst[i] = src[i];\n+            if (i \/ 2 >= 2000) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test1\")\n+    private static void test1_runner() {\n+        int[] array1 = new int[1000];\n+        int[] array2 = new int[10000];\n+        test1(array1, array1);\n+        test1(array2, array2);\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, counts = { IRNode.COUNTEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    @IR(applyIf = { \"PartialPeelLoop\", \"true\" }, failOn = { IRNode.OUTERSTRIPMINEDLOOP })\n+    private static void test2(int[] dst, int[] src) {\n+        \/\/ Partial peel is applied. Some side effect between exit and\n+        \/\/ safepoint.\n+        int v = src[0];\n+        for (int i = 0; ; ) {\n+            synchronized (new Object()) {}\n+            dst[i] = v;\n+            i++;\n+            if (i >= src.length) {\n+                break;\n+            }\n+            v = src[i];\n+            if (i \/ 2 >= 2000) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test2\")\n+    private static void test2_runner() {\n+        int[] array1 = new int[1000];\n+        int[] array2 = new int[10000];\n+        test2(array1, array1);\n+        test2(array2, array2);\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"PartialPeelLoop\", \"false\" }, counts = { IRNode.COUNTEDLOOP, \"1\",  IRNode.OUTERSTRIPMINEDLOOP, \"1\", IRNode.SAFEPOINT, \"1\" })\n+    private static void test3(int[] dst, int[] src) {\n+        int v = src[0];\n+        for (int i = 0; ; ) {\n+            synchronized (new Object()) {}\n+            dst[i] = v;\n+            int inc = test3_helper(2);\n+            v = src[i];\n+            i += (inc \/ 2);\n+            if (i >= src.length) {\n+                break;\n+            }\n+            for (int j = 0; j < 10; j++) {\n+            }\n+            \/\/ safepoint on backedge\n+        }\n+    }\n+\n+    private static int test3_helper(int stop) {\n+        int i = 1;\n+        do {\n+            synchronized (new Object()) {}\n+            i *= 2;\n+        } while (i < stop);\n+        return i;\n+    }\n+\n+    @Run(test = \"test3\")\n+    private static void test3_runner() {\n+        int[] array1 = new int[1000];\n+        test3(array1, array1);\n+        test3_helper(10);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestStripMiningDropsSafepoint.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.loopOpts;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Test that Ideal transformations of CountedLoopNode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.loopOpts.LoopIdealizationTests\n+ *\/\n+public class LoopIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @DontInline\n+    private void blackhole() { }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.DIV, IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.CALL})\n+    \/\/ Checks that a for loop with 0 iterations is removed\n+    public void zeroIterForLoop() {\n+        for (int i = 0; i < 0; i++) {\n+            System.out.println(13 \/ 17 * 23 + 1);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.CALL})\n+    \/\/ Checks that a for loop with 1 iteration doesn't have CountedLoop nodes\n+    public void iterOneBreakForLoop() {\n+        for (int i = 0; i < 500; i++) {\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop() {\n+        for (int i = 0; i < 1; i++) {\n+            this.blackhole();\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop1() {\n+        for (int i = 0; i < 500; i++) {\n+            this.blackhole();\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a for loop with 1 iteration is simplified to straight code\n+    public void oneIterForLoop2() {\n+        for (int i = 0; i < 500; i++) {\n+            this.blackhole();\n+            if (i == 0) {\n+                break;\n+            }\n+            else {\n+               this.blackhole();\n+               i++;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOOP, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop() {\n+        while (true) {\n+            this.blackhole();\n+            break;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop1() {\n+        int i = 0;\n+        while (i < 1) {\n+            this.blackhole();\n+            i++;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.COUNTEDLOOP, IRNode.COUNTEDLOOP_MAIN, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterWhileLoop2() {\n+        int i = 0;\n+        while (i < 500) {\n+            this.blackhole();\n+            if (i == 0) {\n+                 break;\n+            }\n+            else {\n+                this.blackhole();\n+                i++;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOOP, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop() {\n+        do {\n+            this.blackhole();\n+            break;\n+        } while (true);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOOP, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop1() {\n+        do {\n+            this.blackhole();\n+        } while (false);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.ADD, IRNode.LOOP, IRNode.TRAP})\n+    @IR(counts = {IRNode.CALL, \"1\"})\n+    \/\/ Checks that a while loop with 1 iteration is simplified to straight code\n+    public void oneIterDoWhileLoop2() {\n+        int i = 0;\n+        do {\n+            this.blackhole();\n+            i++;\n+        } while (i == -1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/loopOpts\/LoopIdealizationTests.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.scalarReplacement;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267265\n+ * @summary Tests that Escape Analysis and Scalar Replacement is able to handle some simple cases.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.scalarReplacement.ScalarReplacementTests\n+ *\/\n+public class ScalarReplacementTests {\n+    private class Person {\n+        private String name;\n+        private int age;\n+\n+        public Person(Person p) {\n+            this.name = p.getName();\n+            this.age = p.getAge();\n+        }\n+\n+        public Person(String name, int age) {\n+            this.name = name;\n+            this.age = age;\n+        }\n+\n+        public String getName() { return name; }\n+        public int getAge() { return age; }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS, IRNode.ALLOC})\n+    public String stringConstant(int age) {\n+        Person p = new Person(\"Java\", age);\n+        return p.getName();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS, IRNode.ALLOC})\n+    public int intConstant(int age) {\n+        Person p = new Person(\"Java\", age);\n+        return p.getAge();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS, IRNode.ALLOC})\n+    public String nestedStringConstant(int age) {\n+        Person p1 = new Person(\"Java\", age);\n+        Person p2 = new Person(p1);\n+        return p2.getName();\n+    }\n+\n+    @Test\n+    @Arguments(Argument.RANDOM_EACH)\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS, IRNode.ALLOC})\n+    public int nestedIntConstant(int age) {\n+        Person p1 = new Person(\"Java\", age);\n+        Person p2 = new Person(p1);\n+        return p2.getAge();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.CALL, IRNode.LOAD, IRNode.STORE, IRNode.FIELD_ACCESS, IRNode.ALLOC})\n+    public int nestedConstants(int age1, int age2) {\n+        Person p = new Person(\n+                        new Person(\"Java\", age1).getName(),\n+                        new Person(\"Java\", age2).getAge());\n+        return p.getAge();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/ScalarReplacementTests.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test CheckCodeCacheInfo\n+ * @bug 8005885\n+ * @summary Checks VM verbose information related to the code cache\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   compiler.codecache.CheckCodeCacheInfo\n+ *\/\n+\n+package compiler.codecache;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class CheckCodeCacheInfo {\n+    private static final String VERBOSE_REGEXP;\n+\n+    static {\n+        String entry = \"\\\\d+K( \\\\(hdr \\\\d+K \\\\d+%, loc \\\\d+K \\\\d+%, code \\\\d+K \\\\d+%, stub \\\\d+K \\\\d+%, \\\\[oops \\\\d+K \\\\d+%, metadata \\\\d+K \\\\d+%, data \\\\d+K \\\\d+%, pcs \\\\d+K \\\\d+%\\\\]\\\\))?\\\\n\";\n+        String pair = \" #\\\\d+ live = \" + entry\n+                    + \" #\\\\d+ dead = \" + entry;\n+\n+        VERBOSE_REGEXP = \"nmethod blobs per compilation level:\\\\n\"\n+                       + \"none:\\\\n\"\n+                       + pair\n+                       + \"simple:\\\\n\"\n+                       + pair\n+                       + \"limited profile:\\\\n\"\n+                       + pair\n+                       + \"full profile:\\\\n\"\n+                       + pair\n+                       + \"full optimization:\\\\n\"\n+                       + pair\n+                       + \"Non-nmethod blobs:\\\\n\"\n+                       + \" #\\\\d+ runtime = \" + entry\n+                       + \" #\\\\d+ uncommon trap = \" + entry\n+                       + \" #\\\\d+ deoptimization = \" + entry\n+                       + \" #\\\\d+ adapter = \" + entry\n+                       + \" #\\\\d+ buffer blob = \" + entry\n+                       + \" #\\\\d+ other = \" + entry;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb;\n+\n+        pb = ProcessTools.createJavaProcessBuilder(\"-XX:+PrintCodeCache\",\n+                                                   \"-XX:+Verbose\",\n+                                                   \"-version\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+        out.stdoutShouldMatch(VERBOSE_REGEXP);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckCodeCacheInfo.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -58,1 +58,1 @@\n-          \"-XX:ReservedCodeCacheSize=2496k\", \"-XX:-UseCodeCacheFlushing\", \"CodeCacheFullCountTest\", \"WasteCodeCache\");\n+          \"-XX:ReservedCodeCacheSize=2496k\", \"-XX:-UseCodeCacheFlushing\", \"-XX:-MethodFlushing\", \"CodeCacheFullCountTest\", \"WasteCodeCache\");\n@@ -67,1 +67,1 @@\n-            if (fullCount != 1) {\n+            if (fullCount == 0) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CodeCacheFullCountTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,3 @@\n+    private static final String[] XINT_EXPECTED_MESSAGE = new String[] {\n+            \"SegmentedCodeCache has no meaningful effect with -Xint\"\n+    };\n@@ -89,1 +92,1 @@\n-                        + \"without any errors.\";\n+                        + \"but it produces a warning that it is ignored.\";\n@@ -92,1 +95,2 @@\n-                        \/* expected messages *\/ null, UNEXPECTED_MESSAGES,\n+                        XINT_EXPECTED_MESSAGE,\n+                        \/* unexpected messages *\/ null,\n@@ -120,8 +124,0 @@\n-                \/\/ SCC could be explicitly enabled w\/ Xint\n-                errorMessage = String.format(\"It should be possible to \"\n-                                + \"explicitly enable %s in interpreted mode.\",\n-                        SEGMENTED_CODE_CACHE);\n-\n-                CommandLineOptionTest.verifyOptionValue(SEGMENTED_CODE_CACHE,\n-                        \"true\", errorMessage, false, INT_MODE,\n-                        USE_SEGMENTED_CODE_CACHE);\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/TestSegmentedCodeCacheOption.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,3 +66,0 @@\n-                new CodeCacheCLITestCase(CodeCacheCLITestCase\n-                        .CommonDescriptions.INT_MODE.description,\n-                        GENERIC_RUNNER),\n@@ -72,3 +69,0 @@\n-                new CodeCacheCLITestCase(CodeCacheCLITestCase\n-                        .CommonDescriptions.TIERED_LEVEL_0.description,\n-                        GENERIC_RUNNER),\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/TestCodeHeapSizeOptions.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-         * only NonNMethod code heap.\n+         * the whole code cache. Int mode disables SegmentedCodeCache with a warning.\n@@ -71,1 +71,1 @@\n-        INT_MODE(ONLY_SEGMENTED, EnumSet.of(BlobType.NonNMethod), USE_INT_MODE),\n+        INT_MODE(ONLY_SEGMENTED, EnumSet.of(BlobType.All), USE_INT_MODE),\n@@ -90,1 +90,1 @@\n-         * contain information about non-nmethods and non-profiled nmethods\n+         * warn about SegmentedCodeCache and contain information about all\n@@ -94,1 +94,1 @@\n-                EnumSet.of(BlobType.NonNMethod, BlobType.MethodNonProfiled),\n+                EnumSet.of(BlobType.All),\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/common\/CodeCacheCLITestCase.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-        Object b = new Object();;\n+        Object b = new Object();\n@@ -254,1 +254,1 @@\n-        Object b = new Object();;\n+        Object b = new Object();\n@@ -265,1 +265,1 @@\n-        Object b = new Object();;\n+        Object b = new Object();\n@@ -275,1 +275,1 @@\n-        Object b = new Object();;\n+        Object b = new Object();\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/Test6909839.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -30,1 +31,1 @@\n- *      -XX:CompileCommand=compileony,compiler.codegen.Test8005033::testBitCount\n+ *      -XX:CompileCommand=compileonly,compiler.codegen.Test8005033::testBitCount\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/Test8005033.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires vm.flagless\n+ * @requires vm.flagless & vm.compiler1.enabled & vm.compiler2.enabled\n@@ -128,1 +128,1 @@\n-        analyzer.shouldNotContain(\"java.lang.invoke.Invokers$Holder::linkToTargetMethod (9 bytes)   not inlineable\");\n+        analyzer.shouldNotMatch(\"java\\\\.lang\\\\.invoke\\\\..+::linkToTargetMethod \\\\(9 bytes\\\\)   not inlineable\");\n@@ -130,1 +130,1 @@\n-        analyzer.shouldContain(\"java.lang.invoke.Invokers$Holder::linkToTargetMethod (9 bytes)   force inline by annotation\");\n+        analyzer.shouldMatch(\"java\\\\.lang\\\\.invoke\\\\..+::linkToTargetMethod \\\\(9 bytes\\\\)   force inline by annotation\");\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/ResolvedClassTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+\/*\n+ * @test\n+ * @bug 8999999\n+ * @summary Validates StringCoding.countPositives intrinsic with a small range of tests.\n+ * @library \/compiler\/patches\n+ *\n+ * @build java.base\/java.lang.Helper\n+ * @run main compiler.intrinsics.string.TestCountPositives\n+ *\/\n+\n+public class TestCountPositives {\n+\n+    private static byte[] tBa = new byte[4096 + 16];\n+\n+    \/**\n+     * Completely initialize the test array, preparing it for tests of the\n+     * StringCoding.hasNegatives method with a given array segment offset,\n+     * length, and number of negative bytes.\n+     *\/\n+    public static void initialize(int off, int len, int neg) {\n+        assert (len + off <= tBa.length);\n+        \/\/ insert \"canary\" (negative) values before offset\n+        for (int i = 0; i < off; ++i) {\n+            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+        }\n+        \/\/ fill the array segment\n+        for (int i = off; i < len + off; ++i) {\n+            tBa[i] = (byte) (((i - off + 15) & 0x7F));\n+        }\n+        if (neg != 0) {\n+            \/\/ modify a number (neg) disparate array bytes inside\n+            \/\/ segment to be negative.\n+            int div = (neg > 1) ? (len - 1) \/ (neg - 1) : 0;\n+            int idx;\n+            for (int i = 0; i < neg; ++i) {\n+                idx = off + (len - 1) - div * i;\n+                tBa[idx] = (byte) (0x80 | tBa[idx]);\n+            }\n+        }\n+        \/\/ insert \"canary\" negative values after array segment\n+        for (int i = len + off; i < tBa.length; ++i) {\n+            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+        }\n+    }\n+\n+    \/** Sizes of array segments to test. *\/\n+    private static int sizes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 17, 19, 23, 37, 61, 131,\n+            4099 };\n+\n+    \/**\n+     * Test different array segment sizes, offsets, and number of negative\n+     * bytes.\n+     *\/\n+    public static void test_countPositives() throws Exception {\n+        int len, off;\n+        int ng;\n+\n+        for (ng = 0; ng < 57; ++ng) { \/\/ number of negatives in array segment\n+            for (off = 0; off < 8; ++off) { \/\/ starting offset of array segment\n+                for (int i = 0; i < sizes.length; ++i) { \/\/ array segment size\n+                                                         \/\/ choice\n+                    len = sizes[i];\n+                    if (len + off > tBa.length)\n+                        continue;\n+                    initialize(off, len, ng);\n+                    int calculated = Helper.StringCodingCountPositives(tBa, off, len);\n+                    int expected = countPositives(tBa, off, len);\n+                    if (calculated != expected) {\n+                        if (expected != len && calculated >= 0 && calculated < expected) {\n+                            \/\/ allow intrinsics to return early with a lower value,\n+                            \/\/ but only if we're not expecting the full length (no\n+                            \/\/ negative bytes)\n+                            continue;\n+                        }\n+                        throw new Exception(\"Failed test countPositives \" + \"offset: \" + off + \" \"\n+                                + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" negatives: \"\n+                                + ng);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static int countPositives(byte[] ba, int off, int len) {\n+        int limit = off + len;\n+        for (int i = off; i < limit; i++) {\n+            if (ba[i] < 0) {\n+                return i - off;\n+            }\n+        }\n+        return len;\n+    }\n+\n+    public void run() throws Exception {\n+        \/\/ iterate to eventually get intrinsic inlined\n+        for (int j = 0; j < 1000; ++j) {\n+            test_countPositives();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        (new TestCountPositives()).run();\n+        System.out.println(\"countPositives validated\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestCountPositives.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -214,1 +214,1 @@\n-            throw new RuntimeException(\" x = \" + Long.toHexString(x) + \", y = \" + Long.toHexString(y));\n+            throw new RuntimeException(\"expect x == y: x = \" + Long.toHexString(x) + \", y = \" + Long.toHexString(y));\n@@ -219,2 +219,11 @@\n-        if (x == x && y == y && x != y) {\n-            ck(x, y);\n+        \/\/ Check if x and y have identical values.\n+        \/\/ Remember: NaN == x is false for ANY x, including if x is NaN (IEEE standard).\n+        \/\/ Therefore, if x and y are NaN, x != y would return true, which is not what we want.\n+        \/\/ We do not want an Exception if both are NaN.\n+        \/\/ Double.compare takes care of these special cases\n+        \/\/ including NaNs, and comparing -0.0 to 0.0\n+        if (Double.compare(x,y) != 0) {\n+            throw new RuntimeException(\"expect x == y:\"\n+                                    + \"  x = \" + Double.toString(x) + \", y = \" + Double.toString(y)\n+                                    + \" (x = \" + Long.toHexString(Double.doubleToRawLongBits(x))\n+                                    + \", y = \" + Long.toHexString(Double.doubleToRawLongBits(y)) + \")\");\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/unsafe\/ByteBufferTest.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-        Map<Class<?>, Object> map = new HashMap<>();;\n+        Map<Class<?>, Object> map = new HashMap<>();\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/CompileCodeTestCase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,5 @@\n+    private void checkLineStart(CompileCodeTestCase testCase, String line, String match) {\n+        Asserts.assertTrue(line.startsWith(match),\n+                testCase + \" : line \\\"\" + line + \"\\\" does not start with: \\\"\" + match +\"\\\"\");\n+    }\n+\n@@ -101,1 +106,1 @@\n-        \/\/ Therefore compare strings 2 and 3.\n+        \/\/ so discard it and try again.\n@@ -103,11 +108,23 @@\n-        String str3 = CompilerToVMHelper.disassembleCodeBlob(installedCode);\n-        String[] str2Lines = str2.split(System.lineSeparator());\n-        String[] str3Lines = str3.split(System.lineSeparator());\n-        \/\/ skip the first two lines since it contains a timestamp that may vary from different invocations\n-        \/\/ <empty-line>\n-        \/\/ Compiled method (c2)     309  463       4       compiler.jvmci.compilerToVM.CompileCodeTestCase$Dummy::staticMethod (1 bytes)\n-        \/\/ <empty-line>\n-        \/\/ Compiled method (c2)     310  463       4       compiler.jvmci.compilerToVM.CompileCodeTestCase$Dummy::staticMethod (1 bytes)\n-        for (int i = 2; i < str2Lines.length; i++) {\n-            Asserts.assertEQ(str2Lines[i], str3Lines[i],\n-                testCase + \" : 3nd invocation returned different value from 2nd\");\n+        String[] strLines = str2.split(\"\\\\R\");\n+        \/\/ Check some basic layout\n+        int MIN_LINES = 5;\n+        Asserts.assertTrue(strLines.length > 2,\n+            testCase + \" : read \" + strLines.length + \" lines, \" + MIN_LINES + \" expected\");\n+        int l = 1;\n+        checkLineStart(testCase, strLines[l++], \"Compiled method \"); \/\/ 2\n+        checkLineStart(testCase, strLines[l++], \" total in heap  \"); \/\/ 3\n+        int foundDisassemblyLine = -1;\n+        int foundEntryPointLine = -1;\n+        for (; l < strLines.length; ++l) {\n+            String line = strLines[l];\n+            if (line.equals(\"[Disassembly]\") || line.equals(\"[MachCode]\")) {\n+                Asserts.assertTrue(foundDisassemblyLine == -1,\n+                    testCase + \" : Duplicate disassembly section markers found at lines \" + foundDisassemblyLine + \" and \" + l);\n+                foundDisassemblyLine = l;\n+            }\n+            if (line.equals(\"[Entry Point]\") || line.equals(\"[Verified Entry Point]\")) {\n+                Asserts.assertTrue(foundDisassemblyLine != -1,\n+                    testCase + \" : entry point found but [Disassembly] section missing \");\n+                foundEntryPointLine = l;\n+                break;\n+            }\n@@ -115,0 +132,2 @@\n+        Asserts.assertTrue(foundDisassemblyLine != -1, testCase + \" : no disassembly section found\");\n+        Asserts.assertTrue(foundEntryPointLine != -1, testCase + \" : no entry point found\");\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/DisassembleCodeBlobTest.java","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    protected final Architecture arch;\n@@ -64,1 +65,2 @@\n-        config = new TestHotSpotVMConfig(HotSpotJVMCIRuntime.runtime().getConfigStore());\n+        arch = codeCache.getTarget().arch;\n+        config = new TestHotSpotVMConfig(HotSpotJVMCIRuntime.runtime().getConfigStore(), arch);\n@@ -73,1 +75,0 @@\n-        Architecture arch = codeCache.getTarget().arch;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/CodeInstallationTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import jdk.vm.ci.aarch64.AArch64;\n+import jdk.vm.ci.code.Architecture;\n@@ -30,1 +32,1 @@\n-    public TestHotSpotVMConfig(HotSpotVMConfigStore config) {\n+    public TestHotSpotVMConfig(HotSpotVMConfigStore config, Architecture arch) {\n@@ -32,0 +34,1 @@\n+        ropProtection = (arch instanceof AArch64) ? getFieldValue(\"VM_Version::_rop_protection\", Boolean.class) : false;\n@@ -51,0 +54,2 @@\n+\n+    public final boolean ropProtection;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/TestHotSpotVMConfig.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n@@ -257,0 +257,3 @@\n+        if (config.ropProtection) {\n+            code.emitInt(0xdac103be);  \/\/ pacia x30, x29\n+        }\n@@ -472,0 +475,3 @@\n+        if (config.ropProtection) {\n+            code.emitInt(0xdac113be);  \/\/ autia x30, x29\n+        }\n@@ -480,0 +486,3 @@\n+        if (config.ropProtection) {\n+            code.emitInt(0xdac113be);  \/\/ autia x30, x29\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/aarch64\/AArch64TestAssembler.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import static jdk.vm.ci.meta.MetaUtil.internalNameToJava;\n+import static jdk.vm.ci.meta.MetaUtil.toInternalName;\n@@ -166,3 +168,3 @@\n-    public void internalNameTest() {\n-        \/\/ Verify that the last slash in lambda types are not replaced with a '.' as they\n-        \/\/ are part of the type name.\n+    public void lambdaInternalNameTest() {\n+        \/\/ Verify that the last dot in lambda types is properly handled when transitioning from internal name to java\n+        \/\/ name and vice versa.\n@@ -172,4 +174,3 @@\n-        int typeNameLen = TestResolvedJavaType.class.getSimpleName().length();\n-        int index = typeName.indexOf(TestResolvedJavaType.class.getSimpleName());\n-        String suffix = typeName.substring(index + typeNameLen, typeName.length() - 1);\n-        assertEquals(TestResolvedJavaType.class.getName() + suffix, lambdaType.toJavaName());\n+        String javaName = lambda.getClass().getName();\n+        assertEquals(typeName, toInternalName(javaName));\n+        assertEquals(javaName, internalNameToJava(typeName, true, true));\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n@@ -61,2 +61,2 @@\n- * Examples on how to write tests with IR rules can be found in {@link jdk.test.lib.hotspot.ir_framework.examples.IRExample}\n- * and also as part of the internal testing in {@link jdk.test.lib.hotspot.ir_framework.tests.TestIRMatching}.\n+ * Examples on how to write tests with IR rules can be found in {@link ir_framework.examples.IRExample}\n+ * and also as part of the internal testing in {@link ir_framework.tests.TestIRMatching}.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import compiler.lib.ir_framework.driver.IRMatcher;\n+import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n@@ -118,0 +118,1 @@\n+    public static final String OUTERSTRIPMINEDLOOP = START + \"OuterStripMinedLoop\\\\b\" + MID + END;\n@@ -133,0 +134,1 @@\n+    public static final String DIV_BY_ZERO_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*div0_check\" + END;\n@@ -138,0 +140,1 @@\n+    public static final String SAFEPOINT = START + \"SafePoint\" + MID + END;\n@@ -143,0 +146,1 @@\n+    public static final String AND = START + \"And(I|L)\" + MID + END;\n@@ -147,0 +151,1 @@\n+    public static final String LSHIFT = START + \"LShift(I|L)\" + MID + END;\n@@ -149,0 +154,7 @@\n+    public static final String RSHIFT = START + \"RShift(I|L)\" + MID + END;\n+    public static final String RSHIFT_I = START + \"RShiftI\" + MID + END;\n+    public static final String RSHIFT_L = START + \"RShiftL\" + MID + END;\n+    public static final String URSHIFT = START + \"URShift(B|S|I|L)\" + MID + END;\n+    public static final String URSHIFT_I = START + \"URShiftI\" + MID + END;\n+    public static final String URSHIFT_L = START + \"URShiftL\" + MID + END;\n+    public static final String ADD = START + \"Add(I|L|F|D|P)\" + MID + END;\n@@ -152,0 +164,1 @@\n+    public static final String SUB = START + \"Sub(I|L|F|D)\" + MID + END;\n@@ -156,0 +169,1 @@\n+    public static final String MUL = START + \"Mul(I|L|F|D)\" + MID + END;\n@@ -158,0 +172,2 @@\n+    public static final String DIV = START + \"Div(I|L|F|D)\" + MID + END;\n+    public static final String DIV_L = START + \"DivL\" + MID + END;\n@@ -159,0 +175,1 @@\n+    public static final String CONV_L2I = START + \"ConvL2I\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n@@ -606,1 +608,1 @@\n-                builder.append(errors.toString());\n+                builder.append(errors);\n@@ -610,1 +612,1 @@\n-        System.err.println(builder.toString());\n+        System.err.println(builder);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,504 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver;\n-\n-import compiler.lib.ir_framework.*;\n-import compiler.lib.ir_framework.shared.*;\n-import compiler.lib.ir_framework.test.*;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Method;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Parse the hotspot pid file of the test VM to match all @IR rules.\n- *\/\n-public class IRMatcher {\n-    public static final String SAFEPOINT_WHILE_PRINTING_MESSAGE = \"<!-- safepoint while printing -->\";\n-\n-    private static final boolean PRINT_IR_ENCODING = Boolean.parseBoolean(System.getProperty(\"PrintIREncoding\", \"false\"));\n-    private static final Pattern IR_ENCODING_PATTERN =\n-            Pattern.compile(\"(?<=\" + IREncodingPrinter.START + \"\\r?\\n)[\\\\s\\\\S]*(?=\" + IREncodingPrinter.END + \")\");\n-    private static final Pattern COMPILE_ID_PATTERN = Pattern.compile(\"compile_id='(\\\\d+)'\");\n-\n-    private final Map<String, IRMethod> compilations;\n-    private final Class<?> testClass;\n-    private final Map<Method, List<String>> fails;\n-    private final Pattern compileIdPatternForTestClass;\n-    private final String hotspotPidFileName;\n-    private IRMethod irMethod; \/\/ Current IR method to which rules are applied\n-    private Method method; \/\/ Current method to which rules are applied\n-    private IR irAnno; \/\/ Current IR annotation that is processed.\n-    private int irRuleIndex; \/\/ Current IR rule index;\n-\n-    public IRMatcher(String hotspotPidFileName, String irEncoding, Class<?> testClass) {\n-        this.compilations = new HashMap<>();\n-        this.fails = new HashMap<>();\n-        this.testClass = testClass;\n-        this.compileIdPatternForTestClass = Pattern.compile(\"compile_id='(\\\\d+)'.*\" + Pattern.quote(testClass.getCanonicalName())\n-                                                            + \" (\\\\S+)\");\n-        this.hotspotPidFileName = hotspotPidFileName;\n-        setupTestMethods(irEncoding);\n-        if (TestFramework.VERBOSE || PRINT_IR_ENCODING) {\n-            System.out.println(\"Read IR encoding from test VM:\");\n-            System.out.println(irEncoding);\n-        }\n-        if (!compilations.isEmpty()) {\n-            parseHotspotPidFile();\n-            applyRules();\n-        }\n-    }\n-\n-    \/**\n-     * Sets up a map testname -> IRMethod (containing the PrintIdeal and PrintOptoAssembly output for testname).\n-     *\/\n-    private void setupTestMethods(String irEncoding) {\n-        Map<String, int[]> irRulesMap = parseIREncoding(irEncoding);\n-        for (Method m : testClass.getDeclaredMethods()) {\n-            method = m;\n-            IR[] irAnnos = m.getAnnotationsByType(IR.class);\n-            if (irAnnos.length > 0) {\n-                \/\/ Validation of legal @IR attributes and placement of the annotation was already done in Test VM.\n-                int[] ids = irRulesMap.get(m.getName());\n-                TestFramework.check(ids != null, \"Should find method name in validIrRulesMap for \" + m);\n-                TestFramework.check(ids.length > 0, \"Did not find any rule indices for \" + m);\n-                TestFramework.check(ids[ids.length - 1] < irAnnos.length, \"Invalid IR rule index found in validIrRulesMap for \" + m);\n-                if (ids[0] != IREncodingPrinter.NO_RULE_APPLIED) {\n-                    \/\/ If -1, than there was no matching IR rule for the given conditions.\n-                    compilations.put(m.getName(), new IRMethod(m, ids, irAnnos));\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Read the IR encoding emitted by the test VM to decide if an @IR rule must be checked for a method.\n-     *\/\n-    private Map<String, int[]> parseIREncoding(String irEncoding) {\n-        Map<String, int[]> irRulesMap = new HashMap<>();\n-        Matcher matcher = IR_ENCODING_PATTERN.matcher(irEncoding);\n-        TestFramework.check(matcher.find(), \"Did not find IR encoding\");\n-        String[] lines = matcher.group(0).split(\"\\\\R\");\n-\n-        \/\/ Skip first line containing information about the format only\n-        for (int i = 1; i < lines.length; i++) {\n-            String line = lines[i].trim();\n-            String[] splitComma = line.split(\",\");\n-            if (splitComma.length < 2) {\n-                throw new TestFrameworkException(\"Invalid IR match rule encoding. No comma found: \" + splitComma[0]);\n-            }\n-            String testName = splitComma[0];\n-            int[] irRulesIdx = new int[splitComma.length - 1];\n-            for (int j = 1; j < splitComma.length; j++) {\n-                try {\n-                    irRulesIdx[j - 1] = Integer.parseInt(splitComma[j]);\n-                } catch (NumberFormatException e) {\n-                    throw new TestFrameworkException(\"Invalid IR match rule encoding. No number found: \" + splitComma[j]);\n-                }\n-            }\n-            irRulesMap.put(testName, irRulesIdx);\n-        }\n-        return irRulesMap;\n-    }\n-\n-    \/**\n-     * Parse the hotspot_pid*.log file from the test VM. Read the PrintIdeal and PrintOptoAssembly entries for all\n-     * methods of the test class that need to be IR matched (according to IR encoding).\n-     *\/\n-    private void parseHotspotPidFile() {\n-        Map<Integer, String> compileIdMap = new HashMap<>();\n-        try (var br = Files.newBufferedReader(Paths.get(hotspotPidFileName))) {\n-            String line;\n-            StringBuilder builder = new StringBuilder();\n-            boolean append = false;\n-            String currentMethod = \"\";\n-            while ((line = br.readLine()) != null) {\n-                if (append && line.startsWith(\"<\/\")) {\n-                    flushOutput(line, builder, currentMethod);\n-                    append = false;\n-                    currentMethod = \"\";\n-                    continue;\n-                } else if (append) {\n-                    appendLine(builder, line);\n-                    continue;\n-                }\n-\n-                if (maybeTestEntry(line)) {\n-                    addTestMethodCompileId(compileIdMap, line);\n-                } else if (isPrintIdealStart(line)) {\n-                    String methodName = getMethodName(compileIdMap, line);\n-                    if (methodName != null) {\n-                        currentMethod = methodName;\n-                        append = true; \/\/ Append all following lines until we hit the closing <\/ideal> tag.\n-                    }\n-                } else if (isPrintOptoAssemblyStart(line)) {\n-                    String methodName = getMethodName(compileIdMap, line);\n-                    if (methodName != null) {\n-                        TestFramework.check(compilations.containsKey(methodName), \"Must be second entry of \" + methodName);\n-                        currentMethod = methodName;\n-                        append = true; \/\/ Append all following lines until we hit the closing <\/opto_assembly> tag.\n-                    }\n-                }\n-            }\n-        } catch (IOException e) {\n-            throw new TestFrameworkException(\"Error while reading \" + hotspotPidFileName, e);\n-        }\n-    }\n-\n-    \/**\n-     * Write the input to the IR method and reset the builder.\n-     *\/\n-    private void flushOutput(String line, StringBuilder builder, String currentMethod) {\n-        TestFramework.check(!currentMethod.isEmpty(), \"current method must be set\");\n-        IRMethod irMethod = compilations.get(currentMethod);\n-        if (line.startsWith(\"<\/i\")) {\n-            \/\/ PrintIdeal\n-            irMethod.setIdealOutput(builder.toString());\n-        } else {\n-            \/\/ PrintOptoAssembly\n-            irMethod.setOptoAssemblyOutput(builder.toString());\n-        }\n-        builder.setLength(0);\n-    }\n-\n-    \/**\n-     * Only consider non-osr (no \"compile_kind\") and compilations with C2 (no \"level\")\n-     *\/\n-    private boolean maybeTestEntry(String line) {\n-        return line.startsWith(\"<task_queued\") && !line.contains(\"compile_kind='\") && !line.contains(\"level='\");\n-    }\n-\n-    \/**\n-     * Need to escape XML special characters.\n-     *\/\n-    private static void appendLine(StringBuilder builder, String line) {\n-        if (line.contains(\"&\")) {\n-            line = line.replace(\"&lt;\", \"<\");\n-            line = line.replace(\"&gt;\", \">\");\n-            line = line.replace(\"&quot;\", \"\\\"\");\n-            line = line.replace(\"&apos;\", \"'\");\n-            line = line.replace(\"&amp;\", \"&\");\n-        }\n-        builder.append(line).append(System.lineSeparator());\n-    }\n-\n-    private static int getCompileId(Matcher matcher) {\n-        int compileId;\n-        try {\n-            compileId = Integer.parseInt(matcher.group(1));\n-        } catch (NumberFormatException e) {\n-            throw new TestRunException(\"Could not parse compile id\", e);\n-        }\n-        return compileId;\n-    }\n-\n-    \/**\n-     * Parse the compile id from this line if it belongs to a method that needs to be IR tested (part of test class\n-     * and IR encoding from the test VM specifies that this method has @IR rules to be checked).\n-     *\/\n-    private void addTestMethodCompileId(Map<Integer, String> compileIdMap, String line) {\n-        Matcher matcher = compileIdPatternForTestClass.matcher(line);\n-        if (matcher.find()) {\n-            \/\/ Only care about test class entries. Might have non-class entries as well if user specified additional\n-            \/\/ compile commands. Ignore these.\n-            String methodName = matcher.group(2);\n-            if (compilations.containsKey(methodName)) {\n-                \/\/ We only care about methods that we are actually gonna IR match based on IR encoding.\n-                int compileId = getCompileId(matcher);\n-                TestRun.check(!methodName.isEmpty(), \"method name cannot be empty\");\n-                compileIdMap.put(compileId, methodName);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Make sure that line does not contain compile_kind which is used for OSR compilations which we are not\n-     * interested in.\n-     *\/\n-    private static boolean isPrintIdealStart(String line) {\n-        return line.startsWith(\"<ideal\") && !line.contains(\"compile_kind='\");\n-    }\n-\n-    \/**\n-     * Make sure that line does not contain compile_kind which is used for OSR compilations which we are not\n-     * interested in.\n-     *\/\n-    private static boolean isPrintOptoAssemblyStart(String line) {\n-        return line.startsWith(\"<opto_assembly\") && !line.contains(\"compile_kind='\");\n-    }\n-\n-    \/**\n-     * Get method name for this line by looking up the compile id.\n-     * Returns null if not an interesting method (i.e. from test class).\n-     *\/\n-    private String getMethodName(Map<Integer, String> compileIdMap, String line) {\n-        Matcher matcher = COMPILE_ID_PATTERN.matcher(line);\n-        TestFramework.check(matcher.find(), \"Is \" + hotspotPidFileName + \" corrupted?\");\n-        int compileId = getCompileId(matcher);\n-        return compileIdMap.get(compileId);\n-    }\n-\n-    \/**\n-     * Do an IR matching of all methods with appliable @IR rules fetched during parsing of the hotspot pid file.\n-     *\/\n-    private void applyRules() {\n-        compilations.values().forEach(this::applyRulesForMethod);\n-        reportFailuresIfAny();\n-    }\n-\n-    private void applyRulesForMethod(IRMethod irMethod) {\n-        this.irMethod = irMethod;\n-        method = irMethod.getMethod();\n-        String testOutput = irMethod.getOutput();\n-        if (testOutput.isEmpty()) {\n-            String msg = \"Method was not compiled. Did you specify any compiler directives preventing a compilation or used a \" +\n-                         \"@Run method in STANDALONE mode? In the latter case, make sure to always trigger a C2 compilation \" +\n-                         \"by invoking the test enough times.\";\n-            fails.computeIfAbsent(method, k -> new ArrayList<>()).add(msg);\n-            return;\n-        }\n-\n-        if (TestFramework.VERBOSE) {\n-            System.out.println(\"Output of \" + method + \":\");\n-            System.out.println(testOutput);\n-        }\n-        Arrays.stream(irMethod.getRuleIds()).forEach(this::applyIRRule);\n-    }\n-\n-    \/**\n-     * Apply a single @IR rule as part of a method.\n-     *\/\n-    private void applyIRRule(int id) {\n-        irAnno = irMethod.getIrAnno(id);\n-        irRuleIndex = id;\n-        StringBuilder failMsg = new StringBuilder();\n-        applyFailOn(failMsg);\n-        try {\n-            applyCounts(failMsg);\n-        } catch (TestFormatException e) {\n-            \/\/ Logged. Continue to check other rules.\n-        }\n-        if (!failMsg.isEmpty()) {\n-            failMsg.insert(0, \"@IR rule \" + (id + 1) + \": \\\"\" + irAnno + \"\\\"\" + System.lineSeparator());\n-            fails.computeIfAbsent(method, k -> new ArrayList<>()).add(failMsg.toString());\n-        }\n-    }\n-\n-    \/**\n-     * Apply the failOn regexes of the @IR rule.\n-     *\/\n-    private void applyFailOn(StringBuilder failMsg) {\n-        if (irAnno.failOn().length != 0) {\n-            String failOnRegex = String.join(\"|\", IRNode.mergeNodes(irAnno.failOn()));\n-            Pattern pattern = Pattern.compile(failOnRegex);\n-            Matcher matcher = pattern.matcher(irMethod.getOutput());\n-            long matchCount = matcher.results().count();\n-            if (matchCount > 0) {\n-                addFailOnFailsForOutput(failMsg, pattern, matchCount);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * A failOn regex failed. Apply all regexes again to log the exact regex which failed. The failure is later reported\n-     * to the user.\n-     *\/\n-    private void addFailOnFailsForOutput(StringBuilder failMsg, Pattern pattern, long matchCount) {\n-        long idealCount = pattern.matcher(irMethod.getIdealOutput()).results().count();\n-        long optoAssemblyCount = pattern.matcher(irMethod.getOptoAssemblyOutput()).results().count();\n-        if (matchCount != idealCount + optoAssemblyCount || (idealCount != 0 && optoAssemblyCount != 0)) {\n-            \/\/ Report with Ideal and Opto Assembly\n-            addFailOnFailsForOutput(failMsg, irMethod.getOutput());\n-            irMethod.needsAllOutput();\n-        } else if (optoAssemblyCount == 0) {\n-            \/\/ Report with Ideal only\n-            addFailOnFailsForOutput(failMsg, irMethod.getIdealOutput());\n-            irMethod.needsIdeal();\n-        } else {\n-            \/\/ Report with Opto Assembly only\n-            addFailOnFailsForOutput(failMsg, irMethod.getOptoAssemblyOutput());\n-            irMethod.needsOptoAssembly();\n-        }\n-    }\n-\n-    \/**\n-     * Apply the regexes to the testOutput and log the failures.\n-     *\/\n-    private void addFailOnFailsForOutput(StringBuilder failMsg, String testOutput) {\n-        List<String> failOnNodes = IRNode.mergeNodes(irAnno.failOn());\n-        Pattern pattern;\n-        Matcher matcher;\n-        failMsg.append(\"- failOn: Graph contains forbidden nodes:\").append(System.lineSeparator());\n-        int nodeId = 1;\n-        for (String nodeRegex : failOnNodes) {\n-            pattern = Pattern.compile(nodeRegex);\n-            matcher = pattern.matcher(testOutput);\n-            long matchCount = matcher.results().count();\n-            if (matchCount > 0) {\n-                matcher.reset();\n-                failMsg.append(\"    Regex \").append(nodeId).append(\": \").append(nodeRegex).append(System.lineSeparator());\n-                failMsg.append(\"    Matched forbidden node\").append(matchCount > 1 ? \"s (\" + matchCount + \")\" : \"\")\n-                       .append(\":\").append(System.lineSeparator());\n-                matcher.results().forEach(r -> failMsg.append(\"      \").append(r.group()).append(System.lineSeparator()));\n-            }\n-            nodeId++;\n-        }\n-    }\n-\n-    \/**\n-     * Apply the counts regexes of the @IR rule.\n-     *\/\n-    private void applyCounts(StringBuilder failMsg) {\n-        if (irAnno.counts().length != 0) {\n-            boolean hasFails = false;\n-            String testOutput = irMethod.getOutput();\n-            int countsId = 1;\n-            final List<String> nodesWithCount = IRNode.mergeNodes(irAnno.counts());\n-            for (int i = 0; i < nodesWithCount.size(); i += 2) {\n-                String node = nodesWithCount.get(i);\n-                TestFormat.check(i + 1 < nodesWithCount.size(), \"Missing count\" + getPostfixErrorMsg(node));\n-                String countString = nodesWithCount.get(i + 1);\n-                long expectedCount;\n-                ParsedComparator<Long> parsedComparator;\n-                try {\n-                    parsedComparator = ParsedComparator.parseComparator(countString);\n-                    expectedCount = Long.parseLong(parsedComparator.getStrippedString());\n-                } catch (NumberFormatException e) {\n-                    TestFormat.fail(\"Provided invalid count \\\"\" + countString + \"\\\"\" + getPostfixErrorMsg(node));\n-                    return;\n-                } catch (CheckedTestFrameworkException e) {\n-                    TestFormat.fail(\"Invalid comparator \\\"\" + e.getMessage() + \"\\\" in \\\"\" + countString + \"\\\" for count\" + getPostfixErrorMsg(node));\n-                    return;\n-                } catch (IndexOutOfBoundsException e) {\n-                    TestFormat.fail(\"Provided empty value\" + getPostfixErrorMsg(node));\n-                    return;\n-                }\n-                TestFormat.check(expectedCount >= 0,\"Provided invalid negative count \\\"\" + countString + \"\\\"\" + getPostfixErrorMsg(node));\n-\n-                Pattern pattern = Pattern.compile(node);\n-                Matcher matcher = pattern.matcher(testOutput);\n-                long actualCount = matcher.results().count();\n-                if (!parsedComparator.getPredicate().test(actualCount, expectedCount)) {\n-                    if (!hasFails) {\n-                        failMsg.append(\"- counts: Graph contains wrong number of nodes:\").append(System.lineSeparator());\n-                        hasFails = true;\n-                    }\n-                    addCountsFail(failMsg, node, pattern, expectedCount, actualCount, countsId);\n-                }\n-                countsId++;\n-            }\n-        }\n-    }\n-\n-    private String getPostfixErrorMsg(String node) {\n-        return \" for IR rule \" + irRuleIndex + \", node \\\"\" + node + \"\\\" at \" + method;\n-    }\n-\n-    \/**\n-     * A counts regex failed. Apply all regexes again to log the exact regex which failed. The failure is later reported\n-     * to the user.\n-     *\/\n-    private void addCountsFail(StringBuilder failMsg, String node, Pattern pattern, long expectedCount, long actualCount, int countsId) {\n-        failMsg.append(\"    Regex \").append(countsId).append(\": \").append(node).append(System.lineSeparator());\n-        failMsg.append(\"    Expected \").append(expectedCount).append(\" but found \").append(actualCount);\n-\n-        if (actualCount > 0) {\n-            Matcher matcher = pattern.matcher(irMethod.getOutput());\n-            long idealCount = pattern.matcher(irMethod.getIdealOutput()).results().count();\n-            long optoAssemblyCount = pattern.matcher(irMethod.getOptoAssemblyOutput()).results().count();\n-            if (actualCount != idealCount + optoAssemblyCount || (idealCount != 0 && optoAssemblyCount != 0)) {\n-                irMethod.needsAllOutput();\n-            } else if (optoAssemblyCount == 0) {\n-                irMethod.needsIdeal();\n-            } else {\n-                irMethod.needsOptoAssembly();\n-            }\n-            failMsg.append(\" node\").append(actualCount > 1 ? \"s\" : \"\").append(\":\").append(System.lineSeparator());\n-            matcher.results().forEach(r -> failMsg.append(\"      \").append(r.group()).append(System.lineSeparator()));\n-        } else {\n-            irMethod.needsAllOutput();\n-            failMsg.append(\" nodes.\").append(System.lineSeparator());\n-        }\n-    }\n-\n-    \/**\n-     * Report all IR violations in a pretty format to the user. Depending on the failed regex, we only report\n-     * PrintIdeal or PrintOptoAssembly if the match failed there. If there were failures that matched things\n-     * in both outputs than the entire output is reported. Throws IRViolationException from which the compilation\n-     * can be read and reported to the stdout separately. The exception message only includes the summary of the\n-     * failures.\n-     *\/\n-    private void reportFailuresIfAny() {\n-        TestFormat.reportIfAnyFailures();\n-        if (!fails.isEmpty()) {\n-            StringBuilder failuresBuilder = new StringBuilder();\n-            StringBuilder compilationsBuilder = new StringBuilder();\n-            int failures = 0;\n-            for (Map.Entry<Method, List<String>> entry : fails.entrySet()) {\n-                Method method = entry.getKey();\n-                compilationsBuilder.append(\">>> Compilation of \").append(method).append(\":\").append(System.lineSeparator());\n-                IRMethod irMethod = compilations.get(method.getName());\n-                String output;\n-                if (irMethod.usesIdeal() && irMethod.usesOptoAssembly()) {\n-                    output = irMethod.getOutput();\n-                } else if (irMethod.usesIdeal()) {\n-                    output = irMethod.getIdealOutput();\n-                } else if (irMethod.usesOptoAssembly()) {\n-                    output = irMethod.getOptoAssemblyOutput();\n-                } else {\n-                    output = \"<empty>\";\n-                }\n-                compilationsBuilder.append(output).append(System.lineSeparator()).append(System.lineSeparator());\n-                List<String> list = entry.getValue();\n-                failuresBuilder.append(\"- Method \\\"\").append(method).append(\"\\\":\").append(System.lineSeparator());\n-                failures += list.size();\n-                list.forEach(s -> failuresBuilder.append(\"  * \")\n-                                                 .append(s.replace(System.lineSeparator(),\n-                                                                   System.lineSeparator() + \"    \").trim())\n-                                                 .append(System.lineSeparator()));\n-                failuresBuilder.append(System.lineSeparator());\n-            }\n-            failuresBuilder.insert(0, (\"One or more @IR rules failed:\" + System.lineSeparator()\n-                                       + System.lineSeparator() + \"Failed IR Rules (\" + failures + \")\"\n-                                       + System.lineSeparator()) + \"-----------------\"\n-                                       + \"-\".repeat(String.valueOf(failures).length()) + System.lineSeparator());\n-            failuresBuilder.append(\">>> Check stdout for compilation output of the failed methods\")\n-                           .append(System.lineSeparator()).append(System.lineSeparator());\n-\n-            \/\/ In some very rare cases, the VM output to regex match on contains \"<!-- safepoint while printing -->\"\n-            \/\/ (emitted by ttyLocker::break_tty_for_safepoint) which might be the reason for a matching error.\n-            \/\/ Do not throw an exception in this case (i.e. bailout).\n-            String compilations = compilationsBuilder.toString();\n-            if (!compilations.contains(SAFEPOINT_WHILE_PRINTING_MESSAGE)) {\n-                throw new IRViolationException(failuresBuilder.toString(), compilations);\n-            } else {\n-                System.out.println(\"Found \" + SAFEPOINT_WHILE_PRINTING_MESSAGE + \", bail out of IR matching\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRMatcher.java","additions":0,"deletions":504,"binary":false,"changes":504,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver;\n-\n-import compiler.lib.ir_framework.IR;\n-\n-import java.lang.reflect.Method;\n-\n-\/**\n- * Helper class to store information about a method that needs to be IR matched.\n- *\/\n-class IRMethod {\n-    private final Method method;\n-    private final int[] ruleIds;\n-    private final IR[] irAnnos;\n-    private final StringBuilder outputBuilder;\n-    private String output;\n-    private String idealOutput;\n-    private String optoAssemblyOutput;\n-    private boolean needsIdeal;\n-    private boolean needsOptoAssembly;\n-\n-    public IRMethod(Method method, int[] ruleIds, IR[] irAnnos) {\n-        this.method = method;\n-        this.ruleIds = ruleIds;\n-        this.irAnnos = irAnnos;\n-        this.outputBuilder = new StringBuilder();\n-        this.output = \"\";\n-        this.idealOutput = \"\";\n-        this.optoAssemblyOutput = \"\";\n-    }\n-\n-    public Method getMethod() {\n-        return method;\n-    }\n-\n-    public int[] getRuleIds() {\n-        return ruleIds;\n-    }\n-\n-    public IR getIrAnno(int idx) {\n-        return irAnnos[idx];\n-    }\n-\n-    \/**\n-     * The Ideal output comes always before the Opto Assembly output. We might parse multiple C2 compilations of this method.\n-     * Only keep the very last one by overriding 'output'.\n-     *\/\n-    public void setIdealOutput(String idealOutput) {\n-        outputBuilder.setLength(0);\n-        this.idealOutput = \"PrintIdeal:\" + System.lineSeparator() + idealOutput;\n-        outputBuilder.append(this.idealOutput);\n-    }\n-\n-    \/**\n-     * The Opto Assembly output comes after the Ideal output. Simply append to 'output'.\n-     *\/\n-    public void setOptoAssemblyOutput(String optoAssemblyOutput) {\n-        this.optoAssemblyOutput = \"PrintOptoAssembly:\" + System.lineSeparator() + optoAssemblyOutput;\n-        outputBuilder.append(System.lineSeparator()).append(System.lineSeparator()).append(this.optoAssemblyOutput);\n-        output = outputBuilder.toString();\n-    }\n-\n-    public String getOutput() {\n-        return output;\n-    }\n-\n-    public String getIdealOutput() {\n-        return idealOutput;\n-    }\n-\n-    public String getOptoAssemblyOutput() {\n-        return optoAssemblyOutput;\n-    }\n-\n-    public void needsAllOutput() {\n-        needsIdeal();\n-        needsOptoAssembly();\n-    }\n-\n-    public void needsIdeal() {\n-        needsIdeal = true;\n-    }\n-\n-    public boolean usesIdeal() {\n-        return needsIdeal;\n-    }\n-\n-    public void needsOptoAssembly() {\n-        needsOptoAssembly = true;\n-    }\n-\n-    public boolean usesOptoAssembly() {\n-        return needsOptoAssembly;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRMethod.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,1 +197,1 @@\n-                System.out.println(testListBuilder.toString());\n+                System.out.println(testListBuilder);\n@@ -203,1 +203,1 @@\n-                System.out.println(messagesBuilder.toString());\n+                System.out.println(messagesBuilder);\n@@ -229,1 +229,1 @@\n-        if (stdErr.contains(\"TestFormat.reportIfAnyFailures\")) {\n+        if (stdErr.contains(\"TestFormat.throwIfAnyFailures\")) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Class to build the compilation output of IR matching failures.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+class CompilationOutputBuilder {\n+\n+    public static String build(List<IRMethodMatchResult> results) {\n+        StringBuilder compilationsBuilder = new StringBuilder();\n+        for (IRMethodMatchResult result : results) {\n+            if (result.fail()) {\n+                compilationsBuilder.append(buildMatchedCompilationMessage(result));\n+            }\n+        }\n+        return compilationsBuilder.toString();\n+    }\n+\n+    private static String buildMatchedCompilationMessage(IRMethodMatchResult result) {\n+        return result.getMatchedCompilationOutput() + System.lineSeparator() + System.lineSeparator();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/CompilationOutputBuilder.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.parser.IRMethodParser;\n+\n+import java.util.*;\n+\n+\/**\n+ * This class parses the hotspot_pid* file of the test VM to match all applicable @IR rules afterwards.\n+ *\/\n+public class IRMatcher {\n+    public static final String SAFEPOINT_WHILE_PRINTING_MESSAGE = \"<!-- safepoint while printing -->\";\n+\n+    public IRMatcher(String hotspotPidFileName, String irEncoding, Class<?> testClass) {\n+        IRMethodParser irMethodParser = new IRMethodParser(testClass);\n+        Collection<IRMethod> irMethods = irMethodParser.parse(hotspotPidFileName, irEncoding);\n+        if (irMethods != null) {\n+            applyIRRules(irMethods);\n+        }\n+    }\n+\n+    \/**\n+     * Do an IR matching of all methods with applicable @IR rules prepared with by the {@link IRMethodParser}.\n+     *\/\n+    private void applyIRRules(Collection<IRMethod> irMethods) {\n+        List<IRMethodMatchResult> results = new ArrayList<>();\n+        irMethods.forEach(irMethod -> applyIRRule(irMethod, results));\n+        if (!results.isEmpty()) {\n+            reportFailures(results);\n+        }\n+    }\n+\n+    private void applyIRRule(IRMethod irMethod, List<IRMethodMatchResult> results) {\n+        if (TestFramework.VERBOSE) {\n+            printMethodOutput(irMethod);\n+        }\n+        IRMethodMatchResult result = irMethod.applyIRRules();\n+        if (result.fail()) {\n+            results.add(result);\n+        }\n+    }\n+\n+    private void printMethodOutput(IRMethod irMethod) {\n+        System.out.println(\"Output of \" + irMethod.getOutput() + \":\");\n+        System.out.println(irMethod.getOutput());\n+    }\n+\n+    \/**\n+     * Report all IR violations in a pretty format to the user. Depending on the failed regex, we only report\n+     * PrintIdeal or PrintOptoAssembly if the match failed there. If there were failures that matched things\n+     * in both outputs then the entire output is reported. Throws IRViolationException from which the compilation\n+     * can be read and reported to the stdout separately. The exception message only includes the summary of the\n+     * failures.\n+     *\/\n+    private void reportFailures(List<IRMethodMatchResult> results) {\n+        Collections.sort(results); \/\/ Alphabetically\n+        throwIfNoSafepointWhilePrinting(IRMatcherFailureMessageBuilder.build(results),\n+                                        CompilationOutputBuilder.build(results));\n+    }\n+\n+    \/\/ In some very rare cases, the VM output to regex match on contains \"<!-- safepoint while printing -->\"\n+    \/\/ (emitted by ttyLocker::break_tty_for_safepoint) which might be the reason for a matching error.\n+    \/\/ Do not throw an exception in this case (i.e. bailout).\n+    private void throwIfNoSafepointWhilePrinting(String failures, String compilations) {\n+        if (!compilations.contains(SAFEPOINT_WHILE_PRINTING_MESSAGE)) {\n+            throw new IRViolationException(failures, compilations);\n+        } else {\n+            System.out.println(\"Found \" + SAFEPOINT_WHILE_PRINTING_MESSAGE + \", bail out of IR matching\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/IRMatcher.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Class to build the failure message output of IR matching failures.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+class IRMatcherFailureMessageBuilder {\n+\n+    public static String build(List<IRMethodMatchResult> results) {\n+        StringBuilder failuresBuilder = new StringBuilder();\n+        failuresBuilder.append(buildHeaderMessage(results));\n+        int failureNumber = 1;\n+        for (IRMethodMatchResult irMethodResult : results) {\n+            if (irMethodResult.fail()) {\n+                failuresBuilder.append(buildIRMethodFailureMessage(failureNumber, irMethodResult));\n+                failureNumber++;\n+            }\n+        }\n+        failuresBuilder.append(buildFooterMessage());\n+        return failuresBuilder.toString();\n+    }\n+\n+    private static String buildHeaderMessage(List<IRMethodMatchResult> results) {\n+        int failedIRRulesCount = getFailedIRRulesCount(results);\n+        long failedMethodCount = getFailedMethodCount(results);\n+        return \"One or more @IR rules failed:\" + System.lineSeparator() + System.lineSeparator()\n+               + \"Failed IR Rules (\" + failedIRRulesCount + \") of Methods (\" + failedMethodCount + \")\"\n+               + System.lineSeparator()\n+               +  \"-\".repeat(32 + digitCount(failedIRRulesCount) + digitCount(failedMethodCount))\n+               + System.lineSeparator();\n+    }\n+\n+    private static int getFailedIRRulesCount(List<IRMethodMatchResult> results) {\n+        return results.stream().map(IRMethodMatchResult::getFailedIRRuleCount).reduce(0, Integer::sum);\n+    }\n+\n+    private static long getFailedMethodCount(List<IRMethodMatchResult> results) {\n+        return results.stream().filter(IRMethodMatchResult::fail).count();\n+    }\n+\n+    private static int digitCount(long digit) {\n+        return String.valueOf(digit).length();\n+    }\n+\n+    private static String buildIRMethodFailureMessage(int failureNumber, IRMethodMatchResult result) {\n+        return failureNumber + \")\" + result.buildFailureMessage() + System.lineSeparator();\n+    }\n+\n+    private static String buildFooterMessage() {\n+        return \">>> Check stdout for compilation output of the failed methods\" + System.lineSeparator() + System.lineSeparator();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/IRMatcherFailureMessageBuilder.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package compiler.lib.ir_framework.driver;\n+package compiler.lib.ir_framework.driver.irmatching;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/IRViolationException.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRViolationException.java","status":"renamed"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+\/**\n+ * Interface used by all classes which represent a IR match result. A result should also provide a failure message\n+ * in a pretty format to be used by the {@link IRMatcher}.\n+ *\/\n+public interface MatchResult {\n+    \/**\n+     * Does this match result represent a failure?\n+     *\/\n+    boolean fail();\n+\n+    \/**\n+     * Builds a failure message in a pretty format to be used by the IR matching failure reporting.\n+     *\/\n+    String buildFailureMessage();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/MatchResult.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+\/**\n+ * Enum to describe what kind of compilation output that was matched for a method during IR matching.\n+ *\n+ * @see IRRuleMatchResult\n+ *\/\n+public enum OutputMatch {\n+    \/**\n+     * There was no compilation output. Should not happen and results in a failure.\n+     *\/\n+    NONE,\n+    \/**\n+     * Matched on PrintIdeal.\n+     *\/\n+    IDEAL,\n+    \/**\n+     * Matched on PrintOptoAssembly.\n+     *\/\n+    OPTO_ASSEMBLY,\n+    \/**\n+     * Matched on PrintIdeal and PrintOptoAssembly.\n+     *\/\n+    BOTH\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/OutputMatch.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Base class to build the failure message output for an IR method.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+abstract class FailureMessageBuilder {\n+    protected final IRMethod irMethod;\n+\n+    public FailureMessageBuilder(IRMethod irMethod) {\n+        this.irMethod = irMethod;\n+    }\n+\n+    abstract public String build();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/FailureMessageBuilder.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRule;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Helper class to store information about a method that needs to be IR matched.\n+ *\/\n+public class IRMethod {\n+    private final Method method;\n+    private final List<IRRule> irRules;\n+    private final StringBuilder outputBuilder;\n+    private String output;\n+    private String idealOutput;\n+    private String optoAssemblyOutput;\n+\n+    public IRMethod(Method method, int[] ruleIds, IR[] irAnnos) {\n+        this.method = method;\n+        this.irRules = new ArrayList<>();\n+        for (int i : ruleIds) {\n+            irRules.add(new IRRule(this, i, irAnnos[i - 1]));\n+        }\n+        this.outputBuilder = new StringBuilder();\n+        this.output = \"\";\n+        this.idealOutput = \"\";\n+        this.optoAssemblyOutput = \"\";\n+    }\n+\n+    public Method getMethod() {\n+        return method;\n+    }\n+\n+\n+    \/**\n+     * The Ideal output comes always before the Opto Assembly output. We might parse multiple C2 compilations of this method.\n+     * Only keep the very last one by overriding 'output'.\n+     *\/\n+    public void setIdealOutput(String idealOutput) {\n+        outputBuilder.setLength(0);\n+        this.idealOutput = \"PrintIdeal:\" + System.lineSeparator() + idealOutput;\n+        outputBuilder.append(this.idealOutput);\n+    }\n+\n+    \/**\n+     * The Opto Assembly output comes after the Ideal output. Simply append to 'output'.\n+     *\/\n+    public void setOptoAssemblyOutput(String optoAssemblyOutput) {\n+        this.optoAssemblyOutput = \"PrintOptoAssembly:\" + System.lineSeparator() + optoAssemblyOutput;\n+        outputBuilder.append(System.lineSeparator()).append(System.lineSeparator()).append(this.optoAssemblyOutput);\n+        output = outputBuilder.toString();\n+    }\n+\n+    public String getOutput() {\n+        return output;\n+    }\n+\n+    public String getIdealOutput() {\n+        return idealOutput;\n+    }\n+\n+    public String getOptoAssemblyOutput() {\n+        return optoAssemblyOutput;\n+    }\n+\n+    \/**\n+     * Apply all IR rules of this IR method.\n+     *\/\n+    public IRMethodMatchResult applyIRRules() {\n+        TestFramework.check(!irRules.isEmpty(), \"IRMethod cannot be created if there are no IR rules to apply\");\n+        List<IRRuleMatchResult> results = new ArrayList<>();\n+        if (!output.isEmpty()) {\n+            return getNormalMatchResult(results);\n+        } else {\n+            return new MissingCompilationResult(this, irRules.size());\n+        }\n+    }\n+\n+    private NormalMatchResult getNormalMatchResult(List<IRRuleMatchResult> results) {\n+        for (IRRule irRule : irRules) {\n+            IRRuleMatchResult result = irRule.applyCheckAttribute();\n+            if (result.fail()) {\n+                results.add(result);\n+            }\n+        }\n+        return new NormalMatchResult(this, results);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/IRMethod.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+\/**\n+ * This base class represents an IR matching result of all IR rules of a method.\n+ *\n+ * @see IRRuleMatchResult\n+ * @see IRMethod\n+ *\/\n+abstract public class IRMethodMatchResult implements Comparable<IRMethodMatchResult>, MatchResult {\n+    protected final IRMethod irMethod;\n+\n+    IRMethodMatchResult(IRMethod irMethod) {\n+        this.irMethod = irMethod;\n+    }\n+\n+    abstract public String getMatchedCompilationOutput();\n+\n+    abstract public int getFailedIRRuleCount();\n+\n+    \/**\n+     * Used to sort the failed IR methods alphabetically.\n+     *\/\n+    @Override\n+    public int compareTo(IRMethodMatchResult other) {\n+        return this.irMethod.getMethod().getName().compareTo(other.irMethod.getMethod().getName());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/IRMethodMatchResult.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.OutputMatch;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+\n+import java.util.List;\n+\n+\/**\n+ * Class to build the compilation output for an IR method.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+class MatchedCompilationOutputBuilder {\n+    private final IRMethod irMethod;\n+    private final OutputMatch outputMatch;\n+\n+    public MatchedCompilationOutputBuilder(IRMethod irMethod, List<IRRuleMatchResult> irRulesMatchResults) {\n+        this.irMethod = irMethod;\n+        this.outputMatch = getOutputMatch(irRulesMatchResults);\n+    }\n+\n+    private OutputMatch getOutputMatch(List<IRRuleMatchResult> irRulesMatchResults) {\n+        OutputMatch outputMatch;\n+        if (allMatchesOn(irRulesMatchResults, OutputMatch.IDEAL)) {\n+            outputMatch = OutputMatch.IDEAL;\n+        } else if (allMatchesOn(irRulesMatchResults, OutputMatch.OPTO_ASSEMBLY)) {\n+            outputMatch = OutputMatch.OPTO_ASSEMBLY;\n+        } else {\n+            outputMatch = OutputMatch.BOTH;\n+        }\n+        return outputMatch;\n+    }\n+\n+    private boolean allMatchesOn(List<IRRuleMatchResult> irRulesMatchResults, OutputMatch outputMatch) {\n+        return irRulesMatchResults.stream().allMatch(r -> r.getOutputMatch() == outputMatch);\n+    }\n+\n+    public String build() {\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(getMethodLine());\n+        switch (outputMatch) {\n+            case IDEAL -> builder.append(irMethod.getIdealOutput());\n+            case OPTO_ASSEMBLY -> builder.append(irMethod.getOptoAssemblyOutput());\n+            case BOTH -> builder.append(irMethod.getOutput());\n+            default -> throw new TestFrameworkException(\"found unexpected OutputMatch \" + outputMatch.name());\n+        }\n+        return builder.toString();\n+    }\n+\n+    private String getMethodLine() {\n+        return \">>> Compilation of \" + irMethod.getMethod() + \":\" + System.lineSeparator();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/MatchedCompilationOutputBuilder.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Class to build the failure message output for an IR method with a missing compilation output.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+class MissingCompilationMessageBuilder extends FailureMessageBuilder {\n+\n+    public MissingCompilationMessageBuilder(IRMethod irMethod) {\n+        super(irMethod);\n+    }\n+\n+    @Override\n+    public String build() {\n+        return getMethodLine() + getMissingCompilationMessage();\n+    }\n+\n+    private String getMissingCompilationMessage() {\n+        return \"   * Method was not compiled. Did you specify any compiler directives preventing a compilation \"\n+               + \"or used a @Run method in STANDALONE mode? In the latter case, make sure to always trigger a C2 \"\n+               + \"compilation by \" + \"invoking the test enough times.\";\n+    }\n+    private String getMethodLine() {\n+        return \" Method \\\"\" + irMethod.getMethod() + \"\\\":\" + System.lineSeparator();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/MissingCompilationMessageBuilder.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+\/**\n+ * This class represents an IR matching result where the compilation output was empty.\n+ *\n+ * @see IRRuleMatchResult\n+ * @see IRMethod\n+ *\/\n+public class MissingCompilationResult extends IRMethodMatchResult {\n+    private final int failedIRRules;\n+    private final MissingCompilationMessageBuilder failureMessageBuilder;\n+\n+    MissingCompilationResult(IRMethod irMethod, int failedIRRules) {\n+        super(irMethod);\n+        this.failedIRRules = failedIRRules;\n+        this.failureMessageBuilder = new MissingCompilationMessageBuilder(irMethod);\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getMatchedCompilationOutput() {\n+        return \"<empty>\";\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return failureMessageBuilder.build();\n+    }\n+\n+    private String getMethodLine() {\n+        return \" Method \\\"\" + irMethod.getMethod() + \"\\\":\" + System.lineSeparator();\n+    }\n+\n+    @Override\n+    public int getFailedIRRuleCount() {\n+        return failedIRRules;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/MissingCompilationResult.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Class to build the failure message output for an IR method for failed IR rules.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+class NormalFailureMessageBuilder extends FailureMessageBuilder {\n+    private final List<IRRuleMatchResult> irRulesMatchResults;\n+\n+    public NormalFailureMessageBuilder(IRMethod irMethod, List<IRRuleMatchResult> irRulesMatchResults) {\n+        super(irMethod);\n+        this.irRulesMatchResults = irRulesMatchResults.stream()\n+                                                      .filter(IRRuleMatchResult::fail)\n+                                                      .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public String build() {\n+        return getMethodLine() + getIRRulesFailureMessage();\n+    }\n+\n+    private String getMethodLine() {\n+        int failures = irRulesMatchResults.size();\n+        return \" Method \\\"\" + irMethod.getMethod() + \"\\\" - [Failed IR rules: \" + failures + \"]:\"\n+               + System.lineSeparator();\n+    }\n+\n+    private String getIRRulesFailureMessage() {\n+        StringBuilder failMsg = new StringBuilder();\n+        for (IRRuleMatchResult irRuleResult : irRulesMatchResults) {\n+            failMsg.append(irRuleResult.buildFailureMessage());\n+        }\n+        return failMsg.toString();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NormalFailureMessageBuilder.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents a normal IR matching result of all IR rules of a method.\n+ *\n+ * @see IRRuleMatchResult\n+ * @see IRMethod\n+ *\/\n+class NormalMatchResult extends IRMethodMatchResult {\n+    private final List<IRRuleMatchResult> irRulesMatchResults;\n+    private final NormalFailureMessageBuilder failureMessageBuilder;\n+    private final MatchedCompilationOutputBuilder matchedCompilationOutputBuilder;\n+\n+    NormalMatchResult(IRMethod irMethod, List<IRRuleMatchResult> irRulesMatchResults) {\n+        super(irMethod);\n+        this.irRulesMatchResults = irRulesMatchResults;\n+        this.failureMessageBuilder = new NormalFailureMessageBuilder(irMethod, irRulesMatchResults);\n+        this.matchedCompilationOutputBuilder = new MatchedCompilationOutputBuilder(irMethod, irRulesMatchResults);\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return !irRulesMatchResults.isEmpty();\n+    }\n+\n+    @Override\n+    public String getMatchedCompilationOutput() {\n+        return matchedCompilationOutputBuilder.build();\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return failureMessageBuilder.build();\n+    }\n+\n+    @Override\n+    public int getFailedIRRuleCount() {\n+        return irRulesMatchResults.size();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NormalMatchResult.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+\/**\n+ * Base class representing a check attribute of an IR rule.\n+ *\n+ * @see IR\n+ *\/\n+abstract class CheckAttribute {\n+\n+    abstract public CheckAttributeMatchResult apply(String compilation);\n+\n+    protected List<String> getMatchedNodes(Matcher m) {\n+        List<String> matches = new ArrayList<>();\n+        do {\n+            matches.add(m.group());\n+        } while (m.find());\n+        return matches;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CheckAttribute.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Base class representing a result of an applied check attribute of an IR rule.\n+ *\n+ * @see IR\n+ *\/\n+abstract class CheckAttributeMatchResult implements MatchResult {\n+    protected List<RegexFailure> regexFailures = null;\n+\n+    @Override\n+    public boolean fail() {\n+        return regexFailures != null;\n+    }\n+\n+    public int getMatchesCount() {\n+        if (fail()) {\n+            return regexFailures.stream().map(RegexFailure::getMatchesCount).reduce(0, Integer::sum);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    protected String collectRegexFailureMessages() {\n+        StringBuilder failMsg = new StringBuilder();\n+        for (RegexFailure regexFailure : regexFailures) {\n+            failMsg.append(regexFailure.buildFailureMessage());\n+        }\n+        return failMsg.toString();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CheckAttributeMatchResult.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.shared.Comparison;\n+import compiler.lib.ir_framework.shared.ComparisonConstraintParser;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Class representing a counts attribute of an IR rule.\n+ *\n+ * @see IR#counts()\n+ *\/\n+class Counts extends CheckAttribute {\n+    public List<Constraint> constraints;\n+\n+    private Counts(List<Constraint> constraints) {\n+        this.constraints = constraints;\n+    }\n+\n+    public static Counts create(List<String> nodesWithCountConstraint, IRRule irRule) {\n+        List<Constraint> constraints = new ArrayList<>();\n+        int nodeId = 1;\n+        for (int i = 0; i < nodesWithCountConstraint.size(); i += 2, nodeId++) {\n+            String node = nodesWithCountConstraint.get(i);\n+            TestFormat.check(i + 1 < nodesWithCountConstraint.size(),\n+                             \"Missing count \" + getPostfixErrorMsg(irRule, node));\n+            String countConstraint = nodesWithCountConstraint.get(i + 1);\n+            Comparison<Long> comparison = parseComparison(irRule, node, countConstraint);\n+            constraints.add(new Constraint(node, comparison, nodeId));\n+        }\n+        return new Counts(constraints);\n+    }\n+\n+    private static String getPostfixErrorMsg(IRRule irRule, String node) {\n+        return \"for IR rule \" + irRule.getRuleId() + \", node \\\"\" + node + \"\\\" at \" + irRule.getMethod();\n+    }\n+\n+    private static Comparison<Long> parseComparison(IRRule irRule, String node, String constraint) {\n+        String postfixErrorMsg = \"in count constraint \" + getPostfixErrorMsg(irRule, node);\n+        return ComparisonConstraintParser.parse(constraint, Long::parseLong, postfixErrorMsg);\n+    }\n+\n+    @Override\n+    public CheckAttributeMatchResult apply(String compilation) {\n+        CountsMatchResult result = new CountsMatchResult();\n+        checkConstraints(result, compilation);\n+        return result;\n+    }\n+\n+    private void checkConstraints(CountsMatchResult result, String compilation) {\n+        for (Constraint constraint : constraints) {\n+            checkConstraint(result, compilation, constraint);\n+        }\n+    }\n+\n+    private void checkConstraint(CountsMatchResult result, String compilation, Constraint constraint) {\n+        long foundCount = getFoundCount(compilation, constraint);\n+        Comparison<Long> comparison = constraint.comparison;\n+        if (!comparison.compare(foundCount)) {\n+            result.addFailure(createRegexFailure(compilation, constraint, foundCount));\n+        }\n+    }\n+\n+    private long getFoundCount(String compilation, Constraint constraint) {\n+        Pattern pattern = Pattern.compile(constraint.nodeRegex);\n+        Matcher matcher = pattern.matcher(compilation);\n+        return matcher.results().count();\n+    }\n+\n+    private CountsRegexFailure createRegexFailure(String compilation, Constraint constraint, long foundCount) {\n+        Pattern p = Pattern.compile(constraint.nodeRegex);\n+        Matcher m = p.matcher(compilation);\n+        List<String> matches;\n+        if (m.find()) {\n+            matches = getMatchedNodes(m);\n+        } else {\n+            matches = new ArrayList<>();\n+        }\n+        return new CountsRegexFailure(constraint.nodeRegex, constraint.nodeId, foundCount, constraint.comparison, matches);\n+    }\n+\n+    static class Constraint {\n+        final String nodeRegex;\n+        final Comparison<Long> comparison;\n+        private final int nodeId;\n+\n+        Constraint(String nodeRegex, Comparison<Long> comparison, int nodeId) {\n+            this.nodeRegex = nodeRegex;\n+            this.comparison = comparison;\n+            this.nodeId = nodeId;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/Counts.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+\n+import java.util.ArrayList;\n+\n+\/**\n+ * Class representing a result of an applied counts attribute of an IR rule.\n+ *\n+ * @see IR#counts()\n+ *\/\n+class CountsMatchResult extends CheckAttributeMatchResult {\n+\n+    public void addFailure(RegexFailure regexFailure) {\n+        if (regexFailures == null) {\n+            regexFailures = new ArrayList<>();\n+        }\n+        regexFailures.add(regexFailure);\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return \"     - counts: Graph contains wrong number of nodes:\" + System.lineSeparator()\n+               + collectRegexFailureMessages();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CountsMatchResult.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.shared.Comparison;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents an IR matching failure of a regex of a counts attribute of an IR rule.\n+ *\n+ * @see Counts\n+ *\/\n+class CountsRegexFailure extends RegexFailure {\n+    String failedComparison;\n+\n+    public CountsRegexFailure(String nodeRegex, int nodeId, long foundValue, Comparison<Long> comparison, List<String> matches) {\n+        super(nodeRegex, nodeId, matches);\n+        this.failedComparison = \"[found] \" + foundValue + \" \" + comparison.getComparator() + \" \"\n+                                + comparison.getGivenValue() + \" [given]\";\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return getRegexLine()\n+               + getFailedComparison()\n+               + getMatchedNodesBlock();\n+    }\n+\n+    private String getFailedComparison() {\n+        return \"         - Failed comparison: \" + failedComparison + System.lineSeparator();\n+    }\n+\n+    @Override\n+    protected String getMatchedNodesBlock() {\n+        if (matches.isEmpty()) {\n+            return getEmptyNodeMatchesLine();\n+        } else {\n+            return super.getMatchedNodesBlock();\n+        }\n+    }\n+\n+    private String getEmptyNodeMatchesLine() {\n+        return getMatchedNodesWhiteSpace() + \"- No nodes matched!\" + System.lineSeparator();\n+    }\n+\n+    @Override\n+    protected String getMatchedPrefix() {\n+        return \"Matched\";\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CountsRegexFailure.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Class representing a failOn attribute of an IR rule.\n+ *\n+ * @see IR#failOn()\n+ *\/\n+class FailOn extends CheckAttribute {\n+    private final Pattern quickPattern;\n+    private final List<String> nodes;\n+\n+    public FailOn(List<String> nodes) {\n+        this.nodes = nodes;\n+        this.quickPattern = Pattern.compile(String.join(\"|\", nodes));\n+    }\n+\n+    @Override\n+    public CheckAttributeMatchResult apply(String compilation) {\n+        FailOnMatchResult result = new FailOnMatchResult();\n+        Matcher matcher = quickPattern.matcher(compilation);\n+        if (matcher.find()) {\n+            result.setFailures(createFailOnFailures(compilation));\n+        }\n+        return result;\n+    }\n+\n+    private List<RegexFailure> createFailOnFailures(String compilation) {\n+        List<RegexFailure> regexFailures = new ArrayList<>();\n+        for (int i = 0; i < nodes.size(); i++) {\n+            checkNode(regexFailures, compilation, nodes.get(i), i + 1);\n+        }\n+        return regexFailures;\n+    }\n+\n+    private void checkNode(List<RegexFailure> regexFailures, String compilation, String node, int nodeId) {\n+        Pattern p = Pattern.compile(node);\n+        Matcher m = p.matcher(compilation);\n+        if (m.find()) {\n+            List<String> matches = getMatchedNodes(m);\n+            regexFailures.add(new FailOnRegexFailure(node, nodeId, matches));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/FailOn.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+\n+import java.util.List;\n+\n+\/**\n+ * Class representing a result of an applied failOn attribute of an IR rule.\n+ *\n+ * @see IR#failOn()\n+ *\/\n+class FailOnMatchResult extends CheckAttributeMatchResult {\n+    public void setFailures(List<RegexFailure> regexFailures) {\n+        this.regexFailures = regexFailures;\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return \"     - failOn: Graph contains forbidden nodes:\" + System.lineSeparator()\n+               + collectRegexFailureMessages();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/FailOnMatchResult.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents an IR matching failure of a regex of a failOn attribute of an IR rule.\n+ *\n+ * @see FailOn\n+ *\/\n+class FailOnRegexFailure extends RegexFailure {\n+\n+    public FailOnRegexFailure(String nodeRegex, int nodeId, List<String> matches) {\n+        super(nodeRegex, nodeId, matches);\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return getRegexLine()\n+               + getMatchedNodesBlock();\n+    }\n+\n+    @Override\n+    protected String getMatchedPrefix() {\n+        return \"Matched forbidden\";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/FailOnRegexFailure.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.OutputMatch;\n+import compiler.lib.ir_framework.shared.*;\n+\n+import java.lang.reflect.Method;\n+import java.util.function.Consumer;\n+\n+public class IRRule {\n+    private final IRMethod irMethod;\n+    private final int ruleId;\n+    private final IR irAnno;\n+    private final FailOn failOn;\n+    private final Counts counts;\n+\n+    public IRRule(IRMethod irMethod, int ruleId, IR irAnno) {\n+        this.irMethod = irMethod;\n+        this.ruleId = ruleId;\n+        this.irAnno = irAnno;\n+        this.failOn = initFailOn(irAnno);\n+        this.counts = initCounts(irAnno);\n+    }\n+\n+    private Counts initCounts(IR irAnno) {\n+        String[] countsConstraints = irAnno.counts();\n+        if (countsConstraints.length != 0) {\n+            try {\n+                return Counts.create(IRNode.mergeNodes(countsConstraints), this);\n+            } catch (TestFormatException e) {\n+                \/\/ Logged and reported later. Continue.\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private FailOn initFailOn(IR irAnno) {\n+        String[] failOnNodes = irAnno.failOn();\n+        if (failOnNodes.length != 0) {\n+            return new FailOn(IRNode.mergeNodes(failOnNodes));\n+        }\n+        return null;\n+    }\n+\n+    public int getRuleId() {\n+        return ruleId;\n+    }\n+\n+    public IR getIRAnno() {\n+        return irAnno;\n+    }\n+\n+    public Method getMethod() {\n+        return irMethod.getMethod();\n+    }\n+\n+    \/**\n+     * Apply this IR rule by checking any failOn and counts attributes.\n+     *\/\n+    public IRRuleMatchResult applyCheckAttribute() {\n+        IRRuleMatchResult result = new IRRuleMatchResult(this);\n+        if (failOn != null) {\n+            applyCheckAttribute(failOn, result, result::setFailOnFailures);\n+        }\n+        if (counts != null) {\n+            applyCheckAttribute(counts, result, result::setCountsFailures);\n+        }\n+        return result;\n+    }\n+\n+    private void applyCheckAttribute(CheckAttribute checkAttribute, IRRuleMatchResult result,\n+                                     Consumer<CheckAttributeMatchResult> setFailures) {\n+        CheckAttributeMatchResult checkAttributeResult = checkAttribute.apply(irMethod.getOutput());\n+        if (checkAttributeResult.fail()) {\n+            setFailures.accept(checkAttributeResult);\n+            result.updateOutputMatch(getOutputMatch(checkAttribute, checkAttributeResult));\n+        }\n+    }\n+\n+    \/**\n+     * Determine how the output was matched by reapplying the check attribute for the PrintIdeal and PrintOptoAssembly\n+     * output separately.\n+     *\/\n+    private OutputMatch getOutputMatch(CheckAttribute checkAttribute, CheckAttributeMatchResult checkAttributeResult) {\n+        int totalMatches = checkAttributeResult.getMatchesCount();\n+        int idealFailuresCount = getMatchesCount(checkAttribute, irMethod.getIdealOutput());\n+        int optoAssemblyFailuresCount = getMatchesCount(checkAttribute, irMethod.getOptoAssemblyOutput());\n+        return findOutputMatch(totalMatches, idealFailuresCount, optoAssemblyFailuresCount);\n+    }\n+\n+    private int getMatchesCount(CheckAttribute checkAttribute, String compilation) {\n+        CheckAttributeMatchResult result = checkAttribute.apply(compilation);\n+        return result.getMatchesCount();\n+    }\n+\n+    \/**\n+     * Compare different counts to find out, on what output a failure was matched.\n+     *\/\n+    private OutputMatch findOutputMatch(int totalMatches, int idealFailuresCount, int optoAssemblyFailuresCount) {\n+        if (totalMatches == 0\n+            || someRegexMatchOnlyEntireOutput(totalMatches, idealFailuresCount, optoAssemblyFailuresCount)\n+            || anyMatchOnIdealAndOptoAssembly(idealFailuresCount, optoAssemblyFailuresCount)) {\n+            return OutputMatch.BOTH;\n+        } else if (optoAssemblyFailuresCount == 0) {\n+            return OutputMatch.IDEAL;\n+        } else {\n+            return OutputMatch.OPTO_ASSEMBLY;\n+        }\n+    }\n+\n+    \/**\n+     * Do we have a regex that is only matched on the entire ideal + opto assembly output?\n+     *\/\n+    private boolean someRegexMatchOnlyEntireOutput(int totalCount, int idealFailuresCount, int optoAssemblyFailuresCount) {\n+        return totalCount != idealFailuresCount + optoAssemblyFailuresCount;\n+    }\n+\n+    \/**\n+     * Do we have a match on ideal and opto assembly for this rule?\n+     *\/\n+    private boolean anyMatchOnIdealAndOptoAssembly(int idealFailuresCount, int optoAssemblyFailuresCount) {\n+        return idealFailuresCount > 0 && optoAssemblyFailuresCount > 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/IRRule.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.OutputMatch;\n+\n+\/**\n+ * This class represents an IR matching result of an IR rule.\n+ *\n+ * @see CheckAttributeMatchResult\n+ * @see IRRule\n+ *\/\n+public class IRRuleMatchResult implements MatchResult {\n+    private final IRRule irRule;\n+    private CheckAttributeMatchResult failOnFailures = null;\n+    private CheckAttributeMatchResult countsFailures = null;\n+    private OutputMatch outputMatch;\n+\n+    public IRRuleMatchResult(IRRule irRule) {\n+        this.irRule = irRule;\n+        this.outputMatch = OutputMatch.NONE;\n+    }\n+\n+    private boolean hasFailOnFailures() {\n+        return failOnFailures != null;\n+    }\n+\n+    public void setFailOnFailures(CheckAttributeMatchResult failOnFailures) {\n+        this.failOnFailures = failOnFailures;\n+    }\n+\n+    private boolean hasCountsFailures() {\n+        return countsFailures != null;\n+    }\n+\n+    public void setCountsFailures(CheckAttributeMatchResult countsFailures) {\n+        this.countsFailures = countsFailures;\n+    }\n+\n+    public OutputMatch getOutputMatch() {\n+        return outputMatch;\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return failOnFailures != null || countsFailures != null;\n+    }\n+\n+    public void updateOutputMatch(OutputMatch newOutputMatch) {\n+        TestFramework.check(newOutputMatch != OutputMatch.NONE, \"must be valid state\");\n+        switch (outputMatch) {\n+            case NONE -> outputMatch = newOutputMatch;\n+            case IDEAL -> outputMatch = newOutputMatch != OutputMatch.IDEAL\n+                    ? OutputMatch.BOTH : OutputMatch.IDEAL;\n+            case OPTO_ASSEMBLY -> outputMatch = newOutputMatch != OutputMatch.OPTO_ASSEMBLY\n+                    ? OutputMatch.BOTH : OutputMatch.OPTO_ASSEMBLY;\n+        }\n+    }\n+\n+    \/**\n+     * Build a failure message based on the collected failures of this object.\n+     *\/\n+    @Override\n+    public String buildFailureMessage() {\n+        StringBuilder failMsg = new StringBuilder();\n+        failMsg.append(getIRRuleLine());\n+        if (hasFailOnFailures()) {\n+            failMsg.append(failOnFailures.buildFailureMessage());\n+        }\n+        if (hasCountsFailures()) {\n+            failMsg.append(countsFailures.buildFailureMessage());\n+        }\n+        return failMsg.toString();\n+    }\n+\n+    private String getIRRuleLine() {\n+        return \"   * @IR rule \" + irRule.getRuleId() + \": \\\"\" + irRule.getIRAnno() + \"\\\"\" + System.lineSeparator();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/IRRuleMatchResult.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Base class representing an IR matching failure of a regex of a check attribute of an IR rule.\n+ *\n+ * @see CheckAttributeMatchResult\n+ * @see CheckAttribute\n+ * @see IRRule\n+ *\/\n+abstract class RegexFailure {\n+    protected final String nodeRegex;\n+    protected final int nodeId;\n+    protected final List<String> matches;\n+\n+    public RegexFailure(String nodeRegex, int nodeId, List<String> matches) {\n+        this.nodeRegex = nodeRegex;\n+        this.nodeId = nodeId;\n+        this.matches = addWhiteSpacePrefixForEachLine(matches);\n+    }\n+\n+    private List<String> addWhiteSpacePrefixForEachLine(List<String> matches) {\n+        return matches\n+                .stream()\n+                .map(s -> s.replaceAll(System.lineSeparator(), System.lineSeparator()\n+                                                               + getMatchedNodesItemWhiteSpace() + \"  \"))\n+                .collect(Collectors.toList());\n+    }\n+\n+    abstract public String buildFailureMessage();\n+\n+    public int getMatchesCount() {\n+        return matches.size();\n+    }\n+\n+    protected String getRegexLine() {\n+        return \"       * Regex \" + nodeId + \": \" + nodeRegex + System.lineSeparator();\n+    }\n+\n+    protected String getMatchedNodesBlock() {\n+        return getMatchedNodesHeader() + getMatchesNodeLines();\n+    }\n+\n+    protected String getMatchedNodesHeader() {\n+        int matchCount = matches.size();\n+        return \"\" + getMatchedNodesWhiteSpace() + \"- \" + getMatchedPrefix() + \" node\"\n+               + (matchCount != 1 ? \"s (\" + matchCount + \")\" : \"\") + \":\" + System.lineSeparator();\n+    }\n+\n+    protected String getMatchedNodesWhiteSpace() {\n+        return \"         \";\n+    }\n+\n+    abstract protected String getMatchedPrefix();\n+\n+    protected String getMatchesNodeLines() {\n+        StringBuilder builder = new StringBuilder();\n+        matches.forEach(match -> builder.append(getMatchedNodesItemWhiteSpace()).append(\"* \").append(match).append(System.lineSeparator()));\n+        return builder.toString();\n+    }\n+\n+    private String getMatchedNodesItemWhiteSpace() {\n+        return \"           \";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/RegexFailure.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+\n+\/**\n+ * Base class of a read line from the hotspot_pid* file.\n+ *\/\n+abstract class AbstractLine {\n+    private final BufferedReader reader;\n+    protected String line;\n+\n+    public AbstractLine(BufferedReader reader) {\n+        this.reader = reader;\n+    }\n+\n+    public String getLine() {\n+        return line;\n+    }\n+\n+    \/**\n+     * Read next line and return it. If we've reached the end of the file, return NULL instead.\n+     *\/\n+    public boolean readLine() throws IOException {\n+        line = reader.readLine();\n+        return line != null;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/AbstractLine.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import java.io.BufferedReader;\n+\n+\/**\n+ * Class representing a block line inside a PrintIdeal or PrintOptoAssembly output block read from the hotspot_pid* file.\n+ *\/\n+class BlockLine extends AbstractLine {\n+\n+    public BlockLine(BufferedReader reader) {\n+        super(reader);\n+    }\n+\n+    \/**\n+     * Is this line an end of a PrintIdeal or PrintOptoAssembly output block?\n+     *\/\n+    public boolean isBlockEnd() {\n+        return line.startsWith(\"<\/\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/BlockLine.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+\n+\/**\n+ * Class to read all lines of a PrintIdeal or PrintOptoAssembly block.\n+ *\/\n+class BlockOutputReader {\n+    private final BufferedReader reader;\n+\n+    public BlockOutputReader(BufferedReader reader) {\n+        this.reader = reader;\n+    }\n+\n+    \/**\n+     * Read all lines belonging to a PrintIdeal or PrintOptoAssembly output block.\n+     *\/\n+    public String readBlock() throws IOException {\n+        BlockLine line = new BlockLine(reader);\n+        StringBuilder builder = new StringBuilder();\n+        while (line.readLine() && !line.isBlockEnd()) {\n+            builder.append(escapeXML(line.getLine())).append(System.lineSeparator());\n+        }\n+        return builder.toString();\n+    }\n+\n+    \/**\n+     * Need to escape XML special characters.\n+     *\/\n+    private static String escapeXML(String line) {\n+        if (line.contains(\"&\")) {\n+            line = line.replace(\"&lt;\", \"<\");\n+            line = line.replace(\"&gt;\", \">\");\n+            line = line.replace(\"&quot;\", \"\\\"\");\n+            line = line.replace(\"&apos;\", \"'\");\n+            line = line.replace(\"&amp;\", \"&\");\n+        }\n+        return line;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/BlockOutputReader.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+\/**\n+ * Exception thrown when facing an unexpected format during parsing of the hotspot-pid* file\n+ *\/\n+class FileCorruptedException extends RuntimeException {\n+    public FileCorruptedException(String s) {\n+        super(s);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/FileCorruptedException.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Class to parse the PrintIdeal and PrintOptoAssembly outputs of the test class from the hotspot_pid* file and add them\n+ * to the collection of {@link IRMethod} created by {@link IREncodingParser}.\n+ *\n+ * @see IRMethod\n+ * @see IREncodingParser\n+ *\/\n+class HotSpotPidFileParser {\n+    private static final Pattern COMPILE_ID_PATTERN = Pattern.compile(\"compile_id='(\\\\d+)'\");\n+\n+    private final Pattern compileIdPatternForTestClass;\n+    private Map<String, IRMethod> compilationsMap;\n+\n+    public HotSpotPidFileParser(String testClass) {\n+        this.compileIdPatternForTestClass = Pattern.compile(\"compile_id='(\\\\d+)'.*\" + Pattern.quote(testClass) + \" (\\\\S+)\");\n+    }\n+\n+    public void setCompilationsMap(Map<String, IRMethod> compilationsMap) {\n+        this.compilationsMap = compilationsMap;\n+    }\n+    \/**\n+     * Parse the hotspot_pid*.log file from the test VM. Read the PrintIdeal and PrintOptoAssembly outputs for all\n+     * methods of the test class that need to be IR matched (found in compilations map).\n+     *\/\n+    public Collection<IRMethod> parseCompilations(String hotspotPidFileName) {\n+        try {\n+            processFileLines(hotspotPidFileName);\n+            return compilationsMap.values();\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while reading \" + hotspotPidFileName, e);\n+        } catch (FileCorruptedException e) {\n+            throw new TestFrameworkException(\"Unexpected format of \" + hotspotPidFileName, e);\n+        }\n+    }\n+\n+    private void processFileLines(String hotspotPidFileName) throws IOException {\n+        Map<Integer, IRMethod> compileIdMap = new HashMap<>();\n+        try (var reader = Files.newBufferedReader(Paths.get(hotspotPidFileName))) {\n+            Line line = new Line(reader, compileIdPatternForTestClass);\n+            BlockOutputReader blockOutputReader = new BlockOutputReader(reader);\n+            while (line.readLine()) {\n+                if (line.isTestClassCompilation()) {\n+                    parseTestMethodCompileId(compileIdMap, line.getLine());\n+                } else if (isTestMethodBlockStart(line, compileIdMap)) {\n+                    String blockOutput = blockOutputReader.readBlock();\n+                    setIRMethodOutput(blockOutput, line, compileIdMap);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void parseTestMethodCompileId(Map<Integer, IRMethod> compileIdMap, String line) {\n+        String methodName = parseMethodName(line);\n+        if (isTestAnnotatedMethod(methodName)) {\n+            int compileId = getCompileId(line);\n+            compileIdMap.put(compileId, getIrMethod(methodName));\n+        }\n+    }\n+\n+    private String parseMethodName(String line) {\n+        Matcher matcher = compileIdPatternForTestClass.matcher(line);\n+        TestFramework.check(matcher.find(), \"must find match\");\n+        return matcher.group(2);\n+    }\n+\n+    private boolean isTestAnnotatedMethod(String testMethodName) {\n+        return compilationsMap.containsKey(testMethodName);\n+    }\n+\n+    private IRMethod getIrMethod(String testMethodName) {\n+        return compilationsMap.get(testMethodName);\n+    }\n+\n+\n+\n+    private int getCompileId(String line) {\n+        Matcher matcher = COMPILE_ID_PATTERN.matcher(line);\n+        if (!matcher.find()) {\n+            throw new FileCorruptedException(\"Unexpected format found on this line: \" + line);\n+        }\n+        return Integer.parseInt(matcher.group(1));\n+    }\n+\n+    private boolean isTestMethodBlockStart(Line line, Map<Integer, IRMethod> compileIdMap) {\n+      return line.isBlockStart() && isTestClassMethodBlock(line, compileIdMap);\n+    }\n+\n+    private boolean isTestClassMethodBlock(Line line, Map<Integer, IRMethod> compileIdMap) {\n+        return compileIdMap.containsKey(getCompileId(line.getLine()));\n+    }\n+\n+    public void setIRMethodOutput(String blockOutput, Line blockStartLine, Map<Integer, IRMethod> compileIdMap) {\n+        IRMethod irMethod = compileIdMap.get(getCompileId(blockStartLine.getLine()));\n+        setIRMethodOutput(blockOutput, blockStartLine, irMethod);\n+    }\n+\n+    private void setIRMethodOutput(String blockOutput, Line blockStartLine, IRMethod irMethod) {\n+        if (blockStartLine.isPrintIdealStart()) {\n+            irMethod.setIdealOutput(blockOutput);\n+        } else {\n+            irMethod.setOptoAssemblyOutput(blockOutput);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/HotSpotPidFileParser.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.test.IREncodingPrinter;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Class to parse the IR encoding emitted by the test VM and creating {@link IRMethod} objects for each entry.\n+ *\n+ * @see IRMethod\n+ *\/\n+class IREncodingParser {\n+\n+    private static final boolean PRINT_IR_ENCODING = Boolean.parseBoolean(System.getProperty(\"PrintIREncoding\", \"false\"));\n+    private static final Pattern IR_ENCODING_PATTERN =\n+            Pattern.compile(\"(?<=\" + IREncodingPrinter.START + \"\\r?\\n).*\\\\R([\\\\s\\\\S]*)(?=\" + IREncodingPrinter.END + \")\");\n+\n+    private final Map<String, IRMethod> compilations;\n+    private final Class<?> testClass;\n+\n+    public IREncodingParser(Class<?> testClass) {\n+        this.testClass = testClass;\n+        this.compilations = new HashMap<>();\n+    }\n+\n+    public Map<String, IRMethod> parseIRMethods(String irEncoding) {\n+        if (TestFramework.VERBOSE || PRINT_IR_ENCODING) {\n+            System.out.println(\"Read IR encoding from test VM:\");\n+            System.out.println(irEncoding);\n+        }\n+        createCompilationsMap(irEncoding, testClass);\n+        \/\/ We could have found format errors in @IR annotations. Report them now with an exception.\n+        TestFormat.throwIfAnyFailures();\n+        return compilations;\n+    }\n+\n+    \/**\n+     * Sets up a map testname -> IRMethod (containing the PrintIdeal and PrintOptoAssembly output for testname).\n+     *\/\n+    private void createCompilationsMap(String irEncoding, Class<?> testClass) {\n+        Map<String, int[]> irRulesMap = parseIREncoding(irEncoding);\n+        createIRMethodsWithEncoding(testClass, irRulesMap);\n+    }\n+\n+    \/**\n+     * Read the IR encoding emitted by the test VM to decide if an @IR rule must be checked for a method.\n+     *\/\n+    private Map<String, int[]> parseIREncoding(String irEncoding) {\n+        Map<String, int[]> irRulesMap = new HashMap<>();\n+        String[] irEncodingLines = getIREncodingLines(irEncoding);\n+        for (String s : irEncodingLines) {\n+            String line = s.trim();\n+            String[] splitLine = line.split(\",\");\n+            if (splitLine.length < 2) {\n+                throw new TestFrameworkException(\"Invalid IR match rule encoding. No comma found: \" + splitLine[0]);\n+            }\n+            String testName = splitLine[0];\n+            int[] irRulesIdx = getRuleIndexes(splitLine);\n+            irRulesMap.put(testName, irRulesIdx);\n+        }\n+        return irRulesMap;\n+    }\n+\n+    \/**\n+     * Parse the IR encoding lines without header, explanation line and footer and return them in an array.\n+     *\/\n+    private String[] getIREncodingLines(String irEncoding) {\n+        Matcher matcher = IR_ENCODING_PATTERN.matcher(irEncoding);\n+        TestFramework.check(matcher.find(), \"Did not find IR encoding\");\n+        String lines = matcher.group(1).trim();\n+        if (lines.isEmpty()) {\n+            \/\/ Nothing to IR match.\n+            return new String[0];\n+        }\n+        return lines.split(\"\\\\R\");\n+    }\n+\n+    \/**\n+     * Parse rule indexes from IR encoding line of the format: <method,idx1,idx2,...>\n+     *\/\n+    private int[] getRuleIndexes(String[] splitLine) {\n+        int[] irRulesIdx = new int[splitLine.length - 1];\n+        for (int i = 1; i < splitLine.length; i++) {\n+            try {\n+                irRulesIdx[i - 1] = Integer.parseInt(splitLine[i]);\n+            } catch (NumberFormatException e) {\n+                throw new TestFrameworkException(\"Invalid IR match rule encoding. No number found: \" + splitLine[i]);\n+            }\n+        }\n+        return irRulesIdx;\n+    }\n+\n+    private void createIRMethodsWithEncoding(Class<?> testClass, Map<String, int[]> irRulesMap) {\n+        for (Method m : testClass.getDeclaredMethods()) {\n+            IR[] irAnnos = m.getAnnotationsByType(IR.class);\n+            if (irAnnos.length > 0) {\n+                \/\/ Validation of legal @IR attributes and placement of the annotation was already done in Test VM.\n+                int[] irRuleIds = irRulesMap.get(m.getName());\n+                validateIRRuleIds(m, irAnnos, irRuleIds);\n+                if (hasAnyApplicableIRRules(irRuleIds)) {\n+                    compilations.put(m.getName(), new IRMethod(m, irRuleIds, irAnnos));\n+                }\n+            }\n+        }\n+    }\n+\n+    private void validateIRRuleIds(Method m, IR[] irAnnos, int[] ids) {\n+        TestFramework.check(ids != null, \"Should find method name in validIrRulesMap for \" + m);\n+        TestFramework.check(ids.length > 0, \"Did not find any rule indices for \" + m);\n+        TestFramework.check((ids[0] >= 1 || ids[0] == IREncodingPrinter.NO_RULE_APPLIED)\n+                            && ids[ids.length - 1] <= irAnnos.length,\n+                            \"Invalid IR rule index found in validIrRulesMap for \" + m);\n+    }\n+\n+    \/**\n+     * Does the list of IR rules contain any applicable IR rules for the given conditions?\n+     *\/\n+    private boolean hasAnyApplicableIRRules(int[] irRuleIds) {\n+        return irRuleIds[0] != IREncodingPrinter.NO_RULE_APPLIED;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IREncodingParser.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+\/**\n+ * Class to parse the PrintIdeal and PrintOptoAssembly outputs of the test class and store them into a collection\n+ * of dedicated IRMethod objects used throughout IR matching.\n+ *\n+ * @see IRMethod\n+ *\/\n+public class IRMethodParser {\n+    private final IREncodingParser irEncodingParser;\n+    private final HotSpotPidFileParser hotSpotPidFileParser;\n+\n+    public IRMethodParser(Class<?> testClass) {\n+        this.irEncodingParser = new IREncodingParser(testClass);\n+        this.hotSpotPidFileParser = new HotSpotPidFileParser(testClass.getName());\n+    }\n+\n+    \/**\n+     * Parse the IR encoding and hotspot_pid* file to create a collection of {@link IRMethod} objects.\n+     * Return null if there are no applicable @IR rules in any method of the test class.\n+     *\/\n+    public Collection<IRMethod> parse(String hotspotPidFileName, String irEncoding) {\n+        Map<String, IRMethod> compilationsMap = irEncodingParser.parseIRMethods(irEncoding);\n+        if (!compilationsMap.isEmpty()) {\n+            hotSpotPidFileParser.setCompilationsMap(compilationsMap);\n+            return hotSpotPidFileParser.parseCompilations(hotspotPidFileName);\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IRMethodParser.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import java.io.BufferedReader;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Class representing a normal line read from the hotspot_pid* file.\n+ *\/\n+class Line extends AbstractLine {\n+    private final Pattern compileIdPatternForTestClass;\n+\n+    public Line(BufferedReader reader, Pattern compileIdPatternForTestClass) {\n+        super(reader);\n+        this.compileIdPatternForTestClass = compileIdPatternForTestClass;\n+    }\n+\n+    \/**\n+     * Is this line a start of a @Test annotated method? We only care about test class entries. There might be non-class\n+     * entries as well if user specified additional compile commands. Ignore these.\n+     *\/\n+    public boolean isTestClassCompilation() {\n+        if (isCompilation()) {\n+            Matcher matcher = compileIdPatternForTestClass.matcher(line);\n+            return matcher.find();\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Is this header a C2 non-OSR compilation header entry?\n+     *\/\n+    public boolean isCompilation() {\n+        return line.startsWith(\"<task_queued\") && notOSRCompilation() && notC2Compilation();\n+    }\n+\n+    \/**\n+     * OSR compilations have compile_kind set.\n+     *\/\n+    private boolean notOSRCompilation() {\n+        return !line.contains(\"compile_kind='\");\n+    }\n+\n+    \/**\n+     * Non-C2 compilations have level set.\n+     *\/\n+    private boolean notC2Compilation() {\n+        return !line.contains(\"level='\");\n+    }\n+\n+    \/**\n+     * Is this line a start of a PrintIdeal or PrintOptoAssembly output block?\n+     *\/\n+    public boolean isBlockStart() {\n+        return isPrintIdealStart() || isPrintOptoAssemblyStart();\n+    }\n+\n+    \/**\n+     * Is this line a start of a PrintIdeal output block?\n+     *\/\n+    public boolean isPrintIdealStart() {\n+        \/\/ Ignore OSR compilations which have compile_kind set.\n+        return line.startsWith(\"<ideal\") && notOSRCompilation();\n+    }\n+\n+    \/**\n+     * Is this line a start of a PrintOptoAssembly output block?\n+     *\/\n+    private boolean isPrintOptoAssemblyStart() {\n+        \/\/ Ignore OSR compilations which have compile_kind set.\n+        return line.startsWith(\"<opto_assembly\") && notOSRCompilation();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/Line.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+\n+\/**\n+ * Comparison result of parsing a constraint with {@link ComparisonConstraintParser#parse(String, Function, String)}.\n+ *\/\n+public class Comparison<T extends Comparable<T>> {\n+    private final T givenValue; \/\/ Right hand side\n+    private final BiPredicate<T, T> comparisonPredicate;\n+    private final String comparator;\n+\n+    public Comparison(T givenValue, String comparator, BiPredicate<T, T> comparisonPredicate) {\n+        this.givenValue = givenValue;\n+        this.comparator = comparator;\n+        this.comparisonPredicate = comparisonPredicate;\n+    }\n+\n+    public T getGivenValue() {\n+        return givenValue;\n+    }\n+\n+    public String getComparator() {\n+        return comparator;\n+    }\n+\n+    \/**\n+     * Comparison: foundValue OP givenValue\n+     *\/\n+    public boolean compare(T foundValue) {\n+        return comparisonPredicate.test(foundValue, givenValue);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/Comparison.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+\n+\/**\n+ * Utility class to parse a comparator either in the applyIf* or in the counts properties of an @IR rules.\n+ *\/\n+public class ComparisonConstraintParser<T extends Comparable<T>> {\n+\n+    private enum Comparator {\n+        ONE_CHAR, TWO_CHARS\n+    }\n+\n+    public static <T extends Comparable<T>> Comparison<T> parse(String constraint, Function<String, T> parseFunction,\n+                                                                String postfixErrorMsg) {\n+        try {\n+            return parseConstraintAndValue(constraint, parseFunction);\n+        } catch (EmptyConstraintException e) {\n+            TestFormat.fail(\"Provided empty value \" + postfixErrorMsg);\n+            throw new UnreachableCodeException();\n+        } catch (MissingConstraintValueException e) {\n+            TestFormat.fail(\"Provided empty value after comparator \\\"\" + e.getComparator() + \"\\\" \" + postfixErrorMsg);\n+            throw new UnreachableCodeException();\n+        } catch (InvalidComparatorException e) {\n+            TestFormat.fail(\"Provided invalid comparator \\\"\" + e.getComparator() + \"\\\" \" + postfixErrorMsg);\n+            throw new UnreachableCodeException();\n+        } catch (InvalidConstraintValueException e) {\n+            String comparator = e.getComparator();\n+            if (!comparator.isEmpty()) {\n+                comparator = \" after comparator \\\"\" + comparator + \"\\\"\";\n+            }\n+            TestFormat.fail(\"Provided invalid value \\\"\" + e.getInvalidValue() + \"\\\"\"\n+                                   + comparator + \" \" + postfixErrorMsg);\n+            throw new UnreachableCodeException();\n+        }\n+    }\n+\n+    private static <T extends Comparable<T>> Comparison<T> parseConstraintAndValue(String constraint,\n+                                                                                   Function<String, T> parseFunction) throws\n+            EmptyConstraintException, MissingConstraintValueException,\n+            InvalidComparatorException, InvalidConstraintValueException {\n+        ParsedResult<T> result = parse(constraint);\n+        T givenValue = parseGivenValue(parseFunction, result);\n+        return new Comparison<>(givenValue, result.comparator, result.comparisonPredicate);\n+    }\n+\n+    private static <T extends Comparable<T>> ParsedResult<T> parse(String constraint) throws\n+            EmptyConstraintException, MissingConstraintValueException, InvalidComparatorException {\n+        constraint = constraint.trim();\n+        if (constraint.isEmpty()) {\n+            throw new EmptyConstraintException();\n+        }\n+        switch (constraint.charAt(0)) {\n+            case '<' -> {\n+                throwIfNoValueAfterComparator(constraint, Comparator.ONE_CHAR);\n+                if (constraint.charAt(1) == '=') {\n+                    throwIfNoValueAfterComparator(constraint, Comparator.TWO_CHARS);\n+                    return new ParsedResult<>(constraint.substring(2).trim(), \"<=\", (x, y) -> x.compareTo(y) <= 0);\n+                } else {\n+                    return new ParsedResult<>(constraint.substring(1).trim(), \"<\", (x, y) -> x.compareTo(y) < 0);\n+                }\n+            }\n+            case '>' -> {\n+                throwIfNoValueAfterComparator(constraint, Comparator.ONE_CHAR);\n+                if (constraint.charAt(1) == '=') {\n+                    throwIfNoValueAfterComparator(constraint, Comparator.TWO_CHARS);\n+                    return new ParsedResult<>(constraint.substring(2).trim(), \">=\", (x, y) -> x.compareTo(y) >= 0);\n+                } else {\n+                    return new ParsedResult<>(constraint.substring(1).trim(), \">\", (x, y) -> x.compareTo(y) > 0);\n+                }\n+            }\n+            case '!' -> {\n+                throwIfNoValueAfterComparator(constraint, Comparator.ONE_CHAR);\n+                if (constraint.charAt(1) != '=') {\n+                    throw new InvalidComparatorException(\"!\");\n+                }\n+                throwIfNoValueAfterComparator(constraint, Comparator.TWO_CHARS);\n+                return new ParsedResult<>(constraint.substring(2).trim(), \"!=\", (x, y) -> x.compareTo(y) != 0);\n+            }\n+            case '=' -> { \/\/ Allowed syntax, equivalent to not using any symbol.\n+                throwIfNoValueAfterComparator(constraint, Comparator.ONE_CHAR);\n+                return new ParsedResult<>(constraint.substring(1).trim(), \"=\", (x, y) -> x.compareTo(y) == 0);\n+            }\n+            default -> {\n+                return new ParsedResult<>(constraint.trim(), \"=\", (x, y) -> x.compareTo(y) == 0);\n+            }\n+        }\n+    }\n+\n+    private static void throwIfNoValueAfterComparator(String constraint, Comparator comparator) throws MissingConstraintValueException {\n+        switch (comparator) {\n+            case ONE_CHAR -> {\n+                if (constraint.length() == 1) {\n+                    throw new MissingConstraintValueException(constraint);\n+                }\n+            }\n+            case TWO_CHARS -> {\n+                if (constraint.length() == 2) {\n+                    throw new MissingConstraintValueException(constraint);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static <T extends Comparable<T>> T parseGivenValue(Function<String, T> parseFunction, ParsedResult<T> result)\n+            throws InvalidConstraintValueException {\n+        try {\n+            return parseFunction.apply(result.value);\n+        }\n+        catch (NumberFormatException e) {\n+            throw new InvalidConstraintValueException(result.value, result.comparator);\n+        }\n+    }\n+\n+    static class ParsedResult<T> {\n+        public String value;\n+        public BiPredicate<T, T> comparisonPredicate;\n+        public String comparator;\n+\n+        public ParsedResult(String value, String comparator,BiPredicate<T, T> comparisonPredicate) {\n+            this.value = value;\n+            this.comparator = comparator;\n+            this.comparisonPredicate = comparisonPredicate;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/ComparisonConstraintParser.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception thrown when {@link ComparisonConstraintParser} cannot find a constraint.\n+ *\/\n+class EmptyConstraintException extends Exception {\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/EmptyConstraintException.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception threw when {@link ComparisonConstraintParser} parses an invalid comparator.\n+ *\/\n+public class InvalidComparatorException extends Exception {\n+    private final String comparator;\n+\n+    public InvalidComparatorException(String comparator) {\n+        this.comparator = comparator;\n+    }\n+\n+    public String getComparator() {\n+        return comparator;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/InvalidComparatorException.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception thrown when {@link ComparisonConstraintParser} parses an invalid value.\n+ *\/\n+class InvalidConstraintValueException extends Exception {\n+    private final String invalidValue;\n+    private final String comparator;\n+\n+    public InvalidConstraintValueException(String invalidValue, String comparator) {\n+        this.invalidValue = invalidValue;\n+        this.comparator = comparator;\n+    }\n+\n+    public String getInvalidValue() {\n+        return invalidValue;\n+    }\n+\n+    public String getComparator() {\n+        return comparator;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/InvalidConstraintValueException.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception thrown when {@link ComparisonConstraintParser} cannot find a value in a constraint after a comparator.\n+ *\/\n+class MissingConstraintValueException extends Exception {\n+    private final String comparator;\n+\n+    public MissingConstraintValueException(String comparator) {\n+        this.comparator = comparator;\n+    }\n+\n+    public String getComparator() {\n+        return comparator;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/MissingConstraintValueException.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.shared;\n-\n-import java.util.function.BiPredicate;\n-\n-\/**\n- * Utility class to parse a comparator either in the applyIf* or in the counts properties of an @IR rules.\n- *\/\n-public class ParsedComparator<T extends Comparable<T>> {\n-    private final String strippedString;\n-    private final BiPredicate<T, T> predicate;\n-    private final String comparator;\n-\n-    public ParsedComparator(String strippedString, BiPredicate<T, T> predicate, String comparator) {\n-        this.strippedString = strippedString;\n-        this.predicate = predicate;\n-        this.comparator = comparator;\n-    }\n-\n-    public String getStrippedString() {\n-        return strippedString;\n-    }\n-\n-    public BiPredicate<T, T> getPredicate() {\n-        return predicate;\n-    }\n-\n-    public String getComparator() {\n-        return comparator;\n-    }\n-\n-    \/**\n-     * Return parsed comparator object which provides the predicate to perform the test.\n-     * Allowed comparators: <, <=, >, =>, =, !=\n-     *\/\n-    public static <T extends Comparable<T>> ParsedComparator<T> parseComparator(String value) throws CheckedTestFrameworkException {\n-        BiPredicate<T, T> comparison;\n-        value = value.trim();\n-        String comparator = \"\";\n-        switch (value.charAt(0)) {\n-            case '<':\n-                if (value.charAt(1) == '=') {\n-                    comparator = \"<=\";\n-                    comparison = (x, y) -> x.compareTo(y) <= 0;\n-                    value = value.substring(2).trim();\n-                } else {\n-                    comparator = \"<\";\n-                    comparison = (x, y) -> x.compareTo(y) < 0;\n-                    value = value.substring(1).trim();\n-                }\n-                break;\n-            case '>':\n-                if (value.charAt(1) == '=') {\n-                    comparator = \">=\";\n-                    comparison = (x, y) -> x.compareTo(y) >= 0;\n-                    value = value.substring(2).trim();\n-                } else {\n-                    comparator = \">\";\n-                    comparison = (x, y) -> x.compareTo(y) > 0;\n-                    value = value.substring(1).trim();\n-                }\n-                break;\n-            case '!':\n-                if (value.charAt(1) != '=') {\n-                    throw new CheckedTestFrameworkException(value.substring(0, 1));\n-                }\n-                comparator = \"!=\";\n-                comparison = (x, y) -> x.compareTo(y) != 0;\n-                value = value.substring(2).trim();\n-                break;\n-            case '=': \/\/ Allowed syntax, equivalent to not using any symbol.\n-                comparator = \"=\";\n-                value = value.substring(1).trim();\n-                \/\/ Fall through\n-            default:\n-                comparison = (x, y) -> x.compareTo(y) == 0;\n-                value = value.trim();\n-                break;\n-        }\n-        return new ParsedComparator<>(value, comparison, comparator);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/ParsedComparator.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    public static void reportIfAnyFailures() {\n+    public static void throwIfAnyFailures() {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFormat.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * The error reporting of the IR framework is throwing exceptions unconditionally in separate methods. The calling methods,\n+ * however, do not see these exceptions. As a result, Java and\/or some IDEs could complain about impossible states\n+ * (e.g. uninitialized variables, null pointer dereferences etc. even though an exception will be thrown earlier).\n+ * To avoid that, throw an instance of this class instead.\n+ *\/\n+class UnreachableCodeException extends RuntimeException {\n+    public UnreachableCodeException() {\n+        super(\"Unreachable code\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/UnreachableCodeException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * and checked by the IRMatcher class in the driver VM after the termination of the test VM.\n+ * and checked by the IRMatcher class in the driver VM after the termination of the test VM. IR rule indices start at 1.\n@@ -76,1 +76,1 @@\n-                        validRules.add(i);\n+                        validRules.add(ruleIndex);\n@@ -209,1 +209,1 @@\n-            return checkLongFlag(flag, value, (Long) actualFlagValue);\n+            return checkFlag(Long::parseLong, \"integer\", flag, value, (Long) actualFlagValue);\n@@ -213,1 +213,1 @@\n-            return checkDoubleFlag(flag, value, (Double) actualFlagValue);\n+            return checkFlag(Double::parseDouble, \"floating point\", flag, value, (Double) actualFlagValue);\n@@ -245,3 +245,2 @@\n-    private boolean checkLongFlag(String flag, String value, long actualFlagValue) {\n-        long longValue;\n-        ParsedComparator<Long> parsedComparator;\n+    private <T extends Comparable<T>> boolean checkFlag(Function<String, T> parseFunction, String kind, String flag,\n+                                                        String value, T actualFlagValue) {\n@@ -249,43 +248,5 @@\n-            parsedComparator = ParsedComparator.parseComparator(value);\n-        } catch (CheckedTestFrameworkException e) {\n-            TestFormat.failNoThrow(\"Invalid comparator in \\\"\" + value + \"\\\" for integer based flag \" + flag + failAt());\n-            return false;\n-        }  catch (IndexOutOfBoundsException e) {\n-            TestFormat.failNoThrow(\"Provided empty value for integer based flag \" + flag + failAt());\n-            return false;\n-        }\n-        try {\n-            longValue = Long.parseLong(parsedComparator.getStrippedString());\n-        } catch (NumberFormatException e) {\n-            String comparator = parsedComparator.getComparator();\n-            if (!comparator.isEmpty()) {\n-                comparator = \"after comparator \\\"\" + parsedComparator.getComparator() + \"\\\"\";\n-            }\n-            TestFormat.failNoThrow(\"Invalid value \\\"\" + parsedComparator.getStrippedString() + \"\\\" \"\n-                            + comparator + \" for integer based flag \" + flag + failAt());\n-            return false;\n-        }\n-        return parsedComparator.getPredicate().test(actualFlagValue, longValue);\n-    }\n-\n-    private boolean checkDoubleFlag(String flag, String value, double actualFlagValue) {\n-        double doubleValue;\n-        ParsedComparator<Double> parsedComparator;\n-        try {\n-            parsedComparator = ParsedComparator.parseComparator(value);\n-        } catch (CheckedTestFrameworkException e) {\n-            TestFormat.failNoThrow(\"Invalid comparator in \\\"\" + value + \"\\\" for floating point based flag \" + flag + failAt());\n-            return false;\n-        } catch (IndexOutOfBoundsException e) {\n-            TestFormat.failNoThrow(\"Provided empty value for floating point based flag \" + flag + failAt());\n-            return false;\n-        }\n-        try {\n-            doubleValue = Double.parseDouble(parsedComparator.getStrippedString());\n-        } catch (NumberFormatException e) {\n-            String comparator = parsedComparator.getComparator();\n-            if (!comparator.isEmpty()) {\n-                comparator = \"after comparator \\\"\" + parsedComparator.getComparator() + \"\\\"\";\n-            }\n-            TestFormat.failNoThrow(\"Invalid value \\\"\" + parsedComparator.getStrippedString() + \"\\\" \"\n-                    + comparator + \" for floating point based flag \" + flag + failAt());\n+            String postFixErrorMsg = \"for \" + kind + \" based flag \\\"\" + flag + \"\\\"\" + failAt();\n+            Comparison<T> comparison = ComparisonConstraintParser.parse(value, parseFunction, postFixErrorMsg);\n+            return comparison.compare(actualFlagValue);\n+        } catch (TestFormatException e) {\n+            \/\/ Format exception, do not apply rule.\n@@ -294,1 +255,0 @@\n-        return parsedComparator.getPredicate().test(actualFlagValue, doubleValue);\n@@ -298,1 +258,1 @@\n-        return \" for @IR rule \" + ruleIndex + \" at \" + method;\n+        return \" in @IR rule \" + ruleIndex + \" at \" + method;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":13,"deletions":53,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,1 @@\n-        TestFormat.reportIfAnyFailures();\n+        TestFormat.throwIfAnyFailures();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int StringCodingCountPositives(byte[] ba, int off, int len) {\n+        return StringCoding.countPositives(ba, off, len);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8022585\n+ * @bug 8022585 8277055\n@@ -30,1 +30,4 @@\n- *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining\n+ *                   compiler.print.PrintInlining\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintIntrinsics\n+ *                   compiler.print.PrintInlining\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/PrintInlining.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -130,0 +130,67 @@\n+    private static void testOverflow(String method, long start, long stop, long length, long offset0, long offset1) throws Exception {\n+        Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset0);\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset0);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, start, stop, length, offset1);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+    }\n+\n+    private static void testConditional(String method, long start, long stop, long length, long offset0, long offset1, long start1, long stop1) throws Exception {\n+        Method m;\n+\n+        if (start1 != start) {\n+            m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            compile(m);\n+\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, start, stop, length, offset1, start1-1, stop1);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+\n+        if (stop1 != stop) {\n+            m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            compile(m);\n+\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, start, stop, length, offset1, start1, stop1+1);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+\n+        m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset0, start, stop);\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset0, start, stop);\n+        assertIsCompiled(m);\n+\n+        m.invoke(null, start, stop, length, offset1, start1, stop1);\n+        assertIsCompiled(m);\n+    }\n@@ -160,18 +227,4 @@\n-\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePos\", long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, 0);\n-            assertIsCompiled(m);\n-            try {\n-                m.invoke(null, 0, 100, 100, Long.MAX_VALUE - 50);\n-                throw new RuntimeException(\"should have thrown\");\n-            } catch(InvocationTargetException e) {\n-                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n-                    throw new RuntimeException(\"unexpected exception\");\n-                }\n-            }\n-            assertIsNotCompiled(m);\n-        }\n+        testOverflow(\"testStridePosScalePos\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStrideNegScaleNeg\", 0, 100, 100, 100, Long.MIN_VALUE + 50);\n+        testOverflow(\"testStrideNegScalePos\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStridePosScaleNeg\", 0, 100, 100, 99, Long.MIN_VALUE + 50);\n@@ -180,16 +233,8 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, -50, 50, 100);\n-            assertIsCompiled(m);\n-        }\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, Long.MAX_VALUE, Long.MAX_VALUE - 50, 0, 50);\n-            assertIsCompiled(m);\n-        }\n+        testConditional(\"testStridePosScalePosConditional\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStridePosScalePosConditional\", 0, 100, Long.MAX_VALUE, 0, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStrideNegScaleNegConditional\", 0, 100, 100, 100, 50, 0, 51);\n+        testConditional(\"testStrideNegScaleNegConditional\", 0, 100, Long.MAX_VALUE, 100, Long.MIN_VALUE + 50, 52, 100);\n+        testConditional(\"testStrideNegScalePosConditional\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStrideNegScalePosConditional\", 0, 100, Long.MAX_VALUE, 100, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStridePosScaleNegConditional\", 0, 100, 100, 99, 50, 0, 51);\n+        testConditional(\"testStridePosScaleNegConditional\", 0, 100, Long.MAX_VALUE, 99, Long.MIN_VALUE + 50, 52, 100);\n@@ -224,17 +269,4 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosInIntLoop\", long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, 0);\n-            assertIsCompiled(m);\n-            try {\n-                m.invoke(null, 0, 100, 100, Long.MAX_VALUE - 50);\n-                throw new RuntimeException(\"should have thrown\");\n-            } catch(InvocationTargetException e) {\n-                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n-                    throw new RuntimeException(\"unexpected exception\");\n-                }\n-            }\n-            assertIsNotCompiled(m);\n-        }\n+        testOverflow(\"testStridePosScalePosInIntLoop\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStrideNegScaleNegInIntLoop\", 0, 100, 100, 100, Long.MIN_VALUE + 50);\n+        testOverflow(\"testStrideNegScalePosInIntLoop\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStridePosScaleNegInIntLoop\", 0, 100, 100, 99, Long.MIN_VALUE + 50);\n@@ -242,16 +274,8 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, -50, 50, 100);\n-            assertIsCompiled(m);\n-        }\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, Long.MAX_VALUE, Long.MAX_VALUE - 50, 0, 50);\n-            assertIsCompiled(m);\n-        }\n+        testConditional(\"testStridePosScalePosConditionalInIntLoop\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStridePosScalePosConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 0, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStrideNegScaleNegConditionalInIntLoop\", 0, 100, 100, 100, 50, 0, 51);\n+        testConditional(\"testStrideNegScaleNegConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 100, Long.MIN_VALUE + 50, 52, 100);\n+        testConditional(\"testStrideNegScalePosConditionalInIntLoop\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStrideNegScalePosConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 100, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStridePosScaleNegConditionalInIntLoop\", 0, 100, 100, 99, 50, 0, 51);\n+        testConditional(\"testStridePosScaleNegConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 99, Long.MIN_VALUE + 50, 52, 100);\n@@ -414,0 +438,30 @@\n+    public static void testStrideNegScaleNegConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n@@ -532,1 +586,0 @@\n-        Preconditions.checkIndex(0, length, null);\n@@ -535,0 +588,33 @@\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = -1;\n+        final int stride = 1;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = 1;\n+        final int stride = 1;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = -1;\n+        final int stride = 1;\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestLongRangeCheck.java","additions":154,"deletions":68,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires vm.bits == 64\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/Test6826736.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();;\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/TestMisalignedUnsafeAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.nio.ByteOrder;\n@@ -44,0 +45,2 @@\n+    static final boolean IS_BIG_ENDIAN = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;\n+\n@@ -107,0 +110,4 @@\n+        \/\/ On LE systems, low-order bytes of long and int overlap, but\n+        \/\/ on BE systems, they differ by the size of an int.\n+        long mismatchedOffset = Unsafe.ARRAY_LONG_BASE_OFFSET + (IS_BIG_ENDIAN ? 4 : 0);\n+\n@@ -108,1 +115,1 @@\n-                          dstArrL, Unsafe.ARRAY_LONG_BASE_OFFSET, 4); \/\/ mismatched\n+                          dstArrL, mismatchedOffset, 4); \/\/ mismatched\n@@ -159,0 +166,1 @@\n+        srcOffset += (!flag && IS_BIG_ENDIAN ? 4 : 0);\n@@ -182,0 +190,1 @@\n+        dstOffset += (!flag && IS_BIG_ENDIAN ? 4 : 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/UnsafeCopyMemory.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Asserts;\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestMaskedMacroLogicVector.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-* @requires vm.cpu.features ~= \".*avx512dq.*\"\n-* @requires vm.cpu.features ~= \".*vpopcntdq.*\"\n@@ -30,0 +28,1 @@\n+* @requires vm.cpu.features ~= \".*avx512bw.*\"\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVectorLong.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    static final String[] variables = {\"Memory Limit is:\", \"CPU Shares is:\", \"CPU Quota is:\", \"CPU Period is:\", \"active_processor_count:\"};\n+    static final String[] variables = {\"Memory Limit is:\", \"CPU Quota is:\", \"CPU Period is:\", \"active_processor_count:\"};\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/PlainRead.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,5 @@\n+        \/\/ OLD = use the deprecated -XX:+UseContainerCpuShares flag, which\n+        \/\/ will be removed in the next JDK release. See JDK-8281181.\n+        boolean OLD = true;\n+        boolean NEW = false;\n+\n@@ -111,1 +116,2 @@\n-                testAPCCombo(testCpuSet, 200*1000, 100*1000,   4*1024, true, 1);\n+                testAPCCombo(OLD, testCpuSet, 200*1000, 100*1000,   4*1024, true, 1);\n+                testAPCCombo(NEW, testCpuSet, 200*1000, 100*1000,   4*1024, true, 1);\n@@ -117,3 +123,7 @@\n-                testAPCCombo(testCpuSet, 200*1000, 100*1000, 4*1024, true, 2);\n-                testAPCCombo(testCpuSet, 200*1000, 100*1000, 1023,   true, 2);\n-                testAPCCombo(testCpuSet, 200*1000, 100*1000, 1023,   false,  1);\n+                testAPCCombo(OLD, testCpuSet, 200*1000, 100*1000, 4*1024, true, 2);\n+                testAPCCombo(OLD, testCpuSet, 200*1000, 100*1000, 1023,   true, 2);\n+                testAPCCombo(OLD, testCpuSet, 200*1000, 100*1000, 1023,   false,1);\n+\n+                testAPCCombo(NEW, testCpuSet, 200*1000, 100*1000, 4*1024, true, 2);\n+                testAPCCombo(NEW, testCpuSet, 200*1000, 100*1000, 1023,   true, 2);\n+                testAPCCombo(NEW, testCpuSet, 200*1000, 100*1000, 1023,   false,2);\n@@ -125,3 +135,7 @@\n-                testAPCCombo(testCpuSet, 100*1000, 100*1000, 2*1024, true, 1);\n-                testAPCCombo(testCpuSet, 200*1000, 100*1000, 1023,   true, 2);\n-                testAPCCombo(testCpuSet, 200*1000, 100*1000, 1023,   false,  1);\n+                testAPCCombo(OLD, testCpuSet, 100*1000, 100*1000, 2*1024, true, 1);\n+                testAPCCombo(OLD, testCpuSet, 200*1000, 100*1000, 1023,   true, 2);\n+                testAPCCombo(OLD, testCpuSet, 200*1000, 100*1000, 1023,   false,1);\n+\n+                testAPCCombo(NEW, testCpuSet, 100*1000, 100*1000, 2*1024, true, 1);\n+                testAPCCombo(NEW, testCpuSet, 200*1000, 100*1000, 1023,   true, 2);\n+                testAPCCombo(NEW, testCpuSet, 200*1000, 100*1000, 1023,   false,2);\n@@ -184,2 +198,5 @@\n-    \/\/ Test correctess of automatically selected active processor cound\n-    private static void testAPCCombo(String cpuset, int quota, int period, int shares,\n+    \/\/ Test correctess of automatically selected active processor count\n+    \/\/ Note: when -XX:+UseContainerCpuShares is removed,\n+    \/\/ useContainerCpuShares, shares, and usePreferContainerQuotaForCPUCount\n+    \/\/ should also be removed.\n+    private static void testAPCCombo(boolean useContainerCpuShares, String cpuset, int quota, int period, int shares,\n@@ -193,0 +210,1 @@\n+        System.out.println(\"useContainerCpuShares = \" + useContainerCpuShares);\n@@ -204,1 +222,2 @@\n-        if (!usePreferContainerQuotaForCPUCount) opts.addJavaOpts(\"-XX:-PreferContainerQuotaForCPUCount\");\n+        if (useContainerCpuShares) opts.addJavaOpts(\"-XX:+UseContainerCpuShares\");  \/\/ deprecated\n+        if (!usePreferContainerQuotaForCPUCount) opts.addJavaOpts(\"-XX:-PreferContainerQuotaForCPUCount\");  \/\/ deprecated\n@@ -211,0 +230,1 @@\n+    \/\/ Note: when -XX:+UseContainerCpuShares is removed, this test should also be removed.\n@@ -219,0 +239,1 @@\n+        opts.addJavaOpts(\"-XX:+UseContainerCpuShares\"); \/\/ deprecated\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUAwareness.java","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -118,9 +118,6 @@\n-    \/\/ and setting ParallelGCThreads=4294967296 should give back 0. (SerialGC is ok with ParallelGCThreads=0)\n-    for (long i = 4294967295L; i <= 4294967296L; i++) {\n-      long count = getParallelGCThreadCount(\n-          \"-XX:+UseSerialGC\",\n-          \"-XX:ParallelGCThreads=\" + i,\n-          \"-XX:+PrintFlagsFinal\",\n-          \"-version\");\n-      Asserts.assertEQ(count, i % 4294967296L, \"Specifying ParallelGCThreads=\" + i + \" does not set the thread count properly!\");\n-    }\n+    long count = getParallelGCThreadCount(\n+        \"-XX:+UseSerialGC\",\n+        \"-XX:ParallelGCThreads=4294967295\",\n+        \"-XX:+PrintFlagsFinal\",\n+        \"-version\");\n+    Asserts.assertEQ(count, 4294967295L, \"Specifying ParallelGCThreads=4294967295 does not set the thread count properly!\");\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelGCThreads.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * bug 8281811\n+ * @summary assert(_base == Tuple) failed: Not a Tuple after JDK-8280799\n+ * @requires vm.gc.Shenandoah\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:-BackgroundCompilation -XX:LoopMaxUnroll=1 TestBarrierAboveProj\n+ *\/\n+\n+\n+public class TestBarrierAboveProj {\n+    private static C objField = new C();\n+    private static final Object[] arrayField = new Object[1000];\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1();\n+            test2();\n+        }\n+    }\n+\n+    private static float test1() {\n+        float v = 1;\n+        for (int i = 1; i < 1000; i++) {\n+            if (objField == arrayField[i]) {\n+                return v;\n+            }\n+            v *= 2;\n+        }\n+        return v;\n+    }\n+\n+    private static float test2() {\n+        float v = 1;\n+        volatileField = 0x42;\n+        for (int i = 1; i < 1000; i++) {\n+            if (objField == arrayField[i]) {\n+                return v;\n+            }\n+            v *= 2;\n+        }\n+        return v;\n+    }\n+\n+    private static class C {\n+        public float floatField;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestBarrierAboveProj.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8275775\n+ * @summary Test jcmd VM.classes\n+ * @library \/test\/lib\n+ * @run main\/othervm PrintClasses\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.JDKToolFinder;\n+\n+public class PrintClasses {\n+  public static void main(String args[]) throws Exception {\n+    var pid = Long.toString(ProcessHandle.current().pid());\n+    var pb = new ProcessBuilder();\n+\n+    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.classes\"});\n+    var output = new OutputAnalyzer(pb.start());\n+    output.shouldNotContain(\"instance size\");\n+    output.shouldContain(PrintClasses.class.getSimpleName());\n+\n+    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.classes\", \"-verbose\"});\n+    output = new OutputAnalyzer(pb.start());\n+    output.shouldContain(\"instance size\");\n+    output.shouldContain(PrintClasses.class.getSimpleName());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/PrintClasses.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -48,0 +48,2 @@\n+        \/\/ Use an ArrayList so platform-specific flags can be\n+        \/\/ optionally added.\n@@ -63,0 +65,4 @@\n+        if (Platform.isLinux()) {\n+            deprecated.add(new String[] {\"UseContainerCpuShares\",           \"false\"});\n+            deprecated.add(new String[] {\"PreferContainerQuotaForCPUCount\", \"true\"});\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8167108 8266130\n+ * @bug 8167108 8266130 8282704\n@@ -28,0 +28,1 @@\n+ * @modules java.base\/java.lang:open\n@@ -31,0 +32,1 @@\n+import java.lang.reflect.Method;\n@@ -41,0 +43,4 @@\n+    public StopAtExit(ThreadGroup group, Runnable target) {\n+        super(group, target);\n+    }\n+\n@@ -75,0 +81,2 @@\n+        long manualDestroyCnt = 0;\n+        long manualTerminateCnt = 0;\n@@ -79,1 +87,6 @@\n-            StopAtExit thread = new StopAtExit();\n+            \/\/ Use my own ThreadGroup so the thread count is known and make\n+            \/\/ it a daemon ThreadGroup so it is automatically destroyed when\n+            \/\/ the thread is terminated.\n+            ThreadGroup myTG = new ThreadGroup(\"myTG-\" + count);\n+            myTG.setDaemon(true);\n+            StopAtExit thread = new StopAtExit(myTG, null);\n@@ -110,0 +123,2 @@\n+            \/\/ This stop() call happens after the join() so it should do\n+            \/\/ nothing, but let's make sure.\n@@ -111,0 +126,33 @@\n+\n+            if (myTG.activeCount() != 0) {\n+                \/\/ If the ThreadGroup still has a count, then the thread\n+                \/\/ received the async exception while in exit() so we need\n+                \/\/ to do a manual terminate.\n+                manualTerminateCnt++;\n+                try {\n+                    threadTerminated(myTG, thread);\n+                } catch (Exception e) {\n+                    throw new Error(\"threadTerminated() threw unexpected: \" + e);\n+                }\n+                int activeCount = myTG.activeCount();\n+                if (activeCount != 0) {\n+                    throw new Error(\"threadTerminated() did not clean up \" +\n+                                    \"worker thread: count=\" + activeCount);\n+                }\n+                if (!myTG.isDestroyed()) {\n+                    throw new Error(\"threadTerminated() did not destroy \" +\n+                                    myTG.getName());\n+                }\n+            } else if (!myTG.isDestroyed()) {\n+                \/\/ If the ThreadGroup does not have a count, but is not\n+                \/\/ yet destroyed, then the thread received the async\n+                \/\/ exception while the thread was in the later stages of\n+                \/\/ its threadTerminated() call so we need to do a manual\n+                \/\/ destroy.\n+                manualDestroyCnt++;\n+                try {\n+                    myTG.destroy();\n+                } catch (Exception e) {\n+                    throw new Error(\"myTG.destroy() threw unexpected: \" + e);\n+                }\n+            }\n@@ -113,0 +161,8 @@\n+        if (manualDestroyCnt != 0) {\n+            System.out.println(\"Manually destroyed ThreadGroup \" +\n+                               manualDestroyCnt + \" times.\");\n+        }\n+        if (manualTerminateCnt != 0) {\n+            System.out.println(\"Manually terminated Thread \" +\n+                               manualTerminateCnt + \" times.\");\n+        }\n@@ -123,0 +179,7 @@\n+    static void threadTerminated(ThreadGroup group, Thread thread) throws Exception {\n+        \/\/ ThreadGroup.threadTerminated() is package private:\n+        Method method = ThreadGroup.class.getDeclaredMethod(\"threadTerminated\", Thread.class);\n+        method.setAccessible(true);\n+        method.invoke(group, thread);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/StopAtExit.java","additions":66,"deletions":3,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,5 @@\n+            if (!compressed) {\n+                System.out.println(\"CDS archives with uncompressed oops are still non-deterministic\");\n+                System.out.println(\"See https:\/\/bugs.openjdk.java.net\/browse\/JDK-8282828\");\n+                return;\n+            }\n@@ -81,0 +86,1 @@\n+        String mapName = logName + \".map\";\n@@ -83,0 +89,1 @@\n+            .addPrefix(\"-Xlog:cds+map=trace:file=\" + mapName + \":none:filesize=0\")\n@@ -84,0 +91,1 @@\n+            .addSuffix(args)\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,4 +73,3 @@\n-    \/\/ shared base address test table\n-    private static final String[] testTable = {\n-        \"1g\", \"8g\", \"64g\",\"512g\", \"4t\",\n-        \"32t\", \"128t\", \"0\",\n+    \/\/ shared base address test table for {32, 64}bit VM\n+    private static final String[] testTableShared = {\n+        \"1g\", \"0\",\n@@ -78,0 +77,9 @@\n+        \"0xfff80000\",         \/\/ archive top wraps around 32-bit address space\n+        \"0xffffffff\",         \/\/ archive bottom wraps around 32-bit address space -- due to align_up()\n+        \"0\"                   \/\/ always let OS pick the base address at runtime (ASLR for CDS archive)\n+    };\n+\n+    \/\/ shared base address test table for 64bit VM only\n+    private static final String[] testTable64 = {\n+        \"8g\", \"64g\",\"512g\", \"4t\",\n+        \"32t\", \"128t\",\n@@ -80,1 +88,0 @@\n-        \"0xfff80000\",         \/\/ archive top wraps around 32-bit address space\n@@ -82,1 +89,0 @@\n-        \"0xffffffff\",         \/\/ archive bottom wraps around 32-bit address space -- due to align_up()\n@@ -84,1 +90,1 @@\n-        \"0x500000000\",        \/\/ (20g) below 32g at a 4g aligned address, but cannot be expressed with a logical\n+        \"0x500000000\"         \/\/ (20g) below 32g at a 4g aligned address, but cannot be expressed with a logical\n@@ -86,1 +92,0 @@\n-        \"0\",                  \/\/ always let OS pick the base address at runtime (ASLR for CDS archive)\n@@ -92,1 +97,1 @@\n-    public static void main(String[] args) throws Exception {\n+    public static void test(String[] args, String[] testTable) throws Exception {\n@@ -137,0 +142,7 @@\n+\n+    public static void main(String[] args) throws Exception {\n+        test(args, testTableShared);\n+        if (Platform.is64bit()) {\n+            test(args, testTable64);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/SharedBaseAddress.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.test.lib.Platform;\n@@ -40,5 +41,9 @@\n-    \/\/ shared base address test table\n-    private static final String[] testTable = {\n-        \"1g\", \"8g\", \"64g\",\"512g\", \"4t\",\n-        \"32t\", \"128t\", \"0\",\n-        \"1\", \"64k\", \"64M\", \"320g\",\n+    \/\/ shared base address test table for {32, 64}bit VM\n+    private static final String[] testTableShared = {\n+        \"1g\", \"0\", \"1\", \"64k\", \"64M\"\n+    };\n+\n+    \/\/ shared base address test table for 64bit VM only\n+    private static final String[] testTable64 = {\n+        \"8g\", \"64g\",\"512g\", \"4t\",\n+        \"32t\", \"128t\", \"320g\",\n@@ -48,1 +53,1 @@\n-    public static void main(String[] args) throws Exception {\n+    public static void test(String[] testTable) throws Exception {\n@@ -65,0 +70,7 @@\n+\n+    public static void main(String[] args) throws Exception {\n+        test(testTableShared);\n+        if (Platform.is64bit()) {\n+            test(testTable64);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedBaseAddress.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -469,1 +469,1 @@\n-        opts.addSuffix(suffix).setXShareMode(\"off\");;\n+        opts.addSuffix(suffix).setXShareMode(\"off\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test Loading CDS archived heap objects into ParallelGC\n+ * @bug 8274788\n+ * @requires vm.cds\n+ * @requires vm.gc.Parallel\n+ * @requires vm.gc.G1\n+ *\n+ * @comment don't run this test if any -XX::+Use???GC options are specified, since they will\n+ *          interfere with the the test.\n+ * @requires vm.gc == null\n+ *\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/Hello.java\n+ * @run driver TestParallelGCWithCDS\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestParallelGCWithCDS {\n+    public final static String HELLO = \"Hello World\";\n+    static String helloJar;\n+\n+    public static void main(String... args) throws Exception {\n+        helloJar = JarBuilder.build(\"hello\", \"Hello\");\n+\n+        \/\/ Check if we can use ParallelGC during dump time, or run time, or both.\n+        test(false, true);\n+        test(true,  false);\n+        test(true,  true);\n+\n+        \/\/ With G1 we usually have 2 heap regions. To increase test coverage, we can have 3 heap regions\n+        \/\/ by using \"-Xmx256m -XX:ObjectAlignmentInBytes=64\"\n+        if (Platform.is64bit()) test(false, true, true);\n+    }\n+\n+    final static String G1 = \"-XX:+UseG1GC\";\n+    final static String Parallel = \"-XX:+UseParallelGC\";\n+\n+    static void test(boolean dumpWithParallel, boolean execWithParallel) throws Exception {\n+        test(dumpWithParallel, execWithParallel, false);\n+    }\n+\n+    static void test(boolean dumpWithParallel, boolean execWithParallel, boolean useSmallRegions) throws Exception {\n+        String dumpGC = dumpWithParallel ? Parallel : G1;\n+        String execGC = execWithParallel ? Parallel : G1;\n+        String small1 = useSmallRegions ? \"-Xmx256m\" : \"-showversion\";\n+        String small2 = useSmallRegions ? \"-XX:ObjectAlignmentInBytes=64\" : \"-showversion\";\n+        OutputAnalyzer out;\n+\n+        System.out.println(\"0. Dump with \" + dumpGC);\n+        out = TestCommon.dump(helloJar,\n+                              new String[] {\"Hello\"},\n+                              dumpGC,\n+                              small1,\n+                              small2,\n+                              \"-Xlog:cds\");\n+        out.shouldContain(\"Dumping shared data to file:\");\n+        out.shouldHaveExitValue(0);\n+\n+        System.out.println(\"1. Exec with \" + execGC);\n+        out = TestCommon.exec(helloJar,\n+                              execGC,\n+                              small1,\n+                              small2,\n+                              \"-Xlog:cds\",\n+                              \"Hello\");\n+        out.shouldContain(HELLO);\n+        out.shouldHaveExitValue(0);\n+\n+        int n = 2;\n+        if (!dumpWithParallel && execWithParallel) {\n+            \/\/ We dumped with G1, so we have an archived heap. At exec time, try to load them into\n+            \/\/ a small ParallelGC heap that may be too small.\n+            String[] sizes = {\n+                \"4m\",   \/\/ usually this will success load the archived heap\n+                \"2m\",   \/\/ usually this will fail to load the archived heap, but app can launch\n+                        \/\/ or fail with \"GC triggered before VM initialization completed\"\n+                \"1m\"    \/\/ usually this will cause VM launch to fail with \"Too small maximum heap\"\n+            };\n+            for (String sz : sizes) {\n+                String xmx = \"-Xmx\" + sz;\n+                System.out.println(\"=======\\n\" + n + \". Exec with \" + execGC + \" \" + xmx);\n+                out = TestCommon.exec(helloJar,\n+                                      execGC,\n+                                      small1,\n+                                      small2,\n+                                      xmx,\n+                                      \"-Xlog:cds\",\n+                                      \"Hello\");\n+                if (out.getExitValue() == 0) {\n+                    out.shouldContain(HELLO);\n+                } else {\n+                    String output = out.getStdout() + out.getStderr();\n+                    String exp1 = \"Too small maximum heap\";\n+                    String exp2 = \"GC triggered before VM initialization completed\";\n+                    if (!output.contains(exp1) && !output.contains(exp2)) {\n+                        throw new RuntimeException(\"Either '\" + exp1 + \"' or '\" + exp2 + \"' must be in stdout\/stderr \\n\");\n+                    }\n+                }\n+                n++;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestParallelGCWithCDS.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleDescriptor.Requires;\n+import java.lang.module.ModuleDescriptor.Requires.Modifier;\n+import java.util.Optional;\n+\n+public class ArchivedEnumApp {\n+    public static void main(final String[] args) throws Exception {\n+        \/\/ Validate the archiving of the synthetic Modifier.$VALUES field:\n+        for (Modifier mod : Modifier.values()) {\n+            check(mod);\n+        }\n+        if (Modifier.values().length != 4) {\n+            throw new RuntimeException(\"Modifier.$VALUES.length expeced: 4, actual: \" + Modifier.values().length);\n+        }\n+\n+        \/\/ All 4 enums must exist in synthetic Modifier.$VALUES\n+        check_in_array(Modifier.MANDATED);\n+        check_in_array(Modifier.STATIC);\n+        check_in_array(Modifier.SYNTHETIC);\n+        check_in_array(Modifier.TRANSITIVE);\n+\n+        \/\/ Find this module from (archived) boot layer\n+        String moduleName = \"java.management\";\n+        Optional<Module> module = ModuleLayer.boot().findModule(moduleName);\n+        if (module.isEmpty()) {\n+            throw new RuntimeException(moduleName + \" module is missing in boot layer\");\n+        }\n+        ModuleDescriptor md = module.get().getDescriptor();\n+        System.out.println(\"Module: \" + md);\n+        for (Requires r : md.requires()) {\n+            System.out.println(\"Requires: \" + r);\n+            for (Modifier mod : r.modifiers()) {\n+                System.out.println(\"   modifier: \" + mod);\n+                check(mod);\n+            }\n+        }\n+\n+        System.out.println(\"Success\");\n+    }\n+\n+    static void check(Modifier mod) {\n+        \/\/ The archived Enum object must equal to one of the following\n+        \/\/ four values.\n+        if (mod != Modifier.MANDATED &&\n+            mod != Modifier.STATIC &&\n+            mod != Modifier.SYNTHETIC &&\n+            mod != Modifier.TRANSITIVE) {\n+\n+            System.out.println(\"mod                 = \" + info(mod));\n+            System.out.println(\"Modifier.MANDATED   = \" + info(Modifier.MANDATED));\n+            System.out.println(\"Modifier.STATIC     = \" + info(Modifier.STATIC));\n+            System.out.println(\"Modifier.SYNTHETIC  = \" + info(Modifier.SYNTHETIC));\n+            System.out.println(\"Modifier.TRANSITIVE = \" + info(Modifier.TRANSITIVE));\n+\n+            throw new RuntimeException(\"Archived enum object does not match static fields in enum class: \" + info(mod));\n+        }\n+    }\n+\n+    static void check_in_array(Modifier mod) {\n+        for (Modifier m : Modifier.values()) {\n+            if (mod == m) {\n+                return;\n+            }\n+        }\n+        throw new RuntimeException(\"Enum object is not in $VALUES array: \" + info(mod));\n+    }\n+\n+    static String info(Object o) {\n+        return \"@0x\" + Integer.toHexString(System.identityHashCode(o)) + \" \" + o;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedEnumApp.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275731\n+ * @summary Enum objects that are stored in the archived module graph should match\n+ *          the static final fields in the Enum class.\n+ * @modules java.management\n+ * @requires vm.cds.write.archived.java.heap\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build ArchivedEnumApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar ArchivedEnumApp.jar ArchivedEnumApp\n+ * @run driver ArchivedEnumTest\n+ *\/\n+\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ArchivedEnumTest {\n+    public static void main(String[] args) throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"ArchivedEnumApp.jar\");\n+\n+        OutputAnalyzer out = TestCommon.testDump(appJar,\n+                                                 TestCommon.list(\"ArchivedEnumApp\"));\n+        \/\/ Note: You can get the following line to fail by commenting out\n+        \/\/ the ADD_EXCL(...) lines in cdsHeapVerifier.cpp\n+        out.shouldNotContain(\"object points to a static field that may be reinitialized at runtime\");\n+\n+        TestCommon.run(\"-cp\", appJar,\n+                       \"-Xlog:cds=debug\",\n+                       \"-Xlog:cds+heap\",\n+                       \"ArchivedEnumApp\").assertNormalExit(\"Success\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedEnumTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -57,1 +57,1 @@\n-            JarBuilder.build(true, \"WhiteBox\", \"sun\/hotspot\/WhiteBox\");;\n+            JarBuilder.build(true, \"WhiteBox\", \"sun\/hotspot\/WhiteBox\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/SameNameInTwoLoadersTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,1 @@\n-            if (i != 0) {\n+            if (i != 0 && !out.getStdout().contains(\"LockDuringDumpAgent timeout\")) {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/LockDuringDump.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,5 @@\n+            long started = System.currentTimeMillis();\n+            long timeout = 10000;\n+            synchronized (LITERAL) {\n+                Thread.sleep(1);\n+            }\n@@ -56,1 +61,8 @@\n-                    lock.wait();\n+                    lock.wait(timeout);\n+                    long elapsed = System.currentTimeMillis() - started;\n+                    if (elapsed >= timeout) {\n+                        System.out.println(\"This JVM may decide to not launch any Java threads during -Xshare:dump.\");\n+                        System.out.println(\"This is OK because no string objects could be in a locked state during heap dump.\");\n+                        System.out.println(\"LockDuringDumpAgent timeout after \" + elapsed + \" ms\");\n+                        return;\n+                    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/javaldr\/LockDuringDumpAgent.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires vm.opt.DeoptimizeALot != true\n@@ -505,1 +506,1 @@\n-\/\/ Class hierachy:\n+\/\/ Class hierarchy:\n@@ -621,1 +622,1 @@\n-\/\/ Class hierachy:\n+\/\/ Class hierarchy:\n@@ -667,1 +668,1 @@\n-\/\/ Class hierachy:\n+\/\/ Class hierarchy:\n@@ -696,1 +697,1 @@\n-\/\/ Class hierachy:\n+\/\/ Class hierarchy:\n@@ -736,1 +737,1 @@\n-\/\/ Class hierachy:\n+\/\/ Class hierarchy:\n@@ -814,1 +815,1 @@\n-\/\/ Class hierachy:\n+\/\/ Class hierarchy:\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/AbstractMethodError\/AbstractMethodErrorTest.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -348,1 +348,1 @@\n-\/\/ Class hierachy:\n+\/\/ Class hierarchy:\n@@ -410,1 +410,1 @@\n-\/\/ Class hierachy:\n+\/\/ Class hierarchy:\n@@ -424,1 +424,1 @@\n-\/\/ Class hierachy:\n+\/\/ Class hierarchy:\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/IncompatibleClassChangeError\/IncompatibleClassChangeErrorTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-\/\/ Class hierachy:\n+\/\/ Class hierarchy:\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/methodPrinting\/TestPrintingMethods.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -593,1 +593,1 @@\n-            ((ABBox) dontinline_endlessLoop(new ABBox(this))).synchronizedSlowInc();;\n+            ((ABBox) dontinline_endlessLoop(new ABBox(this))).synchronizedSlowInc();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Heap\/IterateHeapWithEscapeAnalysisEnabled.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8144992\n+ * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @run main\/othervm\/native -agentlib:TestManyBreakpoints\n+ *                          -Xlog:gc+metaspace\n+ *                          -Xint\n+ *                          -XX:MetaspaceSize=16K -XX:MaxMetaspaceSize=64M\n+ *                          TestManyBreakpoints\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+\n+public class TestManyBreakpoints {\n+\n+  static final int BATCHES = 50;\n+  static final int METHODS = 1000;\n+\n+  public static void main(String[] args) throws Exception {\n+    for (int c = 0; c < BATCHES; c++) {\n+      System.out.println(\"Batch \" + c);\n+      TestClassLoader loader = new TestClassLoader();\n+      Class.forName(\"Target\", true, loader);\n+    }\n+  }\n+\n+  private static class TestClassLoader extends ClassLoader implements Opcodes {\n+    static byte[] TARGET_BYTES = generateTarget();\n+\n+    private static byte[] generateTarget() {\n+      ClassWriter cw = new ClassWriter(0);\n+\n+      cw.visit(52, ACC_SUPER | ACC_PUBLIC, \"Target\", null, \"java\/lang\/Object\", null);\n+      for (int m = 0; m < METHODS; m++) {\n+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"m\" + m, \"()V\", null, null);\n+        mv.visitCode();\n+        mv.visitInsn(RETURN);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+      }\n+      cw.visitEnd();\n+      return cw.toByteArray();\n+    }\n+\n+    @Override\n+    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+      if (name.equals(\"Target\")) {\n+        return defineClass(name, TARGET_BYTES, 0, TARGET_BYTES.length);\n+      } else {\n+        return super.findClass(name);\n+      }\n+    }\n+  }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SetBreakpoint\/TestManyBreakpoints.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+\n+#include \"jvmti.h\"\n+\n+#define TARGET_CLASS_NAME \"LTarget;\"\n+\n+static jvmtiEnv *jvmti = NULL;\n+\n+static void\n+check_jvmti_status(JNIEnv* jni, jvmtiError err, const char* msg) {\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"check_jvmti_status: %s, JVMTI function returned error: %d\\n\", msg, err);\n+    jni->FatalError(msg);\n+  }\n+}\n+\n+void JNICALL classprepare(jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread, jclass klass) {\n+    char* buf;\n+    jvmtiError err;\n+\n+    err = jvmti->GetClassSignature(klass, &buf, NULL);\n+    check_jvmti_status(jni_env, err, \"classprepare: GetClassSignature error\");\n+\n+    if (strncmp(buf, TARGET_CLASS_NAME, strlen(TARGET_CLASS_NAME)) == 0) {\n+        jint nMethods;\n+        jmethodID* methods;\n+        int i;\n+\n+        err = jvmti->GetClassMethods(klass, &nMethods, &methods);\n+        check_jvmti_status(jni_env, err, \"classprepare: GetClassMethods error\");\n+        printf(\"Setting breakpoints in %s\\n\", buf);\n+        fflush(stdout);\n+        for (i = 0; i < nMethods; i++) {\n+            err = jvmti->SetBreakpoint(methods[i], 0);\n+            check_jvmti_status(jni_env, err, \"classprepare: SetBreakpoint error\");\n+        }\n+    }\n+}\n+\n+\n+void JNICALL breakpoint(jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread, jmethodID method, jlocation location) {\n+   \/\/ Do nothing\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* vm, char* options, void* reserved) {\n+    jvmtiCapabilities capa;\n+    jvmtiEventCallbacks cbs;\n+    jint err;\n+\n+    err = vm->GetEnv((void**)&jvmti, JVMTI_VERSION_1_0);\n+    if (err != JNI_OK) {\n+        printf(\"Agent_OnLoad: GetEnv error\\n\");\n+        return JNI_ERR;\n+    }\n+\n+    memset(&capa, 0, sizeof(capa));\n+    capa.can_generate_breakpoint_events = 1;\n+    capa.can_generate_single_step_events = 1;\n+    err = jvmti->AddCapabilities(&capa);\n+    if (err != JNI_OK) {\n+        printf(\"Agent_OnLoad: AddCapabilities error\\n\");\n+        return JNI_ERR;\n+    }\n+\n+    memset(&cbs, 0, sizeof(cbs));\n+    cbs.ClassPrepare = classprepare;\n+    cbs.Breakpoint = breakpoint;\n+    err = jvmti->SetEventCallbacks(&cbs, sizeof(cbs));\n+    if (err != JNI_OK) {\n+        printf(\"Agent_OnLoad: SetEventCallbacks error\\n\");\n+        return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+    if (err != JNI_OK) {\n+        printf(\"Agent_OnLoad: SetEventNotificationMode CLASS_PREPARE error\\n\");\n+        return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+    if (err != JNI_OK) {\n+        printf(\"Agent_OnLoad: SetEventNotificationMode BREAKPOINT error\\n\");\n+        return JNI_ERR;\n+    }\n+\n+    return JNI_OK;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SetBreakpoint\/libTestManyBreakpoints.cpp","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n@@ -52,0 +53,1 @@\n+ * @requires vm.opt.DeoptimizeALot != true\n@@ -62,1 +64,0 @@\n- * @requires vm.opt.DeoptimizeALot != true\n@@ -71,1 +72,0 @@\n- * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-            int startPercentage = Integer.parseInt(start.substring(0, start.length() - 1));;\n+            int startPercentage = Integer.parseInt(start.substring(0, start.length() - 1));\n@@ -294,1 +294,1 @@\n-                    \"-XX:StressSeed=\" + Math.abs(rng.nextLong()),\n+                    \"-XX:StressSeed=\" + Math.abs(rng.nextInt()),\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/CtwRunner.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/IRExample.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestCheckedTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestCompileThreshold.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n@@ -63,1 +63,1 @@\n-        exceptions.put(e, baos.toString() + System.lineSeparator() + baosErr.toString());\n+        exceptions.put(e, baos + System.lineSeparator() + baosErr);\n@@ -288,1 +288,1 @@\n-        findIrIds(output, \"testMatchAllIf50\", 0, 21);\n+        findIrIds(output, \"testMatchAllIf50\", 1, 22);\n@@ -294,2 +294,2 @@\n-        findIrIds(output, \"testMatchAllIf50\", 4, 6, 13, 18);\n-        findIrIds(output, \"testMatchNoneIf50\", 0, 3, 8, 10, 17, 22);\n+        findIrIds(output, \"testMatchAllIf50\", 5, 7, 14, 19);\n+        findIrIds(output, \"testMatchNoneIf50\", 1, 4, 9, 11, 18, 23);\n@@ -300,2 +300,2 @@\n-        findIrIds(output, \"testMatchAllIf50\", 7, 12, 19, 21);\n-        findIrIds(output, \"testMatchNoneIf50\", 4, 7, 11, 16, 20, 22);\n+        findIrIds(output, \"testMatchAllIf50\", 8, 13, 20, 22);\n+        findIrIds(output, \"testMatchNoneIf50\", 5, 8, 12, 17, 21, 23);\n@@ -398,1 +398,1 @@\n-            addException(new RuntimeException(\"Could not find encoding: \\\"\" + builder.toString() + System.lineSeparator()));\n+            addException(new RuntimeException(\"Could not find encoding: \\\"\" + builder + System.lineSeparator()));\n@@ -553,1 +553,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}) \/\/ Index 0\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}) \/\/ Index 1\n@@ -557,1 +557,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=50\"}) \/\/ Index 4\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=50\"}) \/\/ Index 5\n@@ -560,1 +560,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=50\"}) \/\/ Index 7\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=50\"}) \/\/ Index 8\n@@ -566,1 +566,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<51\"}) \/\/ Index 13\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<51\"}) \/\/ Index 14\n@@ -574,1 +574,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  49\"}) \/\/ Index 21\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  49\"}) \/\/ Index 22\n@@ -579,1 +579,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"49\"}) \/\/ Index 0\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"49\"}) \/\/ Index 1\n@@ -583,1 +583,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"51\"}) \/\/ Index 4\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"51\"}) \/\/ Index 5\n@@ -587,1 +587,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=49\"}) \/\/ Index 8\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=49\"}) \/\/ Index 9\n@@ -590,1 +590,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=51\"}) \/\/ Index 11\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=51\"}) \/\/ Index 12\n@@ -596,1 +596,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<50\"}) \/\/ Index 17\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<50\"}) \/\/ Index 18\n@@ -601,1 +601,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  50\"}) \/\/ Index 22\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  50\"}) \/\/ Index 23\n@@ -817,1 +817,1 @@\n-    @IR(counts = {IRNode.LOAD, \"!= 1\"})\n+    @IR(counts = {IRNode.LOAD, \"!= 1\"}) \/\/ fail\n@@ -824,1 +824,1 @@\n-    @IR(counts = {IRNode.LOAD, \"1\"})\n+    @IR(counts = {IRNode.LOAD, \"1\"}) \/\/ fail\n@@ -832,2 +832,2 @@\n-    @IR(counts = {IRNode.LOAD, \"0\"})\n-    @IR(counts = {IRNode.STORE, \" <= 0\"})\n+    @IR(counts = {IRNode.LOAD, \"0\"}) \/\/ fail\n+    @IR(counts = {IRNode.STORE, \" <= 0\"}) \/\/ fail\n@@ -1517,1 +1517,1 @@\n-        Asserts.assertTrue(matched, toString() + \" should have been matched\");\n+        Asserts.assertTrue(matched, this + \" should have been matched\");\n@@ -1735,1 +1735,1 @@\n-        matchesList.add(\"but found \" + foundCount);\n+        matchesList.add(\"Failed comparison: [found] \" + foundCount);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestRunTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRMatcher;\n-import compiler.lib.ir_framework.driver.TestVMProcess;\n+import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/Utils.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-         throw new TestFailure(\"Test failed.\");;\n+         throw new TestFailure(\"Test failed.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/series\/series.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,2 @@\n- *  This is a test for jdb 'threadgroup <threadgroup_name>' command.\n+ *  This is a test for jdb 'threadgroup <threadgroup_name>' command and\n+ *  also for the 'threadgroup' command with no argument.\n@@ -35,2 +36,5 @@\n- *  thread holds. The test passes if jdb correctly switches between\n- *  three user-defined threadgroups using 'threadgroup' command.\n+ *  thread holds. The test then makes sure jdb correctly switches between\n+ *  the three user-defined threadgroups using 'threadgroup' command. It then\n+ *  resets the current threadgroup back to the default top level threadgroup\n+ *  by using the 'threadgroup' command with no argument. It then tests that\n+ *  all 3 created threadgroups can be found in the 'threads' output.\n@@ -48,0 +52,1 @@\n+ *      -verbose\n@@ -103,0 +108,9 @@\n+        \/\/ Test switching back to the default top level group.\n+        reply = jdb.receiveReplyFor(JdbCommand.threadgroup);\n+        reply = jdb.receiveReplyFor(JdbCommand.threads);\n+        grep = new Paragrep(reply);\n+        count = grep.find(threadgroup002a.THREADGROUP_NAME);\n+        if (count != threadgroup002a.numThreadGroups) {\n+            failure(\"jdb cannot switch to default top level threadgroup\");\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/threadgroup\/threadgroup002\/threadgroup002.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-        Vector v = new Vector();;\n+        Vector v = new Vector();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/unmonitor\/unmonitor001\/unmonitor001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-                            ReferenceType testedClass = clsEvent.referenceType();;\n+                            ReferenceType testedClass = clsEvent.referenceType();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/BScenarios\/multithrd\/tc02x003.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-            ClassObjectReference class_obj_ref = refType.classObject();;\n+            ClassObjectReference class_obj_ref = refType.classObject();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassObjectReference\/reflectedType\/reflectype002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-                    log3(\"ERROR:  IllegalArgumentException for i3 in stackFrame\");;\n+                    log3(\"ERROR:  IllegalArgumentException for i3 in stackFrame\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/LocalVariable\/isVisible\/isvisible001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-                        frameList = thread2.frames();;\n+                        frameList = thread2.frames();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/frames\/frames001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,3 @@\n+            \/\/ Start each loop with a clear log buffer so we only\n+            \/\/ track the run that can potentially fail:\n+            log.clearLogBuffer();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -76,1 +77,1 @@\n-        Thread thread = new hs201t002Thread();\n+        hs201t002Thread thread = new hs201t002Thread();\n@@ -81,1 +82,0 @@\n-        setThread(thread);\n@@ -84,0 +84,10 @@\n+        \/\/ setThread(thread) enables JVMTI events, and that can only be done on a live thread,\n+        \/\/ so wait until the thread has started.\n+        try {\n+            thread.ready.await();\n+        } catch (InterruptedException e) {\n+        }\n+        setThread(thread);\n+\n+        thread.go.countDown();\n+\n@@ -117,0 +127,4 @@\n+            for (int i = 0; i < stackTrace.length; i++) {\n+                log.display(\"\\t\" + i + \". \" + stackTrace[i]);\n+            }\n+            log.display(\"Retrying...\");\n@@ -139,0 +153,3 @@\n+    CountDownLatch ready = new CountDownLatch(1);\n+    CountDownLatch go = new CountDownLatch(1);\n+\n@@ -145,0 +162,5 @@\n+        ready.countDown();\n+        try {\n+            go.await();\n+        } catch (InterruptedException e) {\n+        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,2 @@\n- *      -agentlib:hs201t002=pathToNewByteCode=.\/bin,-waittime=5\n- *      nsk.jvmti.scenarios.hotswap.HS201.hs201t002\n+ *      -agentlib:hs201t002=pathToNewByteCode=.\/bin,-waittime=5,-verbose\n+ *      nsk.jvmti.scenarios.hotswap.HS201.hs201t002 -verbose\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/TestDescription.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,0 @@\n-static int redefineNumber;\n-static jint newClassSize;\n-static unsigned char* newClassBytes;\n@@ -53,1 +50,0 @@\n-char chbuffer[255];\n@@ -55,1 +51,7 @@\n-const char* getThreadName(JNIEnv* jni_env, jthread thread);\n+\/\/ callbackException (isCatch == false) and callbackExceptionCatch (isCatch == true) handler\n+void handleException(bool isCatch,\n+    jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread,\n+    jmethodID method, jlocation location,\n+    jobject exception);\n+\n+const char* getThreadName(jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread);\n@@ -57,1 +59,1 @@\n-int readNewBytecode(jvmtiEnv* jvmti);\n+int readNewBytecode(jvmtiEnv* jvmti, jint *newClassSize, unsigned char* *newClassBytes);\n@@ -102,1 +104,0 @@\n-\n@@ -104,0 +105,2 @@\n+    jint newClassSize;\n+    unsigned char* newClassBytes;\n@@ -110,1 +113,1 @@\n-    if (!NSK_VERIFY(readNewBytecode(jvmti_env))) {\n+    if (!NSK_VERIFY(readNewBytecode(jvmti_env, &newClassSize, &newClassBytes))) {\n@@ -113,0 +116,1 @@\n+        jvmti_env->Deallocate((unsigned char*)className);\n@@ -124,1 +128,0 @@\n-        return;\n@@ -130,0 +133,3 @@\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate(newClassBytes))) {\n+        nsk_jvmti_setFailStatus();\n+    }\n@@ -139,1 +145,0 @@\n-    redefineNumber = 1;\n@@ -147,1 +152,1 @@\n-    NSK_DISPLAY0(\"\\n\\n>>>> Debugge started, waiting for class loading \\n\");\n+    NSK_DISPLAY0(\">>>> Debugge started, waiting for class loading \\n\");\n@@ -186,1 +191,0 @@\n-    char *generic;\n@@ -188,1 +192,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, &generic))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n@@ -194,2 +198,1 @@\n-        NSK_DISPLAY1(\"\\n\\n>>>> Class loaded: %s\", className);\n-        NSK_DISPLAY0(\", activating breakpoint\\n\");\n+        NSK_DISPLAY1(\">>>> Class loaded: %s, activating breakpoint\\n\", className);\n@@ -202,5 +205,0 @@\n-\n-    if (generic != NULL)\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)generic))) {\n-            nsk_jvmti_setFailStatus();\n-        }\n@@ -219,1 +217,1 @@\n-    NSK_DISPLAY0(\"\\n\\n>>>>Breakpoint fired, enabling SINGLE_STEP\\n\");\n+    NSK_DISPLAY0(\">>>>Breakpoint fired, enabling SINGLE_STEP\\n\");\n@@ -269,1 +267,1 @@\n-                NSK_DISPLAY1(\"\\n\\n>>>> Checking if redefined method is not obsolete\\n\", testStep);\n+                NSK_DISPLAY1(\">>>> Checking if redefined method is not obsolete\\n\", testStep);\n@@ -286,1 +284,1 @@\n-                NSK_DISPLAY1(\"\\n\\n>>>> Popping the currently executing frame\\n\", testStep);\n+                NSK_DISPLAY1(\">>>> Popping the currently executing frame\\n\", testStep);\n@@ -295,1 +293,1 @@\n-                    NSK_DISPLAY1(\"\\n\\n>>>> Disabling single step\\n\", testStep);\n+                    NSK_DISPLAY1(\">>>> Disabling single step\\n\", testStep);\n@@ -305,1 +303,1 @@\n-            NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n+            NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to declaringClassName\\n\\n\");\n@@ -327,18 +325,1 @@\n-    const char *className;\n-\n-    className = getClassName(jvmti_env, jni_env, exception);\n-\n-    if (strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n-        jclass klass;\n-\n-        NSK_DISPLAY2(\"\\n\\n>>>> Exception %s in thread - %s\\n\",\n-                        className, getThreadName(jni_env, thread));\n-\n-        testStep++;\n-        if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n-            nsk_jvmti_setFailStatus();\n-            return;\n-        }\n-\n-        redefineClass(jvmti_env, klass);\n-    }\n+    handleException(false, jvmti_env, jni_env, thread, method, location, exception);\n@@ -358,1 +339,4 @@\n-    const char *className;\n+    handleException(true, jvmti_env, jni_env, thread, method, location, exception);\n+}\n+\n+\/* ============================================================================= *\/\n@@ -360,1 +344,5 @@\n-    className = getClassName(jvmti_env, jni_env, exception);\n+void handleException(bool isCatch,\n+                     jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread,\n+                     jmethodID method, jlocation location,\n+                     jobject exception) {\n+    const char* className = getClassName(jvmti_env, jni_env, exception);\n@@ -362,1 +350,1 @@\n-    if (strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n+    if (className != NULL && strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n@@ -365,2 +353,7 @@\n-        NSK_DISPLAY2(\"\\n\\n>>>> Caught exception %s in thread - %s\\n\",\n-                        className, getThreadName(jni_env, thread));\n+        const char* threadName = getThreadName(jvmti_env, jni_env, thread);\n+        NSK_DISPLAY3(\">>>> %s %s in thread - %s\\n\", isCatch ? \"Caught exception\" : \"Exception\",\n+            className, threadName != NULL ? threadName : \"NULL\");\n+        jvmti->Deallocate((unsigned char*)className);\n+        if (threadName != NULL) {\n+            jvmti->Deallocate((unsigned char*)threadName);\n+        }\n@@ -376,0 +369,1 @@\n+\n@@ -378,1 +372,0 @@\n-\/* ============================================================================= *\/\n@@ -380,1 +373,1 @@\n-int readNewBytecode(jvmtiEnv* jvmti) {\n+int readNewBytecode(jvmtiEnv* jvmti, jint *newClassSize, unsigned char* *newClassBytes) {\n@@ -406,1 +399,1 @@\n-    newClassSize = ftell(bytecode);\n+    *newClassSize = ftell(bytecode);\n@@ -409,1 +402,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->Allocate(newClassSize, &newClassBytes))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->Allocate(*newClassSize, newClassBytes))) {\n@@ -413,1 +406,1 @@\n-    read_bytes = (jint) fread(newClassBytes, 1, newClassSize, bytecode);\n+    read_bytes = (jint) fread(*newClassBytes, 1, *newClassSize, bytecode);\n@@ -415,1 +408,1 @@\n-    if (read_bytes != newClassSize) {\n+    if (read_bytes != *newClassSize) {\n@@ -417,0 +410,2 @@\n+        jvmti->Deallocate(*newClassBytes);\n+        *newClassBytes = NULL;\n@@ -425,1 +420,1 @@\n-const char* getThreadName(JNIEnv* jni_env, jthread thread) {\n+const char* getThreadName(jvmtiEnv* jvmti_env, JNIEnv* jni_env, jthread thread) {\n@@ -429,0 +424,2 @@\n+    jsize jthreadNameLen;\n+    unsigned char *result = NULL;\n@@ -431,2 +428,0 @@\n-    strcpy(chbuffer, \"\");\n-\n@@ -435,1 +430,1 @@\n-        return chbuffer;\n+        return NULL;\n@@ -441,1 +436,1 @@\n-        return chbuffer;\n+        return NULL;\n@@ -446,0 +441,7 @@\n+    jthreadNameLen = jni_env->GetStringUTFLength(jthreadName);\n+\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->Allocate(jthreadNameLen + 1, &result))) {\n+        NSK_COMPLAIN0(\"buffer couldn't be allocated\\n\");\n+        return NULL;\n+    }\n+\n@@ -448,1 +450,1 @@\n-    strcpy(chbuffer, threadName);\n+    memcpy(result, threadName, jthreadNameLen + 1);\n@@ -452,1 +454,1 @@\n-    return chbuffer;\n+    return (char*)result;\n@@ -460,1 +462,0 @@\n-    char *generic;\n@@ -463,2 +464,0 @@\n-    strcpy(chbuffer, \"\");\n-\n@@ -467,6 +466,1 @@\n-        return chbuffer;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, &generic))) {\n-        nsk_jvmti_setFailStatus();\n-        return chbuffer;\n+        return NULL;\n@@ -475,3 +469,1 @@\n-    strcpy(chbuffer, className);\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)className))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n@@ -479,0 +471,1 @@\n+        return NULL;\n@@ -481,6 +474,1 @@\n-    if (generic != NULL)\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*)generic))) {\n-            nsk_jvmti_setFailStatus();\n-        }\n-\n-    return chbuffer;\n+    return className;\n@@ -549,0 +537,4 @@\n+    enableEvent(jvmti, JVMTI_EVENT_CLASS_LOAD, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_BREAKPOINT, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION, testedThread);\n+    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION_CATCH, testedThread);\n@@ -668,5 +660,0 @@\n-    enableEvent(jvmti, JVMTI_EVENT_CLASS_LOAD, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_BREAKPOINT, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION, testedThread);\n-    enableEvent(jvmti, JVMTI_EVENT_EXCEPTION_CATCH, testedThread);\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/hs201t002.cpp","additions":72,"deletions":85,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+        System.out.println(\"Current step: \" + hs201t002.currentStep); \/\/ Avoid calling classloader to find hs201t002 in doInit()\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/newclass\/hs201t002a.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-            while(!MyThread.resume2.get());;\n+            while(!MyThread.resume2.get());\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS203\/hs203t002\/hs203t002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -480,0 +480,7 @@\n+    \/**\n+     * Clear all messages from log buffer.\n+     *\/\n+    public synchronized void clearLogBuffer() {\n+        logBuffer.clear();\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/Log.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-            String vmAddress = makeTransportAddress();;\n+            String vmAddress = makeTransportAddress();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -545,0 +545,1 @@\n+java\/lang\/Enum\/ConstantDirectoryOptimalCapacity.java            8282120 generic-all\n@@ -741,2 +742,0 @@\n-java\/awt\/Robot\/HiDPIScreenCapture\/ScreenCaptureGtkTest.java 8282270 linux-all\n-java\/awt\/Robot\/HiDPIScreenCapture\/HiDPIRobotScreenCaptureTest.java 8282270 windows-all\n@@ -829,1 +828,0 @@\n-jdk\/jfr\/event\/oldobject\/TestLargeRootSet.java                   8276333 generic-x64\n@@ -831,0 +829,1 @@\n+jdk\/jfr\/jvm\/TestWaste.java                                      8282427 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8281628\n+ * @library \/test\/lib\n+ * @summary ensure padding bytes are always added when generated secret\n+ *      is smaller than buffer size.\n+ *\/\n+\n+import javax.crypto.KeyAgreement;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+\n+public class DHKeyAgreementPadding {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        byte[] aliceSecret = new byte[80];\n+        byte[] bobSecret = new byte[80];\n+\n+        KeyAgreement alice = KeyAgreement.getInstance(\"DiffieHellman\");\n+        KeyAgreement bob = KeyAgreement.getInstance(\"DiffieHellman\");\n+\n+        \/\/ The probability of an error is 0.2% or 1\/500. Try more times.\n+        for (int i = 0; i < 5000; i++) {\n+            KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(\"DiffieHellman\");\n+            keyPairGen.initialize(512);\n+            KeyPair aliceKeyPair = keyPairGen.generateKeyPair();\n+            KeyPair bobKeyPair = keyPairGen.generateKeyPair();\n+\n+            \/\/ Different stale data\n+            Arrays.fill(aliceSecret, (byte)'a');\n+            Arrays.fill(bobSecret, (byte)'b');\n+\n+            alice.init(aliceKeyPair.getPrivate());\n+            alice.doPhase(bobKeyPair.getPublic(), true);\n+            int aliceLen = alice.generateSecret(aliceSecret, 0);\n+\n+            bob.init(bobKeyPair.getPrivate());\n+            bob.doPhase(aliceKeyPair.getPublic(), true);\n+            int bobLen = bob.generateSecret(bobSecret, 0);\n+\n+            if (!Arrays.equals(aliceSecret, 0, aliceLen, bobSecret, 0, bobLen)) {\n+                System.out.println(HexFormat.ofDelimiter(\":\").formatHex(aliceSecret, 0, aliceLen));\n+                System.out.println(HexFormat.ofDelimiter(\":\").formatHex(bobSecret, 0, bobLen));\n+                throw new RuntimeException(\"Different secrets observed at runs #\" + i);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KeyAgreement\/DHKeyAgreementPadding.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -244,1 +244,1 @@\n-        expectedMinorVersion = in.readShort();;\n+        expectedMinorVersion = in.readShort();\n","filename":"test\/jdk\/com\/sun\/jdi\/ConstantPoolInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    static Gen1<String> genField = new Gen1<String>();;\n+    static Gen1<String> genField = new Gen1<String>();\n","filename":"test\/jdk\/com\/sun\/jdi\/GenericsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,0 +154,16 @@\n+        \/\/ -R is tested to see if options are passed through.\n+        test(\"-R-Dprop1=val1\",\n+                \"-R-Dprop2=val 2\",\n+                \"-R-Xmixed\",\n+                \"-R--add-modules\", \"-Rjdk.attach\",\n+                \"-R-Xcheck:jni\",\n+                \"-R--enable-preview\",\n+                \"-connect\",\n+                \"com.sun.jdi.CommandLineLaunch:vmexec=java,main=\" + targ + \" \" + outFilename + \" prop1 prop2\")\n+                .expectedProp(\"prop1\", \"val1\")\n+                .expectedProp(\"prop2\", \"val 2\")\n+                .expectedArg(\"-Xmixed\")\n+                .expectedArg(\"--add-modules=jdk.attach\")\n+                .expectedArg(\"-Xcheck:jni\")\n+                .expectedArg(\"--enable-preview\");\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbOptions.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-                    JButton component = new JButton(\"JButton 1\");;\n+                    JButton component = new JButton(\"JButton 1\");\n","filename":"test\/jdk\/java\/awt\/Component\/CompEventOnHiddenComponent\/CompEventOnHiddenComponent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                    new Long(hwnd)});;\n+                    new Long(hwnd)});\n","filename":"test\/jdk\/java\/awt\/EmbeddedFrame\/EmbeddedFrameGrabTest\/EmbeddedFrameGrabTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @summary Verify that increase in Frame's minimumSize gets reflected in the subsequent getSize call\n+ * @run main SetMinimumSizeTest1\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+\n+public class SetMinimumSizeTest1 {\n+\n+    private static Frame frame;\n+    private static volatile Dimension dimension;\n+    private static volatile Dimension actualDimension;\n+\n+    public static void createGUI() {\n+        frame = new Frame();\n+        frame.add(new Button(\"Button\"));\n+        frame.setSize(140, 140);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void doTest() throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> createGUI());\n+\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.waitForIdle();\n+\n+            EventQueue.invokeAndWait(() -> {\n+                dimension = frame.getSize();\n+                dimension.width += 20;\n+                dimension.height += 20;\n+                frame.setMinimumSize(dimension);\n+                frame.invalidate();\n+                frame.validate();\n+            });\n+\n+            robot.waitForIdle();\n+\n+            EventQueue.invokeAndWait(() -> {\n+                actualDimension = frame.getSize();\n+            });\n+\n+            if (!actualDimension.equals(dimension)) {\n+                throw new RuntimeException(\"Test Failed\\n\"\n+                    + \"expected dimension:(\" + dimension.width + \",\" + dimension.height +\")\\n\"\n+                    + \"actual dimension:(\" + actualDimension.width + \",\" + actualDimension.height + \")\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> frame.dispose());\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        doTest();\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Frame\/SetMinimumSizeTest\/SetMinimumSizeTest1.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @summary Verify frame resizes back to minimumSize on calling pack\n+ * @run main SetMinimumSizeTest2\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+\n+public class SetMinimumSizeTest2 {\n+\n+    private static Frame frame;\n+    private static volatile Dimension dimension;\n+    private static volatile Dimension actualDimension;\n+\n+    public static void createGUI() {\n+        frame = new Frame();\n+        frame.add(new Button(\"Button\"));\n+        frame.setMinimumSize(new Dimension(140, 140));\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void doTest() throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(() -> createGUI());\n+\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.waitForIdle();\n+\n+            EventQueue.invokeAndWait(() -> {\n+                dimension = frame.getSize();\n+            });\n+\n+            EventQueue.invokeAndWait(() -> {\n+                frame.setSize(dimension.width + 20, dimension.height + 20);\n+                frame.invalidate();\n+                frame.validate();\n+            });\n+\n+            robot.waitForIdle();\n+\n+            EventQueue.invokeAndWait(() -> {\n+                frame.pack();\n+                frame.invalidate();\n+                frame.validate();\n+            });\n+\n+            robot.waitForIdle();\n+\n+            EventQueue.invokeAndWait(() -> {\n+                actualDimension = frame.getSize();\n+            });\n+\n+            if (!actualDimension.equals(dimension)) {\n+                throw new RuntimeException(\"Test Failed\\n\"\n+                    + \"expected dimension:(\" + dimension.width + \",\" + dimension.height +\")\\n\"\n+                    + \"actual dimension:(\" + actualDimension.width + \",\" + actualDimension.height + \")\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> frame.dispose());\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        doTest();\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/Frame\/SetMinimumSizeTest\/SetMinimumSizeTest2.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -68,1 +68,1 @@\n-        Container cont = getParent();;\n+        Container cont = getParent();\n","filename":"test\/jdk\/java\/awt\/PrintJob\/PrintArcTest\/PrintArcTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-        \/\/ Position the frame on prime number coordinates to avoid\n-        \/\/ them being multiple of the desktop scale; this tests Linux\n+        \/\/ Position the frame on prime number coordinates (mind OFFSET)\n+        \/\/ to avoid them being multiple of the desktop scale; this tests Linux\n@@ -76,1 +76,1 @@\n-        frame.setBounds(83, 97, 400, 300);\n+        frame.setBounds(78, 92, 100, 100);\n","filename":"test\/jdk\/java\/awt\/Robot\/HiDPIScreenCapture\/HiDPIRobotScreenCaptureTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,6 @@\n+import java.awt.image.BufferedImage;\n+import javax.swing.UIManager;\n+import javax.imageio.ImageIO;\n+import java.io.File;\n+import java.io.IOException;\n+\n@@ -43,2 +49,0 @@\n- * @run main\/othervm -Djdk.gtk.version=2 -Dsun.java2d.uiScale=2 ScreenCaptureGtkTest\n- * @run main\/othervm -Djdk.gtk.version=2 -Dsun.java2d.uiScale=3 ScreenCaptureGtkTest\n@@ -46,2 +50,0 @@\n- * @run main\/othervm -Djdk.gtk.version=3 -Dsun.java2d.uiScale=2 ScreenCaptureGtkTest\n- * @run main\/othervm -Djdk.gtk.version=3 -Dsun.java2d.uiScale=3 ScreenCaptureGtkTest\n@@ -55,0 +57,3 @@\n+        final int topOffset = 50;\n+        final int leftOffset = 50;\n+\n@@ -56,3 +61,3 @@\n-        \/\/ Position the frame on prime number coordinates to avoid\n-        \/\/ them being multiple of the desktop scale; this tests Linux\n-        \/\/ color picker better.\n+        \/\/ Position the frame such that color picker will work with\n+        \/\/ prime number coordinates (mind the offset) to avoid them being\n+        \/\/ multiple of the desktop scale; this tests Linux color picker better.\n@@ -63,1 +68,1 @@\n-        frame.setBounds(83, 97, 400, 300);\n+        frame.setBounds(89, 99, 100, 100);\n@@ -77,1 +82,1 @@\n-                for (int i = 1; i < 4; i++) {\n+                for (int i = 1; i < COLORS.length; i++) {\n@@ -79,1 +84,1 @@\n-                    g.fillRect(i, 0, 1, 1);\n+                    g.fillRect(leftOffset + i, topOffset, 1, 1);\n@@ -91,2 +96,1 @@\n-        final Point screenLocation = frame.getLocationOnScreen();\n-        checkPixelColors(robot, screenLocation.x, screenLocation.y);\n+        captureImageOf(frame, robot);\n@@ -94,2 +98,8 @@\n-        robot.delay(100);\n-        frame.dispose();\n+        final Point screenLocation = frame.getLocationOnScreen();\n+        try {\n+            checkPixelColors(robot, screenLocation.x + leftOffset,\n+                    screenLocation.y + topOffset);\n+        } finally {\n+            robot.delay(100);\n+            frame.dispose();\n+        }\n@@ -99,1 +109,1 @@\n-        for (int i = 0; i < 4; i++) {\n+        for (int i = 0; i < COLORS.length; i++) {\n@@ -104,0 +114,1 @@\n+                saveImage();\n@@ -111,0 +122,20 @@\n+\n+    private static BufferedImage image;\n+\n+    static void captureImageOf(Frame frame, Robot robot) {\n+        Rectangle rect = frame.getBounds();\n+        rect.setLocation(frame.getLocationOnScreen());\n+\n+        System.out.println(\"Creating screen capture of \" + rect);\n+        image = robot.createScreenCapture(rect);\n+    }\n+\n+    static void saveImage() {\n+        System.out.println(\"Check image.png\");\n+        try {\n+            ImageIO.write(image, \"png\", new File(\"image.png\"));\n+        } catch(IOException e) {\n+            System.out.println(\"failed to save image.png.\");\n+            e.printStackTrace();\n+        }\n+    }\n","filename":"test\/jdk\/java\/awt\/Robot\/HiDPIScreenCapture\/ScreenCaptureGtkTest.java","additions":46,"deletions":15,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        graphics2D.dispose();;\n+        graphics2D.dispose();\n","filename":"test\/jdk\/java\/awt\/SplashScreen\/GenerateTestImage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8282577\n+ * @summary Verify setting data for a tag doesn't invalidate the profile.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_ColorSpace;\n+import java.awt.color.ICC_Profile;\n+\n+public final class SetTagDataValidation {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        ICC_Profile srgb = ICC_Profile.getInstance(ColorSpace.CS_sRGB);\n+        \/\/ Create a new profile, using the srgb data but private to us.\n+        ICC_Profile icc = ICC_Profile.getInstance(srgb.getData());\n+\n+        \/\/ Get data for some tag, which one isn't important so long as it exists\n+        int tag = ICC_Profile.icSigBlueColorantTag;\n+        byte[] tagData = icc.getData(tag);\n+        if (tagData == null) {\n+            throw new RuntimeException(\"No data for tag\");\n+        }\n+        \/\/ Set the data to be the SAME data which ought to be a harmless no-op\n+        icc.setData(tag, tagData);\n+\n+        \/\/ Perform a color conversion - from rgb to rgb but it doesn't matter\n+        \/\/ we just need to verify the op is applied and results are sane.\n+\n+        ColorSpace cs = new ICC_ColorSpace(icc);\n+        float[] in = new float[3];\n+        in[0] = 0.4f;\n+        in[1] = 0.5f;\n+        in[2] = 0.6f;\n+\n+        \/\/ the toRGB op previously threw an exception - or crashed\n+        float[] out = cs.toRGB(in);\n+        \/\/ If we get this far let's validate the results.\n+        if (out == null || out.length !=3) {\n+            throw new RuntimeException(\"out array invalid\");\n+        }\n+        for (int i=0;i<out.length;i++) {\n+           System.out.println(out[i]);\n+        }\n+        for (int i=0;i<out.length;i++) {\n+           if ((Math.abs(in[i]-out[i]) > 0.01)) {\n+               throw new RuntimeException(\"Inaccurate no-op conversion\");\n+           }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_ColorSpace\/SetTagDataValidation.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import java.awt.color.CMMException;\n@@ -106,0 +107,1 @@\n+                System.err.println(\"Ignoring \" + ignored);\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/MTGetData.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8240756\n+ * @summary Non-English characters are printed with wrong glyphs on MacOS\n+ * @modules java.desktop\/sun.java2d java.desktop\/sun.java2d.loops java.desktop\/sun.font\n+ * @requires os.family == \"mac\"\n+ * @run main MultiSlotFontTest\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.RenderingHints;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.image.BufferedImage;\n+import sun.font.StandardGlyphVector;\n+import sun.java2d.OSXOffScreenSurfaceData;\n+import sun.java2d.SunGraphics2D;\n+import sun.java2d.SurfaceData;\n+import sun.java2d.loops.SurfaceType;\n+\n+public class MultiSlotFontTest {\n+\n+    private static final int WIDTH = 100;\n+    private static final int HEIGHT = 60;\n+\n+    private static final String TEST_STR = \"\\u3042\\u3044\\u3046\\u3048\\u304Aabc\";\n+    private static final int EXPECTED_HEIGHT = 10;\n+    private static final int EXPECTED_WIDTH = 77;\n+    private static final int LIMIT_DIFF_HEIGHT = 3;\n+    private static final int LIMIT_DIFF_WIDTH = 15;\n+\n+    public static void main(String[] args) throws Exception {\n+        MultiSlotFontTest test = new MultiSlotFontTest();\n+    }\n+\n+    public MultiSlotFontTest() {\n+        BufferedImage img = createImage();\n+\n+        SurfaceData sd = OSXOffScreenSurfaceData.createDataIC(img,\n+                             SurfaceType.IntRgb);\n+        SunGraphics2D g2d = new SunGraphics2D(sd,\n+                                    Color.BLACK, Color.WHITE, null);\n+        Font font = g2d.getFont();\n+\n+        if (font.canDisplayUpTo(TEST_STR) != -1) {\n+            System.out.println(\"There is no capable font. Skipping the test.\");\n+            System.out.println(\"Font: \" + font);\n+            return;\n+        }\n+\n+        FontRenderContext frc = new FontRenderContext(null, false, false);\n+        StandardGlyphVector gv = new StandardGlyphVector(font, TEST_STR, frc);\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                             RenderingHints.VALUE_ANTIALIAS_OFF);\n+        g2d.drawGlyphVector(gv, 0.0f, (float)(HEIGHT - 5));\n+        g2d.dispose();\n+\n+        Dimension d = getBounds(img);\n+\n+        if (Math.abs(d.height - EXPECTED_HEIGHT) > LIMIT_DIFF_HEIGHT ||\n+            Math.abs(d.width  - EXPECTED_WIDTH)  > LIMIT_DIFF_WIDTH) {\n+            debugOut(img);\n+            throw new RuntimeException(\n+                \"Incorrect GlyphVector shape \" + d + \",\" + gv);\n+        }\n+    }\n+\n+    private static BufferedImage createImage() {\n+        BufferedImage image = new BufferedImage(WIDTH, HEIGHT,\n+                                      BufferedImage.TYPE_INT_RGB);\n+        Graphics g = image.createGraphics();\n+        g.setColor(Color.WHITE);\n+        g.fillRect(0, 0, WIDTH, HEIGHT);\n+        g.dispose();\n+        return image;\n+    }\n+\n+    private Dimension getBounds(BufferedImage img) {\n+        int top = HEIGHT;\n+        int left = WIDTH;\n+        int right = 0;\n+        int bottom = 0;\n+        for (int y = 0; y < HEIGHT; y++) {\n+            for (int x = 0; x < WIDTH; x++) {\n+                if ((img.getRGB(x, y) & 0xFFFFFF) == 0) {\n+                    if (top    > y) top = y;\n+                    if (bottom < y) bottom = y;\n+                    if (left   > x) left = x;\n+                    if (right  < x) right = x;\n+                }\n+            }\n+        }\n+        return new Dimension(right - left, bottom - top);\n+    }\n+\n+    private void debugOut(BufferedImage img) {\n+        for (int y = 0; y < HEIGHT; y++) {\n+            for (int x = 0; x < WIDTH; x++) {\n+                int c = img.getRGB(x, y) & 0xFFFFFF;\n+                if (c == 0) {\n+                    System.out.print(\"*\");\n+                } else {\n+                    System.out.print(\" \");\n+                }\n+            }\n+            System.out.println();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/GlyphVector\/MultiSlotFontTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n-            pj = PrinterJob.getPrinterJob();;\n+            pj = PrinterJob.getPrinterJob();\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrtException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+ *\n+ * @run testng\/othervm -Xint -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=100000\n+ *   TestDowncall\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-                    al.add(new Space(m.group(2), m.group(3), name));;\n+                    al.add(new Space(m.group(2), m.group(3), name));\n","filename":"test\/jdk\/java\/io\/File\/GetXSpace.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-                        ps[1].substring(0, 4));;\n+                        ps[1].substring(0, 4));\n","filename":"test\/jdk\/java\/io\/File\/createTempFile\/NameTooLong.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        RandomAccessFile raf = new RandomAccessFile(fn , \"rw\");;\n+        RandomAccessFile raf = new RandomAccessFile(fn , \"rw\");\n","filename":"test\/jdk\/java\/io\/RandomAccessFile\/WriteBytesChars.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282696\n+ * @summary Verify message and cause handling of InvalidClassException\n+ *\/\n+import java.io.*;\n+import java.util.Objects;\n+\n+public class TestIceConstructors {\n+    public static void main(String... args) {\n+        String reason = \"reason\";\n+        Throwable cause = new RuntimeException();\n+\n+        testException(new InvalidClassException(reason),\n+                      reason, null);\n+        testException(new InvalidClassException(reason, cause),\n+                      reason, cause);\n+        testException(new InvalidClassException(\"prefix\", reason, cause),\n+                      \"prefix\" + \"; \" + reason, cause);\n+    }\n+\n+    private static void testException(InvalidClassException ice,\n+                                      String expectedMessage,\n+                                      Throwable expectedCause) {\n+        var message = ice.getMessage();\n+        if (!Objects.equals(message, expectedMessage)) {\n+            throw new RuntimeException(\"Unexpected message \" + message);\n+        }\n+\n+        var cause = ice.getCause();\n+        if (cause != expectedCause) {\n+            throw new RuntimeException(\"Unexpected cause\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/InvalidClassException\/TestIceConstructors.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282696\n+ * @summary Verify message and cause handling of InvalidObjectException\n+ *\/\n+import java.io.*;\n+import java.util.Objects;\n+\n+public class TestIoeConstructors {\n+    public static void main(String... args) {\n+        String reason = \"reason\";\n+        Throwable cause = new RuntimeException();\n+\n+        testException(new InvalidObjectException(reason),\n+                      reason, null);\n+        testException(new InvalidObjectException(reason, cause),\n+                      reason, cause);\n+    }\n+\n+    private static void testException(InvalidObjectException ioe,\n+                                      String expectedMessage,\n+                                      Throwable expectedCause) {\n+        var message = ioe.getMessage();\n+        if (!Objects.equals(message, expectedMessage)) {\n+            throw new RuntimeException(\"Unexpected message \" + message);\n+        }\n+\n+        var cause = ioe.getCause();\n+        if (cause != expectedCause) {\n+            throw new RuntimeException(\"Unexpected cause\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/Serializable\/InvalidObjectException\/TestIoeConstructors.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- *      8067796 8224905 8263729 8265173 8272600 8231297\n+ *      8067796 8224905 8263729 8265173 8272600 8231297 8282219\n@@ -1873,0 +1873,2 @@\n+            } else if (AIX.is()) {\n+                envp = new String[] {\"=ExitValue=3\", \"=C:=\\\\\", \"LIBPATH=\" + libpath};\n@@ -1921,0 +1923,3 @@\n+            } else if (AIX.is()) {\n+                envp = new String[] {\"LC_ALL=C\\u0000\\u0000\", \/\/ Yuck!\n+                        \"FO\\u0000=B\\u0000R\", \"LIBPATH=\" + libpath};\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/Basic.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n- * @bug     8140364 8189291\n+ * @bug     8140364 8189291 8283049\n@@ -233,1 +233,1 @@\n-                        if (!warning.contains(\"java.util.ServiceConfigurationError: More than on LoggerFinder implementation\")) {\n+                        if (!warning.contains(\"java.util.ServiceConfigurationError: More than one LoggerFinder implementation\")) {\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/internal\/LoggerFinderLoaderTest\/LoggerFinderLoaderTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1302,3 +1302,3 @@\n-        checkInheritence(Grandpa.class, true, true);\n-        checkInheritence(Dad.class,     true, false);\n-        checkInheritence(Son.class,     true, true);\n+        checkInheritance(Grandpa.class, true, true);\n+        checkInheritance(Dad.class,     true, false);\n+        checkInheritance(Son.class,     true, true);\n@@ -3534,1 +3534,1 @@\n-    static void checkInheritence(AnnotatedElement e, boolean shouldHaveFoo, boolean shouldHaveBar) {\n+    static void checkInheritance(AnnotatedElement e, boolean shouldHaveFoo, boolean shouldHaveBar) {\n","filename":"test\/jdk\/java\/lang\/annotation\/UnitTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @bug 8215510\n+ * @bug 8215510 8283075\n@@ -187,0 +187,13 @@\n+    private void testArrayRankOverflow() {\n+        ClassDesc TwoDArrayDesc =\n+            String.class.describeConstable().get().arrayType().arrayType();\n+\n+        try {\n+            TwoDArrayDesc.arrayType(Integer.MAX_VALUE);\n+            fail(\"\");\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+\n@@ -221,0 +234,1 @@\n+            testArrayRankOverflow();\n","filename":"test\/jdk\/java\/lang\/constant\/ClassDescTest.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-                byte[] classData = getClass(name);;\n+                byte[] classData = getClass(name);\n","filename":"test\/jdk\/java\/lang\/invoke\/8022701\/BogoLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-                byte[] classData = getClass(name);;\n+                byte[] classData = getClass(name);\n","filename":"test\/jdk\/java\/lang\/invoke\/accessProtectedSuper\/BogoLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    private static final Long VALUE3   = new Long(0);;\n+    private static final Long VALUE3   = new Long(0);\n","filename":"test\/jdk\/java\/lang\/management\/RuntimeMXBean\/GetSystemProperties.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8178380 8282444\n","filename":"test\/jdk\/java\/lang\/module\/customfs\/ModulesInCustomFileSystem.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-        q.Hello.hello();\n+        q.r.Hello.hello();\n","filename":"test\/jdk\/java\/lang\/module\/customfs\/m1\/p\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-    exports q;\n+    exports q.r;\n","filename":"test\/jdk\/java\/lang\/module\/customfs\/m2\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-package q;\n+package q.r;\n","filename":"test\/jdk\/java\/lang\/module\/customfs\/m2\/q\/r\/Hello.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/lang\/module\/customfs\/m2\/q\/Hello.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,1 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/..\/sun\/net\/www\/httptest\/ \/test\/lib\n- * @build ClosedChannelList TestHttpServer HttpTransaction HttpCallback\n+ * @library \/test\/lib\n@@ -37,2 +35,14 @@\n-import java.net.*;\n-import java.io.*;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -46,11 +56,2 @@\n-public class LoopbackAddresses implements HttpCallback {\n-    static TestHttpServer server;\n-\n-    public void request (HttpTransaction req) {\n-        req.setResponseEntityBody (\"Hello .\");\n-        try {\n-            req.sendResponse (200, \"Ok\");\n-            req.orderlyClose();\n-        } catch (IOException e) {\n-        }\n-    }\n+public class LoopbackAddresses {\n+    static HttpServer server;\n@@ -66,2 +67,4 @@\n-            server = new TestHttpServer (new LoopbackAddresses(), 1, 10, 0);\n-            ProxyServer pserver = new ProxyServer(InetAddress.getByName(\"localhost\"), server.getLocalPort());\n+            server = HttpServer.create(new InetSocketAddress(loopback, 0), 10, \"\/\", new LoopbackAddressesHandler());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n+            ProxyServer pserver = new ProxyServer(InetAddress.getByName(\"localhost\"), server.getAddress().getPort());\n@@ -74,1 +77,1 @@\n-            URL url = new URL(\"http:\/\/localhost:\"+server.getLocalPort());\n+            URL url = new URL(\"http:\/\/localhost:\"+server.getAddress().getPort());\n@@ -88,1 +91,1 @@\n-                      .port(server.getLocalPort())\n+                      .port(server.getAddress().getPort())\n@@ -100,1 +103,1 @@\n-                server.terminate();\n+                server.stop(1);\n@@ -154,0 +157,15 @@\n+\n+class LoopbackAddressesHandler implements HttpHandler {\n+\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        try {\n+            exchange.sendResponseHeaders(200, 0);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        try(PrintWriter pw = new PrintWriter(exchange.getResponseBody(), false, Charset.forName(\"UTF-8\"))) {\n+            pw.print(\"Hello .\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/ProxySelector\/LoopbackAddresses.java","additions":40,"deletions":22,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/..\/sun\/net\/www\/httptest\/ \/test\/lib\n- * @build ClosedChannelList TestHttpServer HttpTransaction HttpCallback\n+ * @library \/test\/lib\n@@ -35,2 +33,12 @@\n-import java.net.*;\n-import java.io.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.ProxySelector;\n+import java.net.SocketAddress;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n@@ -38,0 +46,5 @@\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -40,2 +53,2 @@\n-public class ProxyTest implements HttpCallback {\n-    static TestHttpServer server;\n+public class ProxyTest {\n+    static HttpServer server;\n@@ -46,9 +59,0 @@\n-    public void request(HttpTransaction req) {\n-        req.setResponseEntityBody(\"Hello .\");\n-        try {\n-            req.sendResponse(200, \"Ok\");\n-            req.orderlyClose();\n-        } catch (IOException e) {\n-        }\n-    }\n-\n@@ -78,1 +82,3 @@\n-            server = new TestHttpServer(new ProxyTest(), 1, 10, loopback, 0);\n+            server = HttpServer.create(new InetSocketAddress(loopback, 0), 10, \"\/\", new ProxyTestHandler());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n@@ -82,1 +88,1 @@\n-                      .port(server.getLocalPort())\n+                      .port(server.getAddress().getPort())\n@@ -96,1 +102,1 @@\n-                server.terminate();\n+                server.stop(1);\n@@ -101,0 +107,15 @@\n+\n+class ProxyTestHandler implements HttpHandler {\n+\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        try {\n+            exchange.sendResponseHeaders(200, 0);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        try(PrintWriter pw = new PrintWriter(exchange.getResponseBody(), false, Charset.forName(\"UTF-8\"))) {\n+            pw.print(\"Hello .\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/ProxySelector\/ProxyTest.java","additions":41,"deletions":20,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282686\n+ * @summary Verify cause and message handling of SocketException\n+ *\/\n+import java.net.SocketException;\n+import java.util.Objects;\n+\n+public class TestSocketExceptionCtor {\n+    public static void main(String... args) {\n+        String message = \"message\";\n+        Throwable cause = new RuntimeException();\n+\n+        testException(new SocketException(cause), cause.toString(), cause);\n+        testException(new SocketException(message, cause), message, cause);\n+    }\n+\n+    private static void testException(SocketException se,\n+                                      String expectedMessage,\n+                                      Throwable expectedCause) {\n+        var message = se.getMessage();\n+        if (!Objects.equals(message, expectedMessage)) {\n+            throw new RuntimeException(\"Unexpected message \" + message);\n+        }\n+\n+        var cause = se.getCause();\n+        if (cause != expectedCause) {\n+            throw new RuntimeException(\"Unexpected cause\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/SocketException\/TestSocketExceptionCtor.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,1 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/..\/sun\/net\/www\/httptest\/ \/test\/lib\n- * @build ClosedChannelList TestHttpServer HttpTransaction HttpCallback\n+ * @library \/test\/lib\n@@ -34,3 +32,17 @@\n-import java.net.*;\n-import java.io.*;\n-\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -39,11 +51,2 @@\n-public class PerConnectionProxy implements HttpCallback {\n-    static TestHttpServer server;\n-\n-    public void request (HttpTransaction req) {\n-        req.setResponseEntityBody (\"Hello .\");\n-        try {\n-            req.sendResponse (200, \"Ok\");\n-            req.orderlyClose();\n-        } catch (IOException e) {\n-        }\n-    }\n+public class PerConnectionProxy {\n+    static HttpServer server;\n@@ -54,2 +57,4 @@\n-            server = new TestHttpServer(new PerConnectionProxy(), 1, 10, loopbackAddress, 0);\n-            ProxyServer pserver = new ProxyServer(loopbackAddress, server.getLocalPort());\n+            server = HttpServer.create(new InetSocketAddress(loopbackAddress, 0), 10, \"\/\", new PerConnectionProxyHandler());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n+            ProxyServer pserver = new ProxyServer(loopbackAddress, server.getAddress().getPort());\n@@ -62,1 +67,1 @@\n-                    .port(server.getLocalPort())\n+                    .port(server.getAddress().getPort())\n@@ -76,1 +81,0 @@\n-\n@@ -85,1 +89,0 @@\n-\n@@ -104,1 +107,1 @@\n-                server.terminate();\n+                server.stop(1);\n@@ -107,1 +110,0 @@\n-\n@@ -148,1 +150,0 @@\n-\n@@ -164,1 +165,0 @@\n-\n@@ -224,0 +224,2 @@\n+    }\n+}\n@@ -225,0 +227,11 @@\n+class PerConnectionProxyHandler implements HttpHandler {\n+\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        try {\n+            exchange.sendResponseHeaders(200, 0);\n+        } catch (IOException e) {\n+        }\n+        try(PrintWriter pw = new PrintWriter(exchange.getResponseBody(), false, Charset.forName(\"UTF-8\"))) {\n+            pw.print(\"Hello .\");\n+        }\n@@ -227,0 +240,1 @@\n+\n","filename":"test\/jdk\/java\/net\/URL\/PerConnectionProxy.java","additions":41,"deletions":27,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.base\/sun.net.www.protocol.file\n@@ -27,4 +28,2 @@\n- * @modules java.base\/sun.net.www java.base\/sun.net.www.protocol.file\n- * @library ..\/..\/..\/sun\/net\/www\/httptest\/\n- * @build HttpCallback TestHttpServer ClosedChannelList HttpTransaction\n- * @run main B5052093\n+ * @library \/test\/lib\n+ * @run main\/othervm B5052093\n@@ -33,3 +32,12 @@\n-import java.net.*;\n-import java.io.*;\n-import sun.net.www.protocol.file.FileURLConnection;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -37,0 +45,2 @@\n+import jdk.test.lib.net.URIBuilder;\n+import sun.net.www.protocol.file.FileURLConnection;\n@@ -38,3 +48,3 @@\n-public class B5052093 implements HttpCallback {\n-    private static TestHttpServer server;\n-    private static long testSize = ((long) (Integer.MAX_VALUE)) + 2;\n+public class B5052093 {\n+    private static HttpServer server;\n+    static long testSize = ((long) (Integer.MAX_VALUE)) + 2;\n@@ -58,9 +68,0 @@\n-    public void request(HttpTransaction req) {\n-        try {\n-            req.setResponseHeader(\"content-length\", Long.toString(testSize));\n-            req.sendResponse(200, \"OK\");\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n@@ -69,1 +70,3 @@\n-        server = new TestHttpServer(new B5052093(), 1, 10, loopback, 0);\n+        server = HttpServer.create(new InetSocketAddress(loopback, 0), 10, \"\/\", new B5052093Handler());\n+        server.setExecutor(Executors.newSingleThreadExecutor());\n+        server.start();\n@@ -71,1 +74,6 @@\n-            URL url = new URL(\"http:\/\/\" + server.getAuthority() + \"\/foo\");\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(server.getAddress().getPort())\n+                    .path(\"\/foo\")\n+                    .build().toURL();\n@@ -92,1 +100,14 @@\n-            server.terminate();\n+            server.stop(1);\n+        }\n+    }\n+}\n+\n+class B5052093Handler implements HttpHandler {\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        try {\n+            exchange.getResponseHeaders().set(\"content-length\", Long.toString(B5052093.testSize));\n+            exchange.sendResponseHeaders(200, 0);\n+            exchange.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n","filename":"test\/jdk\/java\/net\/URLConnection\/B5052093.java","additions":44,"deletions":23,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -488,1 +488,1 @@\n-        assertTrue(subscriber.items.isEmpty());;\n+        assertTrue(subscriber.items.isEmpty());\n","filename":"test\/jdk\/java\/net\/httpclient\/AggregateRequestBodyTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8245462 8229822\n+ * @bug 8245462 8229822 8254786\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelRequestTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-                Socket client=_listener.accept().socket();;\n+                Socket client=_listener.accept().socket();\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/CloseTimeoutChannel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8283325\n+ * @summary Ensure that decoding to ASCII from a stream with a non-ASCII\n+ *          character correctly decodes up until the byte in error.\n+ *\/\n+\n+import java.nio.*;\n+import java.nio.charset.*;\n+import java.util.Arrays;\n+\n+public class ASCIIDecode {\n+\n+    public static void main(String[] args) throws Exception {\n+        final Charset ascii = Charset.forName(\"US-ASCII\");\n+        final CharsetDecoder decoder = ascii.newDecoder();\n+\n+        byte[] ba = new byte[] { 0x60, 0x60, 0x60, (byte)0xFF };\n+\n+        \/\/ Repeat enough times to test that interpreter and JIT:ed versions\n+        \/\/ behave the same (without the patch for 8283325 this fails within\n+        \/\/ 50 000 iterations on the system used for verification)\n+        for (int i = 0; i < 100_000; i++) {\n+            ByteBuffer bb = ByteBuffer.wrap(ba);\n+            char[] ca = new char[4];\n+            CharBuffer cb = CharBuffer.wrap(ca);\n+            CoderResult buf = decoder.decode(bb, cb, true);\n+            if (ca[0] != 0x60 || ca[1] != 0x60 || ca[2] != 0x60) {\n+                throw new RuntimeException(\"Unexpected output on iteration \" + i);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/charset\/CharsetDecoder\/ASCIIDecode.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407\n+ * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8267820\n@@ -675,0 +675,7 @@\n+            \/\/ check POSIX attributes are copied\n+            if (!Platform.isWindows() && testPosixAttributes) {\n+                checkPosixAttributes(\n+                    readAttributes(source, PosixFileAttributes.class, linkOptions),\n+                    readAttributes(target, PosixFileAttributes.class, linkOptions));\n+            }\n+\n@@ -677,8 +684,0 @@\n-\n-                \/\/ check POSIX attributes are copied\n-                if (!Platform.isWindows() && testPosixAttributes) {\n-                    checkPosixAttributes(\n-                        readAttributes(source, PosixFileAttributes.class, linkOptions),\n-                        readAttributes(target, PosixFileAttributes.class, linkOptions));\n-                }\n-\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        Remote impl = new DGCImplInsulation();;\n+        Remote impl = new DGCImplInsulation();\n","filename":"test\/jdk\/java\/rmi\/dgc\/dgcImplInsulation\/DGCImplInsulation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282929\n+ * @summary Verifies that toLocalizedPattern() method correctly returns\n+ *          monetary symbols in a currency formatter\n+ * @run testng ToLocalizedPatternTest\n+ *\/\n+\n+import static org.testng.Assert.assertEquals;\n+import org.testng.annotations.Test;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Locale;\n+\n+@Test\n+public class ToLocalizedPatternTest {\n+    private static final char MONETARY_GROUPING = 'g';\n+    private static final char MONETARY_DECIMAL = 'd';\n+\n+    public void testToLocalizedPattern() {\n+        var dfs = new DecimalFormatSymbols(Locale.US);\n+\n+        \/\/ Customize the decimal format symbols\n+        dfs.setMonetaryGroupingSeparator(MONETARY_GROUPING);\n+        dfs.setMonetaryDecimalSeparator(MONETARY_DECIMAL);\n+\n+        \/\/ create a currency formatter\n+        var cf = (DecimalFormat)DecimalFormat.getCurrencyInstance(Locale.US);\n+        cf.setDecimalFormatSymbols(dfs);\n+\n+        \/\/ check\n+        assertEquals(cf.toLocalizedPattern(),\n+            cf.toPattern()\n+               .replace(',', MONETARY_GROUPING)\n+               .replace('.', MONETARY_DECIMAL));\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/ToLocalizedPatternTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -1075,1 +1075,1 @@\n-         OffsetDateTime after_time_of_stdOffsetTransition1 = OffsetDateTime.of(time_of_stdOffsetTransition1, stdOffset1).plusSeconds(1);;\n+         OffsetDateTime after_time_of_stdOffsetTransition1 = OffsetDateTime.of(time_of_stdOffsetTransition1, stdOffset1).plusSeconds(1);\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/zone\/TCKZoneRules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1054,1 +1054,1 @@\n-            {\"F\", \"Value(AlignedDayOfWeekInMonth)\"},\n+            {\"F\", \"Value(AlignedWeekOfMonth)\"},\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/format\/TestDateTimeFormatterBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +25,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -30,0 +32,4 @@\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n@@ -31,0 +37,1 @@\n+import java.util.Iterator;\n@@ -34,1 +41,3 @@\n-import java.util.concurrent.ThreadLocalRandom;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+import java.util.function.Consumer;\n@@ -36,1 +45,0 @@\n-import java.util.stream.IntStream;\n@@ -38,1 +46,0 @@\n-import static java.util.stream.Collectors.toMap;\n@@ -44,1 +51,1 @@\n- * @bug 8210280\n+ * @bug 8210280 8281631\n@@ -46,1 +53,1 @@\n- * @summary White box tests for HashMap internals around table resize\n+ * @summary White box tests for HashMap-related internals around table sizing\n@@ -48,1 +55,0 @@\n- * @key randomness\n@@ -51,1 +57,1 @@\n-    final ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+\n@@ -53,2 +59,2 @@\n-    final VarHandle THRESHOLD;\n-    final VarHandle TABLE;\n+    final VarHandle HM_TABLE;\n+    final VarHandle WHM_TABLE;\n@@ -57,9 +63,7 @@\n-        Class<?> mClass = HashMap.class;\n-        String nodeClassName = mClass.getName() + \"$Node\";\n-        Class<?> nodeArrayClass = Class.forName(\"[L\" + nodeClassName + \";\");\n-        MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(mClass, MethodHandles.lookup());\n-        TABLE = lookup.findVarHandle(mClass, \"table\", nodeArrayClass);\n-        this.TABLE_SIZE_FOR = lookup.findStatic(\n-                mClass, \"tableSizeFor\",\n-                MethodType.methodType(int.class, int.class));\n-        this.THRESHOLD = lookup.findVarHandle(mClass, \"threshold\", int.class);\n+        MethodHandles.Lookup hmlookup = MethodHandles.privateLookupIn(HashMap.class, MethodHandles.lookup());\n+        TABLE_SIZE_FOR = hmlookup.findStatic(\n+                HashMap.class, \"tableSizeFor\", MethodType.methodType(int.class, int.class));\n+        HM_TABLE = hmlookup.unreflectVarHandle(HashMap.class.getDeclaredField(\"table\"));\n+\n+        MethodHandles.Lookup whmlookup = MethodHandles.privateLookupIn(WeakHashMap.class, MethodHandles.lookup());\n+        WHM_TABLE = whmlookup.unreflectVarHandle(WeakHashMap.class.getDeclaredField(\"table\"));\n@@ -68,0 +72,4 @@\n+    \/*\n+     * utility methods\n+     *\/\n+\n@@ -71,1 +79,3 @@\n-        } catch (Throwable t) { throw new AssertionError(t); }\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n@@ -74,1 +84,1 @@\n-    Object[] table(HashMap map) {\n+    Object[] table(Map<?, ?> map) {\n@@ -76,2 +86,5 @@\n-            return (Object[]) TABLE.get(map);\n-        } catch (Throwable t) { throw new AssertionError(t); }\n+            VarHandle vh = map instanceof WeakHashMap ? WHM_TABLE : HM_TABLE;\n+            return (Object[]) vh.get(map);\n+        } catch (Throwable t) {\n+            throw new AssertionError(t);\n+        }\n@@ -80,1 +93,1 @@\n-    int capacity(HashMap map) {\n+    int capacity(Map<?, ?> map) {\n@@ -84,14 +97,60 @@\n-    @Test\n-    public void testTableSizeFor() {\n-        assertEquals(tableSizeFor(0), 1);\n-        assertEquals(tableSizeFor(1), 1);\n-        assertEquals(tableSizeFor(2), 2);\n-        assertEquals(tableSizeFor(3), 4);\n-        assertEquals(tableSizeFor(15), 16);\n-        assertEquals(tableSizeFor(16), 16);\n-        assertEquals(tableSizeFor(17), 32);\n-        int maxSize = 1 << 30;\n-        assertEquals(tableSizeFor(maxSize - 1), maxSize);\n-        assertEquals(tableSizeFor(maxSize), maxSize);\n-        assertEquals(tableSizeFor(maxSize + 1), maxSize);\n-        assertEquals(tableSizeFor(Integer.MAX_VALUE), maxSize);\n+    \/\/ creates a map with size mappings\n+    Map<String, String> makeMap(int size) {\n+        Map<String, String> map = new HashMap<>();\n+        putN(map, size);\n+        return map;\n+    }\n+\n+    \/\/ creates a \"fake\" map: size() returns the given size, but\n+    \/\/ the entrySet iterator returns only one entry\n+    Map<String, String> fakeMap(int size) {\n+        return new AbstractMap<>() {\n+            public Set<Map.Entry<String, String>> entrySet() {\n+                return new AbstractSet<Map.Entry<String, String>>() {\n+                    public int size() {\n+                        return size;\n+                    }\n+\n+                    public Iterator<Map.Entry<String, String>> iterator() {\n+                        return Set.of(Map.entry(\"1\", \"1\")).iterator();\n+                    }\n+                };\n+            }\n+        };\n+    }\n+\n+    void putN(Map<String, String> map, int n) {\n+        for (int i = 0; i < n; i++) {\n+            String string = Integer.toString(i);\n+            map.put(string, string);\n+        }\n+    }\n+\n+    \/*\n+     * tests of tableSizeFor\n+     *\/\n+\n+    @DataProvider(name = \"tableSizeFor\")\n+    public Object[][] tableSizeForCases() {\n+        final int MAX = 1 << 30;\n+        return new Object[][] {\n+                \/\/ tableSizeFor(arg), expected\n+                { 0,                   1 },\n+                { 1,                   1 },\n+                { 2,                   2 },\n+                { 3,                   4 },\n+                { 4,                   4 },\n+                { 5,                   8 },\n+                { 15,                 16 },\n+                { 16,                 16 },\n+                { 17,                 32 },\n+                { MAX-1,             MAX },\n+                { MAX,               MAX },\n+                { MAX+1,             MAX },\n+                { Integer.MAX_VALUE, MAX }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"tableSizeFor\")\n+    public void tableSizeFor(int arg, int expected) {\n+        assertEquals(tableSizeFor(arg), expected);\n@@ -100,4 +159,11 @@\n-    @Test\n-    public void capacityTestDefaultConstructor() {\n-        capacityTestDefaultConstructor(new HashMap<>());\n-        capacityTestDefaultConstructor(new LinkedHashMap<>());\n+    \/*\n+     * tests for lazy table allocation\n+     *\/\n+\n+    @DataProvider(name = \"lazy\")\n+    public Object[][] lazyTableAllocationCases() {\n+        return new Object[][]{\n+                {new HashMap<>()},\n+                \/\/ { new WeakHashMap<>() }, \/\/ WHM doesn't allocate lazily\n+                {new LinkedHashMap<>()}\n+        };\n@@ -106,1 +172,2 @@\n-    void capacityTestDefaultConstructor(HashMap<Integer, Integer> map) {\n+    @Test(dataProvider = \"lazy\")\n+    public void lazyTableAllocation(Map<?, ?> map) {\n@@ -108,0 +175,1 @@\n+    }\n@@ -109,2 +177,3 @@\n-        map.put(1, 1);\n-        assertEquals(capacity(map), 16); \/\/ default initial capacity\n+    \/*\n+     * tests for default capacity (no-arg constructor)\n+     *\/\n@@ -112,2 +181,7 @@\n-        map.putAll(IntStream.range(0, 64).boxed().collect(toMap(i -> i, i -> i)));\n-        assertEquals(capacity(map), 128);\n+    @DataProvider(name = \"defaultCapacity\")\n+    public Object[][] defaultCapacityCases() {\n+        return new Supplier<?>[][]{\n+                {() -> new HashMap<>()},\n+                {() -> new LinkedHashMap<>()},\n+                {() -> new WeakHashMap<>()}\n+        };\n@@ -116,8 +190,6 @@\n-    @Test\n-    public void capacityTestInitialCapacity() {\n-        int initialCapacity = rnd.nextInt(2, 128);\n-        List<Supplier<HashMap<Integer, Integer>>> suppliers = List.of(\n-            () -> new HashMap<>(initialCapacity),\n-            () -> new HashMap<>(initialCapacity, 0.75f),\n-            () -> new LinkedHashMap<>(initialCapacity),\n-            () -> new LinkedHashMap<>(initialCapacity, 0.75f));\n+    @Test(dataProvider = \"defaultCapacity\")\n+    public void defaultCapacity(Supplier<Map<String, String>> s) {\n+        Map<String, String> map = s.get();\n+        map.put(\"\", \"\");\n+        assertEquals(capacity(map), 16);\n+    }\n@@ -125,3 +197,3 @@\n-        for (Supplier<HashMap<Integer, Integer>> supplier : suppliers) {\n-            HashMap<Integer, Integer> map = supplier.get();\n-            assertNull(table(map));\n+    \/*\n+     * tests for requested capacity (int and int+float constructors)\n+     *\/\n@@ -129,2 +201,11 @@\n-            map.put(1, 1);\n-            assertEquals(capacity(map), tableSizeFor(initialCapacity));\n+    @DataProvider(name = \"requestedCapacity\")\n+    public Iterator<Object[]> requestedCapacityCases() {\n+        ArrayList<Object[]> cases = new ArrayList<>();\n+        for (int i = 2; i < 128; i++) {\n+            int cap = i;\n+            cases.add(new Object[]{\"rhm1\", cap, (Supplier<Map<String, String>>) () -> new HashMap<>(cap)});\n+            cases.add(new Object[]{\"rhm2\", cap, (Supplier<Map<String, String>>) () -> new HashMap<>(cap, 0.75f)});\n+            cases.add(new Object[]{\"rlm1\", cap, (Supplier<Map<String, String>>) () -> new LinkedHashMap<>(cap)});\n+            cases.add(new Object[]{\"rlm2\", cap, (Supplier<Map<String, String>>) () -> new LinkedHashMap<>(cap, 0.75f)});\n+            cases.add(new Object[]{\"rwm1\", cap, (Supplier<Map<String, String>>) () -> new WeakHashMap<>(cap)});\n+            cases.add(new Object[]{\"rwm2\", cap, (Supplier<Map<String, String>>) () -> new WeakHashMap<>(cap, 0.75f)});\n@@ -132,0 +213,94 @@\n+        return cases.iterator();\n+    }\n+\n+    @Test(dataProvider = \"requestedCapacity\")\n+    public void requestedCapacity(String label, int cap, Supplier<Map<String, String>> s) {\n+        Map<String, String> map = s.get();\n+        map.put(\"\", \"\");\n+        assertEquals(capacity(map), tableSizeFor(cap));\n+    }\n+\n+    \/*\n+     * Tests for capacity after map is populated with a given number N of mappings.\n+     * Maps are populated using a copy constructor on a map with N mappings,\n+     * other constructors followed by N put() calls, and other constructors followed\n+     * by putAll() on a map with N mappings.\n+     *\n+     * String labels encode the test case for ease of diagnosis if one of the test cases fails.\n+     * For example, \"plm2pn\" is \"populated LinkedHashMap, 2-arg constructor, followed by putN\".\n+     *\/\n+\n+    \/\/ helper method for one populated capacity case, to provide target types for lambdas\n+    Object[] pcc(String label,\n+                 int size,\n+                 int expectedCapacity,\n+                 Supplier<Map<String, String>> supplier,\n+                 Consumer<Map<String, String>> consumer) {\n+        return new Object[]{label, size, expectedCapacity, supplier, consumer};\n+    }\n+\n+    List<Object[]> genPopulatedCapacityCases(int size, int cap) {\n+        return Arrays.asList(\n+                pcc(\"phmcpy\", size, cap, () -> new HashMap<>(makeMap(size)),       map -> { }),\n+                pcc(\"phm0pn\", size, cap, () -> new HashMap<>(),                    map -> { putN(map, size); }),\n+                pcc(\"phm1pn\", size, cap, () -> new HashMap<>(cap),                 map -> { putN(map, size); }),\n+                pcc(\"phm2pn\", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { putN(map, size); }),\n+                pcc(\"phm0pa\", size, cap, () -> new HashMap<>(),                    map -> { map.putAll(makeMap(size)); }),\n+                pcc(\"phm1pa\", size, cap, () -> new HashMap<>(cap),                 map -> { map.putAll(makeMap(size)); }),\n+                pcc(\"phm2pa\", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { map.putAll(makeMap(size)); }),\n+\n+                pcc(\"plmcpy\", size, cap, () -> new LinkedHashMap<>(makeMap(size)), map -> { }),\n+                pcc(\"plm0pn\", size, cap, () -> new LinkedHashMap<>(),              map -> { putN(map, size); }),\n+                pcc(\"plm1pn\", size, cap, () -> new LinkedHashMap<>(cap),           map -> { putN(map, size); }),\n+                pcc(\"plm2pn\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { putN(map, size); }),\n+                pcc(\"plm0pa\", size, cap, () -> new LinkedHashMap<>(),              map -> { map.putAll(makeMap(size)); }),\n+                pcc(\"plm1pa\", size, cap, () -> new LinkedHashMap<>(cap),           map -> { map.putAll(makeMap(size)); }),\n+                pcc(\"plm2pa\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { map.putAll(makeMap(size)); }),\n+\n+                pcc(\"pwmcpy\", size, cap, () -> new WeakHashMap<>(makeMap(size)),   map -> { }),\n+                pcc(\"pwm0pn\", size, cap, () -> new WeakHashMap<>(),                map -> { putN(map, size); }),\n+                pcc(\"pwm1pn\", size, cap, () -> new WeakHashMap<>(cap),             map -> { putN(map, size); }),\n+                pcc(\"pwm2pn\", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { putN(map, size); }),\n+                pcc(\"pwm0pa\", size, cap, () -> new WeakHashMap<>(),                map -> { map.putAll(makeMap(size)); }),\n+                pcc(\"pwm1pa\", size, cap, () -> new WeakHashMap<>(cap),             map -> { map.putAll(makeMap(size)); }),\n+                pcc(\"pwm2pa\", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { map.putAll(makeMap(size)); })\n+        );\n+    }\n+\n+    List<Object[]> genFakePopulatedCapacityCases(int size, int cap) {\n+        return Arrays.asList(\n+                pcc(\"fhmcpy\", size, cap, () -> new HashMap<>(fakeMap(size)),       map -> { }),\n+                pcc(\"fhm0pa\", size, cap, () -> new HashMap<>(),                    map -> { map.putAll(fakeMap(size)); }),\n+                pcc(\"fhm1pa\", size, cap, () -> new HashMap<>(cap),                 map -> { map.putAll(fakeMap(size)); }),\n+                pcc(\"fhm2pa\", size, cap, () -> new HashMap<>(cap, 0.75f),          map -> { map.putAll(fakeMap(size)); }),\n+\n+                pcc(\"flmcpy\", size, cap, () -> new LinkedHashMap<>(fakeMap(size)), map -> { }),\n+                pcc(\"flm0pa\", size, cap, () -> new LinkedHashMap<>(),              map -> { map.putAll(fakeMap(size)); }),\n+                pcc(\"flm1pa\", size, cap, () -> new LinkedHashMap<>(cap),           map -> { map.putAll(fakeMap(size)); }),\n+                pcc(\"flm2pa\", size, cap, () -> new LinkedHashMap<>(cap, 0.75f),    map -> { map.putAll(fakeMap(size)); }),\n+\n+                pcc(\"fwmcpy\", size, cap, () -> new WeakHashMap<>(fakeMap(size)),   map -> { }),\n+                \/\/ pcc(\"fwm0pa\", size, cap, () -> new WeakHashMap<>(),                map -> { map.putAll(fakeMap(size)); }), \/\/ see note\n+                pcc(\"fwm1pa\", size, cap, () -> new WeakHashMap<>(cap),             map -> { map.putAll(fakeMap(size)); }),\n+                pcc(\"fwm2pa\", size, cap, () -> new WeakHashMap<>(cap, 0.75f),      map -> { map.putAll(fakeMap(size)); })\n+        );\n+\n+        \/\/ Test case \"fwm0pa\" is commented out because WeakHashMap uses a different allocation\n+        \/\/ policy from the other map implementations: it deliberately under-allocates in this case.\n+    }\n+\n+    @DataProvider(name = \"populatedCapacity\")\n+    public Iterator<Object[]> populatedCapacityCases() {\n+        ArrayList<Object[]> cases = new ArrayList<>();\n+        cases.addAll(genPopulatedCapacityCases(11,  16));\n+        cases.addAll(genPopulatedCapacityCases(12,  16));\n+        cases.addAll(genPopulatedCapacityCases(13,  32));\n+        cases.addAll(genPopulatedCapacityCases(64, 128));\n+\n+        \/\/ numbers in this range are truncated by a float computation with 0.75f\n+        \/\/ but can get an exact result with a double computation with 0.75d\n+        cases.addAll(genFakePopulatedCapacityCases(25165824, 33554432));\n+        cases.addAll(genFakePopulatedCapacityCases(25165825, 67108864));\n+        cases.addAll(genFakePopulatedCapacityCases(25165826, 67108864));\n+\n+        return cases.iterator();\n@@ -133,0 +308,12 @@\n+\n+    @Test(dataProvider = \"populatedCapacity\")\n+    public void populatedCapacity(String label, \/\/ unused, included for diagnostics\n+                                  int size,     \/\/ unused, included for diagnostics\n+                                  int expectedCapacity,\n+                                  Supplier<Map<String, String>> s,\n+                                  Consumer<Map<String, String>> c) {\n+        Map<String, String> map = s.get();\n+        c.accept(map);\n+        assertEquals(capacity(map), expectedCapacity);\n+    }\n+\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxResizeTest.java","additions":246,"deletions":59,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.util.HashSet;\n@@ -41,0 +42,1 @@\n+import java.util.Locale;\n@@ -45,0 +47,1 @@\n+import java.util.stream.Collectors;\n@@ -49,2 +52,2 @@\n- * @bug 8231640\n- * @run testng PropertiesStoreTest\n+ * @bug 8231640 8282023\n+ * @run testng\/othervm PropertiesStoreTest\n@@ -55,0 +58,4 @@\n+    \/\/ use a neutral locale, since when the date comment was written by Properties.store(...),\n+    \/\/ it internally calls the Date.toString() which always writes in a locale insensitive manner\n+    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN, Locale.ROOT);\n+    private static final Locale PREV_LOCALE = Locale.getDefault();\n@@ -94,0 +101,20 @@\n+    \/**\n+     * Returns a {@link Locale} to use for testing\n+     *\/\n+    @DataProvider(name = \"localeProvider\")\n+    private Object[][] provideLocales() {\n+        \/\/ pick a non-english locale for testing\n+        Set<Locale> locales = Arrays.stream(Locale.getAvailableLocales())\n+                .filter(l -> !l.getLanguage().isEmpty() && !l.getLanguage().equals(\"en\"))\n+                .limit(1)\n+                .collect(Collectors.toCollection(HashSet::new));\n+        locales.add(Locale.getDefault()); \/\/ always test the default locale\n+        locales.add(Locale.US); \/\/ guaranteed to be present\n+        locales.add(Locale.ROOT); \/\/ guaranteed to be present\n+\n+        \/\/ return the chosen locales\n+        return locales.stream()\n+                .map(m -> new Locale[] {m})\n+                .toArray(n -> new Object[n][0]);\n+    }\n+\n@@ -156,7 +183,16 @@\n-    @Test\n-    public void testStoreWriterDateComment() throws Exception {\n-        final Properties props = new Properties();\n-        props.setProperty(\"a\", \"b\");\n-        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n-        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n-            props.store(writer, null);\n+    @Test(dataProvider = \"localeProvider\")\n+    public void testStoreWriterDateComment(final Locale testLocale) throws Exception {\n+        \/\/ switch the default locale to the one being tested\n+        Locale.setDefault(testLocale);\n+        System.out.println(\"Using locale: \" + testLocale + \" for Properties#store(Writer) test\");\n+        try {\n+            final Properties props = new Properties();\n+            props.setProperty(\"a\", \"b\");\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+            try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+                props.store(writer, null);\n+            }\n+            testDateComment(tmpFile);\n+        } finally {\n+            \/\/ reset to the previous one\n+            Locale.setDefault(PREV_LOCALE);\n@@ -164,1 +200,0 @@\n-        testDateComment(tmpFile);\n@@ -170,7 +205,16 @@\n-    @Test\n-    public void testStoreOutputStreamDateComment() throws Exception {\n-        final Properties props = new Properties();\n-        props.setProperty(\"a\", \"b\");\n-        final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n-        try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n-            props.store(writer, null);\n+    @Test(dataProvider = \"localeProvider\")\n+    public void testStoreOutputStreamDateComment(final Locale testLocale) throws Exception {\n+        \/\/ switch the default locale to the one being tested\n+        Locale.setDefault(testLocale);\n+        System.out.println(\"Using locale: \" + testLocale + \" for Properties#store(OutputStream) test\");\n+        try {\n+            final Properties props = new Properties();\n+            props.setProperty(\"a\", \"b\");\n+            final Path tmpFile = Files.createTempFile(\"8231640\", \"props\");\n+            try (final Writer writer = Files.newBufferedWriter(tmpFile)) {\n+                props.store(writer, null);\n+            }\n+            testDateComment(tmpFile);\n+        } finally {\n+            \/\/ reset to the previous one\n+            Locale.setDefault(PREV_LOCALE);\n@@ -178,1 +222,0 @@\n-        testDateComment(tmpFile);\n@@ -202,1 +245,1 @@\n-            DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN).parse(comment);\n+            FORMATTER.parse(comment);\n","filename":"test\/jdk\/java\/util\/Properties\/PropertiesStoreTest.java","additions":63,"deletions":20,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @bug 8231640\n+ * @bug 8231640 8282023\n@@ -55,2 +55,2 @@\n-    private static final DateTimeFormatter reproducibleDateTimeFormatter = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN)\n-            .withLocale(Locale.ROOT).withZone(ZoneOffset.UTC);\n+    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN, Locale.ROOT)\n+            .withZone(ZoneOffset.UTC);\n@@ -91,1 +91,1 @@\n-        final String sysPropVal = reproducibleDateTimeFormatter.format(Instant.ofEpochSecond(243535322));\n+        final String sysPropVal = FORMATTER.format(Instant.ofEpochSecond(243535322));\n@@ -133,1 +133,1 @@\n-        final String sysPropVal = reproducibleDateTimeFormatter.format(Instant.ofEpochSecond(1234342423));\n+        final String sysPropVal = FORMATTER.format(Instant.ofEpochSecond(1234342423));\n@@ -177,1 +177,1 @@\n-        final String sysPropVal = reproducibleDateTimeFormatter.format(Instant.ofEpochSecond(1234342423));\n+        final String sysPropVal = FORMATTER.format(Instant.ofEpochSecond(1234342423));\n@@ -428,1 +428,1 @@\n-            Instant instant = Instant.from(DateTimeFormatter.ofPattern(DATE_FORMAT_PATTERN).parse(dateComment));\n+            Instant instant = Instant.from(FORMATTER.parse(dateComment));\n@@ -431,1 +431,1 @@\n-            throw new RuntimeException(\"Unexpected date \" + dateComment + \" in stored properties \" + destFile);\n+            throw new RuntimeException(\"Unexpected date \" + dateComment + \" in stored properties \" + destFile, pe);\n","filename":"test\/jdk\/java\/util\/Properties\/StoreReproducibilityTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.random.*;\n+import jdk.internal.util.random.RandomSupport;\n+\n+\/**\n+ * @test\n+ * @summary RandomSupport.convertSeedBytesToLongs sign extension overwrites previous bytes.\n+ * @bug 8282144\n+ * @modules java.base\/jdk.internal.util.random\n+ * @run main T8282144\n+ * @key randomness\n+ *\/\n+\n+\n+public class T8282144 {\n+    public static void main(String[] args) {\n+        RandomGenerator rng = RandomGeneratorFactory.of(\"L64X128MixRandom\").create(42);\n+\n+        for (int i = 1; i < 8; i++) {\n+            byte[] seed = new byte[i];\n+\n+            for (int j = 0; j < 10; j++) {\n+                rng.nextBytes(seed);\n+\n+                long[] existing = RandomSupport.convertSeedBytesToLongs(seed, 1, 1);\n+                long[] testing = convertSeedBytesToLongsFixed(seed, 1, 1);\n+\n+                for (int k = 0; k < existing.length; k++) {\n+                    if (existing[k] != testing[k]) {\n+                        throw new RuntimeException(\"convertSeedBytesToLongs incorrect\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    public static long[] convertSeedBytesToLongsFixed(byte[] seed, int n, int z) {\n+        final long[] result = new long[n];\n+        final int m = Math.min(seed.length, n << 3);\n+\n+        \/\/ Distribute seed bytes into the words to be formed.\n+        for (int j = 0; j < m; j++) {\n+            result[j >> 3] = (result[j >> 3] << 8) | (seed[j] & 0xff);\n+        }\n+\n+        return result;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Random\/T8282144.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8280902\n+ * @summary Test uses custom launcher that starts VM using JNI that verifies\n+ *          ResourceBundle::getBundle with null caller class functions properly\n+ *          using the system class loader unnamed module.  The custom launcher\n+ *          creates a properties file and passes the VM option to the JNI\n+ *          functionality for the resource lookup.\n+ * @library \/test\/lib\n+ * @requires os.family != \"aix\"\n+ * @run main\/native NullCallerResourceBundle\n+ *\/\n+\n+\/\/ Test disabled on AIX since we cannot invoke the JVM on the primordial thread.\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Properties;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class NullCallerResourceBundle {\n+    public static void main(String[] args) throws IOException {\n+\n+        \/\/ build a properties file for the native test\n+        var propPath = Path.of(System.getProperty(\"test.classes\"), \"NullCallerResource.properties\");\n+        try (var stream = Files.newOutputStream(propPath)) {\n+            var props = new Properties();\n+            props.put(\"message\", \"Hello!\");\n+            props.save(stream, \"Test property list\");\n+        }\n+\n+        var launcher = Path.of(System.getProperty(\"test.nativepath\"), \"NullCallerResourceBundle\");\n+        var classpathAppend = \"-Djava.class.path=\" + System.getProperty(\"test.classes\");\n+        var pb = new ProcessBuilder(launcher.toString(), classpathAppend);\n+        var env = pb.environment();\n+\n+        var libDir = Platform.libDir().toString();\n+        var vmDir = Platform.jvmLibDir().toString();\n+\n+        \/\/ set up shared library path\n+        var sharedLibraryPathEnvName = Platform.sharedLibraryPathVariableName();\n+        env.compute(sharedLibraryPathEnvName,\n+                (k, v) -> (v == null) ? libDir : v + File.pathSeparator + libDir);\n+        env.compute(sharedLibraryPathEnvName,\n+                (k, v) -> (v == null) ? vmDir : v + File.pathSeparator + vmDir);\n+\n+        System.out.println(\"Launching: \" + launcher + \" shared library path: \" +\n+                env.get(sharedLibraryPathEnvName));\n+        new OutputAnalyzer(pb.start())\n+                .outputTo(System.out)\n+                .errorTo(System.err)\n+                .shouldHaveExitValue(0);\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/exeNullCallerResourceBundle\/NullCallerResourceBundle.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"jni.h\"\n+#undef NDEBUG\n+#include \"assert.h\"\n+#include \"string.h\"\n+\n+\n+\/*\n+ * The java test running this native test passes in an argument to provide as\n+ * an option for the configuration of the JVM.  The system classpath has the\n+ * classpath of the java test appended so it can pick up the resource that\n+ * was created by the java part of the test.\n+ *\/\n+int main(int argc, char** args) {\n+    JavaVM *jvm;\n+    JNIEnv *env;\n+    JavaVMInitArgs vm_args;\n+    JavaVMOption options[1];\n+    jint rc;\n+\n+    assert(argc == 2);\n+    options[0].optionString = args[1];\n+\n+    vm_args.version = JNI_VERSION_1_2;\n+    vm_args.nOptions = 1;\n+    vm_args.options = options;\n+\n+    if ((rc = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args)) != JNI_OK) {\n+        printf(\"ERROR: cannot create VM.\\n\");\n+        exit(-1);\n+    }\n+\n+    \/\/ b = ResourceBundle.getBundle(\"NullCallerResource\");\n+    jclass class_ResourceBundle = (*env)->FindClass(env, \"java\/util\/ResourceBundle\");\n+    assert(class_ResourceBundle != NULL);\n+    jmethodID mid_ResourceBundle_getBundle = (*env)->GetStaticMethodID(env, class_ResourceBundle, \"getBundle\", \"(Ljava\/lang\/String;)Ljava\/util\/ResourceBundle;\" );\n+    assert(mid_ResourceBundle_getBundle != NULL);\n+    jobject resourceName = (*env)->NewStringUTF(env, \"NullCallerResource\");\n+    assert(resourceName != NULL);\n+    jobject b = (*env)->CallStaticObjectMethod(env, class_ResourceBundle, mid_ResourceBundle_getBundle, resourceName);\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        printf(\"ERROR: Exception was thrown calling ResourceBundle::getBundle.\\n\");\n+        (*env)->ExceptionDescribe(env);\n+        exit(-1);\n+    }\n+\n+    \/\/ msg = b.getString(\"message\");\n+    jmethodID mid_ResourceBundle_getString = (*env)->GetMethodID(env, class_ResourceBundle, \"getString\", \"(Ljava\/lang\/String;)Ljava\/lang\/String;\" );\n+    assert(mid_ResourceBundle_getString != NULL);\n+    jobject key = (*env)->NewStringUTF(env, \"message\");\n+    jobject msg =(*env)->CallObjectMethod(env, b, mid_ResourceBundle_getString, key);\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        printf(\"ERROR: Exception was thrown calling ResourceBundle::getString.\\n\");\n+        (*env)->ExceptionDescribe(env);\n+        exit(-1);\n+    }\n+    assert(msg != NULL);\n+\n+    \/\/ check the message\n+    const char* cstr = (*env)->GetStringUTFChars(env, msg, NULL);\n+    assert(cstr != NULL);\n+    assert(strcmp(cstr,\"Hello!\") == 0);\n+\n+    \/\/ ResourceBundle.clearCache()\n+    jmethodID mid_ResourceBundle_clearCache = (*env)->GetStaticMethodID(env, class_ResourceBundle, \"clearCache\", \"()V\" );\n+    assert(mid_ResourceBundle_clearCache != NULL);\n+    (*env)->CallStaticVoidMethod(env, class_ResourceBundle, mid_ResourceBundle_clearCache);\n+    if ((*env)->ExceptionOccurred(env) != NULL) {\n+        printf(\"ERROR: Exception was thrown calling ResourceBundle::clearCache.\\n\");\n+        (*env)->ExceptionDescribe(env);\n+        exit(-1);\n+    }\n+\n+    (*jvm)->DestroyJavaVM(jvm);\n+    return 0;\n+}\n+\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/exeNullCallerResourceBundle\/exeNullCallerResourceBundle.c","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -450,1 +450,1 @@\n-                expected = (System.getSecurityManager() == null ? global : global2);;\n+                expected = (System.getSecurityManager() == null ? global : global2);\n","filename":"test\/jdk\/java\/util\/logging\/TestAppletLoggerContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4560,0 +4560,24 @@\n+    \/\/This test is for 8281560\n+    @Test\n+    public static void prematureHitEndInNFCCharProperty() {\n+        var testInput = \"a1a1\";\n+        var pat1 = \"(a+|1+)\";\n+        var pat2 = \"([a]+|[1]+)\";\n+\n+        var matcher1 = Pattern.compile(pat1, Pattern.CANON_EQ).matcher(testInput);\n+        var matcher2 = Pattern.compile(pat2, Pattern.CANON_EQ).matcher(testInput);\n+\n+        ArrayList<Boolean> results1 = new ArrayList<>();\n+        ArrayList<Boolean> results2 = new ArrayList<>();\n+\n+        while (matcher1.find()) {\n+            results1.add(matcher1.hitEnd());\n+        }\n+\n+        while (matcher2.find()) {\n+            results2.add(matcher2.hitEnd());\n+        }\n+\n+        assertEquals(results1, results2);\n+    }\n+\n@@ -4566,1 +4590,0 @@\n-\n@@ -4569,0 +4592,1 @@\n+\n","filename":"test\/jdk\/java\/util\/regex\/RegExTest.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8193682\n- * @summary Test Infinite loop while writing on closed GZipOutputStream , ZipOutputStream and JarOutputStream.\n- * @run testng CloseDeflaterTest\n- *\/\n-import java.io.*;\n-import java.util.Random;\n-import java.util.jar.JarOutputStream;\n-import java.util.zip.GZIPOutputStream;\n-import java.util.zip.ZipOutputStream;\n-import java.util.zip.ZipEntry;\n-\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.fail;\n-\n-\n-public class CloseDeflaterTest {\n-\n-    \/\/number of bytes to write\n-    private static final int INPUT_LENGTH= 512;\n-    \/\/OutputStream that will throw an exception during a write operation\n-    private static OutputStream outStream = new OutputStream() {\n-        @Override\n-        public void write(byte[] b, int off, int len) throws IOException {\n-            \/\/throw exception during write\n-            throw new IOException();\n-        }\n-        @Override\n-        public void write(byte b[]) throws IOException {}\n-        @Override\n-        public void write(int b) throws IOException {}\n-    };\n-    private static byte[] inputBytes = new byte[INPUT_LENGTH];\n-    private static Random rand = new Random();\n-\n-    @DataProvider(name = \"testgzipinput\")\n-    public Object[][] testGZipInput() {\n-     \/\/testGZip will close the GZipOutputStream using close() method when the boolean\n-     \/\/useCloseMethod is set to true and finish() method if the value is set to false\n-     return new Object[][] {\n-      { GZIPOutputStream.class, true },\n-      { GZIPOutputStream.class, false },\n-     };\n-    }\n-\n-    @DataProvider(name = \"testzipjarinput\")\n-    public Object[][] testZipAndJarInput() {\n-     \/\/testZipAndJarInput will perfrom write\/closeEntry operations on JarOutputStream when the boolean\n-     \/\/useJar is set to true and on ZipOutputStream if the value is set to false\n-     return new Object[][] {\n-      { JarOutputStream.class, true },\n-      { ZipOutputStream.class, false },\n-     };\n-    }\n-\n-    @BeforeTest\n-    public void before_test()\n-    {\n-       \/\/add inputBytes array with random bytes to write into Zip\n-       rand.nextBytes(inputBytes);\n-    }\n-\n-    \/\/Test for infinite loop by writing bytes to closed GZIPOutputStream\n-    @Test(dataProvider = \"testgzipinput\")\n-    public void testGZip(Class<?> type, boolean useCloseMethod) throws IOException {\n-        GZIPOutputStream zip = new GZIPOutputStream(outStream);\n-        try {\n-            zip.write(inputBytes, 0, INPUT_LENGTH);\n-            \/\/close zip\n-            if(useCloseMethod) {\n-               zip.close();\n-            } else {\n-               zip.finish();\n-            }\n-        } catch (IOException e) {\n-            \/\/expected\n-        }\n-        for (int i = 0; i < 3; i++) {\n-            try {\n-                \/\/write on a closed GZIPOutputStream\n-                zip.write(inputBytes, 0, INPUT_LENGTH);\n-                fail(\"Deflater closed exception not thrown\");\n-            } catch (NullPointerException e) {\n-                \/\/expected , Deflater has been closed exception\n-            }\n-        }\n-    }\n-\n-    \/\/Test for infinite loop by writing bytes to closed ZipOutputStream\/JarOutputStream\n-    @Test(dataProvider = \"testzipjarinput\")\n-    public void testZipCloseEntry(Class<?> type,boolean useJar) throws IOException {\n-        ZipOutputStream zip = null;\n-        if(useJar) {\n-           zip = new JarOutputStream(outStream);\n-        } else {\n-           zip = new ZipOutputStream(outStream);\n-        }\n-        try {\n-            zip.putNextEntry(new ZipEntry(\"\"));\n-        } catch (IOException e) {\n-            \/\/expected to throw IOException since putNextEntry calls write method\n-        }\n-        try {\n-            zip.write(inputBytes, 0, INPUT_LENGTH);\n-            \/\/close zip entry\n-            zip.closeEntry();\n-        } catch (IOException e) {\n-            \/\/expected\n-        }\n-        for (int i = 0; i < 3; i++) {\n-            try {\n-                \/\/write on a closed ZipOutputStream\n-                zip.write(inputBytes, 0, INPUT_LENGTH);\n-                fail(\"Deflater closed exception not thrown\");\n-            } catch (NullPointerException e) {\n-                \/\/expected , Deflater has been closed exception\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/util\/zip\/CloseDeflaterTest.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193682 8278794\n+ * @summary Test Infinite loop while writing on closed Deflater and Inflater.\n+ * @run testng CloseInflaterDeflaterTest\n+ *\/\n+import java.io.*;\n+import java.util.Random;\n+import java.util.jar.JarOutputStream;\n+import java.util.zip.DeflaterInputStream;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.GZIPOutputStream;\n+import java.util.zip.InflaterOutputStream;\n+import java.util.zip.ZipOutputStream;\n+import java.util.zip.ZipEntry;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertThrows;\n+\n+\n+public class CloseInflaterDeflaterTest {\n+\n+    \/\/ Number of bytes to write\/read from Deflater\/Inflater\n+    private static final int INPUT_LENGTH= 512;\n+    \/\/ OutputStream that will throw an exception during a write operation\n+    private static OutputStream outStream = new OutputStream() {\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            throw new IOException();\n+        }\n+        @Override\n+        public void write(byte[] b) throws IOException {}\n+        @Override\n+        public void write(int b) throws IOException {}\n+    };\n+    \/\/ InputStream that will throw an exception during a read operation\n+    private static InputStream inStream = new InputStream() {\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            throw new IOException();\n+        }\n+        @Override\n+        public int read(byte[] b) throws IOException { throw new IOException();}\n+        @Override\n+        public int read() throws IOException { throw new IOException();}\n+    };\n+    \/\/ Input bytes for read\/write operation\n+    private static byte[] inputBytes = new byte[INPUT_LENGTH];\n+    \/\/ Random function to add bytes to inputBytes\n+    private static Random rand = new Random();\n+\n+    \/**\n+     * DataProvider to specify whether to use close() or finish() of OutputStream\n+     *\n+     * @return Entry object indicating which method to use for closing OutputStream\n+     *\/\n+    @DataProvider\n+    public Object[][] testOutputStreams() {\n+     return new Object[][] {\n+      { true },\n+      { false },\n+     };\n+    }\n+\n+    \/**\n+     * DataProvider to specify on which outputstream closeEntry() has to be called\n+     *\n+     * @return Entry object returning either JarOutputStream or ZipOutputStream\n+     *\/\n+    @DataProvider\n+    public Object[][] testZipAndJar() throws IOException{\n+     return new Object[][] {\n+      { new JarOutputStream(outStream)},\n+      { new ZipOutputStream(outStream)},\n+     };\n+    }\n+\n+    \/**\n+     * Add inputBytes array with random bytes to write into OutputStream\n+     *\/\n+    @BeforeTest\n+    public void before_test()\n+    {\n+       rand.nextBytes(inputBytes);\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed GZIPOutputStream\n+     *\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\")\n+    public void testGZip(boolean useCloseMethod) throws IOException {\n+        GZIPOutputStream gzip = new GZIPOutputStream(outStream);\n+        gzip.write(inputBytes, 0, INPUT_LENGTH);\n+        assertThrows(IOException.class, () -> {\n+            \/\/ Close GZIPOutputStream\n+            if (useCloseMethod) {\n+                gzip.close();\n+            } else {\n+                gzip.finish();\n+            }\n+        });\n+        \/\/ Write on a closed GZIPOutputStream, closed Deflater IOException expected\n+        assertThrows(NullPointerException.class , () -> gzip.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed DeflaterOutputStream\n+     *\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\")\n+    public void testDeflaterOutputStream(boolean useCloseMethod) throws IOException {\n+        DeflaterOutputStream def = new DeflaterOutputStream(outStream);\n+        assertThrows(IOException.class , () -> def.write(inputBytes, 0, INPUT_LENGTH));\n+        assertThrows(IOException.class, () -> {\n+            \/\/ Close DeflaterOutputStream\n+            if (useCloseMethod) {\n+                def.close();\n+            } else {\n+                def.finish();\n+            }\n+        });\n+        \/\/ Write on a closed DeflaterOutputStream, 'Deflater has been closed' NPE is expected\n+        assertThrows(NullPointerException.class , () -> def.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by reading bytes from closed DeflaterInputStream\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test\n+    public void testDeflaterInputStream() throws IOException {\n+        DeflaterInputStream def = new DeflaterInputStream(inStream);\n+        assertThrows(IOException.class , () -> def.read(inputBytes, 0, INPUT_LENGTH));\n+        \/\/ Close DeflaterInputStream\n+        def.close();\n+        \/\/ Read from a closed DeflaterInputStream, closed Deflater IOException expected\n+        assertThrows(IOException.class , () -> def.read(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed InflaterOutputStream\n+     *\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\")\n+    public void testInflaterOutputStream(boolean useCloseMethod) throws IOException {\n+        InflaterOutputStream inf = new InflaterOutputStream(outStream);\n+        assertThrows(IOException.class , () -> inf.write(inputBytes, 0, INPUT_LENGTH));\n+        assertThrows(IOException.class , () -> {\n+            \/\/ Close InflaterOutputStream\n+            if (useCloseMethod) {\n+                inf.close();\n+            } else {\n+                inf.finish();\n+            }\n+        });\n+        \/\/ Write on a closed InflaterOutputStream , closed Inflater IOException expected\n+        assertThrows(IOException.class , () -> inf.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed ZipOutputStream\/JarOutputStream\n+     *\n+     * @param zip will be the instance of either JarOutputStream or ZipOutputStream\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testZipAndJar\")\n+    public void testZipCloseEntry(ZipOutputStream zip) throws IOException {\n+        assertThrows(IOException.class , () -> zip.putNextEntry(new ZipEntry(\"\")));\n+        zip.write(inputBytes, 0, INPUT_LENGTH);\n+        assertThrows(IOException.class , () -> zip.closeEntry());\n+        \/\/ Write on a closed ZipOutputStream , 'Deflater has been closed' NPE is expected\n+        assertThrows(NullPointerException.class , () -> zip.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/zip\/CloseInflaterDeflaterTest.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.jar.JarFile;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * @test\n+ * @bug 8280404\n+ * @summary Validate that Zip\/JarFile will throw a ZipException when the CEN\n+ * comment length field contains an incorrect value\n+ * @run testng\/othervm InvalidCommentLengthTest\n+ *\/\n+public class InvalidCommentLengthTest {\n+\n+    \/\/ Name used to create a JAR with an invalid comment length\n+    public static final Path INVALID_CEN_COMMENT_LENGTH_JAR =\n+            Path.of(\"Invalid-CEN-Comment-Length.jar\");\n+    \/\/ Name used to create a JAR with a valid comment length\n+    public static final Path VALID_CEN_COMMENT_LENGTH_JAR =\n+            Path.of(\"Valid-CEN-Comment-Length.jar\");\n+    \/\/ Zip\/Jar CEN file header entry that will be modified\n+    public static final String META_INF_MANIFEST_MF = \"META-INF\/MANIFEST.MF\";\n+    \/\/ Expected ZipException message when the comment length corrupts the\n+    \/\/ Zip\/Jar file\n+    public static final String INVALID_CEN_HEADER_BAD_ENTRY_NAME_OR_COMMENT =\n+            \"invalid CEN header (bad entry name or comment)\";\n+\n+    \/**\n+     * Byte array representing a valid jar file prior modifying the comment length\n+     * entry in a CEN file header.\n+     * The \"Valid-CEN-Comment-Length.jar\" jar file was created via:\n+     * <pre>\n+     *     {@code\n+     *     jar cvf Valid-CEN-Comment-Length.jar Hello.txt Tennis.txt BruceWayne.txt\n+     *     added manifest\n+     *     adding: Hello.txt(in = 12) (out= 14)(deflated -16%)\n+     *     adding: Tennis.txt(in = 53) (out= 53)(deflated 0%)\n+     *     adding: BruceWayne.txt(in = 12) (out= 14)(deflated -16%)\n+     *     }\n+     * <\/pre>\n+     * Its contents are:\n+     * <pre>\n+     *     {@code\n+     *     jar tvf Valid-CEN-Comment-Length.jar\n+     *      0 Wed Mar 02 06:39:24 EST 2022 META-INF\/\n+     *     66 Wed Mar 02 06:39:24 EST 2022 META-INF\/MANIFEST.MF\n+     *     12 Wed Mar 02 06:39:06 EST 2022 Hello.txt\n+     *     53 Wed Mar 02 13:04:48 EST 2022 Tennis.txt\n+     *     12 Wed Mar 02 15:15:34 EST 2022 BruceWayne.txt\n+     *     }\n+     * <\/pre>\n+     * The ByteArray was created by:\n+     * <pre>\n+     *  {@code\n+     *     var jar = Files.readAllBytes(\"Valid-CEN-Comment-Length.jar\");\n+     *     var validEntryName = createByteArray(fooJar,\n+     *           \"VALID_ZIP_WITH_NO_COMMENTS_BYTES\");\n+     *  }\n+     * <\/pre>\n+     *\/\n+    public static byte[] VALID_ZIP_WITH_NO_COMMENTS_BYTES = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14,\n+            (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8, (byte) 0x0,\n+            (byte) 0xec, (byte) 0x34, (byte) 0x62, (byte) 0x54, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x4, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x45, (byte) 0x54, (byte) 0x41, (byte) 0x2d,\n+            (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f, (byte) 0xfe,\n+            (byte) 0xca, (byte) 0x0, (byte) 0x0, (byte) 0x3, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x7, (byte) 0x8, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x2, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0xec, (byte) 0x34, (byte) 0x62, (byte) 0x54,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x4d, (byte) 0x45, (byte) 0x54, (byte) 0x41,\n+            (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f,\n+            (byte) 0x4d, (byte) 0x41, (byte) 0x4e, (byte) 0x49, (byte) 0x46,\n+            (byte) 0x45, (byte) 0x53, (byte) 0x54, (byte) 0x2e, (byte) 0x4d,\n+            (byte) 0x46, (byte) 0xf3, (byte) 0x4d, (byte) 0xcc, (byte) 0xcb,\n+            (byte) 0x4c, (byte) 0x4b, (byte) 0x2d, (byte) 0x2e, (byte) 0xd1,\n+            (byte) 0xd, (byte) 0x4b, (byte) 0x2d, (byte) 0x2a, (byte) 0xce,\n+            (byte) 0xcc, (byte) 0xcf, (byte) 0xb3, (byte) 0x52, (byte) 0x30,\n+            (byte) 0xd4, (byte) 0x33, (byte) 0xe0, (byte) 0xe5, (byte) 0x72,\n+            (byte) 0x2e, (byte) 0x4a, (byte) 0x4d, (byte) 0x2c, (byte) 0x49,\n+            (byte) 0x4d, (byte) 0xd1, (byte) 0x75, (byte) 0xaa, (byte) 0x4,\n+            (byte) 0xa, (byte) 0x98, (byte) 0xe8, (byte) 0x19, (byte) 0xe8,\n+            (byte) 0x19, (byte) 0x2a, (byte) 0x68, (byte) 0xf8, (byte) 0x17,\n+            (byte) 0x25, (byte) 0x26, (byte) 0xe7, (byte) 0xa4, (byte) 0x2a,\n+            (byte) 0x38, (byte) 0xe7, (byte) 0x17, (byte) 0x15, (byte) 0xe4,\n+            (byte) 0x17, (byte) 0x25, (byte) 0x96, (byte) 0x0, (byte) 0x15,\n+            (byte) 0x6b, (byte) 0xf2, (byte) 0x72, (byte) 0xf1, (byte) 0x72,\n+            (byte) 0x1, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7,\n+            (byte) 0x8, (byte) 0xf4, (byte) 0x59, (byte) 0xdc, (byte) 0xa6,\n+            (byte) 0x42, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x42,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b,\n+            (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0xe3, (byte) 0x34,\n+            (byte) 0x62, (byte) 0x54, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x9,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x48, (byte) 0x65,\n+            (byte) 0x6c, (byte) 0x6c, (byte) 0x6f, (byte) 0x2e, (byte) 0x74,\n+            (byte) 0x78, (byte) 0x74, (byte) 0xf3, (byte) 0x48, (byte) 0xcd,\n+            (byte) 0xc9, (byte) 0xc9, (byte) 0x57, (byte) 0x28, (byte) 0xcf,\n+            (byte) 0x2f, (byte) 0xca, (byte) 0x49, (byte) 0xe1, (byte) 0x2,\n+            (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x7, (byte) 0x8,\n+            (byte) 0xd5, (byte) 0xe0, (byte) 0x39, (byte) 0xb7, (byte) 0xe,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xc, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x3,\n+            (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x98, (byte) 0x68, (byte) 0x62,\n+            (byte) 0x54, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xa, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x54, (byte) 0x65, (byte) 0x6e,\n+            (byte) 0x6e, (byte) 0x69, (byte) 0x73, (byte) 0x2e, (byte) 0x74,\n+            (byte) 0x78, (byte) 0x74, (byte) 0x73, (byte) 0xf2, (byte) 0xb,\n+            (byte) 0x50, (byte) 0x8, (byte) 0x48, (byte) 0x2c, (byte) 0xca,\n+            (byte) 0x4c, (byte) 0x4a, (byte) 0x2c, (byte) 0x56, (byte) 0xf0,\n+            (byte) 0x2f, (byte) 0x48, (byte) 0xcd, (byte) 0x53, (byte) 0xc8,\n+            (byte) 0x2c, (byte) 0x56, (byte) 0x48, (byte) 0x54, (byte) 0x48,\n+            (byte) 0x2b, (byte) 0xcd, (byte) 0x53, (byte) 0x8, (byte) 0x49,\n+            (byte) 0xcd, (byte) 0xcb, (byte) 0x3, (byte) 0x72, (byte) 0x42,\n+            (byte) 0xf2, (byte) 0x4b, (byte) 0x8b, (byte) 0xf2, (byte) 0x12,\n+            (byte) 0x73, (byte) 0x53, (byte) 0xf3, (byte) 0x4a, (byte) 0x14,\n+            (byte) 0x4a, (byte) 0xf2, (byte) 0x15, (byte) 0xca, (byte) 0x13,\n+            (byte) 0x4b, (byte) 0x92, (byte) 0x33, (byte) 0xb8, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x7, (byte) 0x8, (byte) 0xaa,\n+            (byte) 0xad, (byte) 0x14, (byte) 0xd, (byte) 0x35, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x35, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0xf1, (byte) 0x79, (byte) 0x62, (byte) 0x54,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0xe, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x42, (byte) 0x72, (byte) 0x75, (byte) 0x63,\n+            (byte) 0x65, (byte) 0x57, (byte) 0x61, (byte) 0x79, (byte) 0x6e,\n+            (byte) 0x65, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74,\n+            (byte) 0xf3, (byte) 0x54, (byte) 0x48, (byte) 0xcc, (byte) 0x55,\n+            (byte) 0x70, (byte) 0x4a, (byte) 0x2c, (byte) 0xc9, (byte) 0x4d,\n+            (byte) 0xcc, (byte) 0xe3, (byte) 0x2, (byte) 0x0, (byte) 0x50,\n+            (byte) 0x4b, (byte) 0x7, (byte) 0x8, (byte) 0x6c, (byte) 0x70,\n+            (byte) 0x60, (byte) 0xbd, (byte) 0xe, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0xc, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x14,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0xec, (byte) 0x34, (byte) 0x62,\n+            (byte) 0x54, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x2, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0,\n+            (byte) 0x4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x4d, (byte) 0x45, (byte) 0x54, (byte) 0x41,\n+            (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f,\n+            (byte) 0xfe, (byte) 0xca, (byte) 0x0, (byte) 0x0, (byte) 0x50,\n+            (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x14, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0xec, (byte) 0x34, (byte) 0x62, (byte) 0x54,\n+            (byte) 0xf4, (byte) 0x59, (byte) 0xdc, (byte) 0xa6, (byte) 0x42,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x42, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x3d, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x4d, (byte) 0x45, (byte) 0x54, (byte) 0x41, (byte) 0x2d,\n+            (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f, (byte) 0x4d,\n+            (byte) 0x41, (byte) 0x4e, (byte) 0x49, (byte) 0x46, (byte) 0x45,\n+            (byte) 0x53, (byte) 0x54, (byte) 0x2e, (byte) 0x4d, (byte) 0x46,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x14,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0xe3, (byte) 0x34, (byte) 0x62,\n+            (byte) 0x54, (byte) 0xd5, (byte) 0xe0, (byte) 0x39, (byte) 0xb7,\n+            (byte) 0xe, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xc,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x9, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0xc1, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x48, (byte) 0x65, (byte) 0x6c, (byte) 0x6c,\n+            (byte) 0x6f, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x14,\n+            (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x98, (byte) 0x68, (byte) 0x62,\n+            (byte) 0x54, (byte) 0xaa, (byte) 0xad, (byte) 0x14, (byte) 0xd,\n+            (byte) 0x35, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x35,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xa, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x6, (byte) 0x1, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x54, (byte) 0x65, (byte) 0x6e, (byte) 0x6e,\n+            (byte) 0x69, (byte) 0x73, (byte) 0x2e, (byte) 0x74, (byte) 0x78,\n+            (byte) 0x74, (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0xf1, (byte) 0x79,\n+            (byte) 0x62, (byte) 0x54, (byte) 0x6c, (byte) 0x70, (byte) 0x60,\n+            (byte) 0xbd, (byte) 0xe, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0xc, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xe,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x73, (byte) 0x1,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x42, (byte) 0x72, (byte) 0x75,\n+            (byte) 0x63, (byte) 0x65, (byte) 0x57, (byte) 0x61, (byte) 0x79,\n+            (byte) 0x6e, (byte) 0x65, (byte) 0x2e, (byte) 0x74, (byte) 0x78,\n+            (byte) 0x74, (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x5,\n+            (byte) 0x0, (byte) 0x5, (byte) 0x0, (byte) 0x28, (byte) 0x1,\n+            (byte) 0x0, (byte) 0x0, (byte) 0xbd, (byte) 0x1, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Create Jar files used by the tests.\n+     * The {@code byte} array {@code VALID_ZIP_WITH_NO_COMMENTS_BYTES} is written\n+     * to disk to create the jar file: {@code Valid-CEN-Comment-Length.jar}.\n+     *\n+     * The jar file {@code InValid-CEN-Comment-Length.jar} is created by copying\n+     * the {@code byte} array {@code VALID_ZIP_WITH_NO_COMMENTS_BYTES} and modifying\n+     * the CEN file header comment length entry for \"META-INF\/MANIFEST.MF\" so that\n+     * new comment length will forward the CEN to a subsequent CEN file header\n+     * entry.\n+     *\n+     * For {@code InValid-CEN-Comment-Length.jar}, the comment length is changed\n+     * from {@code 0x0} to the {@code 0x37}.\n+     *\n+     * @throws IOException If an error occurs\n+     *\/\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        Files.deleteIfExists(VALID_CEN_COMMENT_LENGTH_JAR);\n+        Files.deleteIfExists(INVALID_CEN_COMMENT_LENGTH_JAR);\n+        \/\/ Create the valid jar\n+        Files.write(VALID_CEN_COMMENT_LENGTH_JAR, VALID_ZIP_WITH_NO_COMMENTS_BYTES);\n+        \/\/ Now create an invalid jar\n+        byte[] invalid_bytes = Arrays.copyOf(VALID_ZIP_WITH_NO_COMMENTS_BYTES,\n+                VALID_ZIP_WITH_NO_COMMENTS_BYTES.length);\n+        \/\/ Change CEN file Header comment length so that the length will\n+        \/\/ result in the offset pointing to a subsequent CEN file header\n+        \/\/ resulting in an invalid comment\n+        invalid_bytes[536] = 55;\n+        Files.write(INVALID_CEN_COMMENT_LENGTH_JAR, invalid_bytes);\n+    }\n+\n+    \/**\n+     * Clean up after the test run\n+     *\n+     * @throws IOException If an error occurs\n+     *\/\n+    @AfterTest\n+    public static void cleanup() throws IOException {\n+        Files.deleteIfExists(VALID_CEN_COMMENT_LENGTH_JAR);\n+        Files.deleteIfExists(INVALID_CEN_COMMENT_LENGTH_JAR);\n+    }\n+\n+    \/**\n+     * Validate that the original(valid) Jar file can be opened by {@code ZipFile}\n+     * and the expected Zip entry can be found\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test\n+    public static void ZipFileValidCommentLengthTest() throws IOException {\n+        try (ZipFile jf = new ZipFile(VALID_CEN_COMMENT_LENGTH_JAR.toFile())) {\n+            ZipEntry ze = jf.getEntry(META_INF_MANIFEST_MF);\n+            assertNotNull(ze);\n+            assertEquals(ze.getName(), META_INF_MANIFEST_MF);\n+        }\n+    }\n+\n+    \/**\n+     * Validate that the original(valid) Jar file can be opened by {@code JarFile}\n+     * and the expected Zip entry can be found\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test\n+    public static void JarFileValidCommentLengthTest() throws IOException {\n+        try (JarFile jf = new JarFile(VALID_CEN_COMMENT_LENGTH_JAR.toFile())) {\n+            ZipEntry ze = jf.getEntry(META_INF_MANIFEST_MF);\n+            assertNotNull(ze);\n+            assertEquals(ze.getName(), META_INF_MANIFEST_MF);\n+        }\n+    }\n+\n+    \/**\n+     * Validate that a ZipException is thrown when the CEN file header comment\n+     * length is non-zero and the CEN entry does not contain a comment when\n+     * the Jar file is opened by {@code ZipFile}\n+     *\/\n+    @Test\n+    public static void ZipFileInValidCommentLengthTest() {\n+        var ex= expectThrows(ZipException.class,\n+                () -> new ZipFile(INVALID_CEN_COMMENT_LENGTH_JAR.toFile()));\n+        assertEquals(ex.getMessage(), INVALID_CEN_HEADER_BAD_ENTRY_NAME_OR_COMMENT);\n+    }\n+\n+    \/**\n+     * Validate that a ZipException is thrown when the CEN file header comment\n+     * length is non-zero and the CEN entry does not contain a comment when\n+     * the Jar file is opened by  {@code JarFile}\n+     *\/\n+    @Test\n+    public static void JarFileInValidCommentLengthTest()  {\n+        var ex= expectThrows(ZipException.class,\n+                () -> new JarFile(INVALID_CEN_COMMENT_LENGTH_JAR.toFile()));\n+        assertEquals(ex.getMessage(), INVALID_CEN_HEADER_BAD_ENTRY_NAME_OR_COMMENT);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/InvalidCommentLengthTest.java","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8277922\n+   @key headful\n+   @summary TableCellRenderer of JTable cell with Boolean data should not\n+            support any AccessibleAction.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Robot;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.accessibility.Accessible;\n+import javax.accessibility.AccessibleAction;\n+import javax.accessibility.AccessibleContext;\n+import javax.accessibility.AccessibleTable;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.table.DefaultTableModel;\n+import javax.swing.table.TableCellRenderer;\n+\n+public class BooleanRendererHasAccessibleActionTest {\n+    private volatile JFrame frame;\n+    private volatile JTable table;\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException, AWTException {\n+        final BooleanRendererHasAccessibleActionTest test =\n+            new BooleanRendererHasAccessibleActionTest();\n+\n+        try {\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+                    test.createGUI();\n+                }\n+            });\n+            Robot robot = new Robot();\n+            robot.waitForIdle();\n+\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+                    test.runTest();\n+                }\n+            });\n+        } finally {\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+                    test.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private void createGUI() {\n+        frame = new JFrame(\"BooleanRendererHasAccessibleActionTest\");\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        Container content = frame.getContentPane();\n+        content.setLayout(new BorderLayout());\n+\n+        String[] tblColNames = {\"Column 1\", \"Column 2\", \"Column 3\"};\n+        Object[][] tblData = {\n+            {Boolean.TRUE, \"Text 1\", Boolean.FALSE},\n+            {Boolean.FALSE, \"Text 2\", Boolean.TRUE}\n+        };\n+        final DefaultTableModel tblModel = new DefaultTableModel(\n+                tblData, tblColNames) {\n+            @Override\n+            public Class<?> getColumnClass(int column) {\n+                return getValueAt(0, column).getClass();\n+            }\n+        };\n+        table = new JTable(tblModel);\n+        table.setPreferredScrollableViewportSize(new Dimension(400, 100));\n+\n+        JScrollPane tblScroller = new JScrollPane(table);\n+        tblScroller.setHorizontalScrollBarPolicy(\n+            JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);\n+        tblScroller.setVerticalScrollBarPolicy(\n+            JScrollPane.VERTICAL_SCROLLBAR_ALWAYS\n+        );\n+        content.add(tblScroller, BorderLayout.CENTER);\n+\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    private void dispose() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+    private void runTest() {\n+        if (table == null) {\n+            throw new RuntimeException(\"'table' should not be null\");\n+        }\n+\n+        testAccessibleActionInCellRenderer(0, 0, true);\n+        testAccessibleActionInCellRenderer(1, 0, true);\n+        testAccessibleActionInCellRenderer(0, 2, true);\n+        testAccessibleActionInCellRenderer(1, 2, true);\n+\n+        testAccessibleActionInCell(0, 0, true);\n+        testAccessibleActionInCell(1, 0, true);\n+        testAccessibleActionInCell(0, 2, true);\n+        testAccessibleActionInCell(1, 2, true);\n+\n+        System.out.println(\"Test passed.\");\n+    }\n+\n+    private void testAccessibleActionInCellRenderer(int row, int column,\n+            boolean shouldBeNull) {\n+        System.out.println(String.format(\n+                \"testAccessibleActionInCellRenderer():\" +\n+                    \" row='%d', column='%d', shouldBeNull='%b'\",\n+                row, column, shouldBeNull));\n+\n+        TableCellRenderer cellRenderer = table.getCellRenderer(row, column);\n+        if (!(cellRenderer instanceof Accessible)) {\n+            throw new RuntimeException(\"'cellRenderer' is not Accessible\");\n+        }\n+\n+        AccessibleContext cellRendererAc =\n+            ((Accessible) cellRenderer).getAccessibleContext();\n+        if (cellRendererAc == null) {\n+            throw new RuntimeException(\"'cellRendererAc' should not be null\");\n+        }\n+\n+        AccessibleAction cellRendererAa = cellRendererAc.getAccessibleAction();\n+        if ((shouldBeNull && (cellRendererAa != null)) ||\n+            (!shouldBeNull && (cellRendererAa == null))) {\n+            throw new RuntimeException(\n+                \"Test failed. 'cellRendererAa' is not as should be\");\n+        }\n+    }\n+\n+    private void testAccessibleActionInCell(int row, int column,\n+            boolean shouldBeNull) {\n+        System.out.println(String.format(\"testAccessibleActionInCell():\" +\n+                    \" row='%d', column='%d', shouldBeNull='%b'\",\n+                row, column, shouldBeNull));\n+\n+        AccessibleContext tblAc = table.getAccessibleContext();\n+        AccessibleTable accessibleTbl = tblAc.getAccessibleTable();\n+        if (accessibleTbl == null) {\n+            throw new RuntimeException(\"'accessibleTbl' should not be null\");\n+        }\n+\n+        Accessible cellAccessible = accessibleTbl.getAccessibleAt(row, column);\n+        AccessibleContext cellAc = cellAccessible.getAccessibleContext();\n+        if (cellAc == null) {\n+            throw new RuntimeException(\"'cellAc' should not be null\");\n+        }\n+\n+        AccessibleAction cellAa = cellAc.getAccessibleAction();\n+        if ((shouldBeNull && (cellAa != null)) ||\n+            (!shouldBeNull && (cellAa == null))) {\n+            throw new RuntimeException(\n+                \"Test failed. 'cellAa' is not as should be\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/accessibility\/JTable\/BooleanRendererHasAccessibleActionTest.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -113,0 +114,3 @@\n+                    \/\/ The predicate below tries to recognise failures.  On a port clash, it sees e.g.\n+                    \/\/ Error: Exception thrown by the agent : java.rmi.server.ExportException: Port already in use: 46481; nested exception is:\n+                    \/\/ ...and will never see \"main enter\" from TestApp.\n@@ -117,2 +121,1 @@\n-                                if (line.toLowerCase().contains(\"exception\")\n-                                || line.toLowerCase().contains(\"error\")) {\n+                                if (line.contains(\"Exception\")) {\n@@ -120,0 +123,2 @@\n+                                    bindError.set(line.toLowerCase().contains(\"port already in use\"));\n+                                    return true; \/\/ On Exception, app will never start\n@@ -121,3 +126,3 @@\n-                                bindError.set(line.toLowerCase().contains(\"bindexception\"));\n-                                return true;\n-                            });\n+                                return line.contains(\"main enter\");\n+                            },\n+                            60, TimeUnit.SECONDS);\n@@ -167,0 +172,1 @@\n+    private static final int FREE_PORT_ATTEMPTS = 10;\n@@ -169,1 +175,16 @@\n-        int port = Utils.getFreePort();\n+        for (int i = 1; i <= FREE_PORT_ATTEMPTS; i++) {\n+            int port = Utils.getFreePort();\n+            System.out.println(\"Attempting testDefaultAgent(\" + propertyFile + \") with port: \" + port);\n+            try {\n+                testDefaultAgent(propertyFile, port);\n+                break;  \/\/ return succesfully\n+            } catch (BindException b) {\n+                \/\/ Retry with new port.  Throw if last iteration:\n+                if (i == FREE_PORT_ATTEMPTS) {\n+                    throw(b);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void testDefaultAgent(String propertyFile, int port) throws Exception {\n@@ -238,31 +259,7 @@\n-        boolean retry = false;\n-        do {\n-            try {\n-                \/\/ filter DefaultAgentFilterTest$MyTestObject\n-                testDefaultAgent(\"mgmt1.properties\");\n-                System.out.println(\"----\\tTest FAILED !!\");\n-                throw new RuntimeException(\"---\" + DefaultAgentFilterTest.class.getName() + \" - No exception reported\");\n-            } catch (Exception ex) {\n-                if (ex instanceof InvocationTargetException) {\n-                    if (ex.getCause() instanceof BindException\n-                            || ex.getCause() instanceof java.rmi.ConnectException) {\n-                        System.out.println(\"Failed to allocate ports. Retrying ...\");\n-                        retry = true;\n-                    }\n-                } else if (ex instanceof InvalidClassException) {\n-                    System.out.println(\"----\\tTest PASSED !!\");\n-                } else if (ex instanceof UnmarshalException\n-                        && ((UnmarshalException) ex).getCause() instanceof InvalidClassException) {\n-                    System.out.println(\"----\\tTest PASSED !!\");\n-                } else {\n-                    System.out.println(ex);\n-                    System.out.println(\"----\\tTest FAILED !!\");\n-                    throw ex;\n-                }\n-            }\n-        } while (retry);\n-        retry = false;\n-        do {\n-            try {\n-                \/\/ filter non-existent class\n-                testDefaultAgent(\"mgmt2.properties\");\n+        try {\n+            \/\/ filter DefaultAgentFilterTest$MyTestObject\n+            testDefaultAgent(\"mgmt1.properties\");\n+            System.out.println(\"----\\tTest FAILED !!\");\n+            throw new RuntimeException(\"---\" + DefaultAgentFilterTest.class.getName() + \" - No exception reported\");\n+        } catch (Exception ex) {\n+            if (ex instanceof InvalidClassException) {\n@@ -270,12 +267,7 @@\n-            } catch (Exception ex) {\n-                if (ex instanceof InvocationTargetException) {\n-                    if (ex.getCause() instanceof BindException\n-                            || ex.getCause() instanceof java.rmi.ConnectException) {\n-                        System.out.println(\"Failed to allocate ports. Retrying ...\");\n-                        retry = true;\n-                    }\n-                } else {\n-                    System.out.println(ex);\n-                    System.out.println(\"----\\tTest FAILED !!\");\n-                    throw ex;\n-                }\n+            } else if (ex instanceof UnmarshalException\n+                    && ((UnmarshalException) ex).getCause() instanceof InvalidClassException) {\n+                System.out.println(\"----\\tTest PASSED !!\");\n+            } else {\n+                System.out.println(ex);\n+                System.out.println(\"----\\tTest FAILED !!\");\n+                throw ex;\n@@ -283,2 +275,10 @@\n-        } while (retry);\n-\n+        }\n+        try {\n+            \/\/ filter non-existent class\n+            testDefaultAgent(\"mgmt2.properties\");\n+            System.out.println(\"----\\tTest PASSED !!\");\n+        } catch (Exception ex) {\n+            System.out.println(ex);\n+            System.out.println(\"----\\tTest FAILED !!\");\n+            throw ex;\n+        }\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/connection\/DefaultAgentFilterTest.java","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -487,1 +487,1 @@\n-            local.initCause(remote);\n+            local.addSuppressed(remote);\n","filename":"test\/jdk\/javax\/net\/ssl\/ALPN\/SSLServerSocketAlpnTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -483,1 +483,1 @@\n-            local.initCause(remote);\n+            local.addSuppressed(remote);\n","filename":"test\/jdk\/javax\/net\/ssl\/ALPN\/SSLSocketAlpnTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8280494\n+ * @summary (D)TLS signature schemes\n+ * @modules java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @build DTLSOverDatagram\n+ * @run main\/othervm DTLSSignatureSchemes\n+ *\/\n+\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLParameters;\n+import java.security.Security;\n+\n+\/**\n+ * Test DTLS client authentication.\n+ *\/\n+public class DTLSSignatureSchemes extends DTLSOverDatagram {\n+    private final String[] serverSignatureSchemes;\n+    private final String[] clientSignatureSchemes;\n+\n+    public DTLSSignatureSchemes(String[] serverSignatureSchemes,\n+                            String[] clientSignatureSchemes) {\n+        this.serverSignatureSchemes = serverSignatureSchemes;\n+        this.clientSignatureSchemes = clientSignatureSchemes;\n+    }\n+\n+    @Override\n+    SSLEngine createSSLEngine(boolean isClient) throws Exception {\n+        SSLEngine engine = super.createSSLEngine(isClient);\n+\n+        SSLParameters sslParameters = engine.getSSLParameters();\n+        if (isClient) {\n+            sslParameters.setSignatureSchemes(clientSignatureSchemes);\n+        } else {\n+            sslParameters.setSignatureSchemes(serverSignatureSchemes);\n+        }\n+        engine.setSSLParameters(sslParameters);\n+\n+        return engine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\",\n+                        \"ed25519\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\",\n+                        \"ed25519\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                false);\n+        runTest(null,\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                null,\n+                false);\n+        runTest(new String[0],\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                true);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                new String[0],\n+                true);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_shaNA\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                true);\n+    }\n+\n+    private static void runTest(String[] serverSignatureSchemes,\n+                                String[] clientSignatureSchemes,\n+                                boolean exceptionExpected) throws Exception {\n+        DTLSSignatureSchemes testCase = new DTLSSignatureSchemes(\n+                serverSignatureSchemes, clientSignatureSchemes);\n+        try {\n+            testCase.runTest(testCase);\n+        } catch (Exception e) {\n+            if (!exceptionExpected) {\n+                throw e;\n+            } else { \/\/ Otherwise, swallow the expected exception and return.\n+                return;\n+            }\n+        }\n+\n+        if (exceptionExpected) {\n+            throw new RuntimeException(\"Unexpected success!\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSSignatureSchemes.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282723\n+ * @summary Add constructors taking a cause to JSSE exceptions\n+ *\/\n+import javax.net.ssl.SSLHandshakeException;\n+import java.util.Objects;\n+\n+public class CheckSSLHandshakeException {\n+    private static String exceptionMessage = \"message\";\n+    private static Throwable exceptionCause = new RuntimeException();\n+\n+    public static void main(String[] args) throws Exception {\n+        testException(\n+                new SSLHandshakeException(exceptionMessage, exceptionCause));\n+    }\n+\n+    private static void testException(Exception ex) {\n+        if (!Objects.equals(ex.getMessage(), exceptionMessage)) {\n+            throw new RuntimeException(\"Unexpected exception message\");\n+        }\n+\n+        if (ex.getCause() != exceptionCause) {\n+            throw new RuntimeException(\"Unexpected exception cause\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLException\/CheckSSLHandshakeException.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282723\n+ * @summary Add constructors taking a cause to JSSE exceptions\n+ *\/\n+import javax.net.ssl.SSLKeyException;\n+import java.util.Objects;\n+\n+public class CheckSSLKeyException {\n+    private static String exceptionMessage = \"message\";\n+    private static Throwable exceptionCause = new RuntimeException();\n+\n+    public static void main(String[] args) throws Exception {\n+        testException(\n+                new SSLKeyException(exceptionMessage, exceptionCause));\n+    }\n+\n+    private static void testException(Exception ex) {\n+        if (!Objects.equals(ex.getMessage(), exceptionMessage)) {\n+            throw new RuntimeException(\"Unexpected exception message\");\n+        }\n+\n+        if (ex.getCause() != exceptionCause) {\n+            throw new RuntimeException(\"Unexpected exception cause\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLException\/CheckSSLKeyException.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282723\n+ * @summary Add constructors taking a cause to JSSE exceptions\n+ *\/\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import java.util.Objects;\n+\n+public class CheckSSLPeerUnverifiedException {\n+    private static String exceptionMessage = \"message\";\n+    private static Throwable exceptionCause = new RuntimeException();\n+\n+    public static void main(String[] args) throws Exception {\n+        testException(\n+            new SSLPeerUnverifiedException(exceptionMessage, exceptionCause));\n+    }\n+\n+    private static void testException(Exception ex) {\n+        if (!Objects.equals(ex.getMessage(), exceptionMessage)) {\n+            throw new RuntimeException(\"Unexpected exception message\");\n+        }\n+\n+        if (ex.getCause() != exceptionCause) {\n+            throw new RuntimeException(\"Unexpected exception cause\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLException\/CheckSSLPeerUnverifiedException.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282723\n+ * @summary Add constructors taking a cause to JSSE exceptions\n+ *\/\n+import javax.net.ssl.SSLProtocolException;\n+import java.util.Objects;\n+\n+public class CheckSSLProtocolException {\n+    private static String exceptionMessage = \"message\";\n+    private static Throwable exceptionCause = new RuntimeException();\n+\n+    public static void main(String[] args) throws Exception {\n+        testException(\n+                new SSLProtocolException(exceptionMessage, exceptionCause));\n+    }\n+\n+    private static void testException(Exception ex) {\n+        if (!Objects.equals(ex.getMessage(), exceptionMessage)) {\n+            throw new RuntimeException(\"Unexpected exception message\");\n+        }\n+\n+        if (ex.getCause() != exceptionCause) {\n+            throw new RuntimeException(\"Unexpected exception cause\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLException\/CheckSSLProtocolException.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8280494\n+ * @summary (D)TLS signature schemes\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm SignatureSchemes\n+ *\/\n+\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLSocket;\n+import java.security.Security;\n+\n+public class SignatureSchemes extends SSLSocketTemplate {\n+    private final String[] serverSignatureSchemes;\n+    private final String[] clientSignatureSchemes;\n+    private final boolean exceptionExpected;\n+\n+    public SignatureSchemes(String[] serverSignatureSchemes,\n+                            String[] clientSignatureSchemes,\n+                            boolean exceptionExpected) {\n+        this.serverSignatureSchemes = serverSignatureSchemes;\n+        this.clientSignatureSchemes = clientSignatureSchemes;\n+        this.exceptionExpected = exceptionExpected;\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket sslServerSocket) {\n+        SSLParameters sslParameters = sslServerSocket.getSSLParameters();\n+        sslParameters.setSignatureSchemes(serverSignatureSchemes);\n+        sslServerSocket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        SSLParameters sslParameters = socket.getSSLParameters();\n+        sslParameters.setSignatureSchemes(clientSignatureSchemes);\n+        socket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n+        try {\n+            super.runServerApplication(socket);\n+        } catch (Exception ex) {\n+            \/\/ Just ignore, let the client handle the failure information.\n+        }\n+    }\n+\n+    @Override\n+    protected void runClientApplication(SSLSocket sslSocket) throws Exception {\n+        try {\n+            super.runClientApplication(sslSocket);\n+        } catch (Exception ex) {\n+            if (!exceptionExpected) {\n+                throw ex;\n+            } else {  \/\/ Otherwise, swallow the exception and return.\n+                return;\n+            }\n+        }\n+\n+        if (exceptionExpected) {\n+            throw new RuntimeException(\"Unexpected success!\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\",\n+                        \"ed25519\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\",\n+                        \"ed25519\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                false);\n+        runTest(null,\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                null,\n+                false);\n+        runTest(new String[0],\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                true);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                new String[0],\n+                true);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_shaNA\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                true);\n+    }\n+\n+    private static void runTest(String[] serverSignatureSchemes,\n+                                String[] clientSignatureSchemes,\n+                                boolean exceptionExpected) throws Exception {\n+        new SignatureSchemes(serverSignatureSchemes,\n+                clientSignatureSchemes, exceptionExpected).run();\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/SignatureSchemes.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8806542\n+ * @bug 8065422\n@@ -29,1 +29,2 @@\n- * @run main\/othervm -Djdk.net.hosts.file=hostsForExample EndingDotHostname\n+ * @run main\/othervm --add-opens java.base\/sun.security.ssl=ALL-UNNAMED\n+ *      -Djdk.net.hosts.file=hostsForExample EndingDotHostname\n@@ -33,1 +34,0 @@\n-import java.io.IOException;\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/EndingDotHostname.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        capabilities = SSLExplorer.explore(buffer, 0, recordLength);;\n+        capabilities = SSLExplorer.explore(buffer, 0, recordLength);\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLSocketExplorer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-            capabilities = SSLExplorer.explore(buffer, 0, recordLength);;\n+            capabilities = SSLExplorer.explore(buffer, 0, recordLength);\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLSocketExplorerFailure.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-        capabilities = SSLExplorer.explore(buffer, 0, recordLength);;\n+        capabilities = SSLExplorer.explore(buffer, 0, recordLength);\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLSocketExplorerMatchedSNI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-        capabilities = SSLExplorer.explore(buffer, 0, recordLength);;\n+        capabilities = SSLExplorer.explore(buffer, 0, recordLength);\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLSocketExplorerUnmatchedSNI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-        capabilities = SSLExplorer.explore(buffer, 0, recordLength);;\n+        capabilities = SSLExplorer.explore(buffer, 0, recordLength);\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLSocketExplorerWithCliSNI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-        capabilities = SSLExplorer.explore(buffer, 0, recordLength);;\n+        capabilities = SSLExplorer.explore(buffer, 0, recordLength);\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLSocketExplorerWithSrvSNI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,3 +24,1 @@\n-import javax.net.ssl.KeyManagerFactory;\n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.*;\n@@ -28,0 +26,1 @@\n+import java.lang.reflect.Field;\n@@ -34,0 +33,1 @@\n+import java.security.cert.PKIXBuilderParameters;\n@@ -35,0 +35,2 @@\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n@@ -36,0 +38,1 @@\n+import java.util.Date;\n@@ -37,4 +40,32 @@\n-\/\/ A template to use \"www.example.com\" as the server name.  The caller should\n-\/\/ set a virtual hosts file with System Property, \"jdk.net.hosts.file\". This\n-\/\/ class will map the loopback address to \"www.example.com\", and write to\n-\/\/ the specified hosts file.\n+\/**\n+ * A template to use \"www.example.com\" as the server name.  The caller should\n+ *  set a virtual hosts file with System Property, \"jdk.net.hosts.file\". This\n+ *  class will map the loopback address to \"www.example.com\", and write to\n+ *  the specified hosts file.\n+ *\n+ *  Commands used:\n+ *  # Root CA\n+ *  > openssl req -new -config openssl.cnf -out root-ca.csr \\\n+ *        -keyout private\/root-ca.key -days 7300 -newkey rsa:2048\n+ *  > openssl ca -selfsign -config openssl.cnf -in root-ca.csr \\\n+ *        -out certs\/root-ca.crt -extensions v3_ca\n+ *  -keyfile private\/root-ca.key -days 7300\n+ *\n+ *  # www.example.com\n+ *  > openssl req -new -keyout private\/example.key \\\n+ *        -out example.csr -days 7299 -newkey rsa:2048\n+ *  > openssl ca -config openssl.cnf -in example.csr \\\n+ *        -out certs\/example.crt -extensions usr_cert\n+ *  -keyfile private\/root-ca.key -days 7299\n+ *\n+ *  # Client\n+ *  > openssl req -new -keyout private\/client.key \\\n+ *        -out client.csr -days 7299 -newkey rsa:2048\n+ *  > openssl ca -config openssl.cnf -in client.csr \\\n+ *        -out certs\/client.crt -extensions usr_cert\n+ *  -keyfile private\/root-ca.key -days 7299\n+ *\n+ *  The key files should be in PKCS8 format:\n+ *  > openssl pkcs8 -topk8 -inform PEM -outform pem \\\n+ *         -in private\/example.key -out private\/example-pkcs.key -nocrypt\n+ *\/\n@@ -43,1 +74,1 @@\n-    \/\/ Serial Number: 15223159159760931473 (0xd34386999cc8ca91)\n+    \/\/ Serial Number: 4097 (0x1001)\n@@ -45,1 +76,1 @@\n-    \/\/ Issuer: C=US, ST=California, O=Example, OU=Test\n+    \/\/ Issuer: C = US, ST = California, O = Example, OU = Test\n@@ -47,4 +78,6 @@\n-    \/\/     Not Before: Jan 26 04:50:29 2022 GMT\n-    \/\/     Not After : Feb 25 04:50:29 2022 GMT\n-    \/\/ Subject: C=US, ST=California, O=Example, OU=Test\n-    \/\/ Public Key Algorithm: rsaEncryption\n+    \/\/     Not Before: Feb 25 20:12:04 2022 GMT\n+    \/\/     Not After : Feb 20 20:12:04 2042 GMT\n+    \/\/ Subject: C = US, ST = California, O = Example, OU = Test\n+    \/\/ Subject Public Key Info:\n+    \/\/     Public Key Algorithm: rsaEncryption\n+    \/\/         RSA Public-Key: (2048 bit)\n@@ -52,1 +85,1 @@\n-            \"\"\"\n+        \"\"\"\n@@ -54,18 +87,20 @@\n-            MIIDXDCCAkSgAwIBAgIJANNDhpmcyMqRMA0GCSqGSIb3DQEBCwUAMEMxCzAJBgNV\n-            BAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRAwDgYDVQQKDAdFeGFtcGxlMQ0w\n-            CwYDVQQLDARUZXN0MB4XDTIyMDEyNjA0NTAyOVoXDTIyMDIyNTA0NTAyOVowQzEL\n-            MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEDAOBgNVBAoMB0V4YW1w\n-            bGUxDTALBgNVBAsMBFRlc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB\n-            AQDnOL2hB\/GYyYziXo\/ppxi7V1LfMMLeHt0lZbYlrmNxUlln4naI4B4Lkg75eb1Y\n-            DgC7MZQd5nKijK9Dkq52Z2zLxaqBYnLxKJ36qKPqbtTL3I8mfUvVEeNIDN\/8YTAt\n-            suIEQi54dNtQVrB4YReMdnUq+xCKLAfEio4QLEQr7KtyCBXHZpM7RYRT0giQFvDU\n-            2kls9lFLeqKXgocnA7VpoL0V12hpxDeJoRm1szf0M5YXGJumQLaE5qM\/+P2OOhw\/\n-            T+xkupy2GF02s6FBXkH7NrFIjtuBSaVhSvCG\/N7njWSn339thr3kiPEaCS4KSH5E\n-            E6FEazxZQrTCbkQQ+v3y1pS1AgMBAAGjUzBRMA8GA1UdEwEB\/wQFMAMBAf8wHQYD\n-            VR0OBBYEFMFw2FWUvwZx3FJjm1G9TujCjAJSMB8GA1UdIwQYMBaAFMFw2FWUvwZx\n-            3FJjm1G9TujCjAJSMA0GCSqGSIb3DQEBCwUAA4IBAQCJsJjeYcT\/GtKp64C+9KCi\n-            Vgw\/WnBZwbosSFZmqyID8aAnAxaGMkZ2B2pUZHTtCkBf6d9c0tuWb5yF8npV77sE\n-            bZqeNg2GU7EvH3WPgPbQVT7+Qb+WbY3EEPgJHLytch61Rm\/TRQ3OqD0B+Gs7YjAU\n-            fEspmk1JJ6DWuXX13SHoGWgVnO7rXBnCJaGnGpONtggG4oO5hrwnMzQZKh5eZDhC\n-            7tkNPqVDoLv+QqnFk8q6k8hhxnVf+aw56IdsebN+9Bi+Lv6OQ+stKUo\/u\/RTW2z1\n-            odCOwc8DPF3jbacJsOmLhl3ciuWGOckx9KCvaBeTTgkPdLQH1gpNha2tnqgxUXmC\n+            MIIDtDCCApygAwIBAgICEAEwDQYJKoZIhvcNAQELBQAwQzELMAkGA1UEBhMCVVMx\n+            EzARBgNVBAgTCkNhbGlmb3JuaWExEDAOBgNVBAoTB0V4YW1wbGUxDTALBgNVBAsT\n+            BFRlc3QwHhcNMjIwMjI1MjAxMjA0WhcNNDIwMjIwMjAxMjA0WjBDMQswCQYDVQQG\n+            EwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEQMA4GA1UEChMHRXhhbXBsZTENMAsG\n+            A1UECxMEVGVzdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAKOGhEDj\n+            lZ5R6o20kJdgrIRcY1he4qKLWQ4vU0thqAg4mEcKCZZn4\/NL05UgJCFLwYaxMZZe\n+            etb\/WaTRvQpDDFh7AhsMR24m6zKKJVk9E\/e\/8ur7sGDIVq8hZOBTq85ZdxPj\/zKW\n+            wB1BR\/RcY4DsGno1USlkV7TVeZc1qpJHTPImesevzH7zX8nhnFlf4TTQbpQt6RxU\n+            cr+udWpMOyP9xMerIyp7jpPy79tIaGP2x7ryt2BB9FU4RwPk4DcdfOkmdS86md1c\n+            GI9H5qM5rUzyqey0J8wMRLj+E0Vx0F1XELZeTtyulbIbhrBhu\/KOXZG2zNIeK+2F\n+            XxDlx9tD+bbcJfUCAwEAAaOBsTCBrjAdBgNVHQ4EFgQULjM9fwJnC3Tp1QYM8HNL\n+            y60btl0wbAYDVR0jBGUwY4AULjM9fwJnC3Tp1QYM8HNLy60btl2hR6RFMEMxCzAJ\n+            BgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRAwDgYDVQQKEwdFeGFtcGxl\n+            MQ0wCwYDVQQLEwRUZXN0ggIQATAPBgNVHRMBAf8EBTADAQH\/MA4GA1UdDwEB\/wQE\n+            AwIBBjANBgkqhkiG9w0BAQsFAAOCAQEAR0Mk+2X\/rr4kYYfHsQUIsROwDZSQhQr3\n+            QOeLc7fyTjkM96OHXN2dKVoOcpzgKi1goHW7lh8vVmKRQk2wfFqRZV9\/kQBFK\/gz\n+            QtN5gp+pA8Wk912Uj5gD0loiPcRf5bDElvLnr2iwt4VdKkvGIYa9Eu9CYbkf1x3t\n+            ahVLmrZLBkqvKxo4MG4KGYXkqtII3M6clM4ScFa\/0rR1nGZOgZyqG7AMMHc01csA\n+            oLlEZx2hUcpJbz+sfCGUWYaF2uKJvuWMNFbGSDhfs8pOMGgelMOHaKVtgOEfEASN\n+            TSqzqn0vzjJ78Mi6mN7\/6L\/onDKzROxClw0hc6L+PIhIHftD1ckvVQ==\n@@ -74,27 +109,29 @@\n-            \"\"\"\n-            MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDnOL2hB\/GYyYzi\n-            Xo\/ppxi7V1LfMMLeHt0lZbYlrmNxUlln4naI4B4Lkg75eb1YDgC7MZQd5nKijK9D\n-            kq52Z2zLxaqBYnLxKJ36qKPqbtTL3I8mfUvVEeNIDN\/8YTAtsuIEQi54dNtQVrB4\n-            YReMdnUq+xCKLAfEio4QLEQr7KtyCBXHZpM7RYRT0giQFvDU2kls9lFLeqKXgocn\n-            A7VpoL0V12hpxDeJoRm1szf0M5YXGJumQLaE5qM\/+P2OOhw\/T+xkupy2GF02s6FB\n-            XkH7NrFIjtuBSaVhSvCG\/N7njWSn339thr3kiPEaCS4KSH5EE6FEazxZQrTCbkQQ\n-            +v3y1pS1AgMBAAECggEBAJQAKLkTWZx\/njMjbiCT+Wuo6H2+O21r+ge\/BAk4h6R4\n-            nou1VEQmmHS1h+o992mOhP9NK867vDK5tFGfaRaW+vevzYTF3GbqpbxVB56+VG0s\n-            \/2AWoVx\/96gdvZ1RJEKMFsm9BvvJaLwS0SAsnaMmC7d4Ps0Cg\/JU8bv+aaBn\/BGf\n-            TWiofYWeUk6llco4kO9H2APxUVzlaUUU\/cPAJqX7XktnhDCI9\/esuVg7nVR0XxOF\n-            GDrV\/jdqSYmSbp4aTRXgI9nwxOmlKiGgevTrCUXl3\/KaJxZekllVjushY1VVzgbY\n-            K5R4bcN5MXMmFdgF9DTEW72RqEfg9iXqyhYbZp3Q\/UECgYEA\/yiaJd0w2HS22HSg\n-            o4dJ072WbyR3qUqQmPbSUn9hBQTJAz1eX3cci8u4oawo\/S+jN38b\/DfpSg3eIMLB\n-            vnXW3wZtodpJnFaweKd3yUaSF2r9vZRHJgfPfe67VbruEOF6BsCjTq\/deGeNnGeH\n-            \/IDVn9WtSeRX\/bv\/s5YHvGaHGGUCgYEA5\/vugmilOBq979EqksCG\/7EQHSOoEukO\n-            J\/aunDyEwz+BMEHOEW7tDMUefdiSfnGXSW+ZTmpmvc+aLk37Xuo34jpugK5ayUFY\n-            iYVgiqdnygGiBevBM2o0O\/parQkAGEB8GPButrYItUzubUgXnuw+EdMiXGnpjJaK\n-            S3dPYJEHvhECgYEAjqIIwV\/LPUTJLWjMn30yBN43KLvu9ECNYiSfX6R6\/I43O8tj\n-            ZOQ1nePsutt9MkMd7xjr8OrkSxRDdnbITQqcaaGzSUW33mALV\/btnCMJ6XNSklZA\n-            C39UOuZn7D2JdQBF8V5gK81ddUAVxjeNqdXvFOEidGrj0R\/1iVM10dhSbo0CgYBk\n-            P8GtR02Gtj+4P\/qW2m48VqbxALSkH2SHrpl8WMbCnVHVqcpETFxSNWjc11dPHwVS\n-            rdBhS6fEhM9LDVYAiVTHBZs1LqN67ys0mpfCs18ts5Dx4BRohI+4D5NZzVbmJA+8\n-            s0IU4QtYVbt\/LDVQ7yRPjZ7+sqJDp9ZxkEiUIXhoEQKBgQCPG2f8BhsCYNAOV60F\n-            hJVjhDdf59Mia3B2J9SSnrg6Tl2rWB7GPP19TiSPFS6Sn95mWrMjZ2ZuOXtCYV4H\n-            +hmu87AV2CXFhW5c588cajXMT92GFVMSXdE1OHRzDjhpH+\/ll8SnmQa7sXmEV36+\n-            sawd7mwcB9IEi562wglADxBUCA==\n+        \"\"\"\n+            MIIFHDBOBgkqhkiG9w0BBQ0wQTApBgkqhkiG9w0BBQwwHAQIn\/uWtEzLDK8CAggA\n+            MAwGCCqGSIb3DQIJBQAwFAYIKoZIhvcNAwcECIk7+JC4ErMDBIIEyA3yvNhMm\/Oj\n+            ZdkN0HSzPyLv9bOfUyyx4NA121kizZIq\/FkUjn8pGxzU63rzMk2vU1hmp2\/O3ymr\n+            vmV7gzXRp4ULZCjFwn4cLxi9ieKgBOr9MmgTlRc1oZ9P\/Y8eWhmjGxA2CU3fy7Kv\n+            DyzftqAetV8YzTelk8xqxLrGevB16O3zDbFj4dcmG7a0i75kqlI8QyQklJ9uyE10\n+            SELWFlV6w+3GD82YrbR\/8v4fE5KP\/nAPbtN4h4C7MY3kJQL+apHr5B3Jst+6N62t\n+            JzmxGS5z3ZVT3Bn3mxi8awo8\/XS8s+ZOSnH6nHvz83NBUQwSkVbtujlg+yMD2jg4\n+            Nt3LWfLnF8Q6n4oAQ1ZP9KJyVIh8+PN12txIRoWq1pF74hJmbfVfiCSR\/tMrw6lr\n+            XqlkG1Mi7RmpTCz9ScTUBWY\/dyScYFITenv\/WE+UnfQ+DXBC+78lkmL36M0Rx\/ip\n+            S4O1Tgy\/z\/MIv1s+ZpAFsRRczlpo9lbVEMuSGEWWTIQJCRPFV8Y1NKHmWUgeZpl3\n+            2YUjpHNyQt\/a1s1h1g5w9+UNuABt\/3cUUnlA7psueb6l4x6M92QFBOpe1xUDL51D\n+            RpaipVl1luFWvE84hqgCIv8Kh9EbkAlclmK8CIOkMQAabk0GmhCfEdm+PCW61Cao\n+            rfCMwZ9Bx6zAcXGRrvl0sK35z8C3r8wLftaS\/5xF6RTJBy6XY2iiFW6D44qZDFbh\n+            0rWV8zDtCf2+OZtEvPkeUn3sjevDW78TM6F7HBjXAeIFrNyJGVe2CTlEJLoZi5pX\n+            W1blhMJ93N1mLiDYisILANmJRBfGMt0tYE\/pGcJRlkuqG0qylnqRojjL83CTQvFy\n+            46q\/obR36enRDvCZPvQrX2dB7Vkgpkz\/drZ6+avmKdQcTjY\/ycCd3DclwexhgUoX\n+            QDntZuJQLp7C4tFfHRy2uh4DOEjzMP6a\/NQ3q7p6vc6BTNTFZRUAdyNwcEDIzSLM\n+            nZSPFBiz+gukhtNSCO28kLc8OX1hYsSAMgzbImcMtAiQHG3bFAJ0cs0jF4U9VrJt\n+            4\/97kiDBuCgGb2b5t0+uDqipE6G4B6494IGm5KoIPAPbXMJQstmuzjTJt95UTF+p\n+            e60AnWIXcvEOouIIMzC7gH2g23St5Bo6NixfxcmVfkFa92TDlCTxEz5Z5mnma06k\n+            Pao4Km1eJkYS\/QaCDnCZs\/yCAMhINUTTDd0\/7Y9YE3Dmd5B1s2wOa+ovESSL3Mdv\n+            dZoxh91QR+6hQuz3iYztC\/BszMtATH8MznAoco0QFAhKi56Wppe+p1ATLWFMqk4W\n+            elX9vtw5XLucKy5cMkQYh144SnrerlPJTAOGy0XXKunj8ceZfEN6zcS9Us9IN5aF\n+            iENMFHjPsscrrKFhKypaMIn67PuIhVhw4PnGrWejr6TM1gUx+zOcRCwT+5ka2L7U\n+            aqmgS8cDg5ZfAHcbig7No9kku\/OSk+5QzkVKca2TZQHm++60oQTzRl3\/NWiELO+e\n+            Sl6r8i7dS0Kv3bB\/AbLfIHtDgebxUh78qXMel\/OUWd58ezxBS74rZ4AQTpYcdTbR\n+            jKHploWi8h5yXYn\/YdEZG1vW\/zYseFNb7QKT5Cznucl8O\/+lNZIOVw63Pq368dTD\n+            tG1GZkIlwM+jlJjRew05YQ==\n@@ -104,3 +141,3 @@\n-    \/\/ Serial Number: 14845986384898254166 (0xce0789f5ac256556)\n-    \/\/ Signature Algorithm: sha1WithRSAEncryption\n-    \/\/ Issuer: C=US, ST=California, O=Example, OU=Test\n+    \/\/ Serial Number: 4098 (0x1002)\n+    \/\/ Signature Algorithm: sha256WithRSAEncryption\n+    \/\/ Issuer: C = US, ST = California, O = Example, OU = Test\n@@ -108,4 +145,6 @@\n-    \/\/     Not Before: Jan 26 04:50:29 2022 GMT\n-    \/\/     Not After : Feb 25 04:50:29 2022 GMT\n-    \/\/ Subject: C=US, ST=California, O=Example, OU=Test, CN=www.example.com\n-    \/\/ Public Key Algorithm: rsaEncryption\n+    \/\/     Not Before: Feb 25 20:31:29 2022 GMT\n+    \/\/     Not After : Feb 19 20:31:29 2042 GMT\n+    \/\/ Subject: C = US, ST = California, O = Example, OU = Test, CN = www.example.com\n+    \/\/ Subject Public Key Info:\n+    \/\/     Public Key Algorithm: rsaEncryption\n+    \/\/         RSA Public-Key: (2048 bit)\n@@ -113,1 +152,1 @@\n-            \"\"\"\n+        \"\"\"\n@@ -115,19 +154,19 @@\n-            MIIDjDCCAnSgAwIBAgIJAM4HifWsJWVWMA0GCSqGSIb3DQEBBQUAMEMxCzAJBgNV\n-            BAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRAwDgYDVQQKDAdFeGFtcGxlMQ0w\n-            CwYDVQQLDARUZXN0MB4XDTIyMDEyNjA0NTAyOVoXDTIyMDIyNTA0NTAyOVowXTEL\n-            MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEDAOBgNVBAoMB0V4YW1w\n-            bGUxDTALBgNVBAsMBFRlc3QxGDAWBgNVBAMMD3d3dy5leGFtcGxlLmNvbTCCASIw\n-            DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAK\/i4bVSAF6\/aFHyzrFAON8Uwn2a\n-            Q9jFoAMowUkH6+PCexlt4wCOEMVH9IQPa1yzeVlkYRqHggz3i6aVYvd27Q+c6vOF\n-            FuRegWdJusyEuoXd5nwxSGiZZMLmFQswODSPmucroCG+Tq9RKY5oEKiRP8tUDqyn\n-            eE52PaeSR2Q6mng7BM5Llj7amVgimO3jlH2AWLLpHNTkc3j\/M1QrLFV2PqN4dpxT\n-            OeFuVWzpfTWJSH+9Kq4u\/zBMbYl8ON7DSgJAzc2BOw8VPIYIK6JIw6IDbLn4dIQf\n-            GikdgHKB2K6EDOc9LuX6UqQQODDFU88muAyPgpGfUQjxKZeUoTqoAFyisI0CAwEA\n-            AaNpMGcwCQYDVR0TBAIwADAdBgNVHQ4EFgQUQqf\/4nqluVMZ8huD3I5FNqLXTqAw\n-            HwYDVR0jBBgwFoAUwXDYVZS\/BnHcUmObUb1O6MKMAlIwGgYDVR0RBBMwEYIPd3d3\n-            LmV4YW1wbGUuY29tMA0GCSqGSIb3DQEBBQUAA4IBAQBl8FJD98fJh\/0KY+3LtZDW\n-            CQZDeBSfnpq4milrvHH+gcOCaKYlB9702tAQ6rL1c1dLz\/Lpw1x7EYvO8XIwXMRc\n-            DZghf8EJ6wMpZbLVLAQLCTggiB65XPwmhUoMvgVRVLYoXT3ozmNPt7P+ZURisqem\n-            0\/xVVfxqmHw9Hb4DNlc7oZDgOK7IrqriaBK6Amsu3m2eThsvkwTdJfeFG3ZdV6x5\n-            mbaGZDMt\/wgWIqyq5CZNpXPaFRH7KM4zhcoqXvFAoq9jxWOuBkJUUx5EHaxGhhPw\n-            SMgE1yl4O+N7GJmF\/WMR5zp2LGKMqJ3vwLPv6QNkUmLwB5ZLYJ8E2dpj6DjQWa7X\n+            MIIDaTCCAlGgAwIBAgICEAIwDQYJKoZIhvcNAQELBQAwQzELMAkGA1UEBhMCVVMx\n+            EzARBgNVBAgTCkNhbGlmb3JuaWExEDAOBgNVBAoTB0V4YW1wbGUxDTALBgNVBAsT\n+            BFRlc3QwHhcNMjIwMjI1MjAzMTI5WhcNNDIwMjE5MjAzMTI5WjBdMQswCQYDVQQG\n+            EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEQMA4GA1UECgwHRXhhbXBsZTENMAsG\n+            A1UECwwEVGVzdDEYMBYGA1UEAwwPd3d3LmV4YW1wbGUuY29tMIIBIjANBgkqhkiG\n+            9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3crcRzecIV08Muh6kA0CuVKnPkU2bLC+6bpV\n+            7\/iBZ4D3qMwO8Q02+gP71pPNoAQ1nsifxR4k9mBVYOjar35RVpuFmLRRVMargrxg\n+            4WWDfVgLMhOeCy8+Tl4Mp\/yRL3nkr0MJd57RCOPcPE84J\/1Crq1Luy2+hsXSj25L\n+            VJKx2o6LE0tfwPWnufdNUHzHRuNoBR83OpqIT0uXH15THZS+0ZcQwrJMcKYe4JWl\n+            6oXWcsWbtTG+r7QLIRKck2IG7jjHFpE83Q6Iv2HkhctgGZofwSTZyMmJ8eClovva\n+            WFLDaLL2WuI3NwZM\/\/knjMyfsEWtWsILXayCn5NTT74ClQjWQQIDAQABo00wSzAJ\n+            BgNVHRMEAjAAMB0GA1UdDgQWBBQ9nPjenO4PMLtMTBddNiIDsPywjzAfBgNVHSME\n+            GDAWgBQuMz1\/AmcLdOnVBgzwc0vLrRu2XTANBgkqhkiG9w0BAQsFAAOCAQEAVOvM\n+            fMDOxOCkWB244cx7J+f2qZU6\/1qGlJUiL0WRLRj1XEmB8AYSZEb6Os1suF8sotka\n+            nA9Aw1SFA\/wNyrSKazXNlOKo0In1mu\/OjHU7n6XYVAyDmFGziYY8zTqG1h8ZPrI7\n+            oAkNgnNDwmwy7uCAvMj+Q4QQ0Q4YxTHV\/i3X1HuEwThRgz9cJGdDRIAsimRHDSDO\n+            5hsIJo6VASz0ISrYMxNZQ1og+XktdNssPK616bPf+APwXXnsWSuGkIdGDU059DII\n+            cTSsLTbWkTWDXAAQo+sfDZUrvqopCK000eoywEmPQrTf7O8oAQdRvTsyxwMvOONd\n+            EWQ9pDW9+RC8l5DtRA==\n@@ -136,27 +175,27 @@\n-            \"\"\"\n-            MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCv4uG1UgBev2hR\n-            8s6xQDjfFMJ9mkPYxaADKMFJB+vjwnsZbeMAjhDFR\/SED2tcs3lZZGEah4IM94um\n-            lWL3du0PnOrzhRbkXoFnSbrMhLqF3eZ8MUhomWTC5hULMDg0j5rnK6Ahvk6vUSmO\n-            aBCokT\/LVA6sp3hOdj2nkkdkOpp4OwTOS5Y+2plYIpjt45R9gFiy6RzU5HN4\/zNU\n-            KyxVdj6jeHacUznhblVs6X01iUh\/vSquLv8wTG2JfDjew0oCQM3NgTsPFTyGCCui\n-            SMOiA2y5+HSEHxopHYBygdiuhAznPS7l+lKkEDgwxVPPJrgMj4KRn1EI8SmXlKE6\n-            qABcorCNAgMBAAECggEBAJb2SvfP7BVmf+lmV9V249lE\/jHECFu0M8TCZDOEowiX\n-            0gRfdqjxRp+tRMdcXK\/yM0Nwjo+wowTyK2DNc2YnIw11h4uAPcfA\/ZxjgfssKNPh\n-            Q4Rw4E826W8HACTcPEGQyEmF\/ik4KFz9coeR9kpYcMLZ4MZ77xyZDA4Z1UDHs\/Fg\n-            egrd4k35fxIFOavsjNuekMIjZlyQ2xU1a11QDBrZAu\/pjITXXulg4jCxLbeNOOPs\n-            hH+Sx+jnsVV7qIBNwulzxEdpb3+NkWIMmOQK4HOSeHgjRVvSXXBPgYadMaP\/Bzvx\n-            AwJ9WeLZg7KWHE03aOc7CSMoyHfmhXx3gD8icGpSq8ECgYEA3TWGBSgny\/wket+V\n-            65ldWjp4NOKHbLPtBdL9ygIO+1bGfLl5srCxUWHBYdcWCXKuB5ALCBu0hMY+TlwF\n-            s\/BzZmvVW7RLAEZZ3Q5HpawDlr9j8Kenm4X2Mqh0MSkmwIDRDHF8jRXAvWIzcBiS\n-            +rPZm2CMZpznUSE4X+GrvTSCBbkCgYEAy4yJ58wNUavj\/tR8KySn5ygPABFZ1Uoy\n-            pIyabm18Oe3gCl5UulBskoN0WreTKnA4r9jGlnrgeuu5WfMK53AZKbC+YduZixW4\n-            QFuJBSMbFCBDt4nkhkMMR7VcV4jIqaOK7qNrs7ubGTZhsG8wj6\/WWdCp3Avnx1rS\n-            WCCoYNhAK3UCgYADaLnCBpZmbGJbimqTEPABXflQR1Vy9WrnthK3NETq1rGEZo9b\n-            k6GH8Yu7aEcsqhnIgA3LeDHWAgAf0Qc9eK0unObS3Ppy7KKh54BvKzF690QhB1Rr\n-            7yqWKUZxI4M3YETYfj8\/JWCtCoBkb9yEBJWL8Xb4dd6Sv4JQ5\/dvmQmP8QKBgBX+\n-            5+Aeksnik060U36uBV7bW1OcjGKaFALoFsAcILJ53B4Ct5Eyo6jpf6dV8xdA7T9D\n-            Y6JbQOrHkk4AD4uW94Ej0k7s1hjLjg+WVKYzdvejzO2GfyVrFWaiWIo1A8ohHCBR\n-            lI\/llAsTb1cLjOnaDIXEILbgqnlGfTh8vvVIKRcJAoGALF6Q1Ca2GIx4kJZ2\/Az5\n-            qx89q95wQoWVHcJCA91g\/GKg\/bD0ZJMWEhhVH3QcnDOU7afRGKOPGdSSBdPQnspQ\n-            1OPpPjA3U5Mffy5PJ2bHTpPBeeHOzDO4Jt073zK3N81QovJzS8COoOwuGdcocURH\n-            mFMnEtK7d+EK1C1NTWDyNzU=\n+        \"\"\"\n+            MIIEwAIBADANBgkqhkiG9w0BAQEFAASCBKowggSmAgEAAoIBAQDdytxHN5whXTwy\n+            6HqQDQK5Uqc+RTZssL7pulXv+IFngPeozA7xDTb6A\/vWk82gBDWeyJ\/FHiT2YFVg\n+            6NqvflFWm4WYtFFUxquCvGDhZYN9WAsyE54LLz5OXgyn\/JEveeSvQwl3ntEI49w8\n+            Tzgn\/UKurUu7Lb6GxdKPbktUkrHajosTS1\/A9ae5901QfMdG42gFHzc6mohPS5cf\n+            XlMdlL7RlxDCskxwph7glaXqhdZyxZu1Mb6vtAshEpyTYgbuOMcWkTzdDoi\/YeSF\n+            y2AZmh\/BJNnIyYnx4KWi+9pYUsNosvZa4jc3Bkz\/+SeMzJ+wRa1awgtdrIKfk1NP\n+            vgKVCNZBAgMBAAECggEBAMUMAtJe7J6Tx\/TuqF0swfvGHAHt2eGM0cCzpMATh1xe\n+            rylPSgMNG4faXDcSj4AX3U+ZrKCjHHGruo7jsc5yqm8IsxOtOAjajOwU0vnNh5mn\n+            zCKMXUBQk8lqM1JXyOFmKS8wnsug1NRSJIuMUjbtAf5QxlSg2oHAZUa61cBoqAyk\n+            KXbw9uBYnM4n8WGXdax\/LLPuonjnz2Sc35CC1LhRAF\/K7oyjg7KvScnphIFRaLiU\n+            X4tFH0nLpcao5de0fP5eUEkbUZ3hE6MEZvOsxn5CFkjH2VdtZ9D5dc3ArV3UMe26\n+            +3swdenriYZ73HNJDiLAdeIVh9IrGVxhH9UowF9psIUCgYEA\/Ldlx4vTTlM7URFn\n+            luqK7D8WH9x4JiCLEGxU80nJxxIgF8eqhOFzsQemytTrf4o1xAkyyPIweHzwApCA\n+            lBdwC4Mc44DjoLFVdTET9hEq7E\/UK81znc0mD4v8Hz2JI6h3f2sQrcEAPBvjBwtc\n+            TpS9WlSBKSO3NOb3Hlucq7COVKcCgYEA4KyZ+dOyKVLyGjd0g22v4YW7VC016Hql\n+            uQ7SN1vuI3zQMa2rZfEv5z2L7olJKrDFcmqk8W1tfElrMaSsuohm8khhx0lPtHMw\n+            4Su\/tci\/3rEUl+DPrQExdjrrDXCqpUunOAlMP9qElsNBGdkrQ6QlMnSVVi2v8Vf1\n+            f86Mey2UEtcCgYEAqcOlmqPigfZFnZLcjLPoOQW0HhkjmTE5WgH8GybRZmpVpsPZ\n+            V8R\/zEeAkzbvMFEvBw7Kz9RqHTaIoKBjz5fjC8i7ClVWFGesKbqbVyx3MiH6PKaa\n+            aUIbtEvsRSw4SPztsWnB3YcOWlK9csj97Efc36Zu0a0NcHtLPFh8aZWEN3cCgYEA\n+            oQFv8oWPlmeXkcwN1iWjtfT1EtS3XhuOaXjCkuNxW8MVG5S+UHawAoGrpsyBP3Og\n+            e2cLPuxRWpDunYvKMH6Rb60JTRwvXzxxWdvVLbtoLHkwLcrwaKWDQZvlWCNWVtBJ\n+            TDH1j4jUHYpdO93SUE3wTiEX58Mj48tJ5kYpjBhUlc8CgYEA7PG3ORGqZtfCiNmj\n+            CxvPtQiFC+ogf+v8cMQtrKVTgpnI2pxzG+cSXYvL4cnyY2JnwqarWorUic8JU2e2\n+            EhW53PWUg7VpITlLsqOpATIDiviFAN4qOOxgDt5v0C1PyB3aXe2B5VA3IgczssyR\n+            OLy7p\/DhOpu2bqnpKyIkAuzZgFc=\n@@ -167,3 +206,3 @@\n-    \/\/ Serial Number: 14845986384898254167 (0xce0789f5ac256557)\n-    \/\/ Signature Algorithm: sha1WithRSAEncryption\n-    \/\/ Issuer: C=US, ST=California, O=Example, OU=Test\n+    \/\/ Serial Number: 4099 (0x1003)\n+    \/\/ Signature Algorithm: sha256WithRSAEncryption\n+    \/\/ Issuer: C = US, ST = California, O = Example, OU = Test\n@@ -171,4 +210,6 @@\n-    \/\/     Not Before: Jan 26 04:50:29 2022 GMT\n-    \/\/     Not After : Feb 25 04:50:29 2022 GMT\n-    \/\/ Subject: C=US, ST=California, O=Example, OU=Test, CN=Do-Not-Reply\n-    \/\/ Public Key Algorithm: rsaEncryption\n+    \/\/     Not Before: Feb 25 20:33:59 2022 GMT\n+    \/\/     Not After : Feb 19 20:33:59 2042 GMT\n+    \/\/ Subject: C = US, ST = California, O = Example, OU = Test, CN = Do-Not-Reply\n+    \/\/ Subject Public Key Info:\n+    \/\/     Public Key Algorithm: rsaEncryption\n+    \/\/         RSA Public-Key: (2048 bit)\n@@ -176,1 +217,1 @@\n-            \"\"\"\n+        \"\"\"\n@@ -178,20 +219,19 @@\n-            MIIDkjCCAnqgAwIBAgIJAM4HifWsJWVXMA0GCSqGSIb3DQEBBQUAMEMxCzAJBgNV\n-            BAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRAwDgYDVQQKDAdFeGFtcGxlMQ0w\n-            CwYDVQQLDARUZXN0MB4XDTIyMDEyNjA0NTAyOVoXDTIyMDIyNTA0NTAyOVowWjEL\n-            MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEDAOBgNVBAoMB0V4YW1w\n-            bGUxDTALBgNVBAsMBFRlc3QxFTATBgNVBAMMDERvLU5vdC1SZXBseTCCASIwDQYJ\n-            KoZIhvcNAQEBBQADggEPADCCAQoCggEBAODbsCteHcAg3dktUO5fiPTytIahKZMg\n-            U2h6h0+BT803tYcdN6WDHnLNlU\/3iFnBMpyTwzWhYIftC9c\/TIkXBAGfWl4HHQgc\n-            x08NHPms0E+GF6CDthvHERSvRCBrIyVna0KIZPemBzUfeBeNdiqwsLvg+C5dqWu5\n-            YcILvL6GzTMvdMwJeEX+c2ZYHibqd8aZydWsT+IPVZnueDX6KTOnYvexLFIoid2a\n-            62FavnMWiPKnICertDDg+gHlN2XceW3tlYQwO+HMig4DH3u2x0SApOoM3y8k29Ew\n-            Fn6wquSRomcbDiI8SEOeaBFenu6W0g24iaxIZfqEM52kPbQFdzqg+O0CAwEAAaNy\n-            MHAwCQYDVR0TBAIwADAdBgNVHQ4EFgQU0t+I5iAfPq6C\/I2CSvTKHGK6+2kwHwYD\n-            VR0jBBgwFoAUwXDYVZS\/BnHcUmObUb1O6MKMAlIwIwYDVR0RBBwwGoEYZG8tbm90\n-            LXJlcGx5QGV4YW1wbGUuY29tMA0GCSqGSIb3DQEBBQUAA4IBAQBqWk35XXpb3L+N\n-            7kPlNmSlhfamenVOVYxPBq\/tSFpl728CV0OrGAy79awEFDvzhpbBg9Mz7HS\/a7ax\n-            f+lBbsAt1maWlsVSsaaJrmy3znl9CZiIg+ykZ5ZzLS5FkIbQ6LkzvxYZJ1JYCzXm\n-            P\/5+rbQyIvQaDGL23PmE7AB2Q0q+imt4b9HKs+SnI4XERyj8OF\/kseRtILtP2ltV\n-            r+3XgcBxwyU17CLwsHrjnQ8\/1eGovBKzGAfUXeHBdzOuD3ZemjnqwlzQTf2TAkBP\n-            OuMc8gr2Umc5tMtdiRUFPODO7DG7vB7LKEsJGKWLUtGbR+3S55lIcCF5NFZ\/\/TNZ\n-            4x2GPOJ+\n+            MIIDZjCCAk6gAwIBAgICEAMwDQYJKoZIhvcNAQELBQAwQzELMAkGA1UEBhMCVVMx\n+            EzARBgNVBAgTCkNhbGlmb3JuaWExEDAOBgNVBAoTB0V4YW1wbGUxDTALBgNVBAsT\n+            BFRlc3QwHhcNMjIwMjI1MjAzMzU5WhcNNDIwMjE5MjAzMzU5WjBaMQswCQYDVQQG\n+            EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEQMA4GA1UECgwHRXhhbXBsZTENMAsG\n+            A1UECwwEVGVzdDEVMBMGA1UEAwwMRG8tTm90LVJlcGx5MIIBIjANBgkqhkiG9w0B\n+            AQEFAAOCAQ8AMIIBCgKCAQEA2yJgm3Lthr+97vdEWTb4zaNuLTa\/DkCXdmVNIQk9\n+            kVn2hjZrPc+JghBCaWpohGVTQ+zxplIJXk+QVZ0ePEimE7ahBClz4MlAgMpt1uxy\n+            mYYUAsSZDCaFUI9Cpx1f0BiSWu330196K\/AfRIoT+\/SOZucnpbepxyrt+Az5SKrH\n+            TJR\/OSqeX4XKGPoRI96pKxDOV8pY5\/I9h9yKGuxfufbpOdVODngVLcMKgBAkiD+2\n+            sguEHM+iGLx970+W6yycu1dFY1CAgWLUF3evUxe8avwePgx7lTFXnNueYt96Ny9v\n+            L1o\/WzoBe3z1mTl5Qb\/\/3tYbXn8vdiDYm0dT8wImpDbpvwIDAQABo00wSzAJBgNV\n+            HRMEAjAAMB0GA1UdDgQWBBSXqW\/B1BVjNgowSwa3MBiHMkzp6zAfBgNVHSMEGDAW\n+            gBQuMz1\/AmcLdOnVBgzwc0vLrRu2XTANBgkqhkiG9w0BAQsFAAOCAQEABIMAjT5T\n+            lZDV\/1wmdKCyJQJ7WUjA44N5\/yBGtEmpAJ0VM7\/COnk8lqiYxrk50wK7lt0tiklX\n+            4aLqbAgnDc27z9AQGHOqB69dZprGQT9PsTByjK6i7KPGs30ygyND41j0rju\/GM2e\n+            3xprZbusODENRyL196QV4ai0WVe1hEvv0wTMIcnXYmZHMP8ArdVRHWaDQF6zW0Mh\n+            QbFqklt5W0ZIl2ZmC8z7z2Z6jv\/BYyDo3U96LfdCWsEKxSKiX\/PGHqZu4D3A4VSE\n+            0+fE7cX61kgRdGvZJgFjtYxtfkXd1HlyJ48Dqilzl+rvgvR5XA68zijjN0khPhml\n+            wZhPIOCIaWMZYw==\n@@ -200,27 +240,27 @@\n-            \"\"\"\n-            MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDg27ArXh3AIN3Z\n-            LVDuX4j08rSGoSmTIFNoeodPgU\/NN7WHHTelgx5yzZVP94hZwTKck8M1oWCH7QvX\n-            P0yJFwQBn1peBx0IHMdPDRz5rNBPhhegg7YbxxEUr0QgayMlZ2tCiGT3pgc1H3gX\n-            jXYqsLC74PguXalruWHCC7y+hs0zL3TMCXhF\/nNmWB4m6nfGmcnVrE\/iD1WZ7ng1\n-            +ikzp2L3sSxSKIndmuthWr5zFojypyAnq7Qw4PoB5Tdl3Hlt7ZWEMDvhzIoOAx97\n-            tsdEgKTqDN8vJNvRMBZ+sKrkkaJnGw4iPEhDnmgRXp7ultINuImsSGX6hDOdpD20\n-            BXc6oPjtAgMBAAECggEAKjqX900RoUeK4oKUNHBUtEvwg2g4+pyTjYeVaeULK6tO\n-            uDVQghEB4uWhKQd\/3\/tcmfNWMfhAvMZT9vS4Vvavle5rdkU3upJNDBeWXX2LEaRJ\n-            Q6f4x3a3Sn8v+DamvxuRFUmwTKItsFhcoW+7xYCxcFdrxKlqbATAy0SRCecfGoFw\n-            9pAsFIgIqLGQtV9V9fZWKdXIfLkH3venNImHt0n5pYadl4kZu0gNCmOGRO1MqB51\n-            bdAck3dBg22TE5+sZBIZmCjBAEbrc2RUQu5mAoDs8eeenxBlFYszWZxqM8BkJL5e\n-            SqQkbc18E8Gzdx52xEx6BCLTq0MITKliKX4B2tsQsQKBgQD1DIvt13yg9LlyoiAb\n-            Fc1zzKZQBPRgDUJCGzCPeC6AqbPUjoxvFAHxGNgmJXqAXwsqcs88qlSGAjk6ANAx\n-            fHWUQ3UmkZjGvV0ru3rIPcXvS7isjzm\/cbq1YZua6+ohFl4+hojc\/iyUrOaCd9uY\n-            V2zwrr+A0JJrlev72niEuAtEmwKBgQDq6CaLP79dHqAOIV43+SyX7KdwNkMMWIR7\n-            El6E\/74V0IWOYWFXLmV4sX6BKi0ZBTFZ3wKwMTDqQBYD2\/a7gq43HjzuWu+2dFhA\n-            pCQumMOKNqcNS9NldqoxAiGLxC+JMhGGyf3RO0Ey9gdPnQuje3133Wce8WWaHHv2\n-            lD5BcmzdFwKBgQCCeca7wiPy07s2ZUqxAT\/eq5XWP30a85RW\/IEzsusXyMQepjPy\n-            JPYPuInGbeg3F+QrGuxrQco1fFOaJbq0zq8QXYawHY\/6KfPFCFMM8Y9FpczT3IME\n-            A3tFfo5Kw9hq+6z8n8eZ26BDHXiy+Tysdchksrb20JdVv4LiG+ZVzGT7hwKBgG+b\n-            Bp0IF4JFh6PPBLWxRBeWT2MH1Mkr0R2r945W91fj72BbMeU63Oj\/42u4vx5xEiZx\n-            xxQw+t2AvzTsMAicqOr1CdvxBoz4L+neUnZ1DApBtxKhIPnG7EtGiOuftToIuL0C\n-            gP4EmhB9RbH0mk\/83vqxDUptRGl4+QiJHB76H3DXAoGASGT6tfs1\/92rGqe0COm3\n-            aHpelvW7Wwr9AuBumE7\/ur\/JWAAiM4pm6w7m5H5duYZtG3eWz1s+jvjy8jIPBIkN\n-            RA2DoneC2J\/tsRRNFBqZrOWon5Jv4dc9R79qR13B\/Oqu8H6FYSB2oDyh67Csud3q\n-            PRrz4o7UKM+HQ\/obr1rUYqM=\n+        \"\"\"\n+            MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDbImCbcu2Gv73u\n+            90RZNvjNo24tNr8OQJd2ZU0hCT2RWfaGNms9z4mCEEJpamiEZVND7PGmUgleT5BV\n+            nR48SKYTtqEEKXPgyUCAym3W7HKZhhQCxJkMJoVQj0KnHV\/QGJJa7ffTX3or8B9E\n+            ihP79I5m5yelt6nHKu34DPlIqsdMlH85Kp5fhcoY+hEj3qkrEM5Xyljn8j2H3Ioa\n+            7F+59uk51U4OeBUtwwqAECSIP7ayC4Qcz6IYvH3vT5brLJy7V0VjUICBYtQXd69T\n+            F7xq\/B4+DHuVMVec255i33o3L28vWj9bOgF7fPWZOXlBv\/\/e1htefy92INibR1Pz\n+            AiakNum\/AgMBAAECggEAW0WxWW4AMyzwDnWdWU+FSBm3TUvNPkF3FNBS1NzFcSI4\n+            hWRrPJ6R1sOw9blleSe\/C77IVA89abPYGWDM9C0KR5G89T\/SzSDmJf6qy2dGwF1R\n+            PmnmmWH+CzTwfSzF+KYTZ55QqBDPkTd9vo2Ij1woaAIFyId8RsHBxpyYxESlqGY4\n+            C6IzEqxFQ0obHXasNR+dP4iOWS4ONhxeUHixcrDHxbmoqmHt0WuJwXhlOjxHgr+i\n+            lUPTe5y+Y2B1gVNYrN4KlDTJqJ6lu4n6MFQ46jhfddzTk3uiEOTVWK6nE8Cf0NM7\n+            djTzTcR8xAVpoY5XDlk0aBfEd8Np7TLSjV4vU3J04QKBgQD6scazH\/H9Yu9ZbR7w\n+            EeN\/k7uDDlgahWg8\/93syzdFtSNIRGvdalNMhTfM\/zXaM\/Cl63gvZilWxC+56Uvg\n+            6QC+rBUwzZrm7ryb6hT6Zyoo4w72bw3jGOJ3e2\/bclSLrAcJnL\/1Gq87J3CS16wl\n+            NIHrlOlY8orToEdki+6HaagyEQKBgQDfxZz4Uqsa+jDO\/rEm959+nz2RkaXYu1Ld\n+            DhYONxmlw69\/BbwzOvzr88qKNbd+b+oIK8kpm7Lvpc2\/cuqItTFdehmw+tGhMWYo\n+            XizKCeKeCByFTjXI2\/PEPUHMy0D8M68Tx\/Hq0NbIYqCyzkaamHhXpuJGftxGfd3\/\n+            U0NB4WGOzwKBgQDgnyN7YfcwY1I0XUqoLk8aA2Oy5MpaUQh6B4RwZBENO2T2np\/L\n+            TzZ9zKuX2WAGOB26fMY+KhqGLNjaike7qOpK7eM6zC6sFmMWjGHpj0A+TFwewJi\/\n+            z48zIX2zMbjBQQ05NqLkWdmCdi8u02HiIC78x3thgEiVn\/n4BE1gNXJIEQKBgEdr\n+            dfcXw36\/vZZDWd07CU\/LmUX9u3YaC498MHPnCCuM8lVTSkb7m7\/fNpS4IlGbfJGR\n+            EApUpF6yh6GEFvD9C71u\/AYtd3zAHH\/j1t3BG\/AeXKP7W1U5RmsqtfacJKiaAlYI\n+            6eBtOTAJsop\/Ja+v3DD1laC0Wq+w+orEU2ISgiWnAoGBAK9\/9m3RCYPNYzS\/PQ2B\n+            AgE2FQRuY8FXxHegZo2tBBwIojPeVHO1OoThYVNgiQfW9k27dFkRwXVAtt6Jqgax\n+            fvOby8rWRStXH2qHVyvHicceL7iXs6v2bX20Szsy44eMkoFfAImea6ZdErLdVWvI\n+            fxlYpTIVpBt3Nu2BRJn28ili\n@@ -333,0 +373,4 @@\n+        \/\/ Set the date for the verifying of certificates.\n+        DateFormat df = new SimpleDateFormat(\"MM\/dd\/yyyy\");\n+        Date verifyingDate = df.parse(\"02\/02\/2023\");\n+\n@@ -336,1 +380,11 @@\n-        tmf.init(ts);\n+        if (ts != null) {\n+            PKIXBuilderParameters pkixParams =\n+                    new PKIXBuilderParameters(ts, null);\n+            pkixParams.setDate(verifyingDate);\n+            pkixParams.setRevocationEnabled(false);\n+            ManagerFactoryParameters managerFactoryParameters =\n+                    new CertPathTrustManagerParameters(pkixParams);\n+            tmf.init(managerFactoryParameters);\n+        } else {\n+            tmf.init((KeyStore)null);\n+        }\n@@ -344,1 +398,10 @@\n-            context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+            KeyManager[] kms = kmf.getKeyManagers();\n+            if (kms != null && kms.length != 0) {\n+                KeyManager km = kms[0];\n+                Field verificationDateField =\n+                        km.getClass().getDeclaredField(\"verificationDate\");\n+                verificationDateField.setAccessible(true);\n+                verificationDateField.set(km, verifyingDate);\n+            }\n+\n+            context.init(kms, tmf.getTrustManagers(), null);\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLExampleCert.java","additions":233,"deletions":170,"binary":false,"changes":403,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -352,1 +352,1 @@\n-                    serverException.initCause(clientException);\n+                    serverException.addSuppressed(clientException);\n@@ -358,1 +358,1 @@\n-                    clientException.initCause(serverException);\n+                    clientException.addSuppressed(serverException);\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketSSLEngineTemplate.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -547,1 +547,1 @@\n-            local.initCause(remote);\n+            local.addSuppressed(remote);\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketTemplate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        ModelIdentifier id = new ModelIdentifier(\"test\",\"a\",1);;\n+        ModelIdentifier id = new ModelIdentifier(\"test\",\"a\",1);\n","filename":"test\/jdk\/javax\/sound\/midi\/Gervill\/ModelIdentifier\/NewModelIdentifierStringStringInt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        v = soft.synth.getVoiceStatus();;\n+        v = soft.synth.getVoiceStatus();\n","filename":"test\/jdk\/javax\/sound\/midi\/Gervill\/SoftChannel\/NoteOff.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        v = soft.synth.getVoiceStatus();;\n+        v = soft.synth.getVoiceStatus();\n","filename":"test\/jdk\/javax\/sound\/midi\/Gervill\/SoftChannel\/NoteOff2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -358,1 +358,1 @@\n-        InputStream is = new StringBufferInputStream(query);;\n+        InputStream is = new StringBufferInputStream(query);\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/BaseRowSetTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-        URL u = new URL(\"http:\/\/www.oracle.com\/\");;\n+        URL u = new URL(\"http:\/\/www.oracle.com\/\");\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SQLInputImplTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-        SerialArray sa1 = serializeDeserializeObject(sa);;\n+        SerialArray sa1 = serializeDeserializeObject(sa);\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SerialArrayTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-                && ex1.getErrorCode() == 0);;\n+                && ex1.getErrorCode() == 0);\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SerialExceptionTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        SerialStruct ss1 = serializeDeserializeObject(ss);;\n+        SerialStruct ss1 = serializeDeserializeObject(ss);\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SerialStructTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.KeyEvent;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+\n+import static java.util.stream.Collectors.toList;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8281738\n+ * @summary Check whether pressing <Space> key generates\n+ *          ActionEvent on focused Button or not.\n+ * @run main SpaceKeyActivatesButton\n+ *\/\n+public class SpaceKeyActivatesButton {\n+\n+    private static volatile boolean buttonPressed;\n+    private static JFrame frame;\n+    private static JButton focusedButton;\n+    private static CountDownLatch buttonGainedFocusLatch;\n+\n+    public static void main(String[] s) throws Exception {\n+        runTest();\n+    }\n+\n+    public static void runTest() throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+        robot.setAutoWaitForIdle(true);\n+\n+        List<String> lafs = Arrays.stream(UIManager.getInstalledLookAndFeels())\n+                                  .map(laf -> laf.getClassName())\n+                                  .collect(toList());\n+        for (String laf : lafs) {\n+            buttonGainedFocusLatch = new CountDownLatch(1);\n+            try {\n+                buttonPressed = false;\n+                System.out.println(\"Testing laf : \" + laf);\n+                AtomicBoolean lafSetSuccess = new AtomicBoolean(false);\n+                SwingUtilities.invokeAndWait(() -> {\n+                    lafSetSuccess.set(setLookAndFeel(laf));\n+                    \/\/ Call createUI() only if setting laf succeeded\n+                    if (lafSetSuccess.get()) {\n+                        createUI();\n+                    }\n+                });\n+                \/\/ If setting laf failed, then just get next laf and continue\n+                if (!lafSetSuccess.get()) {\n+                    continue;\n+                }\n+                robot.waitForIdle();\n+\n+                \/\/ Wait until the button2 gains focus.\n+                if (!buttonGainedFocusLatch.await(3, TimeUnit.SECONDS)) {\n+                    throw new RuntimeException(\"Test Failed, waited too long, \" +\n+                            \"but the button can't gain focus for laf : \" + laf);\n+                }\n+\n+                robot.keyPress(KeyEvent.VK_SPACE);\n+                robot.keyRelease(KeyEvent.VK_SPACE);\n+\n+                if (buttonPressed) {\n+                    System.out.println(\"Test Passed for laf : \" + laf);\n+                } else {\n+                    throw new RuntimeException(\"Test Failed, button not pressed for laf : \" + laf);\n+                }\n+\n+            } finally {\n+                SwingUtilities.invokeAndWait(SpaceKeyActivatesButton::disposeFrame);\n+            }\n+        }\n+\n+    }\n+\n+    private static boolean setLookAndFeel(String lafName) {\n+        try {\n+            UIManager.setLookAndFeel(lafName);\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Ignoring Unsupported laf : \" + lafName);\n+            return false;\n+        } catch (ClassNotFoundException | InstantiationException\n+                | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return true;\n+    }\n+\n+    private static void createUI() {\n+        frame = new JFrame();\n+        JPanel panel = new JPanel();\n+        panel.add(new JButton(\"Button1\"));\n+        focusedButton = new JButton(\"Button2\");\n+        focusedButton.addActionListener(e -> buttonPressed = true);\n+        focusedButton.addFocusListener(new FocusAdapter() {\n+            @Override\n+            public void focusGained(FocusEvent e) {\n+                buttonGainedFocusLatch.countDown();\n+            }\n+        });\n+        panel.add(focusedButton);\n+\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.add(panel);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+        focusedButton.requestFocusInWindow();\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JButton\/4659800\/SpaceKeyActivatesButton.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+*\/\n+\n+\/*\n+ * @test\n+ * @bug 8015854\n+ * @requires (os.family == \"mac\")\n+ * @summary Tests HTML image as JButton text for unwanted padding on macOS Aqua LAF\n+ * @run main HtmlButtonImageTest\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JButton;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+\n+public final class HtmlButtonImageTest {\n+    private static JButton button;\n+    private static Path testDir;\n+    private static BufferedImage image;\n+\n+    private static final int BUTTON_HEIGHT = 37;\n+    private static final int BUTTON_WIDTH = 37;\n+    private static final int SQUARE_HEIGHT = 19;\n+    private static final int SQUARE_WIDTH = 19;\n+    private static final int centerX = BUTTON_WIDTH \/ 2;\n+    private static final int centerY = BUTTON_HEIGHT \/ 2;\n+    private static final int minX = centerX - (SQUARE_WIDTH \/ 2);\n+    private static final int minY = centerY - (SQUARE_HEIGHT \/ 2);\n+    private static final int maxX = centerX + (SQUARE_WIDTH \/ 2);\n+    private static final int maxY = centerY + (SQUARE_HEIGHT \/ 2);\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(\"com.apple.laf.AquaLookAndFeel\");\n+        testDir = Path.of(System.getProperty(\"test.classes\", \".\"));\n+        generateRedSquare();\n+\n+        SwingUtilities.invokeAndWait(HtmlButtonImageTest::createButton);\n+        SwingUtilities.invokeAndWait(HtmlButtonImageTest::paintButton);\n+\n+        testImageCentering(image.getRGB(centerX, centerY),\n+                image.getRGB(minX, minY),\n+                image.getRGB(minX, maxY),\n+                image.getRGB(maxX, minY),\n+                image.getRGB(maxX, maxY));\n+    }\n+\n+    private static void generateRedSquare() throws IOException {\n+        BufferedImage bImg = new BufferedImage(SQUARE_WIDTH, SQUARE_HEIGHT,\n+                TYPE_INT_ARGB);\n+        Graphics2D cg = bImg.createGraphics();\n+        cg.setColor(Color.RED);\n+        cg.fillRect(0, 0, SQUARE_WIDTH, SQUARE_HEIGHT);\n+        ImageIO.write(bImg, \"png\", new File(testDir + \"\/red_square.png\"));\n+    }\n+\n+    private static void createButton() {\n+        button = new JButton();\n+        button.setSize(new Dimension(BUTTON_WIDTH, BUTTON_HEIGHT));\n+        button.setText(\"<html><img src='\"\n+                + testDir.resolve(\"red_square.png\").toUri() + \"'><\/html>\");\n+    }\n+\n+    private static void paintButton() {\n+        image = new BufferedImage(BUTTON_HEIGHT, BUTTON_WIDTH, TYPE_INT_ARGB);\n+        Graphics2D graphics2D = image.createGraphics();\n+        button.paint(graphics2D);\n+        graphics2D.dispose();\n+    }\n+\n+    private static boolean checkRedColor(int rgb) {\n+        return (rgb == Color.RED.getRGB());\n+    }\n+\n+    private static void testImageCentering(int... colors) throws IOException {\n+        for (int c : colors) {\n+            if (!checkRedColor(c)) {\n+                ImageIO.write(image, \"png\",\n+                        new File(testDir + \"\/fail_image.png\"));\n+                throw new RuntimeException(\"HTML image not centered in button\");\n+            }\n+        }\n+        System.out.println(\"Passed\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JButton\/HtmlButtonImageTest\/HtmlButtonImageTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+ \/*\n+  * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+  *\n+  * This code is free software; you can redistribute it and\/or modify it\n+  * under the terms of the GNU General Public License version 2 only, as\n+  * published by the Free Software Foundation.\n+  *\n+  * This code is distributed in the hope that it will be useful, but WITHOUT\n+  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+  * version 2 for more details (a copy is included in the LICENSE file that\n+  * accompanied this code).\n+  *\n+  * You should have received a copy of the GNU General Public License version\n+  * 2 along with this work; if not, write to the Free Software Foundation,\n+  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+  *\n+  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+  * or visit www.oracle.com if you need additional information or have any\n+  * questions.\n+  *\/\n+\n+ import javax.swing.JEditorPane;\n+ import javax.swing.SwingUtilities;\n+\n+ \/*\n+  * @test\n+  * @bug 4330998\n+  * @summary Verifies that JEditorPane.setText(null) doesn't throw NullPointerException.\n+  * @run main JEditorPaneSetTextNullTest\n+  *\/\n+ public class JEditorPaneSetTextNullTest {\n+\n+     public static void main(String[] args) throws Exception {\n+         try {\n+             SwingUtilities.invokeAndWait(() -> new JEditorPane().setText(null));\n+             System.out.println(\"Test passed\");\n+         } catch (Exception e) {\n+             throw new RuntimeException(\"Test failed, caught Exception \" + e\n+                     + \" when calling JEditorPane.setText(null)\");\n+         }\n+     }\n+\n+ }\n","filename":"test\/jdk\/javax\/swing\/JEditorPane\/4330998\/JEditorPaneSetTextNullTest.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.imageio.ImageIO;\n+import javax.swing.JEditorPane;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UIManager.LookAndFeelInfo;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+import static javax.swing.UIManager.getInstalledLookAndFeels;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4666101\n+ * @summary Verifies that in a JEditorPane, the down arrow is honoured after you\n+            add text on a line preceding a blank line.\n+ * @run main JEditorPaneNavigationTest\n+ *\/\n+public class JEditorPaneNavigationTest {\n+\n+    private static volatile int caretPos;\n+    private static JEditorPane jep;\n+    private static JFrame frame;\n+    private static Robot robot;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+        robot.setAutoDelay(100);\n+\n+        List<String> lafs = Arrays.stream(getInstalledLookAndFeels())\n+                                  .map(LookAndFeelInfo::getClassName)\n+                                  .collect(Collectors.toList());\n+        for (final String laf : lafs) {\n+            try {\n+                AtomicBoolean lafSetSuccess = new AtomicBoolean(false);\n+                SwingUtilities.invokeAndWait(() -> {\n+                    lafSetSuccess.set(setLookAndFeel(laf));\n+                    if (lafSetSuccess.get()) {\n+                        createUI();\n+                    }\n+                });\n+                if (!lafSetSuccess.get()) {\n+                    continue;\n+                }\n+                robot.waitForIdle();\n+\n+                AtomicReference<Point> pt = new AtomicReference<>();\n+                SwingUtilities.invokeAndWait(() -> pt.set(jep.getLocationOnScreen()));\n+                caretPos = 0;\n+                final Point jEditorLoc = pt.get();\n+\n+                \/\/ Click on JEditorPane\n+                robot.mouseMove(jEditorLoc.x + 50, jEditorLoc.y + 50);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                keyType(KeyEvent.VK_ENTER);\n+                keyType(KeyEvent.VK_ENTER);\n+\n+                typeSomeText();\n+\n+                keyType(KeyEvent.VK_UP);\n+                keyType(KeyEvent.VK_UP);\n+\n+                typeSomeText();\n+\n+                keyType(KeyEvent.VK_DOWN);\n+\n+                System.out.println(\" test1 caret pos = \" + caretPos);\n+\n+                \/\/ Check whether the caret position is at the expected value 5\n+                if (caretPos != 5) {\n+                    captureScreen();\n+                    throw new RuntimeException(\"Test Failed in \" + laf\n+                            + \" expected initial caret position is 5, but actual is \" + caretPos);\n+                }\n+\n+                keyType(KeyEvent.VK_DOWN);\n+\n+                System.out.println(\" test2 caret pos = \" + caretPos);\n+\n+                \/\/ Check whether the caret position is at the expected value 10\n+                if (caretPos != 10) {\n+                    captureScreen();\n+                    throw new RuntimeException(\"Test Failed in \" + laf\n+                            + \" expected final caret position is 10, but actual is \" + caretPos);\n+                }\n+\n+                System.out.println(\"Test Passed in \" + laf);\n+\n+            } finally {\n+                SwingUtilities.invokeAndWait(JEditorPaneNavigationTest::disposeFrame);\n+            }\n+        }\n+    }\n+\n+    private static void captureScreen() {\n+        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+        try {\n+            ImageIO.write(\n+                    robot.createScreenCapture(new Rectangle(0, 0, screenSize.width, screenSize.height)),\n+                    \"png\",\n+                    new File(\"JEditorPaneNavigationTest.png\")\n+            );\n+        } catch (IOException ignore) {\n+        }\n+    }\n+\n+    private static void typeSomeText() {\n+        keyType(KeyEvent.VK_T);\n+        keyType(KeyEvent.VK_E);\n+        keyType(KeyEvent.VK_X);\n+        keyType(KeyEvent.VK_T);\n+    }\n+\n+    private static void keyType(int keyCode) {\n+        robot.keyPress(keyCode);\n+        robot.keyRelease(keyCode);\n+    }\n+\n+\n+    private static void createUI() {\n+        frame = new JFrame();\n+        jep = new JEditorPane();\n+        jep.setPreferredSize(new Dimension(100, 100));\n+        jep.addCaretListener(e -> caretPos = jep.getCaretPosition());\n+        jep.setEditable(true);\n+        JPanel panel = new JPanel();\n+        panel.add(jep);\n+        frame.add(panel);\n+        frame.setLocationRelativeTo(null);\n+        frame.setAlwaysOnTop(true);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    private static boolean setLookAndFeel(String lafName) {\n+        try {\n+            UIManager.setLookAndFeel(lafName);\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Ignoring Unsupported laf : \" + lafName);\n+            return false;\n+        } catch (ClassNotFoundException | InstantiationException\n+                | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return true;\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/JEditorPane\/4666101\/JEditorPaneNavigationTest.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.KeyEvent;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.swing.JFrame;\n+import javax.swing.JList;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UIManager.LookAndFeelInfo;\n+import javax.swing.UnsupportedLookAndFeelException;\n+import javax.swing.event.MenuEvent;\n+import javax.swing.event.MenuListener;\n+\n+\n+import static javax.swing.UIManager.getInstalledLookAndFeels;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4618767\n+ * @summary This test confirms that typing a letter while a JList has focus now makes the selection\n+ *          not jump to the item whose text starts with that letter if that typed letter is accompanied\n+ *          by modifier keys such as ALT or CTRL(eg: ALT+F).\n+ * @run main JListSelectedElementTest\n+ *\/\n+public class JListSelectedElementTest {\n+\n+    private static final int FILE_MENU = KeyEvent.VK_F;\n+    private static JFrame frame;\n+    private static JList<String> list;\n+    private static Robot robot;\n+    private static CountDownLatch listGainedFocusLatch;\n+    private static CountDownLatch menuSelectedEventLatch;\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest();\n+    }\n+\n+    public static void runTest() throws Exception {\n+        robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+        robot.setAutoDelay(200);\n+\n+        final boolean isMac = System.getProperty(\"os.name\")\n+                                    .toLowerCase()\n+                                    .contains(\"os x\");\n+\n+        List<String> lafs = Arrays.stream(getInstalledLookAndFeels())\n+                                  .map(LookAndFeelInfo::getClassName)\n+                                  .collect(Collectors.toList());\n+        for (final String laf : lafs) {\n+            listGainedFocusLatch = new CountDownLatch(1);\n+            menuSelectedEventLatch = new CountDownLatch(1);\n+            try {\n+                AtomicBoolean lafSetSuccess = new AtomicBoolean(false);\n+                SwingUtilities.invokeAndWait(() -> {\n+                    lafSetSuccess.set(setLookAndFeel(laf));\n+                    if (lafSetSuccess.get()) {\n+                        createUI();\n+                    }\n+                });\n+                if (!lafSetSuccess.get()) {\n+                    continue;\n+                }\n+                robot.waitForIdle();\n+\n+                \/\/ Wait until the list gains focus.\n+                if (!listGainedFocusLatch.await(3, TimeUnit.SECONDS)) {\n+                    throw new RuntimeException(\"Waited too long, but can't gain focus for list\");\n+                }\n+\n+                \/\/ Select element named as 'bill'\n+                hitKeys(KeyEvent.VK_B);\n+\n+                \/\/ Assertion check to verify that the selected node is 'bill'\n+                AtomicReference<String> elementSel = new AtomicReference<>();\n+                SwingUtilities.invokeAndWait(() -> elementSel.set(list.getSelectedValue()));\n+                final String elementSelBefore = elementSel.get();\n+                if (!\"bill\".equals(elementSelBefore)) {\n+                    throw new RuntimeException(\"Test failed for \" + laf\n+                            + \" as the list element selected: \" + elementSel\n+                            + \" is not the expected one 'bill'\"\n+                    );\n+                }\n+\n+                \/\/ Now operate Menu using Mnemonics, different key combinations for different OSes.\n+                \/\/ For most OSes it's ALT+F; on macOS it's ALT+CNTRL+F except for Nimbus LaF.\n+                if (isMac && !laf.contains(\"Nimbus\")) {\n+                    hitKeys(KeyEvent.VK_ALT, KeyEvent.VK_CONTROL, FILE_MENU);\n+                } else {\n+                    hitKeys(KeyEvent.VK_ALT, FILE_MENU);\n+                }\n+\n+                \/\/ Wait until the menu got selected.\n+                if (!menuSelectedEventLatch.await(3, TimeUnit.SECONDS)) {\n+                    throw new RuntimeException(\"Waited too long, but can't select menu using mnemonics for \" + laf);\n+                }\n+\n+                hitKeys(KeyEvent.VK_ENTER);\n+\n+                AtomicReference<String> elementSelAfter = new AtomicReference<>();\n+                SwingUtilities.invokeAndWait(() -> elementSelAfter.set(list.getSelectedValue()));\n+\n+                \/\/ As per the fix of BugID 4618767, the list element selection should not change\n+                if (!elementSelBefore.equals(elementSelAfter.get())) {\n+                    throw new RuntimeException(\"Test failed for \" + laf\n+                            + \" as list.getSelectedValue() before = \" + elementSel\n+                            + \" not equal to list.getSelectedValue() after pressing Enter = \" + elementSelAfter\n+                    );\n+                }\n+                System.out.println(\"Test passed for laf: \" + laf);\n+\n+            } finally {\n+                SwingUtilities.invokeAndWait(JListSelectedElementTest::disposeFrame);\n+            }\n+        }\n+    }\n+\n+    private static void hitKeys(int... keys) {\n+        for (int key : keys) {\n+            robot.keyPress(key);\n+        }\n+\n+        for (int i = keys.length - 1; i >= 0; i--) {\n+            robot.keyRelease(keys[i]);\n+        }\n+    }\n+\n+    private static void createUI() {\n+        frame = new JFrame();\n+        list = new JList<>(new String[]{\"anaheim\", \"bill\", \"chicago\", \"dingo\", \"ernie\", \"freak\"});\n+        list.addFocusListener(new FocusAdapter() {\n+            @Override\n+            public void focusGained(FocusEvent e) {\n+                listGainedFocusLatch.countDown();\n+            }\n+        });\n+        JMenu menu = new JMenu(\"File\");\n+        menu.setMnemonic(FILE_MENU);\n+        JMenuItem menuItem = new JMenuItem(\"Dummy\");\n+        menu.add(menuItem);\n+        menu.addMenuListener(new MenuListener() {\n+            @Override\n+            public void menuSelected(MenuEvent e) {\n+                menuSelectedEventLatch.countDown();\n+            }\n+\n+            @Override\n+            public void menuDeselected(MenuEvent e) {\n+            }\n+\n+            @Override\n+            public void menuCanceled(MenuEvent e) {\n+            }\n+        });\n+\n+        JMenuBar menuBar = new JMenuBar();\n+        menuBar.add(menu);\n+\n+        frame.setJMenuBar(menuBar);\n+        frame.setContentPane(list);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.pack();\n+        frame.setAlwaysOnTop(true);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static boolean setLookAndFeel(String lafName) {\n+        try {\n+            UIManager.setLookAndFeel(lafName);\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Ignoring Unsupported L&F: \" + lafName);\n+            return false;\n+        } catch (ClassNotFoundException | InstantiationException\n+                | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return true;\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/JList\/4618767\/JListSelectedElementTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.awt.BorderLayout;\n+import java.awt.ComponentOrientation;\n+import java.awt.Point;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.Robot;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.event.MenuEvent;\n+import javax.swing.event.MenuListener;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug  8277369\n+ * @summary Verifies arrow traversal in RTL orientation in JMenuBar\n+ *\/\n+public class MenuBarRTLBug {\n+\n+    static JFrame frame;\n+    static JMenuBar menuBar;\n+    static JMenu firstMenu;\n+    static JMenuItem a;\n+    static JMenuItem b;\n+    static JMenu secondMenu;\n+    static JMenuItem c;\n+    static JMenuItem d;\n+    static JMenu thirdMenu;\n+    static JMenuItem e;\n+    static JMenuItem f;\n+    static JMenu forthMenu;\n+    static JMenu fifthMenu;\n+\n+    static Point p;\n+    static int width;\n+    static int height;\n+\n+    static volatile boolean passed = false;\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported L&F: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws  Exception {\n+\n+        for (UIManager.LookAndFeelInfo laf : UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing L&F: \" + laf.getClassName());\n+            passed = false;\n+            SwingUtilities.invokeAndWait(() -> setLookAndFeel(laf));\n+            try {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    frame = new JFrame();\n+                    frame.setLayout(new BorderLayout());\n+\n+                    firstMenu = new JMenu(\"first\");\n+                    a = new JMenuItem(\"a\");\n+                    b = new JMenuItem(\"b\");\n+                    firstMenu.add(a);\n+                    firstMenu.add(b);\n+\n+                    secondMenu = new JMenu(\"second\");\n+                    c = new JMenuItem(\"c\");\n+                    d = new JMenuItem(\"d\");\n+                    secondMenu.add(c);\n+                    secondMenu.add(d);\n+                    secondMenu.addMenuListener(new MenuListener() {\n+                        @Override\n+                        public void menuSelected(MenuEvent e) {\n+                            passed = true;\n+                        }\n+                        @Override\n+                        public void menuDeselected(MenuEvent e) {\n+                        }\n+\n+                        @Override\n+                        public void menuCanceled(MenuEvent e) {\n+                        }\n+                    });\n+\n+                    thirdMenu = new JMenu(\"third\");\n+                    e = new JMenuItem(\"e\");\n+                    f = new JMenuItem(\"f\");\n+                    thirdMenu.add(e);\n+                    thirdMenu.add(f);\n+\n+                    forthMenu = new JMenu(\"fourth\");\n+                    e = new JMenuItem(\"e\");\n+                    f = new JMenuItem(\"f\");\n+                    forthMenu.add(e);\n+                    forthMenu.add(f);\n+\n+                    fifthMenu = new JMenu(\"fifth\");\n+                    e = new JMenuItem(\"e\");\n+                    f = new JMenuItem(\"f\");\n+                    fifthMenu.add(e);\n+                    fifthMenu.add(f);\n+\n+                    menuBar = new JMenuBar();\n+                    menuBar.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);\n+                    menuBar.add(firstMenu);\n+                    menuBar.add(secondMenu);\n+                    menuBar.add(thirdMenu);\n+                    menuBar.add(forthMenu);\n+                    menuBar.add(fifthMenu);\n+                    frame.setJMenuBar(menuBar);\n+\n+                    frame.setLocationRelativeTo(null);\n+                    frame.pack();\n+                    frame.setVisible(true);\n+                });\n+                Robot robot = new Robot();\n+                robot.setAutoDelay(100);\n+                robot.waitForIdle();\n+                robot.delay(1000);\n+                SwingUtilities.invokeAndWait(() -> {\n+                    p = thirdMenu.getLocationOnScreen();\n+                    width = thirdMenu.getWidth();\n+                    height = thirdMenu.getHeight();\n+                });\n+                robot.mouseMove(p.x + width \/ 2, p.y + height \/ 2);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.delay(1000);\n+                robot.keyPress(KeyEvent.VK_RIGHT);\n+                robot.keyRelease(KeyEvent.VK_RIGHT);\n+                robot.delay(1000);\n+                if (!passed) {\n+                    throw new RuntimeException(\"Arrow traversal order not correct in RTL orientation\");\n+                }\n+            } finally {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    if (frame != null) {\n+                        frame.dispose();\n+                    }\n+                });\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JMenuBar\/MenuBarRTLBug.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import javax.swing.DefaultListModel;\n+import javax.swing.ListModel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JFrame;\n+import javax.swing.JList;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family != \"mac\")\n+ * @bug  6911375\n+ * @summary Verifies mouseWheel effect on JList without scrollBar\n+ *\/\n+public class TestMouseWheelScroll {\n+\n+    static JFrame frame;\n+    static JScrollPane scrollPane;\n+    static volatile Point p;\n+    static volatile int width;\n+    static volatile int height;\n+    static volatile Point viewPosition;\n+    static volatile Point newPosition;\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported L&F: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        for (UIManager.LookAndFeelInfo laf : UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing L&F: \" + laf.getClassName());\n+            SwingUtilities.invokeAndWait(() -> setLookAndFeel(laf));\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+\n+            try {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    frame = new JFrame();\n+                    JList list = new JList(createListModel());\n+                    \/\/ disable list bindings\n+                    list.getInputMap().getParent().clear();\n+                    scrollPane = new JScrollPane(list);\n+\n+                    scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);\n+                    frame.add(scrollPane);\n+                    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+                    frame.setSize(200,200);\n+                    frame.setLocationRelativeTo(null);\n+                    frame.setVisible(true);\n+                });\n+                robot.waitForIdle();\n+                robot.delay(1000);\n+                SwingUtilities.invokeAndWait(() -> {\n+                    p = frame.getLocationOnScreen();\n+                    width = frame.getWidth();\n+                    height = frame.getHeight();\n+                });\n+                robot.mouseMove(p.x + width \/ 2, p.y + height \/ 2);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.waitForIdle();\n+                SwingUtilities.invokeAndWait(() -> {\n+                    viewPosition = scrollPane.getViewport().getViewPosition();\n+                });\n+                robot.delay(1000);\n+                robot.mouseWheel(1);\n+                robot.delay(500);\n+                SwingUtilities.invokeAndWait(() -> {\n+                    newPosition = scrollPane.getViewport().getViewPosition();\n+                });\n+                robot.delay(1000);\n+                if (newPosition.equals(viewPosition)) {\n+                    throw new RuntimeException(\"Mouse wheel not handled\");\n+                }\n+            } finally {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    if (frame != null) {\n+                        frame.dispose();\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    private static ListModel createListModel() {\n+        DefaultListModel model = new DefaultListModel();\n+        for (int i = 0; i < 100; i++) {\n+            model.addElement(\"element \" + i);\n+        }\n+        return model;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JScrollPane\/TestMouseWheelScroll.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8236907\n+ * @summary  Verifies if JTable last row is visible.\n+ * @run main LastVisibleRow\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.event.InputEvent;\n+import java.awt.image.BufferedImage;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import javax.print.attribute.HashPrintRequestAttributeSet;\n+import javax.print.attribute.PrintRequestAttributeSet;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.WindowConstants;\n+\n+public class LastVisibleRow {\n+    static JFrame frame;\n+    static JTable table;\n+    static Robot testRobot;\n+\n+    public static void main(String[] args) throws Exception {\n+        Point clkPoint;\n+        try {\n+            testRobot = new Robot();\n+\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+\n+                public void run() {\n+                    createAndShowGUI();\n+                }\n+            });\n+            testRobot.delay(1000);\n+            testRobot.waitForIdle();\n+            BufferedImage bufferedImageBefore = testRobot.createScreenCapture(getCaptureRect());\n+            testRobot.delay(1000);\n+            testRobot.waitForIdle();\n+            clkPoint = getMousePosition();\n+            mouseEvents(clkPoint);\n+            testRobot.waitForIdle();\n+            clearSelect();\n+            testRobot.waitForIdle();\n+            BufferedImage bufferedImageAfter = testRobot.createScreenCapture(getCaptureRect());\n+            testRobot.delay(1000);\n+\n+            if (!compare(bufferedImageBefore, bufferedImageAfter)) {\n+                throw new RuntimeException(\"Test Case Failed!!\");\n+            }\n+        } finally {\n+            if (frame != null) SwingUtilities.invokeAndWait(() -> frame.dispose());\n+        }\n+    }\n+\n+    \/*\n+     *\n+     * Get clickable screen point for particular row and column of a table\n+     * param row   Row Number\n+     * param column    Column Number\n+     * return Point\n+     *\/\n+    private static Point getCellClickPoint(final int row, final int column) {\n+        Point result;\n+\n+        Rectangle rect = table.getCellRect(row, column, false);\n+        Point point = new Point(rect.x + rect.width \/ 2,\n+                rect.y + rect.height \/ 2);\n+        SwingUtilities.convertPointToScreen(point, table);\n+        result = point;\n+\n+        return result;\n+    }\n+\n+    private static void createAndShowGUI() {\n+        final PrintRequestAttributeSet printReqAttr = new HashPrintRequestAttributeSet();\n+        printReqAttr.add(javax.print.attribute.standard.OrientationRequested.LANDSCAPE);\n+        frame = new JFrame();\n+        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+        Container contentPane = frame.getContentPane();\n+        JPanel centerPane = new JPanel(new BorderLayout());\n+        centerPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n+        JPanel tablePaneContainer = new JPanel(new BorderLayout());\n+        JPanel tablePane = new JPanel(new BorderLayout());\n+        table = new JTable(new Object[][]{{\"row_1_col_1\", \"row_1_col_2\", \"row_1_col_3\"}, {\"row_2_col_1\", \"row_2_col_2\", \"row_2_col_3\"}, {\"row_3_col_1\", \"row_3_col_2\", \"row_3_col_3\"}, {\"row_4_col_1\", \"row_4_col_2\", \"row_4_col_3\"}}, new String[]{\"Col1\", \"Col2\", \"Col3\"});\n+        table.setPreferredSize(new Dimension(0, (table.getRowHeight() * 3)));\n+\n+        tablePane.add(table.getTableHeader(), BorderLayout.NORTH);\n+        tablePane.add(table, BorderLayout.CENTER);\n+        tablePaneContainer.add(tablePane, BorderLayout.CENTER);\n+        centerPane.add(tablePaneContainer, BorderLayout.NORTH);\n+        contentPane.add(centerPane, BorderLayout.CENTER);\n+        frame.setSize(400, 120);\n+        frame.setVisible(true);\n+        frame.setLocationRelativeTo(null);\n+\n+    }\n+\n+    \/*\n+     *\n+     * mouseEvents for last row click\n+     *\/\n+\n+    private static void mouseEvents(Point clkPnt)  {\n+        testRobot.mouseMove(clkPnt.x, clkPnt.y);\n+        testRobot.delay(50);\n+        testRobot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        testRobot.delay(50);\n+        testRobot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        testRobot.delay(50);\n+    }\n+    \/*\n+     *\n+     * getMousePosition Actions for last row click\n+     * returns Point\n+     * throws Exception\n+     *\/\n+\n+    private static Point getMousePosition() throws Exception {\n+        final Point[] clickPoint = new Point[1];\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                clickPoint[0] = getCellClickPoint(2, 0);\n+            }\n+        });\n+        return clickPoint[0];\n+    }\n+\n+    \/*\n+     *\n+     * Clears the selected table row\n+     * throws Exception\n+     *\/\n+\n+    private static void clearSelect() throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                table.getSelectionModel().clearSelection();\n+                table.setFocusable(false);\n+            }\n+        });\n+    }\n+\n+    \/*\n+     * getCaptureRect Method - To Compute the Rectangle for\n+     * Screen Capturing the Last Row for comparison\n+     * return Rectangle\n+     *\/\n+\n+    private static Rectangle getCaptureRect() throws InterruptedException, InvocationTargetException {\n+        final Rectangle[] captureRect = new Rectangle[1];\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                Rectangle cellRect = table.getCellRect(2, 0, true);\n+                Point point = new Point(cellRect.x, cellRect.y);\n+                SwingUtilities.convertPointToScreen(point, table);\n+\n+                captureRect[0] = new Rectangle(point.x, point.y, table.getColumnCount() * cellRect.width, cellRect.height);\n+            }\n+        });\n+        return captureRect[0];\n+    }\n+\n+    \/*\n+     * Compare method - to compare two images.\n+     * param bufferedImage1    Buffered Image Before click\n+     * param bufferedImage2    Buffered Image After click\n+     * return Boolean\n+     *\/\n+\n+    static Boolean compare(BufferedImage bufferedImage1, BufferedImage bufferedImage2) {\n+        if (bufferedImage1.getWidth() == bufferedImage2.getWidth()\n+                && bufferedImage1.getHeight() == bufferedImage2.getHeight()) {\n+            for (int x = 0; x < bufferedImage1.getWidth(); x++) {\n+                for (int y = 0; y < bufferedImage1.getHeight(); y++) {\n+                    if (bufferedImage1.getRGB(x, y) != bufferedImage2.getRGB(x, y)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        } else {\n+            return false;\n+        }\n+        return true;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTable\/8236907\/LastVisibleRow.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.GridLayout;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.swing.InputVerifier;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JTextField;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UIManager.LookAndFeelInfo;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+import static javax.swing.UIManager.getInstalledLookAndFeels;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4532513\n+ * @summary Verifies that DefaultCaret doesn't requests focus in mouseClick and mousePressed\n+ *          causing the associated input verifier to fire twice.\n+ * @run main DefaultCaretRequestsFocusTest\n+ *\/\n+public class DefaultCaretRequestsFocusTest {\n+\n+    private static JTextField jTextField1;\n+    private static JTextField jTextField2;\n+    private static JTextField jTextField3;\n+    private static JFrame frame;\n+    private static Robot robot;\n+    private static volatile int shouldYieldFocusCount;\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest();\n+    }\n+\n+    public static void runTest() throws Exception {\n+        robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+        robot.setAutoDelay(200);\n+\n+        List<String> lafs = Arrays.stream(getInstalledLookAndFeels())\n+                                  .map(LookAndFeelInfo::getClassName)\n+                                  .collect(Collectors.toList());\n+        for (final String laf : lafs) {\n+            try {\n+                AtomicBoolean lafSetSuccess = new AtomicBoolean(false);\n+                SwingUtilities.invokeAndWait(() -> {\n+                    lafSetSuccess.set(setLookAndFeel(laf));\n+                    if (lafSetSuccess.get()) {\n+                        createUI();\n+                    }\n+                });\n+                if (!lafSetSuccess.get()) {\n+                    continue;\n+                }\n+                robot.waitForIdle();\n+\n+                AtomicReference<Point> jTextField1LocRef = new AtomicReference<>();\n+                AtomicReference<Point> jTextField2LocRef = new AtomicReference<>();\n+                SwingUtilities.invokeAndWait(() -> {\n+                    jTextField1LocRef.set(jTextField1.getLocationOnScreen());\n+                    jTextField2LocRef.set(jTextField2.getLocationOnScreen());\n+                });\n+                final Point jTextField1Loc = jTextField1LocRef.get();\n+                final Point jTextField2Loc = jTextField2LocRef.get();\n+\n+                shouldYieldFocusCount = 0;\n+\n+                \/\/ Click on TextField2\n+                robot.mouseMove(jTextField2Loc.x + 5, jTextField2Loc.y + 5);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                typeSomeText();\n+\n+                \/\/ Click on TextField1\n+                robot.mouseMove(jTextField1Loc.x + 5, jTextField1Loc.y + 5);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                typeSomeText();\n+\n+                if (shouldYieldFocusCount == 1) {\n+                    System.out.println(\"Test passed for \" + laf);\n+                } else {\n+                    throw new RuntimeException(\"Test failed for \" + laf\n+                            + \" as InputVerifier.shouldYieldFocus() was called \" + shouldYieldFocusCount\n+                            + \" times on jTextField2, but it is expected to be called only once.\");\n+                }\n+\n+            } finally {\n+                SwingUtilities.invokeAndWait(DefaultCaretRequestsFocusTest::disposeFrame);\n+            }\n+        }\n+    }\n+\n+    private static void typeSomeText() {\n+        robot.keyPress(KeyEvent.VK_T);\n+        robot.keyRelease(KeyEvent.VK_T);\n+        robot.keyPress(KeyEvent.VK_E);\n+        robot.keyRelease(KeyEvent.VK_E);\n+        robot.keyPress(KeyEvent.VK_X);\n+        robot.keyRelease(KeyEvent.VK_X);\n+        robot.keyPress(KeyEvent.VK_T);\n+        robot.keyRelease(KeyEvent.VK_T);\n+    }\n+\n+    private static void createUI() {\n+        frame = new JFrame();\n+        jTextField1 = new JTextField(6);\n+        jTextField2 = new JTextField(6);\n+        jTextField3 = new JTextField(6);\n+        JPanel panel = new JPanel();\n+        panel.setLayout(new GridLayout(3, 1));\n+        panel.add(jTextField1);\n+        panel.add(jTextField2);\n+        panel.add(jTextField3);\n+\n+        InputVerifier iv = new InputVerifier() {\n+            public boolean verify(JComponent input) {\n+                System.out.println(\"InputVerifier.verify() called\");\n+                return false;\n+            }\n+\n+            public boolean shouldYieldFocus(JComponent input) {\n+                ++shouldYieldFocusCount;\n+                System.out.println(\"InputVerifier.shouldYieldFocus() called \" + shouldYieldFocusCount);\n+                return false;\n+            }\n+        };\n+\n+        jTextField2.setInputVerifier(iv);\n+\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.add(panel);\n+        frame.pack();\n+        frame.setAlwaysOnTop(true);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static boolean setLookAndFeel(String lafName) {\n+        try {\n+            UIManager.setLookAndFeel(lafName);\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Ignoring Unsupported laf : \" + lafName);\n+            return false;\n+        } catch (ClassNotFoundException | InstantiationException\n+                | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return true;\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/JTextField\/4532513\/DefaultCaretRequestsFocusTest.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import javax.swing.SwingUtilities;\n+import javax.swing.JTextField;\n+\n+\/*\n+ * @test\n+ * @bug 8037965\n+ * @summary Verifies NPE in TextLayout.getBaselineFromGraphic() for invalid\n+ *          Unicode characters\n+ *\/\n+public class SwingUnicodeTest {\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(() ->\n+            new JTextField(new StringBuilder().appendCodePoint(0xFFFF).\n+                            appendCodePoint(0x10000).toString()));\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTextField\/SwingUnicodeTest.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.swing.JFrame;\n+import javax.swing.JTree;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UIManager.LookAndFeelInfo;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+import static javax.swing.UIManager.getInstalledLookAndFeels;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4518432\n+ * @summary Verifies that Copying from JTree node and then changing the data in the component that was copied from,\n+ *          is not causing the pastes to use the new edited data instead of the original copied data.\n+ * @run main JTreeNodeCopyPasteTest\n+ *\/\n+public class JTreeNodeCopyPasteTest {\n+\n+    private static JFrame frame;\n+    private static JTree tree;\n+    private static Robot robot;\n+    private static boolean isMac;\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest();\n+    }\n+\n+    private static void runTest() throws Exception {\n+        isMac = System.getProperty(\"os.name\").toLowerCase().contains(\"os x\");\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n+        robot.setAutoWaitForIdle(true);\n+\n+        \/\/ Filter out Motif laf, as it doesn't support copy-paste in JTree.\n+        List<String> lafs = Arrays.stream(getInstalledLookAndFeels())\n+                                  .filter(laf -> !laf.getName().contains(\"Motif\"))\n+                                  .map(LookAndFeelInfo::getClassName)\n+                                  .collect(Collectors.toList());\n+        for (final String laf : lafs) {\n+            try {\n+                AtomicBoolean lafSetSuccess = new AtomicBoolean(false);\n+                SwingUtilities.invokeAndWait(() -> {\n+                    lafSetSuccess.set(setLookAndFeel(laf));\n+                    if (lafSetSuccess.get()) {\n+                        createUI();\n+                    }\n+                });\n+                if (!lafSetSuccess.get()) {\n+                    continue;\n+                }\n+\n+                robot.waitForIdle();\n+\n+                \/\/ Select the node named as 'colors'\n+                Point pt = getNodeLocation(1);\n+                robot.mouseMove(pt.x, pt.y);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                String expectedNodeName = getCurrentNodeName();\n+\n+                \/\/ Copy the contents of that node\n+                copyOrPaste(KeyEvent.VK_C, laf);\n+\n+                \/\/ Edit the Contents of that cell\n+                mouseTripleClick();\n+\n+                typeSomeText();\n+\n+                robot.keyPress(KeyEvent.VK_ENTER);\n+                robot.keyRelease(KeyEvent.VK_ENTER);\n+\n+                \/\/ Select next node\n+                pt = getNodeLocation(2);\n+                robot.mouseMove(pt.x, pt.y);\n+\n+                \/\/ Edit the Contents of that cell\n+                mouseTripleClick();\n+\n+                \/\/ paste the content copied earlier\n+                copyOrPaste(KeyEvent.VK_V, laf);\n+\n+                robot.keyPress(KeyEvent.VK_ENTER);\n+                robot.keyRelease(KeyEvent.VK_ENTER);\n+\n+                \/\/ Now get the node contents of second node\n+                String actualNodeName = getCurrentNodeName();\n+\n+                if (expectedNodeName.equals(actualNodeName)) {\n+                    System.out.println(\"Test Passed in \" + laf);\n+                } else {\n+                    throw new RuntimeException(\"Test Failed in \" + laf + \", Expected : \" + expectedNodeName\n+                            + \", but actual : \" + actualNodeName);\n+                }\n+            } finally {\n+                SwingUtilities.invokeAndWait(JTreeNodeCopyPasteTest::disposeFrame);\n+            }\n+        }\n+    }\n+\n+    private static String getCurrentNodeName() throws Exception {\n+        AtomicReference<String> nodeName = new AtomicReference<>();\n+        SwingUtilities.invokeAndWait(() -> {\n+            nodeName.set(tree.getLastSelectedPathComponent().toString().trim());\n+        });\n+        return nodeName.get();\n+    }\n+\n+    private static Point getNodeLocation(int rowCount) throws Exception {\n+        AtomicReference<Point> treeNodeLoc = new AtomicReference<>();\n+        SwingUtilities.invokeAndWait(() -> {\n+            final Point locationOnScreen = tree.getLocationOnScreen();\n+            Rectangle rt = tree.getPathBounds(tree.getPathForRow(rowCount));\n+            locationOnScreen.translate((int) (rt.getX() + rt.getWidth() \/ 2), (int) (rt.getY() + rt.getHeight() \/ 2));\n+            treeNodeLoc.set(locationOnScreen);\n+        });\n+        return treeNodeLoc.get();\n+    }\n+\n+    private static void copyOrPaste(int keyCode, String laf) {\n+        \/\/ For AquaLookAndFeel in Mac, the key combination for copy\/paste is META + (C or V)\n+        \/\/ For other OSes and other lafs, the key combination is CONTROL + (C or V)\n+        robot.keyPress(isMac && laf.contains(\"Aqua\") ? KeyEvent.VK_META : KeyEvent.VK_CONTROL);\n+        robot.keyPress(keyCode);\n+        robot.keyRelease(keyCode);\n+        robot.keyRelease(isMac && laf.contains(\"Aqua\") ? KeyEvent.VK_META : KeyEvent.VK_CONTROL);\n+    }\n+\n+    private static void mouseTripleClick() {\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+    }\n+\n+    private static void typeSomeText() {\n+        robot.keyPress(KeyEvent.VK_T);\n+        robot.keyRelease(KeyEvent.VK_T);\n+        robot.keyPress(KeyEvent.VK_E);\n+        robot.keyRelease(KeyEvent.VK_E);\n+        robot.keyPress(KeyEvent.VK_X);\n+        robot.keyRelease(KeyEvent.VK_X);\n+        robot.keyPress(KeyEvent.VK_T);\n+        robot.keyRelease(KeyEvent.VK_T);\n+    }\n+\n+    private static void createUI() {\n+        frame = new JFrame();\n+        tree = new JTree();\n+        tree.setEditable(true);\n+        frame.setContentPane(tree);\n+        frame.setSize(new Dimension(200, 200));\n+        frame.setAlwaysOnTop(true);\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.toFront();\n+        frame.setVisible(true);\n+    }\n+\n+    private static boolean setLookAndFeel(String lafName) {\n+        try {\n+            UIManager.setLookAndFeel(lafName);\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Ignoring Unsupported laf : \" + lafName);\n+            return false;\n+        } catch (ClassNotFoundException | InstantiationException\n+                | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return true;\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/JTree\/4518432\/JTreeNodeCopyPasteTest.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JTree;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UIManager.LookAndFeelInfo;\n+import javax.swing.UnsupportedLookAndFeelException;\n+import javax.swing.event.MenuEvent;\n+import javax.swing.event.MenuListener;\n+\n+import static javax.swing.UIManager.getInstalledLookAndFeels;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4618767\n+ * @summary This test confirms that typing a letter while a JTree has focus now makes the selection\n+ *          not jump to the item whose text starts with that letter if that typed letter is accompanied\n+ *          by modifier keys such as ALT or CTRL(eg: ALT+F).\n+ * @run main JTreeSelectedElementTest\n+ *\/\n+public class JTreeSelectedElementTest {\n+\n+    private static final int FILE_MENU = KeyEvent.VK_F;\n+    private static JFrame frame;\n+    private static JTree tree;\n+    private static Robot robot;\n+    private static CountDownLatch menuSelectedEventLatch;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+        robot.setAutoDelay(200);\n+\n+        final boolean isMac = System.getProperty(\"os.name\")\n+                                    .toLowerCase()\n+                                    .contains(\"os x\");\n+\n+        List<String> lafs = Arrays.stream(getInstalledLookAndFeels())\n+                                  .map(LookAndFeelInfo::getClassName)\n+                                  .collect(Collectors.toList());\n+        for (final String laf : lafs) {\n+            menuSelectedEventLatch = new CountDownLatch(1);\n+            try {\n+                AtomicBoolean lafSetSuccess = new AtomicBoolean(false);\n+                SwingUtilities.invokeAndWait(() -> {\n+                    lafSetSuccess.set(setLookAndFeel(laf));\n+                    if (lafSetSuccess.get()) {\n+                        createUI();\n+                    }\n+                });\n+                if (!lafSetSuccess.get()) {\n+                    continue;\n+                }\n+                robot.waitForIdle();\n+\n+                \/\/ Select the node named as 'colors'\n+                Point pt = getNodeLocation(1);\n+                robot.mouseMove(pt.x, pt.y);\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                \/\/ Assertion check to verify that the selected node is 'colors'\n+                final String elementSelBefore = getCurrentNodeName();\n+                if (!\"colors\".equals(elementSelBefore)) {\n+                    throw new RuntimeException(\"Test failed for \" + laf\n+                            + \" as the tree node selected: \" + elementSelBefore\n+                            + \" is not the expected one 'colors'\"\n+                    );\n+                }\n+\n+                \/\/ Now operate Menu using Mnemonics, different key combinations for different OSes.\n+                \/\/ For most OSes it's ALT+F; on macOS it's ALT+CNTRL+F except for Nimbus LaF.\n+                if (isMac && !laf.contains(\"Nimbus\")) {\n+                    hitKeys(KeyEvent.VK_ALT, KeyEvent.VK_CONTROL, FILE_MENU);\n+                } else {\n+                    hitKeys(KeyEvent.VK_ALT, FILE_MENU);\n+                }\n+\n+                \/\/ Wait until the menu got selected.\n+                if (!menuSelectedEventLatch.await(3, TimeUnit.SECONDS)) {\n+                    throw new RuntimeException(\"Waited too long, but can't select menu using mnemonics for \" + laf);\n+                }\n+\n+                hitKeys(KeyEvent.VK_ENTER);\n+\n+                String elementSelAfter = getCurrentNodeName();\n+\n+                \/\/ As per the fix of BugID 4618767, the tree element selection should not change\n+                if (!elementSelBefore.equals(elementSelAfter)) {\n+                    throw new RuntimeException(\"Test failed for \" + laf\n+                            + \" as tree.getLastSelectedPathComponent() before: \" + elementSelBefore\n+                            + \" not same as tree.getLastSelectedPathComponent() after pressing Enter: \"\n+                            + elementSelAfter\n+                    );\n+                }\n+\n+                System.out.println(\"Test passed for laf: \" + laf);\n+\n+            } finally {\n+                SwingUtilities.invokeAndWait(JTreeSelectedElementTest::disposeFrame);\n+            }\n+        }\n+    }\n+\n+    private static void hitKeys(int... keys) {\n+        for (int key : keys) {\n+            robot.keyPress(key);\n+        }\n+\n+        for (int i = keys.length - 1; i >= 0; i--) {\n+            robot.keyRelease(keys[i]);\n+        }\n+    }\n+\n+    private static String getCurrentNodeName() throws Exception {\n+        AtomicReference<String> nodeName = new AtomicReference<>();\n+        SwingUtilities.invokeAndWait(() -> {\n+            nodeName.set(tree.getLastSelectedPathComponent().toString().trim());\n+        });\n+        return nodeName.get();\n+    }\n+\n+    private static Point getNodeLocation(int rowCount) throws Exception {\n+        AtomicReference<Point> treeNodeLoc = new AtomicReference<>();\n+        SwingUtilities.invokeAndWait(() -> {\n+            final Point locationOnScreen = tree.getLocationOnScreen();\n+            Rectangle rt = tree.getPathBounds(tree.getPathForRow(rowCount));\n+            locationOnScreen.translate(rt.x + rt.width \/ 2, rt.y + rt.height \/ 2);\n+            treeNodeLoc.set(locationOnScreen);\n+        });\n+        return treeNodeLoc.get();\n+    }\n+\n+    private static void createUI() {\n+        frame = new JFrame();\n+        tree = new JTree();\n+        JMenu menu = new JMenu(\"File\");\n+        menu.setMnemonic(FILE_MENU);\n+        JMenuItem menuItem = new JMenuItem(\"Dummy\");\n+        menu.add(menuItem);\n+        menu.addMenuListener(new MenuListener() {\n+            @Override\n+            public void menuSelected(MenuEvent e) {\n+                menuSelectedEventLatch.countDown();\n+            }\n+\n+            @Override\n+            public void menuDeselected(MenuEvent e) {\n+            }\n+\n+            @Override\n+            public void menuCanceled(MenuEvent e) {\n+            }\n+        });\n+\n+        JMenuBar menuBar = new JMenuBar();\n+        menuBar.add(menu);\n+\n+        frame.setJMenuBar(menuBar);\n+        frame.setContentPane(tree);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.pack();\n+        frame.setAlwaysOnTop(true);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static boolean setLookAndFeel(String lafName) {\n+        try {\n+            UIManager.setLookAndFeel(lafName);\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Ignoring Unsupported L&F: \" + lafName);\n+            return false;\n+        } catch (ClassNotFoundException | InstantiationException\n+                | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return true;\n+    }\n+\n+    private static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/JTree\/4618767\/JTreeSelectedElementTest.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -3631,1 +3631,1 @@\n-    static void IS_DEFAULTMaskedByte128VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_DEFAULTMaskedByte128VectorTests(IntFunction<byte[]> fa,\n@@ -3637,3 +3637,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3641,3 +3642,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3669,1 +3671,1 @@\n-    static void IS_NEGATIVEMaskedByte128VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_NEGATIVEMaskedByte128VectorTests(IntFunction<byte[]> fa,\n@@ -3675,3 +3677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3679,3 +3682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3631,1 +3631,1 @@\n-    static void IS_DEFAULTMaskedByte256VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_DEFAULTMaskedByte256VectorTests(IntFunction<byte[]> fa,\n@@ -3637,3 +3637,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3641,3 +3642,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3669,1 +3671,1 @@\n-    static void IS_NEGATIVEMaskedByte256VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_NEGATIVEMaskedByte256VectorTests(IntFunction<byte[]> fa,\n@@ -3675,3 +3677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3679,3 +3682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3631,1 +3631,1 @@\n-    static void IS_DEFAULTMaskedByte512VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_DEFAULTMaskedByte512VectorTests(IntFunction<byte[]> fa,\n@@ -3637,3 +3637,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3641,3 +3642,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3669,1 +3671,1 @@\n-    static void IS_NEGATIVEMaskedByte512VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_NEGATIVEMaskedByte512VectorTests(IntFunction<byte[]> fa,\n@@ -3675,3 +3677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3679,3 +3682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3631,1 +3631,1 @@\n-    static void IS_DEFAULTMaskedByte64VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_DEFAULTMaskedByte64VectorTests(IntFunction<byte[]> fa,\n@@ -3637,3 +3637,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3641,3 +3642,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3669,1 +3671,1 @@\n-    static void IS_NEGATIVEMaskedByte64VectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_NEGATIVEMaskedByte64VectorTests(IntFunction<byte[]> fa,\n@@ -3675,3 +3677,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3679,3 +3682,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3636,1 +3636,1 @@\n-    static void IS_DEFAULTMaskedByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_DEFAULTMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n@@ -3642,3 +3642,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3646,3 +3647,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3674,1 +3676,1 @@\n-    static void IS_NEGATIVEMaskedByteMaxVectorTestsSmokeTest(IntFunction<byte[]> fa,\n+    static void IS_NEGATIVEMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n@@ -3680,3 +3682,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n-            VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                VectorMask<Byte> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3684,3 +3687,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2628,1 +2628,1 @@\n-    static void IS_DEFAULTMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_DEFAULTMaskedDouble128VectorTests(IntFunction<double[]> fa,\n@@ -2634,3 +2634,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2638,3 +2639,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2666,1 +2668,1 @@\n-    static void IS_NEGATIVEMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NEGATIVEMaskedDouble128VectorTests(IntFunction<double[]> fa,\n@@ -2672,3 +2674,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2676,3 +2679,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2705,1 +2709,1 @@\n-    static void IS_FINITEMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_FINITEMaskedDouble128VectorTests(IntFunction<double[]> fa,\n@@ -2711,3 +2715,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2715,3 +2720,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2745,1 +2751,1 @@\n-    static void IS_NANMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NANMaskedDouble128VectorTests(IntFunction<double[]> fa,\n@@ -2751,3 +2757,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2755,3 +2762,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2785,1 +2793,1 @@\n-    static void IS_INFINITEMaskedDouble128VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_INFINITEMaskedDouble128VectorTests(IntFunction<double[]> fa,\n@@ -2791,3 +2799,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2795,3 +2804,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2628,1 +2628,1 @@\n-    static void IS_DEFAULTMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_DEFAULTMaskedDouble256VectorTests(IntFunction<double[]> fa,\n@@ -2634,3 +2634,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2638,3 +2639,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2666,1 +2668,1 @@\n-    static void IS_NEGATIVEMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NEGATIVEMaskedDouble256VectorTests(IntFunction<double[]> fa,\n@@ -2672,3 +2674,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2676,3 +2679,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2705,1 +2709,1 @@\n-    static void IS_FINITEMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_FINITEMaskedDouble256VectorTests(IntFunction<double[]> fa,\n@@ -2711,3 +2715,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2715,3 +2720,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2745,1 +2751,1 @@\n-    static void IS_NANMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NANMaskedDouble256VectorTests(IntFunction<double[]> fa,\n@@ -2751,3 +2757,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2755,3 +2762,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2785,1 +2793,1 @@\n-    static void IS_INFINITEMaskedDouble256VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_INFINITEMaskedDouble256VectorTests(IntFunction<double[]> fa,\n@@ -2791,3 +2799,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2795,3 +2804,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2628,1 +2628,1 @@\n-    static void IS_DEFAULTMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_DEFAULTMaskedDouble512VectorTests(IntFunction<double[]> fa,\n@@ -2634,3 +2634,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2638,3 +2639,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2666,1 +2668,1 @@\n-    static void IS_NEGATIVEMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NEGATIVEMaskedDouble512VectorTests(IntFunction<double[]> fa,\n@@ -2672,3 +2674,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2676,3 +2679,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2705,1 +2709,1 @@\n-    static void IS_FINITEMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_FINITEMaskedDouble512VectorTests(IntFunction<double[]> fa,\n@@ -2711,3 +2715,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2715,3 +2720,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2745,1 +2751,1 @@\n-    static void IS_NANMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NANMaskedDouble512VectorTests(IntFunction<double[]> fa,\n@@ -2751,3 +2757,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2755,3 +2762,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2785,1 +2793,1 @@\n-    static void IS_INFINITEMaskedDouble512VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_INFINITEMaskedDouble512VectorTests(IntFunction<double[]> fa,\n@@ -2791,3 +2799,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2795,3 +2804,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2628,1 +2628,1 @@\n-    static void IS_DEFAULTMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_DEFAULTMaskedDouble64VectorTests(IntFunction<double[]> fa,\n@@ -2634,3 +2634,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2638,3 +2639,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2666,1 +2668,1 @@\n-    static void IS_NEGATIVEMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NEGATIVEMaskedDouble64VectorTests(IntFunction<double[]> fa,\n@@ -2672,3 +2674,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2676,3 +2679,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2705,1 +2709,1 @@\n-    static void IS_FINITEMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_FINITEMaskedDouble64VectorTests(IntFunction<double[]> fa,\n@@ -2711,3 +2715,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2715,3 +2720,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2745,1 +2751,1 @@\n-    static void IS_NANMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NANMaskedDouble64VectorTests(IntFunction<double[]> fa,\n@@ -2751,3 +2757,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2755,3 +2762,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2785,1 +2793,1 @@\n-    static void IS_INFINITEMaskedDouble64VectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_INFINITEMaskedDouble64VectorTests(IntFunction<double[]> fa,\n@@ -2791,3 +2799,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2795,3 +2804,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2633,1 +2633,1 @@\n-    static void IS_DEFAULTMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_DEFAULTMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n@@ -2639,3 +2639,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2643,3 +2644,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2671,1 +2673,1 @@\n-    static void IS_NEGATIVEMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NEGATIVEMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n@@ -2677,3 +2679,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2681,3 +2684,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2710,1 +2714,1 @@\n-    static void IS_FINITEMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_FINITEMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n@@ -2716,3 +2720,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2720,3 +2725,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2750,1 +2756,1 @@\n-    static void IS_NANMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_NANMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n@@ -2756,3 +2762,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2760,3 +2767,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2790,1 +2798,1 @@\n-    static void IS_INFINITEMaskedDoubleMaxVectorTestsSmokeTest(IntFunction<double[]> fa,\n+    static void IS_INFINITEMaskedDoubleMaxVectorTests(IntFunction<double[]> fa,\n@@ -2796,3 +2804,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n-            VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                VectorMask<Double> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2800,3 +2809,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2638,1 +2638,1 @@\n-    static void IS_DEFAULTMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_DEFAULTMaskedFloat128VectorTests(IntFunction<float[]> fa,\n@@ -2644,3 +2644,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2648,3 +2649,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2676,1 +2678,1 @@\n-    static void IS_NEGATIVEMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NEGATIVEMaskedFloat128VectorTests(IntFunction<float[]> fa,\n@@ -2682,3 +2684,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2686,3 +2689,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2715,1 +2719,1 @@\n-    static void IS_FINITEMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_FINITEMaskedFloat128VectorTests(IntFunction<float[]> fa,\n@@ -2721,3 +2725,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2725,3 +2730,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2755,1 +2761,1 @@\n-    static void IS_NANMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NANMaskedFloat128VectorTests(IntFunction<float[]> fa,\n@@ -2761,3 +2767,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2765,3 +2772,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2795,1 +2803,1 @@\n-    static void IS_INFINITEMaskedFloat128VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_INFINITEMaskedFloat128VectorTests(IntFunction<float[]> fa,\n@@ -2801,3 +2809,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2805,3 +2814,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2638,1 +2638,1 @@\n-    static void IS_DEFAULTMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_DEFAULTMaskedFloat256VectorTests(IntFunction<float[]> fa,\n@@ -2644,3 +2644,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2648,3 +2649,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2676,1 +2678,1 @@\n-    static void IS_NEGATIVEMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NEGATIVEMaskedFloat256VectorTests(IntFunction<float[]> fa,\n@@ -2682,3 +2684,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2686,3 +2689,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2715,1 +2719,1 @@\n-    static void IS_FINITEMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_FINITEMaskedFloat256VectorTests(IntFunction<float[]> fa,\n@@ -2721,3 +2725,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2725,3 +2730,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2755,1 +2761,1 @@\n-    static void IS_NANMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NANMaskedFloat256VectorTests(IntFunction<float[]> fa,\n@@ -2761,3 +2767,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2765,3 +2772,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2795,1 +2803,1 @@\n-    static void IS_INFINITEMaskedFloat256VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_INFINITEMaskedFloat256VectorTests(IntFunction<float[]> fa,\n@@ -2801,3 +2809,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2805,3 +2814,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2638,1 +2638,1 @@\n-    static void IS_DEFAULTMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_DEFAULTMaskedFloat512VectorTests(IntFunction<float[]> fa,\n@@ -2644,3 +2644,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2648,3 +2649,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2676,1 +2678,1 @@\n-    static void IS_NEGATIVEMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NEGATIVEMaskedFloat512VectorTests(IntFunction<float[]> fa,\n@@ -2682,3 +2684,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2686,3 +2689,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2715,1 +2719,1 @@\n-    static void IS_FINITEMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_FINITEMaskedFloat512VectorTests(IntFunction<float[]> fa,\n@@ -2721,3 +2725,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2725,3 +2730,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2755,1 +2761,1 @@\n-    static void IS_NANMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NANMaskedFloat512VectorTests(IntFunction<float[]> fa,\n@@ -2761,3 +2767,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2765,3 +2772,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2795,1 +2803,1 @@\n-    static void IS_INFINITEMaskedFloat512VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_INFINITEMaskedFloat512VectorTests(IntFunction<float[]> fa,\n@@ -2801,3 +2809,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2805,3 +2814,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2638,1 +2638,1 @@\n-    static void IS_DEFAULTMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_DEFAULTMaskedFloat64VectorTests(IntFunction<float[]> fa,\n@@ -2644,3 +2644,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2648,3 +2649,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2676,1 +2678,1 @@\n-    static void IS_NEGATIVEMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NEGATIVEMaskedFloat64VectorTests(IntFunction<float[]> fa,\n@@ -2682,3 +2684,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2686,3 +2689,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2715,1 +2719,1 @@\n-    static void IS_FINITEMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_FINITEMaskedFloat64VectorTests(IntFunction<float[]> fa,\n@@ -2721,3 +2725,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2725,3 +2730,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2755,1 +2761,1 @@\n-    static void IS_NANMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NANMaskedFloat64VectorTests(IntFunction<float[]> fa,\n@@ -2761,3 +2767,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2765,3 +2772,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2795,1 +2803,1 @@\n-    static void IS_INFINITEMaskedFloat64VectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_INFINITEMaskedFloat64VectorTests(IntFunction<float[]> fa,\n@@ -2801,3 +2809,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2805,3 +2814,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2643,1 +2643,1 @@\n-    static void IS_DEFAULTMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_DEFAULTMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n@@ -2649,3 +2649,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -2653,3 +2654,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -2681,1 +2683,1 @@\n-    static void IS_NEGATIVEMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NEGATIVEMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n@@ -2687,3 +2689,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -2691,3 +2694,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n@@ -2720,1 +2724,1 @@\n-    static void IS_FINITEMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_FINITEMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n@@ -2726,3 +2730,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_FINITE, vmask);\n@@ -2730,3 +2735,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n@@ -2760,1 +2766,1 @@\n-    static void IS_NANMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_NANMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n@@ -2766,3 +2772,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_NAN, vmask);\n@@ -2770,3 +2777,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n@@ -2800,1 +2808,1 @@\n-    static void IS_INFINITEMaskedFloatMaxVectorTestsSmokeTest(IntFunction<float[]> fa,\n+    static void IS_INFINITEMaskedFloatMaxVectorTests(IntFunction<float[]> fa,\n@@ -2806,3 +2814,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n-            VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                VectorMask<Float> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n@@ -2810,3 +2819,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":45,"deletions":35,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -3593,1 +3593,1 @@\n-    static void IS_DEFAULTMaskedInt128VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_DEFAULTMaskedInt128VectorTests(IntFunction<int[]> fa,\n@@ -3599,3 +3599,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3603,3 +3604,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3631,1 +3633,1 @@\n-    static void IS_NEGATIVEMaskedInt128VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_NEGATIVEMaskedInt128VectorTests(IntFunction<int[]> fa,\n@@ -3637,3 +3639,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3641,3 +3644,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3593,1 +3593,1 @@\n-    static void IS_DEFAULTMaskedInt256VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_DEFAULTMaskedInt256VectorTests(IntFunction<int[]> fa,\n@@ -3599,3 +3599,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3603,3 +3604,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3631,1 +3633,1 @@\n-    static void IS_NEGATIVEMaskedInt256VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_NEGATIVEMaskedInt256VectorTests(IntFunction<int[]> fa,\n@@ -3637,3 +3639,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3641,3 +3644,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3593,1 +3593,1 @@\n-    static void IS_DEFAULTMaskedInt512VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_DEFAULTMaskedInt512VectorTests(IntFunction<int[]> fa,\n@@ -3599,3 +3599,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3603,3 +3604,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3631,1 +3633,1 @@\n-    static void IS_NEGATIVEMaskedInt512VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_NEGATIVEMaskedInt512VectorTests(IntFunction<int[]> fa,\n@@ -3637,3 +3639,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3641,3 +3644,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3593,1 +3593,1 @@\n-    static void IS_DEFAULTMaskedInt64VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_DEFAULTMaskedInt64VectorTests(IntFunction<int[]> fa,\n@@ -3599,3 +3599,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3603,3 +3604,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3631,1 +3633,1 @@\n-    static void IS_NEGATIVEMaskedInt64VectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_NEGATIVEMaskedInt64VectorTests(IntFunction<int[]> fa,\n@@ -3637,3 +3639,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3641,3 +3644,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3598,1 +3598,1 @@\n-    static void IS_DEFAULTMaskedIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_DEFAULTMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n@@ -3604,3 +3604,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3608,3 +3609,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3636,1 +3638,1 @@\n-    static void IS_NEGATIVEMaskedIntMaxVectorTestsSmokeTest(IntFunction<int[]> fa,\n+    static void IS_NEGATIVEMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n@@ -3642,3 +3644,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            IntVector av = IntVector.fromArray(SPECIES, a, i);\n-            VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                VectorMask<Integer> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3646,3 +3649,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3615,1 +3615,1 @@\n-    static void IS_DEFAULTMaskedLong128VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_DEFAULTMaskedLong128VectorTests(IntFunction<long[]> fa,\n@@ -3621,3 +3621,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3625,3 +3626,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3653,1 +3655,1 @@\n-    static void IS_NEGATIVEMaskedLong128VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_NEGATIVEMaskedLong128VectorTests(IntFunction<long[]> fa,\n@@ -3659,3 +3661,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3663,3 +3666,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3615,1 +3615,1 @@\n-    static void IS_DEFAULTMaskedLong256VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_DEFAULTMaskedLong256VectorTests(IntFunction<long[]> fa,\n@@ -3621,3 +3621,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3625,3 +3626,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3653,1 +3655,1 @@\n-    static void IS_NEGATIVEMaskedLong256VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_NEGATIVEMaskedLong256VectorTests(IntFunction<long[]> fa,\n@@ -3659,3 +3661,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3663,3 +3666,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3615,1 +3615,1 @@\n-    static void IS_DEFAULTMaskedLong512VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_DEFAULTMaskedLong512VectorTests(IntFunction<long[]> fa,\n@@ -3621,3 +3621,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3625,3 +3626,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3653,1 +3655,1 @@\n-    static void IS_NEGATIVEMaskedLong512VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_NEGATIVEMaskedLong512VectorTests(IntFunction<long[]> fa,\n@@ -3659,3 +3661,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3663,3 +3666,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3615,1 +3615,1 @@\n-    static void IS_DEFAULTMaskedLong64VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_DEFAULTMaskedLong64VectorTests(IntFunction<long[]> fa,\n@@ -3621,3 +3621,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3625,3 +3626,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3653,1 +3655,1 @@\n-    static void IS_NEGATIVEMaskedLong64VectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_NEGATIVEMaskedLong64VectorTests(IntFunction<long[]> fa,\n@@ -3659,3 +3661,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3663,3 +3666,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3620,1 +3620,1 @@\n-    static void IS_DEFAULTMaskedLongMaxVectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_DEFAULTMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n@@ -3626,3 +3626,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3630,3 +3631,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3658,1 +3660,1 @@\n-    static void IS_NEGATIVEMaskedLongMaxVectorTestsSmokeTest(IntFunction<long[]> fa,\n+    static void IS_NEGATIVEMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n@@ -3664,3 +3666,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            LongVector av = LongVector.fromArray(SPECIES, a, i);\n-            VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                VectorMask<Long> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3668,3 +3671,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3622,1 +3622,1 @@\n-    static void IS_DEFAULTMaskedShort128VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_DEFAULTMaskedShort128VectorTests(IntFunction<short[]> fa,\n@@ -3628,3 +3628,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3632,3 +3633,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3660,1 +3662,1 @@\n-    static void IS_NEGATIVEMaskedShort128VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_NEGATIVEMaskedShort128VectorTests(IntFunction<short[]> fa,\n@@ -3666,3 +3668,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3670,3 +3673,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3622,1 +3622,1 @@\n-    static void IS_DEFAULTMaskedShort256VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_DEFAULTMaskedShort256VectorTests(IntFunction<short[]> fa,\n@@ -3628,3 +3628,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3632,3 +3633,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3660,1 +3662,1 @@\n-    static void IS_NEGATIVEMaskedShort256VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_NEGATIVEMaskedShort256VectorTests(IntFunction<short[]> fa,\n@@ -3666,3 +3668,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3670,3 +3673,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3622,1 +3622,1 @@\n-    static void IS_DEFAULTMaskedShort512VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_DEFAULTMaskedShort512VectorTests(IntFunction<short[]> fa,\n@@ -3628,3 +3628,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3632,3 +3633,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3660,1 +3662,1 @@\n-    static void IS_NEGATIVEMaskedShort512VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_NEGATIVEMaskedShort512VectorTests(IntFunction<short[]> fa,\n@@ -3666,3 +3668,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3670,3 +3673,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3622,1 +3622,1 @@\n-    static void IS_DEFAULTMaskedShort64VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_DEFAULTMaskedShort64VectorTests(IntFunction<short[]> fa,\n@@ -3628,3 +3628,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3632,3 +3633,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3660,1 +3662,1 @@\n-    static void IS_NEGATIVEMaskedShort64VectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_NEGATIVEMaskedShort64VectorTests(IntFunction<short[]> fa,\n@@ -3666,3 +3668,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3670,3 +3673,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3627,1 +3627,1 @@\n-    static void IS_DEFAULTMaskedShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_DEFAULTMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n@@ -3633,3 +3633,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n@@ -3637,3 +3638,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n@@ -3665,1 +3667,1 @@\n-    static void IS_NEGATIVEMaskedShortMaxVectorTestsSmokeTest(IntFunction<short[]> fa,\n+    static void IS_NEGATIVEMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n@@ -3671,3 +3673,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-            VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                VectorMask<Short> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n@@ -3675,3 +3678,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Compare.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -51,1 +50,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-CompressExpand.template","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-op.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-    static void [[TEST]]Masked$vectorteststype$SmokeTest(IntFunction<$type$[]> fa,\n+    static void [[TEST]]Masked$vectorteststype$(IntFunction<$type$[]> fa,\n@@ -29,3 +29,4 @@\n-        for (int i = 0; i < a.length; i += SPECIES.length()) {\n-            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n-            VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.[[TEST]], vmask);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.[[TEST]], vmask);\n@@ -33,3 +34,4 @@\n-            \/\/ Check results as part of computation.\n-            for (int j = 0; j < SPECIES.length(); j++) {\n-                Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && test[[TEST]](a[i + j]));\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && test[[TEST]](a[i + j]));\n+                }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Test.template","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        test.load(true);\n+        test.loadTestLibrary();\n@@ -60,1 +60,4 @@\n-        test.load(System.mapLibraryName(\"zip\"));\n+        test.load(System.mapLibraryName(\"zip\"), true \/* succeed *\/);\n+\n+        \/\/ load non-existent library\n+        test.load(System.mapLibraryName(\"NotExist\"), false \/* fail to load *\/);\n","filename":"test\/jdk\/jdk\/internal\/loader\/NativeLibraries\/Main.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        load(true); \/\/ expect loading of native library succeed\n+        loadTestLibrary(); \/\/ expect loading of native library succeed\n@@ -104,1 +104,1 @@\n-    public void load(boolean succeed) {\n+    public void loadTestLibrary() {\n@@ -106,5 +106,1 @@\n-        if (succeed) {\n-            assertTrue(nl != null, \"fail to load library\");\n-        } else {\n-            assertTrue(nl == null, \"load library should fail\");\n-        }\n+        assertTrue(nl != null, \"fail to load \" + libraryPath());\n@@ -113,1 +109,1 @@\n-    public void load(String pathname) {\n+    public void load(String pathname, boolean succeed) {\n@@ -115,1 +111,5 @@\n-        assertTrue(nl != null, \"fail to load zip library\");\n+        if (succeed) {\n+            assertTrue(nl != null, \"fail to load \" + pathname);\n+        } else {\n+            assertTrue(nl == null, \"expect to return null for \" + pathname);\n+        }\n","filename":"test\/jdk\/jdk\/internal\/loader\/NativeLibraries\/java.base\/jdk\/internal\/loader\/NativeLibrariesTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-               r2.dump(twoEventTypes);;\n+               r2.dump(twoEventTypes);\n@@ -201,1 +201,1 @@\n-           r1.dump(threeEventTypes);;\n+           r1.dump(threeEventTypes);\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestRecordingFile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.consumer;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.Name;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.jfr.Event;\n+\n+\/**\n+ * @test\n+ * @summary Verifies that all traces of sensitive data is removed\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.api.consumer.TestRecordingFileSanitization\n+ *\/\n+public class TestRecordingFileSanitization {\n+    \/\/ Less than 16 characters, stored in event\n+    private final static String SHORT_PASSWORD = \"abcde123\";\n+    \/\/ More than 16 characters, stored in constant pool\n+    private final static String LONG_PASSWORD = \"abcdefghijklmnopqrstuvxyz1234567890\";\n+\n+    @Name(\"Sensitive\")\n+    public static class SensitiveEvent extends Event {\n+        String shortPassword;\n+        String longPassword;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        Path sensitive = Path.of(\"sensitive.jfr\");\n+        Path sanitized = Path.of(\"sanitized.jfr\");\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            SensitiveEvent e = new SensitiveEvent();\n+            e.shortPassword = SHORT_PASSWORD;\n+            e.longPassword = LONG_PASSWORD;\n+            e.commit();\n+            r.stop();\n+            r.dump(sensitive);\n+        }\n+        try (RecordingFile r = new RecordingFile(sensitive)) {\n+            r.write(sanitized, e -> !e.getEventType().getName().equals(\"Sensitive\"));\n+        }\n+\n+        expect(sensitive, SHORT_PASSWORD);\n+        expect(sensitive, LONG_PASSWORD);\n+        missing(sanitized, SHORT_PASSWORD);\n+        missing(sanitized, LONG_PASSWORD);\n+    }\n+\n+    private static void expect(Path file, String text) throws IOException {\n+        if (!find(file, text)) {\n+            throw new AssertionError(\"Expected to find '\" + text +\"' in \" + file);\n+        }\n+        System.out.println(\"OK, found '\" + text + \"' in \" + file );\n+    }\n+\n+    private static void missing(Path file, String text) throws IOException {\n+        if (find(file, text)) {\n+            throw new AssertionError(\"Didn't expect to find '\" + text +\"' in \" + file);\n+        }\n+        System.out.println(\"OK, missing '\" + text + \"' in \" + file);\n+    }\n+\n+    private static boolean find(Path file, String text) throws IOException {\n+        byte[] textBytes = stringToBytes(text);\n+        byte[] fileBytes = Files.readAllBytes(file);\n+        for (int i = 0; i < fileBytes.length - textBytes.length; i++) {\n+            if (find(fileBytes, i, textBytes)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean find(byte[] haystack, int start, byte[] needle) {\n+        for (int i = 0; i < needle.length; i++) {\n+            if (haystack[start + i] != needle[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static byte[] stringToBytes(String text) {\n+        byte[] bytes = new byte[text.length()];\n+        for (int i = 0; i < text.length(); i++) {\n+            if (text.charAt(i) > 127) {\n+                throw new Error(\"Test only allows characters that becomes one byte with LEB128\");\n+            }\n+            bytes[i] = (byte)(text.charAt(i));\n+        }\n+        return bytes;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestRecordingFileSanitization.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.consumer;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n+import java.util.Random;\n+\n+import jdk.jfr.Configuration;\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+\/**\n+ * @test\n+ * @summary Tests RecordingFile::write(Path, Predicate<RecordedEvent>)\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.api.consumer.TestRecordingFileWrite\n+ *\/\n+public class TestRecordingFileWrite {\n+\n+    static class ScrubEvent extends Event {\n+        long id;\n+        String message;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        Path scrubbed = Paths.get(\"scrubbed.jfr\");\n+        Path original = Paths.get(\"original.jfr\");\n+\n+        createRecording(original);\n+        Queue<String> ids = scrubRecording(original, scrubbed);\n+        System.out.println(\"Original size: \" + Files.size(original));\n+        System.out.println(\"Scrubbed size: \" + Files.size(scrubbed));\n+        System.out.println(\"Scrubbed event count: \" + ids.size());\n+        if (ids.size() < 50_000) {\n+            throw new AssertionError(\"Expected at least 50 000 events to be included\");\n+        }\n+        verify(scrubbed, ids);\n+    }\n+\n+    private static void verify(Path scrubbed, Queue<String> events) throws Exception {\n+        try (RecordingFile rf = new RecordingFile(scrubbed)) {\n+            while (rf.hasMoreEvents()) {\n+                String event = rf.readEvent().toString();\n+                String expected = events.poll();\n+                if (!event.equals(expected)) {\n+                    System.out.println(\"Found:\");\n+                    System.out.println(event);\n+                    System.out.println(\"Expected:\");\n+                    System.out.println(expected);\n+                    throw new Exception(\"Found event that should not be there. See log\");\n+                }\n+            }\n+        }\n+        if (!events.isEmpty()) {\n+            throw new AssertionError(\"Missing events \" + events);\n+        }\n+    }\n+\n+    private static Queue<String> scrubRecording(Path original, Path scrubbed) throws IOException {\n+        Queue<String> events = new ArrayDeque<>(150_000);\n+        Random random = new Random();\n+        try (RecordingFile rf = new RecordingFile(original)) {\n+            rf.write(scrubbed, event -> {\n+                boolean keep = random.nextInt(10) == 0;\n+                if (event.getEventType().getName().equals(\"jdk.OldObjectSample\")) {\n+                    System.out.println(event);\n+                    keep = true;\n+                }\n+                if (keep) {\n+                    events.add(event.toString());\n+                }\n+                return keep;\n+            });\n+        }\n+        return events;\n+    }\n+\n+    private static void createRecording(Path file) throws Exception {\n+        \/\/ Use profile configuration so more complex data structures\n+        \/\/ are serialized\n+        Configuration c = Configuration.getConfiguration(\"profile\");\n+        try (Recording r = new Recording(c)) {\n+            r.start();\n+            String s = \"A\";\n+            \/\/ Generate sufficient number of events to provoke\n+            \/\/ chunk rotations\n+            for (int i = 0; i < 1_000_000; i++) {\n+                ScrubEvent event = new ScrubEvent();\n+                event.message = s.repeat(i % 30);\n+                event.id = i;\n+                event.commit();\n+            }\n+            r.stop();\n+            r.dump(file);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestRecordingFileWrite.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -92,1 +92,1 @@\n-                        success.set(true);;\n+                        success.set(true);\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/filestream\/TestReuse.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-            CommonHelper.waitForSystemCurrentMillisToChange();;\n+            CommonHelper.waitForSystemCurrentMillisToChange();\n@@ -113,1 +113,1 @@\n-            CommonHelper.waitForSystemCurrentMillisToChange();;\n+            CommonHelper.waitForSystemCurrentMillisToChange();\n","filename":"test\/jdk\/jdk\/jfr\/api\/recording\/event\/TestEventTime.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-        testDefaultSettings();;\n-        testProfileSettings();;\n+        testDefaultSettings();\n+        testProfileSettings();\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestActiveSettingEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.Event;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.internal.test.WhiteBox;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import jdk.jfr.Configuration;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @run main\/othervm -XX:TLABSize=2k jdk.jfr.jvm.TestWaste\n+ *\/\n+public class TestWaste {\n+    static List<Object> list = new LinkedList<>();\n+    static Random random = new Random();\n+\n+    public static void main(String... args) throws Exception {\n+        WhiteBox.setWriteAllObjectSamples(true);\n+        Configuration c = Configuration.getConfiguration(\"profile\");\n+        Path file = Path.of(\"recording.jfr\");\n+        Path scrubbed = Path.of(\"scrubbed.jfr\");\n+        try (Recording r = new Recording(c)) {\n+            \/\/ Old objects that are cleared out should not create waste\n+            r.enable(\"jdk.OldObjectSample\")\n+             .with(\"cutoff\", \"infinity\")\n+             .withStackTrace();\n+            \/\/ No stack trace waste from allocation sample\n+            r.enable(\"jdk.ObjectAllocationSample\")\n+             .with(\"throttle\", \"1000\/s\")\n+             .withoutStackTrace();\n+            \/\/ Unused threads should not create unreasonable amount of waste\n+            r.disable(\"jdk.ThreadStart\");\n+            r.disable(\"jdk.ThreadStop\");\n+            \/\/ jdk.GCPhaseParallel can often, but not always, take up a very\n+            \/\/ large part of the recording. Disable to make test more stable\n+            r.disable(\"jdk.GCPhaseParallel\");\n+            r.start();\n+            \/\/ Generate data\n+            for (int i = 0; i < 5_000_000; i++) {\n+                foo(50);\n+                if (i % 3_000_000 == 0) {\n+                    System.gc();\n+                }\n+                if (i % 10_000 == 0) {\n+                    Thread t = new Thread();\n+                    t.start();\n+                }\n+            }\n+            r.stop();\n+            r.dump(file);\n+            final Map<String, Long> histogram = new HashMap<>();\n+            try (RecordingFile rf = new RecordingFile(file)) {\n+                rf.write(scrubbed, event -> {\n+                    String key = event.getEventType().getName();\n+                    histogram.merge(key, 1L, (x, y) -> x + y);\n+                    return true;\n+                });\n+            }\n+            for (var entry : histogram.entrySet()) {\n+                System.out.println(entry.getKey() + \" \" + entry.getValue());\n+            }\n+            float fileSize = Files.size(file);\n+            System.out.printf(\"File size: %.2f MB\\n\", fileSize \/ (1024 * 1024));\n+            float scrubbedSize = Files.size(scrubbed);\n+            System.out.printf(\"Scrubbed size: %.2f MB\\n\", scrubbedSize \/ (1024 * 1024));\n+            float waste = 1 - scrubbedSize \/ fileSize;\n+            System.out.printf(\"Waste: %.2f%%\\n\", 100 * waste);\n+            if (waste > 0.10) {\n+                throw new AssertionError(\"Found more than 10% waste\");\n+            }\n+        }\n+    }\n+\n+    static void foo(int depth) {\n+        bar(depth - 1);\n+    }\n+\n+    static void bar(int depth) {\n+        if (depth > 1) {\n+            if (random.nextBoolean()) {\n+                foo(depth);\n+            } else {\n+                bar(depth - 1);\n+            }\n+        } else {\n+            list.add(new String(\"hello\"));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestWaste.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.tool;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.jfr.Name;\n+import jdk.jfr.Recording;\n+import jdk.jfr.Category;\n+import jdk.jfr.Event;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+\/**\n+ * @test\n+ * @summary Test jfr scrub\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.tool.TestScrub\n+ *\/\n+public class TestScrub {\n+\n+    @Name(\"example.Tiger\")\n+    @Category(\"Mammal\")\n+    private static class TigerEvent extends Event {\n+    }\n+\n+    @Name(\"example.Zebra\")\n+    @Category(\"Mammal\")\n+\n+    private static class ZebraEvent extends Event {\n+    }\n+\n+    @Name(\"example.Tigerfish\")\n+    @Category(\"Fish\")\n+    private static class TigerfishEvent extends Event {\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        Path file = Path.of(\"recording.jfr\");\n+        Path autogenerated = Path.of(\"recording-scrubbed.jfr\");\n+\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            emit(100, \"India\", TigerEvent.class);\n+            emit(100, \"Namibia\", ZebraEvent.class);\n+            emit(10000, \"Lake Tanganyika\", TigerfishEvent.class);\n+            r.stop();\n+            r.dump(file);\n+        }\n+        testAutogeneratedFilename(file, autogenerated);\n+\n+        testEventInclude(file);\n+        testEventExclude(file);\n+        testEventMixedIncludeExclude(file);\n+\n+        testCategoryExclude(file);\n+        testCategoryInclude(file);\n+\n+        testThreadExclude(file);\n+        testThreadInclude(file);\n+    }\n+\n+    private static void testAutogeneratedFilename(Path file, Path autogenerated) throws Throwable {\n+        List<String> arguments = new ArrayList<>();\n+        arguments.add(\"scrub\");\n+        arguments.add(file.toAbsolutePath().toString());\n+        ExecuteHelper.jfr(arguments.toArray(String[]::new));\n+\n+        if (!Files.exists(autogenerated)) {\n+            throw new AssertionError(\"Expected to find auto-generated file \" + autogenerated);\n+        }\n+        Files.delete(autogenerated);\n+    }\n+\n+    private static void testEventInclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--include-events\", \"Zebra\")) {\n+            assertEvent(event, \"Zebra\");\n+            assertNotEvent(event, \"Tiger\", \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--include-events\", \"Tiger*\")) {\n+            assertEvent(event, \"Tiger\", \"Tigerfish\");\n+            assertNotEvent(event, \"Zebra\");\n+        }\n+        for (var event : scrub(file, \"--include-events\", \"Tiger,Zebra\")) {\n+            assertEvent(event, \"Tiger\", \"Zebra\");\n+            assertNotEvent(event, \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--include-events\", \"Tiger\", \"--include-events\", \"Zebra\")) {\n+            assertEvent(event, \"Tiger\", \"Zebra\");\n+            assertNotEvent(event, \"Tigerfish\");\n+        }\n+    }\n+\n+    private static void testEventExclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--exclude-events\", \"Zebra\")) {\n+            assertNotEvent(event, \"Zebra\");\n+            assertEvent(event, \"Tiger\", \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-events\", \"Tiger*\")) {\n+            assertEvent(event, \"Zebra\");\n+            assertNotEvent(event, \"Tiger\", \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-events\", \"Tiger,Zebra\")) {\n+            assertEvent(event, \"Tigerfish\");\n+            assertNotEvent(event, \"Tiger\", \"Zebra\");\n+        }\n+\n+        for (var event : scrub(file, \"--exclude-events\", \"Tiger\", \"--exclude-events\", \"Zebra\")) {\n+            assertEvent(event, \"Tigerfish\");\n+            assertNotEvent(event, \"Tiger\", \"Zebra\");\n+        }\n+    }\n+\n+    private static void testEventMixedIncludeExclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--include-events\", \"Tiger*\", \"--exclude-events\", \"Tigerfish\")) {\n+            assertNotEvent(event, \"Zebra\", \"Tigerfish\");\n+            assertEvent(event, \"Tiger\");\n+        }\n+        for (var event : scrub(file, \"--exclude-events\", \"Tiger*\", \"--include-events\", \"Tiger\")) {\n+            assertEvent(event, \"Zebra\", \"Tiger\");\n+            assertNotEvent(event, \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-events\", \"example.*\", \"--include-events\", \"example.*\")) {\n+            assertNotEvent(event, \"Tigerfish\", \"Tiger\", \"Zebra\");\n+        }\n+        for (var event : scrub(file, \"--include-events\", \"example.*\", \"--exclude-events\", \"example.*\")) {\n+            assertNotEvent(event, \"Tigerfish\", \"Tiger\", \"Zebra\");\n+        }\n+    }\n+\n+    private static void testCategoryInclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--include-categories\", \"Mammal\")) {\n+            assertEvent(event, \"Zebra\", \"Tiger\");\n+            assertNotEvent(event, \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--include-categories\", \"Sahara\")) {\n+            assertNotEvent(event, \"Tiger\", \"Tigerfish\", \"Zebra\");\n+        }\n+        for (var event : scrub(file, \"--include-categories\", \"Fish,Mammal\")) {\n+            assertEvent(event, \"Tiger\", \"Zebra\", \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--include-categories\", \"Mammal\", \"--include-categories\", \"Fish\")) {\n+            assertEvent(event, \"Tiger\", \"Zebra\", \"Tigerfish\");\n+        }\n+    }\n+\n+    private static void testCategoryExclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--exclude-categories\", \"Mammal\")) {\n+            assertNotEvent(event, \"Zebra\", \"Tiger\");\n+            assertEvent(event, \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-categories\", \"Mammal,Fish\")) {\n+            assertNotEvent(event, \"Zebra\", \"Tiger\", \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-categories\", \"Mammal\")) {\n+            assertNotEvent(event, \"Zebra\", \"Tiger\");\n+            assertEvent(event, \"Tigerfish\");\n+        }\n+        for (var event : scrub(file, \"--exclude-categories\", \"Mammal\")) {\n+            assertNotEvent(event, \"Zebra\", \"Tiger\");\n+            assertEvent(event, \"Tigerfish\");\n+        }\n+    }\n+\n+    private static void testThreadInclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--include-threads\", \"Namibia\")) {\n+            assertThread(event, \"Namibia\");\n+            assertNotThread(event, \"India\", \"Lake Tanganyika\");\n+        }\n+\n+        for (var event : scrub(file, \"--include-threads\", \"Nam*\")) {\n+            assertThread(event, \"Namibia\");\n+            assertNotThread(event, \"Lake Tanganyika\", \"India\");\n+        }\n+\n+        for (var event : scrub(file, \"--include-threads\", \"Namibia,Lake\")) {\n+            assertThread(event, \"Namibia\", \"Lake Tanganyika\");\n+            assertNotThread(event, \"India\");\n+        }\n+\n+        for (var event : scrub(file, \"--include-threads\", \"India\", \"--include-threads\", \"Lake Tanganyika\")) {\n+            assertThread(event, \"India\", \"Lake Tanganyika\");\n+            assertNotThread(event, \"Namibia\");\n+        }\n+    }\n+\n+    private static void testThreadExclude(Path file) throws Throwable {\n+        for (var event : scrub(file, \"--exclude-threads\", \"Namibia\")) {\n+            assertThread(event, \"India\", \"Lake Tanganyika\");\n+            assertNotThread(event, \"Namibia\");\n+        }\n+\n+        for (var event : scrub(file, \"--exclude-threads\", \"Nam*\")) {\n+            assertThread(event, \"Lake Tanganyika\", \"India\");\n+            assertNotThread(event, \"Namibia\");\n+        }\n+\n+        for (var event : scrub(file, \"--exclude-threads\", \"Namibia,Lake Tanganyika\")) {\n+            assertThread(event, \"India\");\n+            assertNotThread(event, \"Namibia\", \"Lake Tanganyika\");\n+        }\n+\n+        for (var event : scrub(file, \"--exclude-events\", \"India\", \"--include-events\", \"Lake Tanganyika\")) {\n+            assertThread(event, \"Namibia\");\n+            assertNotThread(event, \"India\", \"Lake Tanganyika\");\n+        }\n+    }\n+\n+    private static void assertNotThread(RecordedEvent event, String... threadNames) {\n+        String s = event.getThread().getJavaName();\n+        for (String threadName : threadNames) {\n+            if (threadName.equals(s)) {\n+                throw new AssertionError(\"Found unexpected thread\" + threadName);\n+            }\n+        }\n+    }\n+\n+    private static void assertThread(RecordedEvent event, String... threadNames) {\n+        String s = event.getThread().getJavaName();\n+        for (String threadName : threadNames) {\n+            if (threadName.equals(s)) {\n+                return;\n+            }\n+        }\n+        throw new AssertionError(\"Found unexpected thread\" + s);\n+    }\n+\n+    private static void assertNotEvent(RecordedEvent event, String... eventNames) {\n+        String s = event.getEventType().getName();\n+        for (String eventName : eventNames) {\n+            String n = \"example.\" + eventName;\n+            if (n.equals(s)) {\n+                throw new AssertionError(\"Found unexpected \" + eventName + \" event\");\n+            }\n+        }\n+    }\n+\n+    private static void assertEvent(RecordedEvent event, String... eventNames) {\n+        String s = event.getEventType().getName();\n+        for (String eventName : eventNames) {\n+            String n = \"example.\" + eventName;\n+            if (n.equals(s)) {\n+                return;\n+            }\n+        }\n+        throw new AssertionError(\"Found unexpected \" + s + \" event\");\n+    }\n+\n+    private static List<RecordedEvent> scrub(Path input, String... options) throws Throwable {\n+        Path output = Path.of(\"scrubbed.jfr\");\n+        List<String> arguments = new ArrayList<>();\n+        arguments.add(\"scrub\");\n+        arguments.addAll(Arrays.asList(options));\n+        arguments.add(input.toAbsolutePath().toString());\n+        arguments.add(output.toAbsolutePath().toString());\n+\n+        var outp = ExecuteHelper.jfr(arguments.toArray(String[]::new));\n+        System.out.println(outp.getStderr());\n+        System.out.println(outp.getStdout());\n+        List<RecordedEvent> events = RecordingFile.readAllEvents(output);\n+        Files.delete(output);\n+        return events;\n+    }\n+\n+    private static void emit(int count, String threadName, Class<? extends Event> eventClass) throws Throwable {\n+        Thread t = new Thread(() -> emitEvents(count, eventClass), threadName);\n+        t.start();\n+        t.join();\n+    }\n+\n+    private static void emitEvents(int count, Class<? extends Event> eventClass) {\n+        for (int i = 0; i < count; i++) {\n+            try {\n+                Event event = eventClass.getDeclaredConstructor().newInstance();\n+                event.commit();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestScrub.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, SAP SE. All rights reserved.\n+ * Copyright (c) 2019, 2022, SAP SE. All rights reserved.\n@@ -72,0 +72,1 @@\n+ * @summary Test POSIX ZIP file operations.\n@@ -76,1 +77,0 @@\n- * @summary Test POSIX zip file operations.\n@@ -531,3 +531,5 @@\n-        try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE_COPY, ENV_DEFAULT)) {\n-            checkEntries(zip, checkExpects.noPermDataInZip);\n-        }\n+        if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\"))\n+            try (FileSystem zip = FileSystems.newFileSystem(ZIP_FILE_COPY,\n+                ENV_DEFAULT)) {\n+                checkEntries(zip, checkExpects.noPermDataInZip);\n+            }\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestPosix.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+    permission java.lang.RuntimePermission \"accessUserInformation\";\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/test.policy","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -8,0 +8,1 @@\n+    permission java.lang.RuntimePermission \"accessUserInformation\";\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/test.policy.posix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    public static final String PLAIN_TOOLTIP_COMP_TITLE = resourceManager.getString(\"ToolTipDemo.plain\");;\n+    public static final String PLAIN_TOOLTIP_COMP_TITLE = resourceManager.getString(\"ToolTipDemo.plain\");\n@@ -63,1 +63,1 @@\n-    public static final String HTML_TOOLTIP_COMP_TITLE = resourceManager.getString(\"ToolTipDemo.html\");;\n+    public static final String HTML_TOOLTIP_COMP_TITLE = resourceManager.getString(\"ToolTipDemo.html\");\n","filename":"test\/jdk\/sanity\/client\/lib\/SwingSet3\/src\/com\/sun\/swingset3\/demos\/tooltip\/ToolTipDemo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8275715\n+ * @summary Tests that paint method is not called twice\n+ * @run main\/othervm MultiPaintEventTest\n+ *\/\n+\n+import java.awt.*;\n+\n+public class MultiPaintEventTest extends Canvas {\n+\n+    private int count = 0;\n+    private final Object lock = new Object();\n+\n+    public void paint(Graphics g) {\n+        synchronized(lock) {\n+            count++;\n+        }\n+\n+        int w = getWidth();\n+        int h = getHeight();\n+\n+        Graphics2D g2d = (Graphics2D)g;\n+        if (count % 2 == 1) {\n+            g2d.setColor(Color.green);\n+        } else {\n+            g2d.setColor(Color.red);\n+        }\n+        g2d.fillRect(0, 0, w, h);\n+    }\n+\n+    public int getCount() {\n+        synchronized(lock) {\n+            return count;\n+        }\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(400, 400);\n+    }\n+\n+    public static void main(String[] args) {\n+        MultiPaintEventTest test = new MultiPaintEventTest();\n+        Frame frame = new Frame();\n+        frame.setUndecorated(true);\n+        frame.add(test);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+\n+        try {\n+            Thread.sleep(2000);\n+            if (test.getCount() > 1) {\n+                throw new RuntimeException(\"Processed unnecessary paint().\");\n+            }\n+        } catch (InterruptedException ex) {\n+            throw new RuntimeException(\"Failed: Interrupted\");\n+        } finally {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/DirectX\/MultiPaintEventTest\/MultiPaintEventTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -261,1 +261,1 @@\n-                                       cs.getMinValue(0);;\n+                                       cs.getMinValue(0);\n@@ -271,1 +271,1 @@\n-                                       cs.getMinValue(0);;\n+                                       cs.getMinValue(0);\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/ImageFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,4 +27,2 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/..\/sun\/net\/www\/httptest\/\n- * @build HttpCallback TestHttpServer ClosedChannelList HttpTransaction\n- * @run main AuthHeaderTest\n+ * @library \/test\/lib\n+ * @run main\/othervm AuthHeaderTest\n@@ -34,40 +32,20 @@\n-import java.io.*;\n-import java.net.*;\n-\n-public class AuthHeaderTest implements HttpCallback {\n-\n-    static int count = 0;\n-    static String authstring;\n-\n-    void errorReply (HttpTransaction req, String reply) throws IOException {\n-        req.addResponseHeader (\"Connection\", \"close\");\n-        req.addResponseHeader (\"Www-authenticate\", reply);\n-        req.sendResponse (401, \"Unauthorized\");\n-        req.orderlyClose();\n-    }\n-\n-    void okReply (HttpTransaction req) throws IOException {\n-        req.setResponseEntityBody (\"Hello .\");\n-        req.sendResponse (200, \"Ok\");\n-        req.orderlyClose();\n-    }\n-\n-    public void request (HttpTransaction req) {\n-        try {\n-            authstring = req.getRequestHeader (\"Authorization\");\n-            System.out.println (authstring);\n-            switch (count) {\n-            case 0:\n-                errorReply (req, \"Basic realm=\\\"wallyworld\\\"\");\n-                break;\n-            case 1:\n-                \/* client stores a username\/pw for wallyworld\n-                 *\/\n-                okReply (req);\n-                break;\n-            }\n-            count ++;\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.net.Authenticator;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.PasswordAuthentication;\n+import java.net.Proxy;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n+\n+public class AuthHeaderTest {\n+    static HttpServer server;\n@@ -94,2 +72,0 @@\n-    static TestHttpServer server;\n-\n@@ -101,3 +77,13 @@\n-            server = new TestHttpServer (new AuthHeaderTest(), 1, 10, loopback, 0);\n-            System.out.println (\"Server: listening on port: \" + server.getAuthority());\n-            client (\"http:\/\/\" + server.getAuthority() + \"\/d1\/foo.html\");\n+            server = HttpServer.create(new InetSocketAddress(loopback, 0), 10, \"\/\", new AuthHeaderTestHandler());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n+            System.out.println (\"Server: listening on port: \" + server.getAddress().getPort());\n+\n+            String serverURL = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(server.getAddress().getPort())\n+                    .path(\"\/\")\n+                    .build()\n+                    .toString();\n+            client (serverURL + \"d1\/foo.html\");\n@@ -106,1 +92,1 @@\n-                server.terminate();\n+                server.stop(1);\n@@ -114,1 +100,1 @@\n-        server.terminate();\n+        server.stop(1);\n@@ -118,1 +104,1 @@\n-        server.terminate();\n+        server.stop(1);\n@@ -141,0 +127,42 @@\n+\n+class AuthHeaderTestHandler implements HttpHandler {\n+    static int count = 0;\n+    static String authstring;\n+\n+    void errorReply (HttpExchange req, String reply) throws IOException {\n+        req.getResponseHeaders().set(\"Connection\", \"close\");\n+        req.getResponseHeaders().set(\"Www-authenticate\", reply);\n+        req.sendResponseHeaders(401, -1);\n+    }\n+\n+    void okReply (HttpExchange req) throws IOException {\n+        req.sendResponseHeaders (200, 0);\n+        try(PrintWriter pw = new PrintWriter(req.getResponseBody(), false, Charset.forName(\"UTF-8\"))) {\n+            pw.print(\"Hello .\");\n+        }\n+    }\n+\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        try {\n+            if(exchange.getRequestHeaders().get(\"Authorization\") != null) {\n+                authstring = exchange.getRequestHeaders().get(\"Authorization\").get(0);\n+                System.out.println (authstring);\n+            }\n+\n+            switch (count) {\n+                case 0:\n+                    errorReply (exchange, \"Basic realm=\\\"wallyworld\\\"\");\n+                    break;\n+                case 1:\n+                    \/* client stores a username\/pw for wallyworld\n+                     *\/\n+                    okReply (exchange);\n+                    break;\n+            }\n+            count ++;\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/net\/www\/AuthHeaderTest.java","additions":81,"deletions":53,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,4 +27,1 @@\n- * @modules java.base\/sun.net.www\n- *          java.management\n- * @library ..\/..\/httptest\/\n- * @build HttpCallback TestHttpServer HttpTransaction\n+ * @library \/test\/lib\n@@ -35,3 +32,12 @@\n-import java.net.*;\n-import java.io.*;\n-import java.lang.management.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n@@ -40,0 +46,5 @@\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -54,4 +65,2 @@\n-public class B5045306\n-{\n-    static SimpleHttpTransaction httpTrans;\n-    static TestHttpServer server;\n+public class B5045306 {\n+    static HttpServer server;\n@@ -59,1 +68,1 @@\n-    public static void main(String[] args) throws Exception {\n+    public static void main(String[] args) {\n@@ -66,2 +75,3 @@\n-            httpTrans = new SimpleHttpTransaction();\n-            server = new TestHttpServer(httpTrans, 1, 10, InetAddress.getLocalHost(), 0);\n+            server = HttpServer.create(new InetSocketAddress(InetAddress.getLocalHost(), 0), 10, \"\/\", new SimpleHttpTransactionHandler());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n@@ -79,1 +89,1 @@\n-            System.out.println(\"http server listen on: \" + server.getLocalPort());\n+            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n@@ -82,1 +92,1 @@\n-            String baseURLStr = \"http:\/\/\" + hostAddr + \":\" + server.getLocalPort() + \"\/\";\n+            String baseURLStr = \"http:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n@@ -101,1 +111,1 @@\n-            if (SimpleHttpTransaction.failed)\n+            if (SimpleHttpTransactionHandler.failed)\n@@ -140,1 +150,1 @@\n-            server.terminate();\n+            server.stop(1);\n@@ -148,1 +158,1 @@\n-class SimpleHttpTransaction implements HttpCallback\n+class SimpleHttpTransactionHandler implements HttpHandler\n@@ -150,1 +160,1 @@\n-    static boolean failed = false;\n+    static volatile boolean failed = false;\n@@ -158,1 +168,1 @@\n-    public void request(HttpTransaction trans) {\n+    public void handle(HttpExchange trans) {\n@@ -162,1 +172,1 @@\n-                port1 = trans.channel().socket().getPort();\n+                port1 = trans.getLocalAddress().getPort();\n@@ -168,2 +178,4 @@\n-                trans.setResponseEntityBody (responseBody, responseBody.length);\n-                trans.sendResponse(200, \"OK\");\n+                trans.sendResponseHeaders(200, 0);\n+                try(PrintWriter pw = new PrintWriter(trans.getResponseBody(), false, Charset.forName(\"UTF-8\"))) {\n+                    pw.print(responseBody);\n+                }\n@@ -171,1 +183,1 @@\n-                int port2 = trans.channel().socket().getPort();\n+                int port2 = trans.getLocalAddress().getPort();\n@@ -177,2 +189,0 @@\n-                trans.setResponseHeader (\"Content-length\", Integer.toString(0));\n-\n@@ -185,2 +195,1 @@\n-\n-                trans.sendResponse(200, \"OK\");\n+                trans.sendResponseHeaders(200, -1);\n@@ -192,2 +201,0 @@\n-                trans.setResponseEntityBody (responseBody, responseBody.length);\n-\n@@ -195,3 +202,4 @@\n-                trans.setResponseHeader(\"Content-length\", Integer.toString(responseBody.length+1));\n-                trans.sendResponse(200, \"OK\");\n-\n+                trans.sendResponseHeaders(200, responseBody.length+1);\n+                try(PrintWriter pw = new PrintWriter(trans.getResponseBody(), false, Charset.forName(\"UTF-8\"))) {\n+                    pw.print(responseBody);\n+                }\n@@ -199,1 +207,1 @@\n-                trans.channel().socket().close();\n+                trans.close();\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B5045306.java","additions":44,"deletions":36,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.util.*;\n-import java.io.IOException;\n-\n-\/**\n- * This class provides a partial implementation of the HttpCallback\n- * interface. Use this class if you want to use the requestURI as a means\n- * of tracking multiple invocations of a request (on the server).\n- * In this case, you implement the modified request() method, which includes\n- * an integer count parameter. This parameter indicates the number of times\n- * (starting at zero) the request URI has been received.\n- *\/\n-\n-public abstract class AbstractCallback implements HttpCallback {\n-\n-    Map requests;\n-\n-    static class Request {\n-        URI uri;\n-        int count;\n-\n-        Request (URI u) {\n-            uri = u;\n-            count = 0;\n-        }\n-    }\n-\n-    AbstractCallback () {\n-        requests = Collections.synchronizedMap (new HashMap());\n-    }\n-\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    public void request (HttpTransaction msg) {\n-        URI uri = msg.getRequestURI();\n-        Request req = (Request) requests.get (uri);\n-        if (req == null) {\n-            req = new Request (uri);\n-            requests.put (uri, req);\n-        }\n-        request (msg, req.count++);\n-    }\n-\n-    \/**\n-     * Same as HttpCallback interface except that the integer n\n-     * is provided to indicate sequencing of repeated requests using\n-     * the same request URI. n starts at zero and is incremented\n-     * for each successive call.\n-     *\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     * @param n value is 0 at first call, and is incremented by 1 for\n-     *        each subsequent call using the same request URI.\n-     *\/\n-    abstract public void request (HttpTransaction msg, int n);\n-}\n","filename":"test\/jdk\/sun\/net\/www\/httptest\/AbstractCallback.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.nio.channels.*;\n-import java.util.*;\n-\n-class ClosedChannelList {\n-\n-    static final long TIMEOUT = 10 * 1000; \/* 10 sec *\/\n-\n-    static class Element {\n-        long expiry;\n-        SelectionKey key;\n-        Element (long l, SelectionKey key) {\n-            expiry = l;\n-            this.key = key;\n-        }\n-    }\n-\n-    LinkedList list;\n-\n-    public ClosedChannelList () {\n-        list = new LinkedList ();\n-    }\n-\n-    \/* close chan after TIMEOUT milliseconds *\/\n-\n-    public synchronized void add (SelectionKey key) {\n-        long exp = System.currentTimeMillis () + TIMEOUT;\n-        list.add (new Element (exp, key));\n-    }\n-\n-    public synchronized void check () {\n-        check (false);\n-    }\n-\n-    public synchronized void terminate () {\n-        check (true);\n-    }\n-\n-    public synchronized void check (boolean forceClose) {\n-        Iterator iter = list.iterator ();\n-        long now = System.currentTimeMillis();\n-        while (iter.hasNext ()) {\n-            Element elm = (Element)iter.next();\n-            if (forceClose || elm.expiry <= now) {\n-                SelectionKey k = elm.key;\n-                try {\n-                    k.channel().close ();\n-                } catch (IOException e) {}\n-                k.cancel();\n-                iter.remove();\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/httptest\/ClosedChannelList.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This interface is implemented by classes that wish to handle incoming HTTP\n- * requests and generate responses. This could be a general purpose HTTP server\n- * or a test case that expects specific requests from a client.\n- * <p>\n- * The incoming request fields can be examined via the {@link HttpTransaction}\n- * object, and a response can also be generated and sent via the request object.\n- *\/\n-public interface HttpCallback {\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    void request (HttpTransaction msg);\n-}\n","filename":"test\/jdk\/sun\/net\/www\/httptest\/HttpCallback.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,330 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import java.net.*;\n-import sun.net.www.MessageHeader;\n-\n-\/**\n- * This class encapsulates a HTTP request received and a response to be\n- * generated in one transaction. It provides methods for examaining the\n- * request from the client, and for building and sending a reply.\n- *\/\n-\n-public class HttpTransaction {\n-\n-    String command;\n-    URI requesturi;\n-    TestHttpServer.Server server;\n-    MessageHeader reqheaders, reqtrailers;\n-    String reqbody;\n-    byte[] rspbody;\n-    MessageHeader rspheaders, rsptrailers;\n-    SelectionKey  key;\n-    int rspbodylen;\n-    boolean rspchunked;\n-\n-    HttpTransaction (TestHttpServer.Server server, String command,\n-                        URI requesturi, MessageHeader headers,\n-                        String body, MessageHeader trailers, SelectionKey  key) {\n-        this.command = command;\n-        this.requesturi = requesturi;\n-        this.reqheaders = headers;\n-        this.reqbody = body;\n-        this.reqtrailers = trailers;\n-        this.key = key;\n-        this.server = server;\n-    }\n-\n-    \/**\n-     * Get the value of a request header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the request header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getRequestHeader (String key) {\n-        return reqheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the value of a response header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the response header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getResponseHeader (String key) {\n-        return rspheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the request URI\n-     *\n-     * @return the request URI\n-     *\/\n-    public URI getRequestURI () {\n-        return requesturi;\n-    }\n-\n-    public String toString () {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append (\"Request from: \").append (key.channel().toString()).append(\"\\r\\n\");\n-        buf.append (\"Command: \").append (command).append(\"\\r\\n\");\n-        buf.append (\"Request URI: \").append (requesturi).append(\"\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        buf.append (reqheaders.toString()).append(\"\\r\\n\");\n-        buf.append (\"Body: \").append (reqbody).append(\"\\r\\n\");\n-        buf.append (\"---------Response-------\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        if (rspheaders != null) {\n-            buf.append (rspheaders.toString()).append(\"\\r\\n\");\n-        }\n-        String rbody = rspbody == null? \"\": new String (rspbody);\n-        buf.append (\"Body: \").append (rbody).append(\"\\r\\n\");\n-        return new String (buf);\n-    }\n-\n-    \/**\n-     * Get the value of a request trailer whose name is specified by\n-     * the String argument.\n-     *\n-     * @param key the name of the request trailer\n-     * @return the value of the trailer or null if it does not exist\n-     *\/\n-    public String getRequestTrailer (String key) {\n-        return reqtrailers.findValue (key);\n-    }\n-\n-    \/**\n-     * Add a response header to the response. Multiple calls with the same\n-     * key value result in multiple header lines with the same key identifier\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void addResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.add (key, val);\n-    }\n-\n-    \/**\n-     * Set a response header. Searches for first header with named key\n-     * and replaces its value with val\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void setResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.set (key, val);\n-    }\n-\n-    \/**\n-     * Add a response trailer to the response. Multiple calls with the same\n-     * key value result in multiple trailer lines with the same key identifier\n-     * @param key the name of the request trailer to add\n-     * @param val the value of the trailer\n-     *\/\n-    public void addResponseTrailer (String key, String val) {\n-        if (rsptrailers == null)\n-            rsptrailers = new MessageHeader ();\n-        rsptrailers.add (key, val);\n-    }\n-\n-    \/**\n-     * Get the request method\n-     *\n-     * @return the request method\n-     *\/\n-    public String getRequestMethod (){\n-        return command;\n-    }\n-\n-    \/**\n-     * Perform an orderly close of the TCP connection associated with this\n-     * request. This method guarantees that any response already sent will\n-     * not be reset (by this end). The implementation does a shutdownOutput()\n-     * of the TCP connection and for a period of time consumes and discards\n-     * data received on the reading side of the connection. This happens\n-     * in the background. After the period has expired the\n-     * connection is completely closed.\n-     *\/\n-\n-    public void orderlyClose () {\n-        try {\n-            server.orderlyCloseChannel (key);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Do an immediate abortive close of the TCP connection associated\n-     * with this request.\n-     *\/\n-    public void abortiveClose () {\n-        try {\n-            server.abortiveCloseChannel(key);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Get the SocketChannel associated with this request\n-     *\n-     * @return the socket channel\n-     *\/\n-    public SocketChannel channel() {\n-        return (SocketChannel) key.channel();\n-    }\n-\n-    \/**\n-     * Get the request entity body associated with this request\n-     * as a single String.\n-     *\n-     * @return the entity body in one String\n-     *\/\n-    public String getRequestEntityBody (){\n-        return reqbody;\n-    }\n-\n-    \/**\n-     * Set the entity response body with the given string\n-     * The content length is set to the length of the string\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (String body){\n-        rspbody = body.getBytes();\n-        rspbodylen = body.length();\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-    \/**\n-     * Set the entity response body with the given byte[]\n-     * The content length is set to the gven length\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (byte[] body, int len){\n-        rspbody = body;\n-        rspbodylen = len;\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-\n-\n-    \/**\n-     * Set the entity response body by reading the given inputstream\n-     *\n-     * @param is the inputstream from which to read the body\n-     *\/\n-    public void setResponseEntityBody (InputStream is) throws IOException {\n-        byte[] buf = new byte [2048];\n-        byte[] total = new byte [2048];\n-        int total_len = 2048;\n-        int c, len=0;\n-        while ((c=is.read (buf)) != -1) {\n-            if (len+c > total_len) {\n-                byte[] total1 = new byte [total_len * 2];\n-                System.arraycopy (total, 0, total1, 0, len);\n-                total = total1;\n-                total_len = total_len * 2;\n-            }\n-            System.arraycopy (buf, 0, total, len, c);\n-            len += c;\n-        }\n-        setResponseEntityBody (total, len);\n-    }\n-\n-    \/* chunked *\/\n-\n-    \/**\n-     * Set the entity response body with the given array of strings\n-     * The content encoding is set to \"chunked\" and each array element\n-     * is sent as one chunk.\n-     * @param body the array of string chunks to send in the response\n-     *\/\n-    public void setResponseEntityBody (String[] body) {\n-        StringBuffer buf = new StringBuffer ();\n-        int len = 0;\n-        for (int i=0; i<body.length; i++) {\n-            String chunklen = Integer.toHexString (body[i].length());\n-            len += body[i].length();\n-            buf.append (chunklen).append (\"\\r\\n\");\n-            buf.append (body[i]).append (\"\\r\\n\");\n-        }\n-        buf.append (\"0\\r\\n\");\n-        rspbody = new String (buf).getBytes();\n-        rspbodylen = rspbody.length;\n-        rspchunked = true;\n-        addResponseHeader (\"Transfer-encoding\", \"chunked\");\n-    }\n-\n-    \/**\n-     * Send the response with the current set of response parameters\n-     * but using the response code and string tag line as specified\n-     * @param rCode the response code to send\n-     * @param rTag the response string to send with the response code\n-     *\/\n-    public void sendResponse (int rCode, String rTag) throws IOException {\n-        OutputStream os = new TestHttpServer.NioOutputStream(channel());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        if (rspheaders != null) {\n-            rspheaders.print (ps);\n-        } else {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush ();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        } else if (rspchunked) {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush();\n-    }\n-\n-    \/* sends one byte less than intended *\/\n-\n-    public void sendPartialResponse (int rCode, String rTag)throws IOException {\n-        OutputStream os = new TestHttpServer.NioOutputStream(channel());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        ps.flush();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen-1);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        }\n-        ps.flush();\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/httptest\/HttpTransaction.java","additions":0,"deletions":330,"binary":false,"changes":330,"status":"deleted"},{"patch":"@@ -1,797 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import sun.net.www.MessageHeader;\n-import java.util.*;\n-\n-\/**\n- * This class implements a simple HTTP server. It uses multiple threads to\n- * handle connections in parallel, and also multiple connections\/requests\n- * can be handled per thread.\n- * <p>\n- * It must be instantiated with a {@link HttpCallback} object to which\n- * requests are given and must be handled.\n- * <p>\n- * Simple synchronization between the client(s) and server can be done\n- * using the {@link #waitForCondition(String)}, {@link #setCondition(String)} and\n- * {@link #rendezvous(String,int)} methods.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\n- * If changes are made here, please sure they are propagated to\n- * the HTTPS equivalent in the JSSE regression test suite.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\/\n-\n-public class TestHttpServer {\n-\n-    ServerSocketChannel schan;\n-    int threads;\n-    int cperthread;\n-    HttpCallback cb;\n-    Server[] servers;\n-\n-    \/**\n-     * Create a <code>TestHttpServer<code> instance with the specified callback object\n-     * for handling requests. One thread is created to handle requests,\n-     * and up to ten TCP connections will be handled simultaneously.\n-     * @param cb the callback object which is invoked to handle each\n-     *  incoming request\n-     *\/\n-\n-    public TestHttpServer (HttpCallback cb) throws IOException {\n-        this (cb, 1, 10, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpServer<code> instance with the specified callback object\n-     * for handling requests. One thread is created to handle requests,\n-     * and up to ten TCP connections will be handled simultaneously.\n-     * @param cb the callback object which is invoked to handle each\n-     *  incoming request\n-     * @param address the address to bind the server to. <code>Null<\/code>\n-     *  means bind to the wildcard address.\n-     * @param port the port number to bind the server to. <code>Zero<\/code>\n-     *  means choose any free port.\n-     *\/\n-\n-    public TestHttpServer (HttpCallback cb, InetAddress address, int port) throws IOException {\n-        this (cb, 1, 10, address, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpServer<code> instance with the specified number of\n-     * threads and maximum number of connections per thread. This functions\n-     * the same as the 4 arg constructor, where the port argument is set to zero.\n-     * @param cb the callback object which is invoked to handle each\n-     *     incoming request\n-     * @param threads the number of threads to create to handle requests\n-     *     in parallel\n-     * @param cperthread the number of simultaneous TCP connections to\n-     *     handle per thread\n-     *\/\n-\n-    public TestHttpServer (HttpCallback cb, int threads, int cperthread)\n-        throws IOException {\n-        this (cb, threads, cperthread, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpServer<code> instance with the specified number\n-     * of threads and maximum number of connections per thread and running on\n-     * the specified port. The specified number of threads are created to\n-     * handle incoming requests, and each thread is allowed\n-     * to handle a number of simultaneous TCP connections.\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n-     * @param threads the number of threads to create to handle\n-     *  requests in parallel\n-     * @param cperthread the number of simultaneous TCP connections\n-     *  to handle per thread\n-     * @param port the port number to bind the server to. <code>Zero<\/code>\n-     *  means choose any free port.\n-     *\/\n-\n-    public TestHttpServer (HttpCallback cb, int threads, int cperthread, int port)\n-            throws IOException {\n-        this(cb, threads, cperthread, null, port);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpServer<code> instance with the specified number\n-     * of threads and maximum number of connections per thread and running on\n-     * the specified port. The specified number of threads are created to\n-     * handle incoming requests, and each thread is allowed\n-     * to handle a number of simultaneous TCP connections.\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n-     * @param threads the number of threads to create to handle\n-     *  requests in parallel\n-     * @param cperthread the number of simultaneous TCP connections\n-     *  to handle per thread\n-     * @param address the address to bind the server to. <code>Null<\/code>\n-     *  means bind to the wildcard address.\n-     * @param port the port number to bind the server to. <code>Zero<\/code>\n-     *  means choose any free port.\n-     *\/\n-\n-    public TestHttpServer (HttpCallback cb, int threads, int cperthread,\n-                           InetAddress address, int port)\n-        throws IOException {\n-        schan = ServerSocketChannel.open ();\n-        InetSocketAddress addr = new InetSocketAddress (address, port);\n-        schan.socket().bind (addr);\n-        this.threads = threads;\n-        this.cb = cb;\n-        this.cperthread = cperthread;\n-        servers = new Server [threads];\n-        for (int i=0; i<threads; i++) {\n-            servers[i] = new Server (cb, schan, cperthread);\n-            servers[i].start();\n-        }\n-    }\n-\n-    \/**\n-     * Tell all threads in the server to exit within 5 seconds.\n-     * This is an abortive termination. Just prior to the thread exiting\n-     * all channels in that thread waiting to be closed are forceably closed.\n-     * @throws InterruptedException\n-     *\/\n-\n-    public void terminate () {\n-        for (int i=0; i<threads; i++) {\n-            servers[i].terminate ();\n-        }\n-\n-        for (int i = 0; i < threads; i++) {\n-            try {\n-                servers[i].join();\n-            } catch (InterruptedException e) {\n-                System.err.println(\"Unexpected InterruptedException during terminating server\");\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * return the local port number to which the server is bound.\n-     * @return the local port number\n-     *\/\n-\n-    public int getLocalPort () {\n-        return schan.socket().getLocalPort ();\n-    }\n-\n-    public String getAuthority() {\n-        InetAddress address = schan.socket().getInetAddress();\n-        String hostaddr = address.getHostAddress();\n-        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n-        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n-        return hostaddr + \":\" + getLocalPort();\n-    }\n-\n-    static class Server extends Thread {\n-\n-        ServerSocketChannel schan;\n-        Selector selector;\n-        SelectionKey listenerKey;\n-        SelectionKey key; \/* the current key being processed *\/\n-        HttpCallback cb;\n-        ByteBuffer consumeBuffer;\n-        int maxconn;\n-        int nconn;\n-        ClosedChannelList clist;\n-        volatile boolean shutdown;\n-\n-        Server (HttpCallback cb, ServerSocketChannel schan, int maxconn) {\n-            this.schan = schan;\n-            this.maxconn = maxconn;\n-            this.cb = cb;\n-            nconn = 0;\n-            consumeBuffer = ByteBuffer.allocate (512);\n-            clist = new ClosedChannelList ();\n-            try {\n-                selector = Selector.open ();\n-                schan.configureBlocking (false);\n-                listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);\n-            } catch (IOException e) {\n-                System.err.println (\"Server could not start: \" + e);\n-                throw new RuntimeException(\"Server could not start: \" + e, e);\n-            }\n-        }\n-\n-        \/* Stop the thread as soon as possible *\/\n-        public void terminate () {\n-            shutdown = true;\n-        }\n-\n-        public void run ()  {\n-            try {\n-                while (true) {\n-                    selector.select(1000);\n-                    Set<SelectionKey> selected = selector.selectedKeys();\n-                    Iterator<SelectionKey> iter = selected.iterator();\n-                    while (iter.hasNext()) {\n-                        key = iter.next();\n-                        if (key.equals (listenerKey)) {\n-                            SocketChannel sock = schan.accept ();\n-                            if (sock == null) {\n-                                \/* false notification *\/\n-                                iter.remove();\n-                                continue;\n-                            }\n-                            sock.configureBlocking (false);\n-                            sock.register (selector, SelectionKey.OP_READ);\n-                            nconn ++;\n-                            System.out.println(\"SERVER: new connection. chan[\" + sock + \"]\");\n-                            if (nconn == maxconn) {\n-                                \/* deregister *\/\n-                                listenerKey.cancel ();\n-                                listenerKey = null;\n-                            }\n-                        } else {\n-                            if (key.isReadable()) {\n-                                boolean closed;\n-                                SocketChannel chan = (SocketChannel) key.channel();\n-                                System.out.println(\"SERVER: connection readable. chan[\" + chan + \"]\");\n-                                if (key.attachment() != null) {\n-                                    System.out.println(\"Server: consume\");\n-                                    closed = consume (chan);\n-                                } else {\n-                                    closed = read (chan, key);\n-                                }\n-                                if (closed) {\n-                                    chan.close ();\n-                                    key.cancel ();\n-                                    if (nconn == maxconn) {\n-                                        listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);\n-                                    }\n-                                    nconn --;\n-                                }\n-                            }\n-                        }\n-                        iter.remove();\n-                    }\n-                    clist.check();\n-                    if (shutdown) {\n-                        System.out.println(\"Force to Shutdown\");\n-                        SelectionKey sKey = schan.keyFor(selector);\n-                        if (sKey != null) {\n-                            sKey.cancel();\n-                        }\n-\n-                        clist.terminate ();\n-                        selector.close();\n-                        schan.socket().close();\n-                        schan.close();\n-                        return;\n-                    }\n-                }\n-            } catch (IOException e) {\n-                System.out.println (\"Server exception: \" + e);\n-                \/\/ TODO finish\n-            }\n-        }\n-\n-        \/* read all the data off the channel without looking at it\n-             * return true if connection closed\n-             *\/\n-        boolean consume (SocketChannel chan) {\n-            try {\n-                consumeBuffer.clear ();\n-                int c = chan.read (consumeBuffer);\n-                if (c == -1)\n-                    return true;\n-            } catch (IOException e) {\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        \/* return true if the connection is closed, false otherwise *\/\n-\n-        private boolean read (SocketChannel chan, SelectionKey key) {\n-            HttpTransaction msg;\n-            boolean res;\n-            try {\n-                InputStream is = new BufferedInputStream (new NioInputStream (chan));\n-                String requestline = readLine (is);\n-                MessageHeader mhead = new MessageHeader (is);\n-                String clen = mhead.findValue (\"Content-Length\");\n-                String trferenc = mhead.findValue (\"Transfer-Encoding\");\n-                String data = null;\n-                if (trferenc != null && trferenc.equals (\"chunked\"))\n-                    data = new String (readChunkedData (is));\n-                else if (clen != null)\n-                    data = new String (readNormalData (is, Integer.parseInt (clen)));\n-                String[] req = requestline.split (\" \");\n-                if (req.length < 2) {\n-                    \/* invalid request line *\/\n-                    return false;\n-                }\n-                String cmd = req[0];\n-                URI uri = null;\n-                try {\n-                    uri = new URI (req[1]);\n-                    msg = new HttpTransaction (this, cmd, uri, mhead, data, null, key);\n-                    cb.request (msg);\n-                } catch (URISyntaxException e) {\n-                    System.err.println (\"Invalid URI: \" + e);\n-                    msg = new HttpTransaction (this, cmd, null, null, null, null, key);\n-                    msg.sendResponse (501, \"Whatever\");\n-                }\n-                res = false;\n-            } catch (IOException e) {\n-                res = true;\n-            }\n-            return res;\n-        }\n-\n-        byte[] readNormalData (InputStream is, int len) throws IOException {\n-            byte [] buf  = new byte [len];\n-            int c, off=0, remain=len;\n-            while (remain > 0 && ((c=is.read (buf, off, remain))>0)) {\n-                remain -= c;\n-                off += c;\n-            }\n-            return buf;\n-        }\n-\n-        private void readCRLF(InputStream is) throws IOException {\n-            int cr = is.read();\n-            int lf = is.read();\n-\n-            if (((cr & 0xff) != 0x0d) ||\n-                ((lf & 0xff) != 0x0a)) {\n-                throw new IOException(\n-                    \"Expected <CR><LF>:  got '\" + cr + \"\/\" + lf + \"'\");\n-            }\n-        }\n-\n-        byte[] readChunkedData (InputStream is) throws IOException {\n-            LinkedList l = new LinkedList ();\n-            int total = 0;\n-            for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {\n-                l.add (readNormalData(is, len));\n-                total += len;\n-                readCRLF(is);  \/\/ CRLF at end of chunk\n-            }\n-            readCRLF(is); \/\/ CRLF at end of Chunked Stream.\n-            byte[] buf = new byte [total];\n-            Iterator i = l.iterator();\n-            int x = 0;\n-            while (i.hasNext()) {\n-                byte[] b = (byte[])i.next();\n-                System.arraycopy (b, 0, buf, x, b.length);\n-                x += b.length;\n-            }\n-            return buf;\n-        }\n-\n-        private int readChunkLen (InputStream is) throws IOException {\n-            int c, len=0;\n-            boolean done=false, readCR=false;\n-            while (!done) {\n-                c = is.read ();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        int x=0;\n-                        if (c >= 'a' && c <= 'f') {\n-                            x = c - 'a' + 10;\n-                        } else if (c >= 'A' && c <= 'F') {\n-                            x = c - 'A' + 10;\n-                        } else if (c >= '0' && c <= '9') {\n-                            x = c - '0';\n-                        }\n-                        len = len * 16 + x;\n-                    }\n-                }\n-            }\n-            return len;\n-        }\n-\n-        private String readLine (InputStream is) throws IOException {\n-            boolean done=false, readCR=false;\n-            byte[] b = new byte [512];\n-            int c, l = 0;\n-\n-            while (!done) {\n-                c = is.read ();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        b[l++] = (byte)c;\n-                    }\n-                }\n-            }\n-            return new String (b);\n-        }\n-\n-        \/** close the channel associated with the current key by:\n-         * 1. shutdownOutput (send a FIN)\n-         * 2. mark the key so that incoming data is to be consumed and discarded\n-         * 3. After a period, close the socket\n-         *\/\n-\n-        synchronized void orderlyCloseChannel (SelectionKey key) throws IOException {\n-            SocketChannel ch = (SocketChannel)key.channel ();\n-            System.out.println(\"SERVER: orderlyCloseChannel chan[\" + ch + \"]\");\n-            ch.socket().shutdownOutput();\n-            key.attach (this);\n-            clist.add (key);\n-        }\n-\n-        synchronized void abortiveCloseChannel (SelectionKey key) throws IOException {\n-            SocketChannel ch = (SocketChannel)key.channel ();\n-            System.out.println(\"SERVER: abortiveCloseChannel chan[\" + ch + \"]\");\n-\n-            Socket s = ch.socket ();\n-            s.setSoLinger (true, 0);\n-            ch.close();\n-        }\n-    }\n-\n-\n-    \/**\n-     * Implements blocking reading semantics on top of a non-blocking channel\n-     *\/\n-\n-    static class NioInputStream extends InputStream {\n-        SocketChannel channel;\n-        Selector selector;\n-        ByteBuffer chanbuf;\n-        SelectionKey key;\n-        int available;\n-        byte[] one;\n-        boolean closed;\n-        ByteBuffer markBuf; \/* reads may be satisifed from this buffer *\/\n-        boolean marked;\n-        boolean reset;\n-        int readlimit;\n-\n-        public NioInputStream (SocketChannel chan) throws IOException {\n-            this.channel = chan;\n-            selector = Selector.open();\n-            chanbuf = ByteBuffer.allocate (1024);\n-            key = chan.register (selector, SelectionKey.OP_READ);\n-            available = 0;\n-            one = new byte[1];\n-            closed = marked = reset = false;\n-        }\n-\n-        public synchronized int read (byte[] b) throws IOException {\n-            return read (b, 0, b.length);\n-        }\n-\n-        public synchronized int read () throws IOException {\n-            return read (one, 0, 1);\n-        }\n-\n-        public synchronized int read (byte[] b, int off, int srclen) throws IOException {\n-\n-            int canreturn, willreturn;\n-\n-            if (closed)\n-                return -1;\n-\n-            if (reset) { \/* satisfy from markBuf *\/\n-                canreturn = markBuf.remaining ();\n-                willreturn = canreturn>srclen ? srclen : canreturn;\n-                markBuf.get(b, off, willreturn);\n-                if (canreturn == willreturn) {\n-                    reset = false;\n-                }\n-            } else { \/* satisfy from channel *\/\n-                canreturn = available();\n-                if (canreturn == 0) {\n-                    block ();\n-                    canreturn = available();\n-                }\n-                willreturn = canreturn>srclen ? srclen : canreturn;\n-                chanbuf.get(b, off, willreturn);\n-                available -= willreturn;\n-\n-                if (marked) { \/* copy into markBuf *\/\n-                    try {\n-                        markBuf.put (b, off, willreturn);\n-                    } catch (BufferOverflowException e) {\n-                        marked = false;\n-                    }\n-                }\n-            }\n-            return willreturn;\n-        }\n-\n-        public synchronized int available () throws IOException {\n-            if (closed)\n-                throw new IOException (\"Stream is closed\");\n-\n-            if (reset)\n-                return markBuf.remaining();\n-\n-            if (available > 0)\n-                return available;\n-\n-            chanbuf.clear ();\n-            available = channel.read (chanbuf);\n-            if (available > 0)\n-                chanbuf.flip();\n-            else if (available == -1)\n-                throw new IOException (\"Stream is closed\");\n-            return available;\n-        }\n-\n-        \/**\n-         * block() only called when available==0 and buf is empty\n-         *\/\n-        private synchronized void block () throws IOException {\n-            \/\/assert available == 0;\n-            int n = selector.select ();\n-            \/\/assert n == 1;\n-            selector.selectedKeys().clear();\n-            available ();\n-        }\n-\n-        public void close () throws IOException {\n-            if (closed)\n-                return;\n-            channel.close ();\n-            closed = true;\n-        }\n-\n-        public synchronized void mark (int readlimit) {\n-            if (closed)\n-                return;\n-            this.readlimit = readlimit;\n-            markBuf = ByteBuffer.allocate (readlimit);\n-            marked = true;\n-            reset = false;\n-        }\n-\n-        public synchronized void reset () throws IOException {\n-            if (closed )\n-                return;\n-            if (!marked)\n-                throw new IOException (\"Stream not marked\");\n-            marked = false;\n-            reset = true;\n-            markBuf.flip ();\n-        }\n-    }\n-\n-    static class NioOutputStream extends OutputStream {\n-        SocketChannel channel;\n-        ByteBuffer buf;\n-        SelectionKey key;\n-        Selector selector;\n-        boolean closed;\n-        byte[] one;\n-\n-        public NioOutputStream (SocketChannel channel) throws IOException {\n-            this.channel = channel;\n-            selector = Selector.open ();\n-            key = channel.register (selector, SelectionKey.OP_WRITE);\n-            closed = false;\n-            one = new byte [1];\n-        }\n-\n-        public synchronized void write (int b) throws IOException {\n-            one[0] = (byte)b;\n-            write (one, 0, 1);\n-        }\n-\n-        public synchronized void write (byte[] b) throws IOException {\n-            write (b, 0, b.length);\n-        }\n-\n-        public synchronized void write (byte[] b, int off, int len) throws IOException {\n-            if (closed)\n-                throw new IOException (\"stream is closed\");\n-\n-            buf = ByteBuffer.allocate (len);\n-            buf.put (b, off, len);\n-            buf.flip ();\n-            int n;\n-            while ((n = channel.write (buf)) < len) {\n-                len -= n;\n-                if (len == 0)\n-                    return;\n-                selector.select ();\n-                selector.selectedKeys().clear ();\n-            }\n-        }\n-\n-        public void close () throws IOException {\n-            if (closed)\n-                return;\n-            channel.close ();\n-            closed = true;\n-        }\n-    }\n-\n-    \/**\n-     * Utilities for synchronization. A condition is\n-     * identified by a string name, and is initialized\n-     * upon first use (ie. setCondition() or waitForCondition()). Threads\n-     * are blocked until some thread calls (or has called) setCondition() for the same\n-     * condition.\n-     * <P>\n-     * A rendezvous built on a condition is also provided for synchronizing\n-     * N threads.\n-     *\/\n-\n-    private static HashMap conditions = new HashMap();\n-\n-    \/*\n-     * Modifiable boolean object\n-     *\/\n-    private static class BValue {\n-        boolean v;\n-    }\n-\n-    \/*\n-     * Modifiable int object\n-     *\/\n-    private static class IValue {\n-        int v;\n-        IValue (int i) {\n-            v =i;\n-        }\n-    }\n-\n-\n-    private static BValue getCond (String condition) {\n-        synchronized (conditions) {\n-            BValue cond = (BValue) conditions.get (condition);\n-            if (cond == null) {\n-                cond = new BValue();\n-                conditions.put (condition, cond);\n-            }\n-            return cond;\n-        }\n-    }\n-\n-    \/**\n-     * Set the condition to true. Any threads that are currently blocked\n-     * waiting on the condition, will be unblocked and allowed to continue.\n-     * Threads that subsequently call waitForCondition() will not block.\n-     * If the named condition did not exist prior to the call, then it is created\n-     * first.\n-     *\/\n-\n-    public static void setCondition (String condition) {\n-        BValue cond = getCond (condition);\n-        synchronized (cond) {\n-            if (cond.v) {\n-                return;\n-            }\n-            cond.v = true;\n-            cond.notifyAll();\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition does not exist, then it is created and initialized\n-     * to false. If the condition exists or has just been created and its value\n-     * is false, then the thread blocks until another thread sets the condition.\n-     * If the condition exists and is already set to true, then this call returns\n-     * immediately without blocking.\n-     *\/\n-\n-    public static void waitForCondition (String condition) {\n-        BValue cond = getCond (condition);\n-        synchronized (cond) {\n-            if (!cond.v) {\n-                try {\n-                    cond.wait();\n-                } catch (InterruptedException e) {}\n-            }\n-        }\n-    }\n-\n-    \/* conditions must be locked when accessing this *\/\n-    static HashMap rv = new HashMap();\n-\n-    \/**\n-     * Force N threads to rendezvous (ie. wait for each other) before proceeding.\n-     * The first thread(s) to call are blocked until the last\n-     * thread makes the call. Then all threads continue.\n-     * <p>\n-     * All threads that call with the same condition name, must use the same value\n-     * for N (or the results may be not be as expected).\n-     * <P>\n-     * Obviously, if fewer than N threads make the rendezvous then the result\n-     * will be a hang.\n-     *\/\n-\n-    public static void rendezvous (String condition, int N) {\n-        BValue cond;\n-        IValue iv;\n-        String name = \"RV_\"+condition;\n-\n-        \/* get the condition *\/\n-\n-        synchronized (conditions) {\n-            cond = (BValue)conditions.get (name);\n-            if (cond == null) {\n-                \/* we are first caller *\/\n-                if (N < 2) {\n-                    throw new RuntimeException (\"rendezvous must be called with N >= 2\");\n-                }\n-                cond = new BValue ();\n-                conditions.put (name, cond);\n-                iv = new IValue (N-1);\n-                rv.put (name, iv);\n-            } else {\n-                \/* already initialised, just decrement the counter *\/\n-                iv = (IValue) rv.get (name);\n-                iv.v --;\n-            }\n-        }\n-\n-        if (iv.v > 0) {\n-            waitForCondition (name);\n-        } else {\n-            setCondition (name);\n-            synchronized (conditions) {\n-                clearCondition (name);\n-                rv.remove (name);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition exists and is set then remove it, so it can\n-     * be re-initialized and used again. If the condition does not exist, or\n-     * exists but is not set, then the call returns without doing anything.\n-     * Note, some higher level synchronization\n-     * may be needed between clear and the other operations.\n-     *\/\n-\n-    public static void clearCondition(String condition) {\n-        BValue cond;\n-        synchronized (conditions) {\n-            cond = (BValue) conditions.get (condition);\n-            if (cond == null) {\n-                return;\n-            }\n-            synchronized (cond) {\n-                if (cond.v) {\n-                    conditions.remove (condition);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/httptest\/TestHttpServer.java","additions":0,"deletions":797,"binary":false,"changes":797,"status":"deleted"},{"patch":"@@ -351,1 +351,1 @@\n-                        new ByteArrayInputStream(certStr.getBytes());;\n+                        new ByteArrayInputStream(certStr.getBytes());\n","filename":"test\/jdk\/sun\/security\/provider\/certpath\/DisabledAlgorithms\/CPBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-                        new ByteArrayInputStream(certStr.getBytes());;\n+                        new ByteArrayInputStream(certStr.getBytes());\n","filename":"test\/jdk\/sun\/security\/provider\/certpath\/DisabledAlgorithms\/CPBuilderWithMD5.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,6 @@\n-import java.io.*;\n-import java.net.*;\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.ServerSocket;\n+import java.net.URL;\n@@ -38,3 +42,9 @@\n-import javax.net.*;\n-import javax.net.ssl.*;\n-import java.security.cert.*;\n+\n+import javax.net.ServerSocketFactory;\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSession;\n","filename":"test\/jdk\/sun\/security\/ssl\/InputRecord\/ClientHelloRead.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8281234\n+ * @summary The -protected option is not always checked in keytool and jarsigner\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.x509\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.util.JarUtils;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.X500Name;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.*;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.jar.JarFile;\n+\n+public class AutoKeyStore {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        JarUtils.createJarFile(Path.of(\"unsigned.jar\"), Path.of(\".\"),\n+                Files.writeString(Path.of(\"file\"), \"hello\"));\n+\n+        SecurityTools.keytool(\"\"\"\n+                -J--add-exports -Jjava.base\/sun.security.tools.keytool=ALL-UNNAMED\n+                -J--add-exports -Jjava.base\/sun.security.x509=ALL-UNNAMED\n+                -providerClass AutoKeyStore$AutoProvider\n+                -providerPath $test.classes\n+                -storetype AUTO -keystore NONE -protected\n+                -list\n+                \"\"\").shouldHaveExitValue(0)\n+                .shouldContain(\"Keystore type: AUTO\")\n+                .shouldContain(\"Keystore provider: AUTO\")\n+                .shouldContain(\"PrivateKeyEntry\");\n+\n+        SecurityTools.jarsigner(\"\"\"\n+                -J--add-exports -Jjava.base\/sun.security.tools.keytool=ALL-UNNAMED\n+                -J--add-exports -Jjava.base\/sun.security.x509=ALL-UNNAMED\n+                -providerClass AutoKeyStore$AutoProvider\n+                -providerPath $test.classes\n+                -storetype AUTO -keystore NONE -protected\n+                -signedJar signed.jar\n+                unsigned.jar\n+                one\n+                \"\"\").shouldHaveExitValue(0)\n+                .shouldContain(\"jar signed.\");\n+\n+        Asserts.assertTrue(new JarFile(\"signed.jar\")\n+                .getEntry(\"META-INF\/ONE.EC\") != null);\n+    }\n+\n+    public static class AutoProvider extends Provider {\n+        public AutoProvider() {\n+            super(\"AUTO\", \"1.1.1\", \"auto\");\n+            put(\"KeyStore.AUTO\", \"AutoKeyStore$KeyStoreImpl\");\n+        }\n+    }\n+\n+    \/\/ This keystore is not based on file. Whenever it's loaded\n+    \/\/ a self-sign certificate is generated inside\n+    public static class KeyStoreImpl extends KeyStoreSpi {\n+\n+        private PrivateKey pri;\n+        private PublicKey pub;\n+        private X509Certificate cert;\n+\n+        @Override\n+        public Key engineGetKey(String alias, char[] password) {\n+            return pri;\n+        }\n+\n+        @Override\n+        public Certificate[] engineGetCertificateChain(String alias) {\n+            return new Certificate[] { cert };\n+        }\n+\n+        @Override\n+        public Certificate engineGetCertificate(String alias) {\n+            return cert;\n+        }\n+\n+        @Override\n+        public Date engineGetCreationDate(String alias) {\n+            return new Date();\n+        }\n+\n+        @Override\n+        public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) throws KeyStoreException {\n+            throw new KeyStoreException(\"Not supported\");\n+        }\n+\n+        @Override\n+        public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) throws KeyStoreException {\n+            throw new KeyStoreException(\"Not supported\");\n+        }\n+\n+        @Override\n+        public void engineSetCertificateEntry(String alias, Certificate cert) throws KeyStoreException {\n+            throw new KeyStoreException(\"Not supported\");\n+        }\n+\n+        @Override\n+        public void engineDeleteEntry(String alias) throws KeyStoreException {\n+            throw new KeyStoreException(\"Not supported\");\n+        }\n+\n+        @Override\n+        public Enumeration<String> engineAliases() {\n+            return Collections.enumeration(List.of(\"one\"));\n+        }\n+\n+        @Override\n+        public boolean engineContainsAlias(String alias) {\n+            return alias.equalsIgnoreCase(\"one\");\n+        }\n+\n+        @Override\n+        public int engineSize() {\n+            return 1;\n+        }\n+\n+        @Override\n+        public boolean engineIsKeyEntry(String alias) {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean engineIsCertificateEntry(String alias) {\n+            return false;\n+        }\n+\n+        @Override\n+        public String engineGetCertificateAlias(Certificate cert) {\n+            return \"one\";\n+        }\n+\n+        @Override\n+        public void engineStore(OutputStream stream, char[] password) {\n+        }\n+\n+        @Override\n+        public void engineLoad(InputStream stream, char[] password) throws IOException {\n+            try {\n+                CertAndKeyGen cag = new CertAndKeyGen(\"EC\", \"SHA256withECDSA\");\n+                cag.generate(\"secp256r1\");\n+                pri = cag.getPrivateKey();\n+                pub = cag.getPublicKey();\n+                cert = cag.getSelfCertificate(new X500Name(\"CN=one\"), 3600);\n+            } catch (Exception e) {\n+                throw new IOException(\"Not loaded\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/AutoKeyStore.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277474\n+ * @summary jarsigner -verify should check if the algorithm parameters of\n+ *          its signature algorithm use disabled or legacy algorithms\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class CheckAlgParams {\n+    private static final String JAVA_SECURITY_FILE = \"java.security\";\n+\n+    public static void main(String[] args) throws Exception{\n+\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-genkeypair -keyalg RSASSA-PSS -alias ca -dname CN=CA \" +\n+                \"-ext bc:c\")\n+                .shouldHaveExitValue(0);\n+\n+        JarUtils.createJarFile(Path.of(\"a.jar\"), Path.of(\".\"), Path.of(\"ks\"));\n+\n+        SecurityTools.jarsigner(\"-keystore ks -storepass changeit \" +\n+                \"-signedjar signeda.jar \" +\n+                \"-verbose\" +\n+                \" a.jar ca\")\n+                .shouldHaveExitValue(0);\n+\n+        Files.writeString(Files.createFile(Paths.get(JAVA_SECURITY_FILE)),\n+                \"jdk.jar.disabledAlgorithms=SHA256\\n\" +\n+                \"jdk.security.legacyAlgorithms=\\n\");\n+\n+        SecurityTools.jarsigner(\"-verify signeda.jar \" +\n+                \"-J-Djava.security.properties=\" +\n+                JAVA_SECURITY_FILE +\n+                \" -keystore ks -storepass changeit -verbose -debug\")\n+                .shouldMatch(\"Digest algorithm: SHA-256.*(disabled)\")\n+                .shouldMatch(\"Signature algorithm: RSASSA-PSS using PSSParameterSpec.*hashAlgorithm=SHA-256.*(disabled)\")\n+                .shouldContain(\"The jar will be treated as unsigned\")\n+                .shouldHaveExitValue(0);\n+\n+        Files.deleteIfExists(Paths.get(JAVA_SECURITY_FILE));\n+        Files.writeString(Files.createFile(Paths.get(JAVA_SECURITY_FILE)),\n+                \"jdk.jar.disabledAlgorithms=\\n\" +\n+                \"jdk.security.legacyAlgorithms=SHA256\\n\");\n+\n+        SecurityTools.jarsigner(\"-verify signeda.jar \" +\n+                \"-J-Djava.security.properties=\" +\n+                JAVA_SECURITY_FILE +\n+                \" -keystore ks -storepass changeit -verbose -debug\")\n+                .shouldMatch(\"Digest algorithm: SHA-256.*(weak)\")\n+                .shouldMatch(\"Signature algorithm: RSASSA-PSS using PSSParameterSpec.*hashAlgorithm=SHA-256.*(weak)\")\n+                .shouldNotContain(\"The jar will be treated as unsigned\")\n+                .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/CheckAlgParams.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282633\n+ * @summary jarsigner should display the named curve to better explain why\n+ *          an EC key is disabled or will be disabled.\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class DisableCurveTest {\n+    private static final String JAVA_SECURITY_FILE = \"java.security\";\n+\n+    public static void main(String[] args) throws Exception{\n+        SecurityTools.keytool(\"-keystore ks -storepass changeit \" +\n+                \"-genkeypair -keyalg EC -alias ca -dname CN=CA \" +\n+                \"-ext bc:c\")\n+                .shouldHaveExitValue(0);\n+\n+        JarUtils.createJarFile(Path.of(\"a.jar\"), Path.of(\".\"), Path.of(\"ks\"));\n+\n+        Files.writeString(Files.createFile(Paths.get(JAVA_SECURITY_FILE)),\n+                \"jdk.jar.disabledAlgorithms=secp256r1\\n\" +\n+                \"jdk.certpath.disabledAlgorithms=secp256r1\\n\");\n+\n+        SecurityTools.jarsigner(\"-keystore ks -storepass changeit \" +\n+                \"-signedjar signeda.jar -verbose \" +\n+                \"-J-Djava.security.properties=\" +\n+                JAVA_SECURITY_FILE +\n+                \" a.jar ca\")\n+                .shouldContain(\">>> Signer\")\n+                .shouldContain(\"Signature algorithm: SHA256withECDSA, 256-bit EC (secp256r1) key (disabled)\")\n+                .shouldContain(\"Warning:\")\n+                .shouldContain(\"The EC (secp256r1) signing key has a keysize of 256 which is considered a security risk and is disabled\")\n+                .shouldHaveExitValue(0);\n+\n+        SecurityTools.jarsigner(\"-verify signeda.jar \" +\n+                \"-J-Djava.security.properties=\" +\n+                JAVA_SECURITY_FILE +\n+                \" -keystore ks -storepass changeit -verbose -debug\")\n+                .shouldContain(\"- Signed by\")\n+                .shouldContain(\"Signature algorithm: SHA256withECDSA, 256-bit EC (secp256r1) key (disabled)\")\n+                .shouldContain(\"WARNING: The jar will be treated as unsigned\")\n+                .shouldHaveExitValue(0);\n+\n+        Files.deleteIfExists(Paths.get(JAVA_SECURITY_FILE));\n+        Files.writeString(Files.createFile(Paths.get(JAVA_SECURITY_FILE)),\n+                \"jdk.security.legacyAlgorithms=secp256r1\\n\");\n+\n+        SecurityTools.jarsigner(\"-keystore ks -storepass changeit \" +\n+                \"-signedjar signeda.jar -verbose \" +\n+                \"-J-Djava.security.properties=\" +\n+                JAVA_SECURITY_FILE +\n+                \" a.jar ca\")\n+                .shouldContain(\">>> Signer\")\n+                .shouldContain(\"Signature algorithm: SHA256withECDSA, 256-bit EC (secp256r1) key (weak)\")\n+                .shouldContain(\"Warning:\")\n+                .shouldContain(\"The EC (secp256r1) signing key has a keysize of 256 which is considered a security risk. This key size will be disabled in a future update\")\n+                .shouldHaveExitValue(0);\n+\n+        SecurityTools.jarsigner(\"-verify signeda.jar \" +\n+                \"-J-Djava.security.properties=\" +\n+                JAVA_SECURITY_FILE +\n+                \" -keystore ks -storepass changeit -verbose -debug\")\n+                .shouldContain(\"- Signed by\")\n+                .shouldContain(\"Signature algorithm: SHA256withECDSA, 256-bit EC (secp256r1) key (weak)\")\n+                .shouldContain(\"jar verified\")\n+                .shouldContain(\"The EC (secp256r1) signing key has a keysize of 256 which is considered a security risk. This key size will be disabled in a future update\")\n+                .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/DisableCurveTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"","filename":"test\/jdk\/sun\/security\/util\/HostnameChecker\/NullHostnameCheck.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/util\/HostnameMatcher\/NullHostnameCheck.java","status":"renamed"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4514108 7192189\n+ * @summary Verify host name matching behaves as defined in RFC2818 and RFC6125.\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.util java.base\/sun.security.x509\n+ *\/\n+\n+import java.security.cert.*;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import jdk.test.lib.security.CertUtils;\n+import sun.security.util.*;\n+import sun.security.x509.X509CertImpl;\n+\n+\/**\n+ * Certificate 1:\n+ *   . no subject alternative names, most specific CN is foo1.com.\n+ *     (also test if serialnumber attribute is ignored)\n+ * <pre>\n+    [\n+    [\n+      Version: V1\n+      Subject: SERIALNUMBER=12 + CN=foo1.com, CN=foo2.com, O=Sun, C=US\n+      Signature Algorithm: SHA1withRSA, OID = 1.2.840.113549.1.1.5\n+\n+      Key:  com.sun.net.ssl.internal.ssl.JSA_RSAPublicKey@1d8957f\n+      Validity: [From: Fri Mar 22 12:22:57 GMT 2002,\n+                   To: Tue Mar 22 12:22:57 GMT 2022]\n+      Issuer: CN=CA, O=Sun, C=US\n+      SerialNumber: [  0  ]\n+\n+    ]\n+      Algorithm: [SHA1withRSA]\n+      Signature:\n+    0000: B8 E1 F8 A8 23 EB C4 E9   F9 03 F6 97 FA DD A2 56  ....#..........V\n+    0010: 06 B6 95 99 68 6B F8 72   6A 27 F4 13 CC 40 06 83  ....hk.rj'...@..\n+    0020: 62 C1 94 72 63 EA 69 FD   78 A2 06 D8 3B F5 D0 2C  b..rc.i.x...;..,\n+    0030: 97 D6 29 84 FA 6F 2E E1   13 6A C7 5D DE 2F 6A 2F  ..)..o...j.].\/j\/\n+    0040: 08 85 43 3B 7D DB C1 AB   1A DC 38 BE F7 4B 6B 82  ..C;......8..Kk.\n+    0050: 84 06 FA 46 82 77 42 A6   47 55 33 63 2B D4 05 2E  ...F.wB.GU3c+...\n+    0060: 76 F5 1B 6A CD 8E B2 B3   83 8E 9D 13 BC 82 0C 4B  v..j...........K\n+    0070: DE 8A 63 B5 EA F1 07 00   C0 7E C9 75 DF 13 FC 34  ..c........u...4\n+\n+    ]\n+ * <\/pre>\n+ *\n+ * Certificate 2:\n+ *   . CN contains IP address, must be ignored.\n+ * <pre>\n+    [\n+    [\n+      Version: V1\n+      Subject: CN=1.2.3.4, O=Sun, C=US\n+      Signature Algorithm: SHA1withRSA, OID = 1.2.840.113549.1.1.5\n+\n+      Key:  com.sun.net.ssl.internal.ssl.JSA_RSAPublicKey@173831b\n+      Validity: [From: Fri Mar 22 12:22:57 GMT 2002,\n+                   To: Tue Mar 22 12:22:57 GMT 2022]\n+      Issuer: CN=CA, O=Sun, C=US\n+      SerialNumber: [    01]\n+\n+    ]\n+      Algorithm: [SHA1withRSA]\n+      Signature:\n+    0000: 15 86 83 1E 79 7F 8B 06   1F E0 BF 79 0F EA 84 D1  ....y......y....\n+    0010: C5 CD 2C D6 9D 4A 36 7C   75 41 E6 0D 8C 1D 65 60  ..,..J6.uA....e`\n+    0020: 0F 53 15 54 41 43 AE F9   E9 54 34 8A 4B B9 39 12  .S.TAC...T4.K.9.\n+    0030: DE 58 21 86 D3 F9 11 6C   4F 72 EF 8C 4B C3 66 FC  .X!....lOr..K.f.\n+    0040: BD AB 87 63 8F 59 1D C3   FE 76 DB B7 76 43 C2 A1  ...c.Y...v..vC..\n+    0050: 4D D7 92 C4 CA C6 DC 59   CA A6 1B 6D FE 01 AC F4  M......Y...m....\n+    0060: 09 86 D8 A1 40 C4 C2 77   BF 53 21 9A 3B 43 2E 9A  ....@..w.S!.;C..\n+    0070: D4 0C BE 85 47 A5 02 35   7D EE 27 11 36 0E 80 14  ....G..5..'.6...\n+\n+    ]\n+ * <\/pre>\n+ *\n+ * Certificate 3:\n+ *   . Contains subject alternative name extension with DNS altfoo1.com,\n+ *     DNS altfoo2.com, IP 5.6.7.8. CNs in subject DN must be ignored.\n+ * <pre>\n+    [\n+    [\n+      Version: V3\n+      Subject: SERIALNUMBER=12 + CN=foo1.com, CN=foo2.com, O=Sun, C=US\n+      Signature Algorithm: SHA1withRSA, OID = 1.2.840.113549.1.1.5\n+\n+      Key:  com.sun.net.ssl.internal.ssl.JSA_RSAPublicKey@18e2b22\n+      Validity: [From: Fri Mar 22 12:22:57 GMT 2002,\n+                   To: Tue Mar 22 12:22:57 GMT 2022]\n+      Issuer: CN=CA, O=Sun, C=US\n+      SerialNumber: [    02]\n+\n+    Certificate Extensions: 1\n+    [1]: ObjectId: 2.5.29.17 Criticality=false\n+    SubjectAlternativeName [\n+    [DNSName: altfoo1.com, DNSName: altfoo2.com, IPAddress: 5.6.7.8]]\n+\n+    ]\n+      Algorithm: [SHA1withRSA]\n+      Signature:\n+    0000: 65 A6 E5 96 4A D5 8F 8D   3E 70 7D 63 BE B1 58 1C  e...J...>p.c..X.\n+    0010: B5 35 EF 7D E8 00 9C 9E   56 E7 E9 52 71 7B BD 35  .5......V..Rq..5\n+    0020: 3D B5 F5 F7 B2 49 A0 E4   23 BB 2A 0A 25 84 0E E2  =....I..#.*.%...\n+    0030: 4B 6D 61 73 D5 C8 F1 0A   EC 2B F2 98 3D 80 F9 DC  Kmas.....+..=...\n+    0040: F5 D1 2A 36 44 EB 59 9A   E9 DF 97 FA AE C0 86 F1  ..*6D.Y.........\n+    0050: 2C 7B 54 21 F2 3A 56 83   0D E0 5A E1 0D FC D5 E2  ,.T!.:V...Z.....\n+    0060: 45 44 ED C8 C6 F8 26 8E   0C 14 ED D0 F7 37 1C 01  ED....&......7..\n+    0070: A5 E2 61 29 5D 14 B3 5A   EF 72 CC 9B 13 05 B0 B1  ..a)]..Z.r......\n+\n+    ]\n+ * <\/pre>\n+ *\n+ * Certificate 4:\n+ *   . SubjAltName contains wildcard char, in the leftmost as well as\n+ *     in the middle component.\n+ * <pre>\n+   [\n+   [\n+    Version: V3\n+    Subject: SERIALNUMBER=12, O=Sun, C=US\n+    Signature Algorithm: SHA1withRSA, OID = 1.2.840.113549.1.1.5\n+\n+    Key:  com.sun.net.ssl.internal.ssl.JSA_RSAPublicKey@17a8bd\n+    Validity: [From: Mon Apr 01 22:32:38 PST 2002,\n+               To: Fri Apr 01 22:32:38 PST 2022]\n+    Issuer: CN=CA, O=Sun, C=US\n+    SerialNumber: [    02]\n+\n+    Certificate Extensions: 1\n+    [1]: ObjectId: 2.5.29.17 Criticality=false\n+    SubjectAlternativeName [\n+\n+    [DNSName: f*.bar.com, DNSName: altfoo.b*.com]]\n+\n+   ]\n+   Algorithm: [SHA1withRSA]\n+   Signature:\n+   0000: BB 9B 00 DB C9 94 15 34   03 9F 28 59 20 4D 10 63  .......4..(Y M.c\n+   0010: 63 6A F5 C8 56 7B 7C CC   E7 06 7E 1E BE 0B 84 92  cj..V...........\n+   0020: 05 0A 12 5E 21 5D 70 03   DA 27 0B 4E 39 67 FC 8D  ...^!]p..'.N9g..\n+   0030: D6 FC A6 5B F5 CA F1 4C   75 53 33 E3 4F 30 88 68  ...[...LuS3.O0.h\n+   0040: B8 F1 2C DF C2 A8 71 A7   37 55 66 7C 51 23 BB C2  ..,...q.7Uf.Q#..\n+   0050: 25 70 EA EE 44 ED 32 63   56 E0 BA C8 94 36 87 E2  %p..D.2cV....6..\n+   0060: 94 00 2A 3D 4C 46 78 E9   2B 20 9F 73 3C 8E 92 2E  ..*=LFx.+ .s<...\n+   0070: 66 85 C6 27 3A 84 21 94   82 93 B1 A4 94 B6 DE 2F  f..':.!........\/\n+\n+   ]\n+ * <\/pre>\n+ *\n+ *\/\n+\n+public class TestHostnameChecker {\n+\n+    public static void main(String[] args) throws Exception {\n+        X509Certificate cert1 = CertUtils.getCertFromFile(\"cert1.crt\");\n+        X509Certificate cert2 = CertUtils.getCertFromFile(\"cert2.crt\");\n+        X509Certificate cert3 = CertUtils.getCertFromFile(\"cert3.crt\");\n+        X509Certificate cert4 = CertUtils.getCertFromFile(\"cert4.crt\");\n+        X509Certificate cert5 = CertUtils.getCertFromFile(\"cert5.crt\");\n+\n+        HostnameChecker checker = HostnameChecker.getInstance(\n+                HostnameChecker.TYPE_TLS);\n+        System.out.println(\"TLS tests.........\");\n+        System.out.println(\"==================\");\n+        check(checker, \"foo1.com\", cert1, true);\n+        check(checker, \"foo2.com\", cert1, false);\n+        check(checker, \"1.2.3.4\", cert2, false);\n+        check(checker, \"foo1.com\", cert3, false);\n+        check(checker, \"foo2.com\", cert3, false);\n+        check(checker, \"altfoo1.com\", cert3, true);\n+        check(checker, \"altfoo2.com\", cert3, true);\n+        check(checker, \"5.6.7.8\", cert3, true);\n+        check(checker, \"foo.bar.com\", cert4, true);\n+        check(checker, \"altfoo.bar.com\", cert4, false);\n+        check(checker, \"2001:db8:3c4d:15::1a2f:1a2b\", cert5, true);\n+        check(checker, \"2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b\", cert5, true);\n+        check(checker, \"2002:db8:3c4d:15::1a2f:1a2b\", cert5, false);\n+        check(checker, \"foo.bar.example.net\", mock(\"foo.*.example.net\"), false);\n+        check(checker, \"baz1.example.net\", mock(\"baz*.example.net\"), true);\n+        check(checker, \"foobaz.example.net\", mock(\"*baz.example.net\"), true);\n+        check(checker, \"buzz.example.net\", mock(\"b*z.example.net\"), true);\n+        check(checker, \"公司.example.net\", mock(\"xn--5*.example.net\"), false);\n+        check(checker, \"公司.江利子.example.net\",\n+                       mock(\"*.xn--kcry6tjko.example.net\"), true);\n+\n+        checker = HostnameChecker.getInstance(\n+                                HostnameChecker.TYPE_LDAP);\n+        System.out.println();\n+        System.out.println(\"LDAP tests.........\");\n+        System.out.println(\"==================\");\n+        check(checker, \"foo1.com\", cert1, true);\n+        check(checker, \"foo2.com\", cert1, false);\n+        check(checker, \"foo1.com\", cert3, false);\n+        check(checker, \"foo2.com\", cert3, false);\n+        check(checker, \"altfoo1.com\", cert3, true);\n+        check(checker, \"altfoo2.com\", cert3, true);\n+        check(checker, \"5.6.7.8\", cert3, true);\n+        check(checker, \"foo.bar.com\", cert4, true);\n+        check(checker, \"altfoo.bar.com\", cert4, false);\n+    }\n+\n+    private static X509Certificate mock(String domain) {\n+        return new X509CertImpl() {\n+            @Override\n+            public Collection<List<?>> getSubjectAlternativeNames() {\n+                return List.of(List.of(2, domain));\n+            }\n+        };\n+    }\n+\n+    private static void check(HostnameChecker checker, String name,\n+                 X509Certificate cert, boolean expectedResult)\n+                 throws Exception {\n+        try {\n+            checker.match(name, cert);\n+            if (expectedResult == false) {\n+                throw new Exception(\"Passed invalid test: \" + name);\n+            }\n+        } catch (CertificateException e) {\n+            if (expectedResult == true) {\n+                throw new Exception(\"Failed valid test: \" + name, e);\n+            }\n+        }\n+        System.out.println(\"OK: \" + name);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/util\/HostnameChecker\/TestHostnameChecker.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"","filename":"test\/jdk\/sun\/security\/util\/HostnameChecker\/cert1.crt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/util\/HostnameMatcher\/cert1.crt","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/util\/HostnameChecker\/cert2.crt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/util\/HostnameMatcher\/cert2.crt","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/util\/HostnameChecker\/cert3.crt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/util\/HostnameMatcher\/cert3.crt","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/util\/HostnameChecker\/cert4.crt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/util\/HostnameMatcher\/cert4.crt","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/util\/HostnameChecker\/cert5.crt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/util\/HostnameMatcher\/cert5.crt","status":"renamed"},{"patch":"@@ -1,232 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4514108\n- * @summary Verify host name matching behaves as defined in RFC2818.\n- * @library \/test\/lib\n- * @modules java.base\/sun.security.util\n- *\/\n-\n-import java.security.cert.*;\n-\n-import jdk.test.lib.security.CertUtils;\n-import sun.security.util.*;\n-\n-\/**\n- * Certificate 1:\n- *   . no subject alternative names, most specific CN is foo1.com.\n- *     (also test if serialnumber attribute is ignored)\n- * <pre>\n-    [\n-    [\n-      Version: V1\n-      Subject: SERIALNUMBER=12 + CN=foo1.com, CN=foo2.com, O=Sun, C=US\n-      Signature Algorithm: SHA1withRSA, OID = 1.2.840.113549.1.1.5\n-\n-      Key:  com.sun.net.ssl.internal.ssl.JSA_RSAPublicKey@1d8957f\n-      Validity: [From: Fri Mar 22 12:22:57 GMT 2002,\n-                   To: Tue Mar 22 12:22:57 GMT 2022]\n-      Issuer: CN=CA, O=Sun, C=US\n-      SerialNumber: [  0  ]\n-\n-    ]\n-      Algorithm: [SHA1withRSA]\n-      Signature:\n-    0000: B8 E1 F8 A8 23 EB C4 E9   F9 03 F6 97 FA DD A2 56  ....#..........V\n-    0010: 06 B6 95 99 68 6B F8 72   6A 27 F4 13 CC 40 06 83  ....hk.rj'...@..\n-    0020: 62 C1 94 72 63 EA 69 FD   78 A2 06 D8 3B F5 D0 2C  b..rc.i.x...;..,\n-    0030: 97 D6 29 84 FA 6F 2E E1   13 6A C7 5D DE 2F 6A 2F  ..)..o...j.].\/j\/\n-    0040: 08 85 43 3B 7D DB C1 AB   1A DC 38 BE F7 4B 6B 82  ..C;......8..Kk.\n-    0050: 84 06 FA 46 82 77 42 A6   47 55 33 63 2B D4 05 2E  ...F.wB.GU3c+...\n-    0060: 76 F5 1B 6A CD 8E B2 B3   83 8E 9D 13 BC 82 0C 4B  v..j...........K\n-    0070: DE 8A 63 B5 EA F1 07 00   C0 7E C9 75 DF 13 FC 34  ..c........u...4\n-\n-    ]\n- * <\/pre>\n- *\n- * Certificate 2:\n- *   . CN contains IP address, must be ignored.\n- * <pre>\n-    [\n-    [\n-      Version: V1\n-      Subject: CN=1.2.3.4, O=Sun, C=US\n-      Signature Algorithm: SHA1withRSA, OID = 1.2.840.113549.1.1.5\n-\n-      Key:  com.sun.net.ssl.internal.ssl.JSA_RSAPublicKey@173831b\n-      Validity: [From: Fri Mar 22 12:22:57 GMT 2002,\n-                   To: Tue Mar 22 12:22:57 GMT 2022]\n-      Issuer: CN=CA, O=Sun, C=US\n-      SerialNumber: [    01]\n-\n-    ]\n-      Algorithm: [SHA1withRSA]\n-      Signature:\n-    0000: 15 86 83 1E 79 7F 8B 06   1F E0 BF 79 0F EA 84 D1  ....y......y....\n-    0010: C5 CD 2C D6 9D 4A 36 7C   75 41 E6 0D 8C 1D 65 60  ..,..J6.uA....e`\n-    0020: 0F 53 15 54 41 43 AE F9   E9 54 34 8A 4B B9 39 12  .S.TAC...T4.K.9.\n-    0030: DE 58 21 86 D3 F9 11 6C   4F 72 EF 8C 4B C3 66 FC  .X!....lOr..K.f.\n-    0040: BD AB 87 63 8F 59 1D C3   FE 76 DB B7 76 43 C2 A1  ...c.Y...v..vC..\n-    0050: 4D D7 92 C4 CA C6 DC 59   CA A6 1B 6D FE 01 AC F4  M......Y...m....\n-    0060: 09 86 D8 A1 40 C4 C2 77   BF 53 21 9A 3B 43 2E 9A  ....@..w.S!.;C..\n-    0070: D4 0C BE 85 47 A5 02 35   7D EE 27 11 36 0E 80 14  ....G..5..'.6...\n-\n-    ]\n- * <\/pre>\n- *\n- * Certificate 3:\n- *   . Contains subject alternative name extension with DNS altfoo1.com,\n- *     DNS altfoo2.com, IP 5.6.7.8. CNs in subject DN must be ignored.\n- * <pre>\n-    [\n-    [\n-      Version: V3\n-      Subject: SERIALNUMBER=12 + CN=foo1.com, CN=foo2.com, O=Sun, C=US\n-      Signature Algorithm: SHA1withRSA, OID = 1.2.840.113549.1.1.5\n-\n-      Key:  com.sun.net.ssl.internal.ssl.JSA_RSAPublicKey@18e2b22\n-      Validity: [From: Fri Mar 22 12:22:57 GMT 2002,\n-                   To: Tue Mar 22 12:22:57 GMT 2022]\n-      Issuer: CN=CA, O=Sun, C=US\n-      SerialNumber: [    02]\n-\n-    Certificate Extensions: 1\n-    [1]: ObjectId: 2.5.29.17 Criticality=false\n-    SubjectAlternativeName [\n-    [DNSName: altfoo1.com, DNSName: altfoo2.com, IPAddress: 5.6.7.8]]\n-\n-    ]\n-      Algorithm: [SHA1withRSA]\n-      Signature:\n-    0000: 65 A6 E5 96 4A D5 8F 8D   3E 70 7D 63 BE B1 58 1C  e...J...>p.c..X.\n-    0010: B5 35 EF 7D E8 00 9C 9E   56 E7 E9 52 71 7B BD 35  .5......V..Rq..5\n-    0020: 3D B5 F5 F7 B2 49 A0 E4   23 BB 2A 0A 25 84 0E E2  =....I..#.*.%...\n-    0030: 4B 6D 61 73 D5 C8 F1 0A   EC 2B F2 98 3D 80 F9 DC  Kmas.....+..=...\n-    0040: F5 D1 2A 36 44 EB 59 9A   E9 DF 97 FA AE C0 86 F1  ..*6D.Y.........\n-    0050: 2C 7B 54 21 F2 3A 56 83   0D E0 5A E1 0D FC D5 E2  ,.T!.:V...Z.....\n-    0060: 45 44 ED C8 C6 F8 26 8E   0C 14 ED D0 F7 37 1C 01  ED....&......7..\n-    0070: A5 E2 61 29 5D 14 B3 5A   EF 72 CC 9B 13 05 B0 B1  ..a)]..Z.r......\n-\n-    ]\n- * <\/pre>\n- *\n- * Certificate 4:\n- *   . SubjAltName contains wildcard char, in the leftmost as well as\n- *     in the middle component.\n- * <pre>\n-   [\n-   [\n-    Version: V3\n-    Subject: SERIALNUMBER=12, O=Sun, C=US\n-    Signature Algorithm: SHA1withRSA, OID = 1.2.840.113549.1.1.5\n-\n-    Key:  com.sun.net.ssl.internal.ssl.JSA_RSAPublicKey@17a8bd\n-    Validity: [From: Mon Apr 01 22:32:38 PST 2002,\n-               To: Fri Apr 01 22:32:38 PST 2022]\n-    Issuer: CN=CA, O=Sun, C=US\n-    SerialNumber: [    02]\n-\n-    Certificate Extensions: 1\n-    [1]: ObjectId: 2.5.29.17 Criticality=false\n-    SubjectAlternativeName [\n-\n-    [DNSName: f*.bar.com, DNSName: altfoo.b*.com]]\n-\n-   ]\n-   Algorithm: [SHA1withRSA]\n-   Signature:\n-   0000: BB 9B 00 DB C9 94 15 34   03 9F 28 59 20 4D 10 63  .......4..(Y M.c\n-   0010: 63 6A F5 C8 56 7B 7C CC   E7 06 7E 1E BE 0B 84 92  cj..V...........\n-   0020: 05 0A 12 5E 21 5D 70 03   DA 27 0B 4E 39 67 FC 8D  ...^!]p..'.N9g..\n-   0030: D6 FC A6 5B F5 CA F1 4C   75 53 33 E3 4F 30 88 68  ...[...LuS3.O0.h\n-   0040: B8 F1 2C DF C2 A8 71 A7   37 55 66 7C 51 23 BB C2  ..,...q.7Uf.Q#..\n-   0050: 25 70 EA EE 44 ED 32 63   56 E0 BA C8 94 36 87 E2  %p..D.2cV....6..\n-   0060: 94 00 2A 3D 4C 46 78 E9   2B 20 9F 73 3C 8E 92 2E  ..*=LFx.+ .s<...\n-   0070: 66 85 C6 27 3A 84 21 94   82 93 B1 A4 94 B6 DE 2F  f..':.!........\/\n-\n-   ]\n- * <\/pre>\n- *\n- *\/\n-\n-public class TestHostnameChecker {\n-\n-    public static void main(String[] args) throws Exception {\n-        X509Certificate cert1 = CertUtils.getCertFromFile(\"cert1.crt\");\n-        X509Certificate cert2 = CertUtils.getCertFromFile(\"cert2.crt\");\n-        X509Certificate cert3 = CertUtils.getCertFromFile(\"cert3.crt\");\n-        X509Certificate cert4 = CertUtils.getCertFromFile(\"cert4.crt\");\n-        X509Certificate cert5 = CertUtils.getCertFromFile(\"cert5.crt\");\n-\n-        HostnameChecker checker = HostnameChecker.getInstance(\n-                HostnameChecker.TYPE_TLS);\n-        System.out.println(\"TLS tests.........\");\n-        System.out.println(\"==================\");\n-        check(checker, \"foo1.com\", cert1, true);\n-        check(checker, \"foo2.com\", cert1, false);\n-        check(checker, \"1.2.3.4\", cert2, false);\n-        check(checker, \"foo1.com\", cert3, false);\n-        check(checker, \"foo2.com\", cert3, false);\n-        check(checker, \"altfoo1.com\", cert3, true);\n-        check(checker, \"altfoo2.com\", cert3, true);\n-        check(checker, \"5.6.7.8\", cert3, true);\n-        check(checker, \"foo.bar.com\", cert4, true);\n-        check(checker, \"altfoo.bar.com\", cert4, true);\n-        check(checker, \"2001:db8:3c4d:15::1a2f:1a2b\", cert5, true);\n-        check(checker, \"2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b\", cert5, true);\n-        check(checker, \"2002:db8:3c4d:15::1a2f:1a2b\", cert5, false);\n-\n-        checker = HostnameChecker.getInstance(\n-                                HostnameChecker.TYPE_LDAP);\n-        System.out.println();\n-        System.out.println(\"LDAP tests.........\");\n-        System.out.println(\"==================\");\n-        check(checker, \"foo1.com\", cert1, true);\n-        check(checker, \"foo2.com\", cert1, false);\n-        check(checker, \"foo1.com\", cert3, false);\n-        check(checker, \"foo2.com\", cert3, false);\n-        check(checker, \"altfoo1.com\", cert3, true);\n-        check(checker, \"altfoo2.com\", cert3, true);\n-        check(checker, \"5.6.7.8\", cert3, true);\n-        check(checker, \"foo.bar.com\", cert4, true);\n-        check(checker, \"altfoo.bar.com\", cert4, false);\n-    }\n-\n-    private static void check(HostnameChecker checker, String name,\n-                 X509Certificate cert, boolean expectedResult)\n-                 throws Exception {\n-        try {\n-            checker.match(name, cert);\n-            if (expectedResult == false) {\n-                throw new Exception(\"Passed invalid test: \" + name);\n-            }\n-        } catch (CertificateException e) {\n-            if (expectedResult == true) {\n-                throw e;\n-            }\n-        }\n-        System.out.println(\"OK: \" + name);\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/util\/HostnameMatcher\/TestHostnameChecker.java","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-        PemEncoding $TESTSRC\/..\/HostnameMatcher\/cert5.crt\n+        PemEncoding $TESTSRC\/..\/HostnameChecker\/cert5.crt\n","filename":"test\/jdk\/sun\/security\/util\/Pem\/encoding.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277976\n+ * @summary Break up SEQUENCE in X509Certificate::getSubjectAlternativeNames\n+ *          and X509Certificate::getIssuerAlternativeNames in otherName\n+ * @modules java.base\/sun.security.util\n+ *          java.base\/sun.security.x509\n+ *          java.base\/sun.security.tools.keytool\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.util.DerValue;\n+import sun.security.util.ObjectIdentifier;\n+import sun.security.x509.CertificateExtensions;\n+import sun.security.x509.DNSName;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.OIDMap;\n+import sun.security.x509.OtherName;\n+import sun.security.x509.SubjectAlternativeNameExtension;\n+import sun.security.x509.X500Name;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Date;\n+\n+public class Parse {\n+\n+    public static class MyDNSName extends DNSName {\n+        public MyDNSName(byte[] in) throws IOException {\n+            super(new String(Arrays.copyOfRange(in, 2, in.length),\n+                    StandardCharsets.US_ASCII));\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        OIDMap.addAttribute(\"n1\", \"1.2.3.6\", MyDNSName.class);\n+\n+        CertificateExtensions exts = new CertificateExtensions();\n+        GeneralNames names = new GeneralNames();\n+\n+        byte[] d1 = new byte[] {\n+                DerValue.tag_OctetString, 5, 'a', '.', 'c', 'o', 'm' };\n+        names.add(new GeneralName(\n+                new OtherName(ObjectIdentifier.of(\"1.2.3.5\"), d1)));\n+\n+        byte[] d2 = new byte[] {\n+                DerValue.tag_UTF8String, 5, 'a', '.', 'c', 'o', 'm' };\n+        names.add(new GeneralName(\n+                new OtherName(ObjectIdentifier.of(\"1.2.3.6\"), d2)));\n+\n+        exts.set(\"x\", new SubjectAlternativeNameExtension(names));\n+        CertAndKeyGen g = new CertAndKeyGen(\"Ed25519\", \"Ed25519\");\n+        g.generate(-1);\n+        X509Certificate x = g.getSelfCertificate(new X500Name(\"CN=ME\"),\n+                new Date(),\n+                100000,\n+                exts);\n+\n+        int found = 0;\n+        for (var san : x.getSubjectAlternativeNames()) {\n+            if (san.size() >= 4 && san.get(0).equals(0)) {\n+                if (san.get(2).equals(\"1.2.3.5\")) {\n+                    Asserts.assertTrue(Arrays.equals((byte[]) san.get(3), d1));\n+                    found++;\n+                } else if (san.get(2).equals(\"1.2.3.6\")) {\n+                    Asserts.assertEQ(san.get(3), \"a.com\");\n+                    found++;\n+                }\n+            }\n+        }\n+        Asserts.assertEQ(found, 2);\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/security\/x509\/OtherName\/Parse.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -137,1 +137,1 @@\n-            OutputAnalyzer output = ProcessTools.executeProcess(processBuilder);;\n+            OutputAnalyzer output = ProcessTools.executeProcess(processBuilder);\n@@ -174,1 +174,1 @@\n-            OutputAnalyzer output = ProcessTools.executeProcess(processBuilder);;\n+            OutputAnalyzer output = ProcessTools.executeProcess(processBuilder);\n","filename":"test\/jdk\/sun\/tools\/jhsdb\/BasicLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-            this.uses = uses != null ? uses : Collections.emptySet();;\n+            this.uses = uses != null ? uses : Collections.emptySet();\n","filename":"test\/jdk\/tools\/jar\/modularJar\/Basic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-            int save = getVersion();;\n+            int save = getVersion();\n","filename":"test\/jdk\/tools\/jar\/multiRelease\/data\/test13\/v10\/version\/Nested.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.Supplier;\n@@ -89,0 +90,12 @@\n+    final public String getRawPropertyValue(\n+            String key, Supplier<String> getDefault) {\n+        return rawProperties.stream()\n+                .filter(item -> item.getKey().equals(key))\n+                .map(e -> e.getValue()).findAny().orElseGet(getDefault);\n+    }\n+\n+    private String getDesciption(JPackageCommand cmd) {\n+        return getRawPropertyValue(\"description\", () -> cmd.getArgumentValue(\n+                \"--description\", unused -> cmd.name()));\n+    }\n+\n@@ -284,0 +297,20 @@\n+    private void verifyDescription(JPackageCommand cmd) throws IOException {\n+        if (TKit.isWindows()) {\n+            String expectedDescription = getDesciption(cmd);\n+            Path launcherPath = cmd.appLauncherPath(name);\n+            String actualDescription =\n+                    WindowsHelper.getExecutableDesciption(launcherPath);\n+            TKit.assertEquals(expectedDescription, actualDescription,\n+                    String.format(\"Check file description of [%s]\", launcherPath));\n+        } else if (TKit.isLinux() && !cmd.isImagePackageType()) {\n+            String expectedDescription = getDesciption(cmd);\n+            Path desktopFile = LinuxHelper.getDesktopFile(cmd, name);\n+            if (Files.exists(desktopFile)) {\n+                TKit.assertTextStream(\"Comment=\" + expectedDescription)\n+                        .label(String.format(\"[%s] file\", desktopFile))\n+                        .predicate(String::equals)\n+                        .apply(Files.readAllLines(desktopFile).stream());\n+            }\n+        }\n+    }\n+\n@@ -287,0 +320,1 @@\n+        verifyDescription(cmd);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -166,0 +166,23 @@\n+    public static String getExecutableDesciption(Path pathToExeFile) {\n+        Executor exec = Executor.of(\"powershell\",\n+                \"-NoLogo\",\n+                \"-NoProfile\",\n+                \"-Command\",\n+                \"(Get-Item \\\\\\\"\"\n+                + pathToExeFile.toAbsolutePath()\n+                + \"\\\\\\\").VersionInfo | select FileDescription\");\n+\n+        var lineIt = exec.dumpOutput().executeAndGetOutput().iterator();\n+        while (lineIt.hasNext()) {\n+            var line = lineIt.next();\n+            if (line.trim().equals(\"FileDescription\")) {\n+                \/\/ Skip \"---------------\" and move to the description value\n+                lineIt.next();\n+                return lineIt.next().trim();\n+            }\n+        }\n+\n+        throw new RuntimeException(String.format(\n+                \"Failed to get file description of [%s]\", pathToExeFile));\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * launchers.\n+ * launchers with unique description (\"LauncherName Description\").\n@@ -83,1 +83,2 @@\n-                    \"--arguments\", \"the\", \"--arguments\", \"King\");\n+                    \"--arguments\", \"the\", \"--arguments\", \"King\",\n+                    \"--description\", \"AddLauncherTest Description\");\n@@ -92,0 +93,1 @@\n+                .addRawProperties(Map.entry(\"description\", \"Baz2 Description\"))\n@@ -96,0 +98,1 @@\n+                .addRawProperties(Map.entry(\"description\", \"foo Description\"))\n@@ -100,0 +103,1 @@\n+                .addRawProperties(Map.entry(\"description\", \"Bar Description\"))\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,2 @@\n- * In otherwords the TypeParameter in scope should be used ex: Interface<IE>, Parent<PE>\n-   and Child<CE>\n+ * In other words the TypeParameter in scope should be used ex: Interface<IE>, Parent<PE>\n+ * and Child<CE>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-        public void foo();\n+    public void foo();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg3\/I2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-        public void foo();\n+    public void foo();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg3\/I3.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-        public void foo();\n+    public void foo();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg3\/I4.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-    public static class P<K, V> extends GP {\n+   public static class P<K, V> extends GP {\n@@ -38,2 +38,2 @@\n-       \/** A nested class in parent *\/\n-       public class PN<K, V>{}\n+      \/** A nested class in parent *\/\n+      public class PN<K, V>{}\n@@ -41,5 +41,5 @@\n-       \/** A property in parent *\/\n-       private DoubleProperty rate;\n-       public final void setRate(double l){}\n-       public final double getRate(){return 1;}\n-       public DoubleProperty rateProperty() {return null;}\n+      \/** A property in parent *\/\n+      private DoubleProperty rate;\n+      public final void setRate(double l){}\n+      public final double getRate(){return 1;}\n+      public DoubleProperty rateProperty() {return null;}\n@@ -47,2 +47,2 @@\n-        \/** A ctor in parent *\/\n-       public P() {}\n+      \/** A ctor in parent *\/\n+      public P() {}\n@@ -50,5 +50,5 @@\n-       \/**\n-        * A ctor in parent.\n-        * @param s string\n-        *\/\n-       public P(String s) {}\n+      \/**\n+       * A ctor in parent.\n+       * @param s string\n+       *\/\n+      public P(String s) {}\n@@ -56,2 +56,2 @@\n-       \/** field0 in parent *\/\n-       public int field0;\n+      \/** field0 in parent *\/\n+      public int field0;\n@@ -59,2 +59,2 @@\n-       \/** field1 in parent *\/\n-       public int field1;\n+      \/** field1 in parent *\/\n+      public int field1;\n@@ -63,30 +63,2 @@\n-       \/\/ m0 in parent\n-       public void m0() {}\n-\n-       \/** m1 in parent *\/\n-       public void m1() {}\n-\n-       \/** m2 in parent *\/\n-       public void m2() {}\n-\n-       \/** m3 in parent *\/\n-       public void m3() {}\n-\n-       \/** m4 in parent\n-           @param k a key\n-           @param v a value\n-        *\/\n-       public void m4(K k, V v) {}\n-\n-       \/\/ No comment\n-       public void m5() {}\n-\n-       \/\/ No comment\n-       public void m6() {}\n-\n-        \/** {@inheritDoc} *\/\n-        public void m7() {}\n-\n-    }\n-\n-    public static class C extends P {\n+      \/\/ m0 in parent\n+      public void m0() {}\n@@ -94,1 +66,2 @@\n-       public C(String s) {}\n+      \/** m1 in parent *\/\n+      public void m1() {}\n@@ -96,1 +69,2 @@\n-       public int field1;\n+      \/** m2 in parent *\/\n+      public void m2() {}\n@@ -98,2 +72,2 @@\n-       \/** A modified method *\/\n-       public void m1() {}\n+      \/** m3 in parent *\/\n+      public void m3() {}\n@@ -101,2 +75,5 @@\n-       \/** {@inheritDoc} *\/\n-       public void m2() {}\n+      \/** m4 in parent\n+       @param k a key\n+       @param v a value\n+       *\/\n+      public void m4(K k, V v) {}\n@@ -104,2 +81,2 @@\n-       \/\/ No comment method\n-       public void m3() {}\n+      \/\/ No comment\n+      public void m5() {}\n@@ -107,1 +84,2 @@\n-       public void m4(String k, String v) {}\n+      \/\/ No comment\n+      public void m6() {}\n@@ -109,2 +87,2 @@\n-       \/\/ Do something else than the parent\n-       public void m5() {}\n+      \/** {@inheritDoc} *\/\n+      public void m7() {}\n@@ -112,21 +90,1 @@\n-       \/** A test of links to the methods in this class. <p>\n-        * {@link m0},\n-        * {@link m1},\n-        * {@link m2},\n-        * {@link m3},\n-        * {@link m4},\n-        * {@link m5},\n-        * {@link m6},\n-        * {@link m7},\n-        * End of links\n-        *\n-        * @see #m0()\n-        * @see #m1()\n-        * @see #m2()\n-        * @see #m3()\n-        * @see #m4(String k, String v)\n-        * @see #m5()\n-        * @see #m6()\n-        * @see #m7()\n-        *\/\n-       public void m6() {}\n+   }\n@@ -134,3 +92,45 @@\n-        \/** m7 in Child. *\/\n-        public void m7() {}\n-    }\n+   public static class C extends P {\n+\n+      public C(String s) {}\n+\n+      public int field1;\n+\n+      \/** A modified method *\/\n+      public void m1() {}\n+\n+      \/** {@inheritDoc} *\/\n+      public void m2() {}\n+\n+      \/\/ No comment method\n+      public void m3() {}\n+\n+      public void m4(String k, String v) {}\n+\n+      \/\/ Do something else than the parent\n+      public void m5() {}\n+\n+      \/** A test of links to the methods in this class. <p>\n+       * {@link m0},\n+       * {@link m1},\n+       * {@link m2},\n+       * {@link m3},\n+       * {@link m4},\n+       * {@link m5},\n+       * {@link m6},\n+       * {@link m7},\n+       * End of links\n+       *\n+       * @see #m0()\n+       * @see #m1()\n+       * @see #m2()\n+       * @see #m3()\n+       * @see #m4(String k, String v)\n+       * @see #m5()\n+       * @see #m6()\n+       * @see #m7()\n+       *\/\n+      public void m6() {}\n+\n+      \/** m7 in Child. *\/\n+      public void m7() {}\n+   }\n@@ -138,2 +138,2 @@\n-    \/** Tickle this {@link TestEnum#doSomething()} *\/\n-    public class DoubleProperty {}\n+   \/** Tickle this {@link TestEnum#doSomething()} *\/\n+   public class DoubleProperty {}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg5\/Classes.java","additions":87,"deletions":87,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-     public interface A {\n+    public interface A {\n@@ -29,2 +29,2 @@\n-         \/** field f in A *\/\n-         public int f = 0;\n+        \/** field f in A *\/\n+        public int f = 0;\n@@ -32,1 +32,1 @@\n-         public static String QUOTE = \"Winter is coming\";\n+        public static String QUOTE = \"Winter is coming\";\n@@ -34,2 +34,2 @@\n-         \/** a documented static method *\/\n-         public static void msd() {}\n+        \/** a documented static method *\/\n+        public static void msd() {}\n@@ -37,2 +37,2 @@\n-         \/* An undocumented static method *\/\n-         public static void msn() {}\n+        \/* An undocumented static method *\/\n+        public static void msn() {}\n@@ -40,7 +40,7 @@\n-         \/** A property in parent *\/\n-         DoubleProperty rate = null;\n-         public void setRate(double l);\n-         public double getRate();\n-         public DoubleProperty rateProperty();\n-         \/\/ A support class\n-         public interface DoubleProperty {}\n+        \/** A property in parent *\/\n+        DoubleProperty rate = null;\n+        public void setRate(double l);\n+        public double getRate();\n+        public DoubleProperty rateProperty();\n+        \/\/ A support class\n+        public interface DoubleProperty {}\n@@ -48,2 +48,2 @@\n-         \/** AA in A *\/\n-         public interface AA {}\n+        \/** AA in A *\/\n+        public interface AA {}\n@@ -51,2 +51,2 @@\n-         \/** m0 in A *\/\n-         public void m0();\n+        \/** m0 in A *\/\n+        public void m0();\n@@ -54,2 +54,2 @@\n-         \/** m1 in A *\/\n-         public void m1();\n+        \/** m1 in A *\/\n+        public void m1();\n@@ -57,2 +57,2 @@\n-         \/** m2 in A *\/\n-         public void m2();\n+        \/** m2 in A *\/\n+        public void m2();\n@@ -60,3 +60,3 @@\n-         \/** m3 in A *\/\n-         public void m3();\n-     }\n+        \/** m3 in A *\/\n+        public void m3();\n+    }\n@@ -64,3 +64,3 @@\n-     public interface B extends A {\n-         \/\/ No comment\n-         public void m0();\n+    public interface B extends A {\n+        \/\/ No comment\n+        public void m0();\n@@ -68,2 +68,2 @@\n-         \/** m1 in B *\/\n-         public void m1();\n+        \/** m1 in B *\/\n+        public void m1();\n@@ -71,2 +71,2 @@\n-         \/** {@inheritDoc} *\/\n-         public void m2();\n+        \/** {@inheritDoc} *\/\n+        public void m2();\n@@ -74,2 +74,2 @@\n-         \/** @throws Exception e *\/\n-         public void m3() throws Exception;\n+        \/** @throws Exception e *\/\n+        public void m3() throws Exception;\n@@ -77,3 +77,3 @@\n-         \/** n in B *\/\n-         public void n();\n-     }\n+        \/** n in B *\/\n+        public void n();\n+    }\n@@ -81,3 +81,3 @@\n-     public interface C extends A, B  {\n-         \/** m in C *\/\n-         public void m();\n+    public interface C extends A, B  {\n+        \/** m in C *\/\n+        public void m();\n@@ -85,3 +85,3 @@\n-         \/** o in C *\/\n-         public void o();\n-     }\n+        \/** o in C *\/\n+        public void o();\n+    }\n@@ -111,2 +111,2 @@\n-         \/** m in D *\/\n-         public void m();\n+        \/** m in D *\/\n+        public void m();\n@@ -114,2 +114,2 @@\n-         \/** n in D *\/\n-         public void n();\n+        \/** n in D *\/\n+        public void n();\n@@ -117,4 +117,4 @@\n-         \/\/ no comment\n-         public void o();\n-     }\n- }\n+        \/\/ no comment\n+        public void o();\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg5\/Interfaces.java","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg6\/Sub.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug      8250768 8261976 8277300\n+ * @bug      8250768 8261976 8277300 8282452\n@@ -123,0 +123,14 @@\n+\n+    @Test\n+    public void test8282452() {\n+        javadoc(\"-d\", \"out-8282452\",\n+                \"--patch-module\", \"java.base=\" + Paths.get(testSrc, \"api\").toAbsolutePath().toString(),\n+                \"--add-exports\", \"java.base\/preview=m\",\n+                \"--source-path\", Paths.get(testSrc, \"api\").toAbsolutePath().toString(),\n+                \"--show-packages=all\",\n+                \"preview\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"java.base\/preview\/NoPreview.html\", false,\n+                    \"refers to one or more preview\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPreview\/TestPreview.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package preview;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.javac.PreviewFeature.Feature;\n+\n+public class NoPreview {\n+\n+    @PreviewFeature(feature=Feature.TEST)\n+    public T get() {\n+        return null;\n+    }\n+\n+    @PreviewFeature(feature=Feature.TEST)\n+    public static class T {}\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPreview\/api\/preview\/NoPreview.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-                \/\/ Field inheritence from non-public superclass.\n+                \/\/ Field inheritance from non-public superclass.\n@@ -159,1 +159,1 @@\n-                \/\/ Field inheritence from non-public superclass.\n+                \/\/ Field inheritance from non-public superclass.\n@@ -164,1 +164,1 @@\n-                \/\/ Method inheritence from non-public superclass.\n+                \/\/ Method inheritance from non-public superclass.\n@@ -198,1 +198,1 @@\n-                \/\/ Field inheritence from non-public superinterface.\n+                \/\/ Field inheritance from non-public superinterface.\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPrivateClasses\/TestPrivateClasses.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      4490068 8075778\n+ * @bug      4490068 8075778 8283041\n@@ -268,0 +268,10 @@\n+                    \"\"\",\n+                \"\"\"\n+                    \/** Comment. *\/\n+                    public class X {\n+                        \/**\n+                         * @author Jim\n+                         * {@return the result}\n+                         *\/\n+                        public int m() { return 0; }\n+                    }\n@@ -272,1 +282,2 @@\n-                src.resolve(\"C.java\").toString());\n+                src.resolve(\"C.java\").toString(),\n+                src.resolve(\"X.java\").toString());\n@@ -278,0 +289,3 @@\n+        checkOutput(Output.OUT, true,\n+                \"X.java:5: warning: {@return} not at beginning of description\");\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testReturnTag\/TestReturnTag.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -414,1 +414,1 @@\n-                    <script type=\"text\/javascript\" src=\"script-dir\/jquery-3.5.1.min.js\"><\/script>\n+                    <script type=\"text\/javascript\" src=\"script-dir\/jquery-3.6.0.min.js\"><\/script>\n@@ -687,1 +687,1 @@\n-                \"script-dir\/jquery-3.5.1.min.js\",\n+                \"script-dir\/jquery-3.6.0.min.js\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearch\/TestSearch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      8017191 8182765 8200432 8239804 8250766 8262992\n+ * @bug      8017191 8182765 8200432 8239804 8250766 8262992 8281944\n@@ -28,1 +28,1 @@\n- * @library  ..\/..\/lib\n+ * @library  \/tools\/lib ..\/..\/lib\n@@ -30,1 +30,1 @@\n- * @build    javadoc.tester.*\n+ * @build    toolbox.ToolBox javadoc.tester.*\n@@ -35,0 +35,4 @@\n+import toolbox.ToolBox;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n@@ -113,0 +117,36 @@\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testErroneous() throws IOException {\n+        Path src = Path.of(\"erroneous\", \"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package erroneous;\n+                \/**\n+                 * Comment.\n+                 * @see <a href=\"\n+                 *\/\n+                public class C {\n+                    private C() { }\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", Path.of(\"erroneous\", \"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--no-platform-links\",\n+                \"erroneous\");\n+        checkExit(Exit.ERROR);\n+\n+        checkOutput(\"erroneous\/C.html\", true,\n+                \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>See Also:<\/dt>\n+                    <dd>\n+                    <ul class=\"see-list\">\n+                    <li><span class=\"invalid-tag\">invalid input: '&lt;a href=\"'<\/span><\/li>\n+                    <\/ul>\n+                    <\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeTag\/TestSeeTag.java","additions":44,"deletions":4,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     4496223 4496270 4618686 4720974 4812240 6253614 6253604\n+ * @summary <DESC>\n+ * @library ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.*\n+ * @run main TestTagInheritance\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+\n+public class TestTagInheritance extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestTagInheritance tester = new TestTagInheritance();\n+        tester.runTests();\n+    }\n+\n+    @Test\n+    public void test() {\n+        javadoc(\"-Xdoclint:none\",\n+                \"-d\", \"out\",\n+                \"-sourcepath\", testSrc,\n+                \"pkg\", \"firstSentence\", \"firstSentence2\");\n+        checkExit(Exit.OK);\n+\n+        \/\/Test bad inheritDoc tag warning.\n+        checkOutput(Output.OUT, true,\n+                \"warning: @inheritDoc used but testBadInheritDocTag() \"\n+                + \"does not override or implement any method.\");\n+\n+        \/\/Test valid usage of inheritDoc tag.\n+        for (int i = 1; i < 40; i++) {\n+            checkOutput(\"pkg\/TestTagInheritance.html\", true,\n+                    \"Test \" + i + \" passes\");\n+        }\n+\n+        \/\/First sentence test (6253614)\n+        checkOutput(\"firstSentence\/B.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">First sentence.<\/div>\"\"\");\n+\n+        \/\/Another first sentence test (6253604)\n+        checkOutput(\"firstSentence2\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">First sentence.<\/div>\"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/TestTagInheritance.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug     4496223 4496270 4618686 4720974 4812240 6253614 6253604\n- * @summary <DESC>\n- * @library ..\/..\/lib\n- * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n- * @build javadoc.tester.*\n- * @run main TestTagInheritence\n- *\/\n-\n-\/\/ TODO: Inheritence should be Inheritance!   fix separately as noreg-trivial\n-import javadoc.tester.JavadocTester;\n-\n-public class TestTagInheritence extends JavadocTester {\n-\n-    public static void main(String... args) throws Exception {\n-        TestTagInheritence tester = new TestTagInheritence();\n-        tester.runTests();\n-    }\n-\n-    @Test\n-    public void test() {\n-        javadoc(\"-Xdoclint:none\",\n-                \"-d\", \"out\",\n-                \"-sourcepath\", testSrc,\n-                \"pkg\", \"firstSentence\", \"firstSentence2\");\n-        checkExit(Exit.OK);\n-\n-        \/\/Test bad inheritDoc tag warning.\n-        checkOutput(Output.OUT, true,\n-                \"warning: @inheritDoc used but testBadInheritDocTag() \"\n-                + \"does not override or implement any method.\");\n-\n-        \/\/Test valid usage of inheritDoc tag.\n-        for (int i = 1; i < 40; i++) {\n-            checkOutput(\"pkg\/TestTagInheritence.html\", true,\n-                    \"Test \" + i + \" passes\");\n-        }\n-\n-        \/\/First sentence test (6253614)\n-        checkOutput(\"firstSentence\/B.html\", true,\n-                \"\"\"\n-                    <div class=\"block\">First sentence.<\/div>\"\"\");\n-\n-        \/\/Another first sentence test (6253604)\n-        checkOutput(\"firstSentence2\/C.html\", true,\n-                \"\"\"\n-                    <div class=\"block\">First sentence.<\/div>\"\"\");\n-    }\n-}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/TestTagInheritence.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-public class TestTagInheritence extends TestAbstractClass implements TestInterface{\n+public class TestTagInheritance extends TestAbstractClass implements TestInterface{\n@@ -31,1 +31,1 @@\n-  \/\/This method below tests tag inheritence from a class.\n+  \/\/This method below tests tag inheritance from a class.\n@@ -60,1 +60,1 @@\n-   * This method tests @inheritDoc with an inteface.  Here is the inherited comment:<br>\n+   * This method tests @inheritDoc with an interface.  Here is the inherited comment:<br>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/pkg\/TestTagInheritance.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/pkg\/TestTagInheritence.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/C.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/C.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/Foo.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/Foo.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/I.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/I.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/Iface.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/Iface.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main TestThrowsTagInheritence\n+ * @run main TestThrowsTagInheritance\n@@ -36,1 +36,0 @@\n-\/\/ TODO: should be TestThrowsInheritance!\n@@ -39,1 +38,1 @@\n-public class TestThrowsTagInheritence extends JavadocTester {\n+public class TestThrowsTagInheritance extends JavadocTester {\n@@ -42,1 +41,1 @@\n-        TestThrowsTagInheritence tester = new TestThrowsTagInheritence();\n+        TestThrowsTagInheritance tester = new TestThrowsTagInheritance();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/TestThrowsTagInheritance.java","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/TestThrowsTagInheritence.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/pkg\/Abstract.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/pkg\/Abstract.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/pkg\/Extender.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/pkg\/Extender.java","status":"renamed"},{"patch":"@@ -61,0 +61,1 @@\n+import java.util.stream.Stream;\n@@ -269,1 +270,4 @@\n-     * Typically called on a tester object in main()\n+     * The methods are invoked in the order found using getDeclaredMethods.\n+     * The arguments for the invocation are provided {@link #getTestArgs(Method)}.\n+     *\n+     * Typically called on a tester object in main().\n@@ -271,0 +275,1 @@\n+     * @throws IllegalArgumentException if any test method does not have a recognized signature\n@@ -274,1 +279,1 @@\n-        runTests(m -> new Object[0]);\n+        runTests(this::getTestArgs);\n@@ -279,0 +284,3 @@\n+     * The methods are invoked in the order found using getDeclaredMethods.\n+     * The arguments for the invocation are provided by a given function.\n+     *\n@@ -283,1 +291,1 @@\n-     * @throws Exception if any errors occurred\n+     * @throws Exception if any errors occurred while executing a test method\n@@ -286,1 +294,1 @@\n-        for (Method m: getClass().getDeclaredMethods()) {\n+        for (Method m : getClass().getDeclaredMethods()) {\n@@ -289,7 +297,1 @@\n-                try {\n-                    out.println(\"Running test \" + m.getName());\n-                    m.invoke(this, f.apply(m));\n-                } catch (InvocationTargetException e) {\n-                    Throwable cause = e.getCause();\n-                    throw (cause instanceof Exception) ? ((Exception) cause) : e;\n-                }\n+                runTest(m, f);\n@@ -302,0 +304,89 @@\n+    \/**\n+     * Run the specified methods annotated with @Test, or all methods annotated\n+     * with @Test if none are specified, followed by printSummary.\n+     * The methods are invoked in the order given in the methodNames argument,\n+     * or the order returned by getDeclaredMethods if no names are provided.\n+     * The arguments for the invocation are provided {@link #getTestArgs(Method)}.\n+     *\n+     * Typically called on a tester object in main(String[] args), perhaps using\n+     * args as the list of method names.\n+     *\n+     * @throws IllegalStateException if any methods annotated with @Test are overloaded\n+     * @throws IllegalArgumentException if any of the method names does not name a suitable method\n+     * @throws NullPointerException if {@code methodNames} is {@code null}, or if any of the names are {@code null}\n+     * @throws Exception if any errors occurred while executing a test method\n+     *\/\n+    public void runTests(String... methodNames) throws Exception {\n+        runTests(this::getTestArgs, methodNames);\n+    }\n+\n+    \/**\n+     * Run the specified methods annotated with @Test, or all methods annotated\n+     * with @Test if non are specified, followed by printSummary.\n+     * The methods are invoked in the order given in the methodNames argument,\n+     * or the order returned by getDeclaredMethods if no names are provided.\n+     * The arguments for the invocation are provided {@link #getTestArgs(Method)}.\n+     *\n+     * Typically called on a tester object in main(String[] args), perhaps using\n+     * args as the list of method names.\n+     *\n+     * @throws IllegalStateException if any methods annotated with @Test are overloaded\n+     * @throws IllegalArgumentException if any of the method names does not name a suitable method\n+     * @throws NullPointerException if {@code methodNames} is {@code null}, or if any of the names are {@code null}\n+     * @throws Exception if any errors occurred while executing a test method\n+     *\/\n+    public void runTests(Function<Method, Object[]> f, String... methodNames) throws Exception {\n+        if (methodNames.length == 0) {\n+            runTests(f);\n+        } else {\n+            Map<String, Method> testMethods = Stream.of(getClass().getDeclaredMethods())\n+                    .filter(this::isTestMethod)\n+                    .collect(Collectors.toMap(Method::getName, Function.identity(),\n+                            (o, n) -> {\n+                                throw new IllegalStateException(\"test method \" + o.getName() + \" is overloaded\");\n+                            }));\n+\n+            List<Method> list = new ArrayList<>();\n+            for (String mn : methodNames) {\n+                Method m = testMethods.get(mn);\n+                if (m == null) {\n+                    throw new IllegalArgumentException(\"test method \" + mn + \" not found\");\n+                }\n+                list.add(m);\n+            }\n+\n+            for (Method m : list) {\n+                runTest(m, f);\n+            }\n+        }\n+    }\n+\n+    protected boolean isTestMethod(Method m) {\n+        return m.getAnnotation(Test.class) != null;\n+    }\n+\n+    protected Object[] getTestArgs(Method m) throws IllegalArgumentException {\n+        Class<?>[] paramTypes = m.getParameterTypes();\n+        if (paramTypes.length == 0) {\n+            return new Object[] {};\n+        } else if (paramTypes.length == 1 && paramTypes[0] == Path.class) {\n+            return new Object[] { Path.of(m.getName())};\n+        } else {\n+            throw new IllegalArgumentException(\"unknown signature for method \"\n+                    + m + Stream.of(paramTypes)\n+                    .map(Class::toString)\n+                    .collect(Collectors.joining(\", \", \"(\", \")\")))  ;\n+        }\n+    }\n+\n+    protected void runTest(Method m, Function<Method, Object[]> f) throws Exception {\n+        try {\n+            out.println(\"Running test \" + m.getName());\n+            m.invoke(this, f.apply(m));\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            throw (cause instanceof Exception) ? ((Exception) cause) : e;\n+        }\n+\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":102,"deletions":11,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8272853\n+ * @summary improve `JavadocTester.runTests`\n+ * @library \/tools\/lib\/ ..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestRunTests\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+\n+import java.io.PrintStream;\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+public class TestRunTests {\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface RunTest {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        TestRunTests t = new TestRunTests();\n+        t.run();\n+    }\n+\n+    PrintStream out = System.out;\n+\n+    void run() throws Exception {\n+        for (Method m : getClass().getDeclaredMethods()) {\n+            Annotation a = m.getAnnotation(RunTest.class);\n+            if (a != null) {\n+                try {\n+                    out.println(\"Running \" + m);\n+                    m.invoke(this);\n+                    out.println();\n+                } catch (InvocationTargetException e) {\n+                    error(\"Invocation Target Exception while running \" + m + \": \" + e.getCause());\n+                } catch (Exception e) {\n+                    error(\"Exception while running \" + m + \": \" + e);\n+                }\n+            }\n+        }\n+        out.flush();\n+        if (errors > 0) {\n+            out.println(errors + \" errors occurred\");\n+            throw new Exception(errors + \" errors occurred\");\n+        }\n+    }\n+\n+    int errors;\n+\n+    @RunTest\n+    public void testNoArgs() throws Exception {\n+        MainGroup g = new MainGroup();\n+        g.runTests();\n+        checkEqualUnordered(g.log, Set.of(\"m1()\", \"m2(m2)\", \"m3()\", \"m4(m4)\"));\n+    }\n+\n+    @RunTest\n+    public void testMethodNames() throws Exception {\n+        MainGroup g = new MainGroup();\n+        g.runTests(\"m1\", \"m4\", \"m2\");\n+        checkEqualOrdered(g.log, List.of(\"m1()\", \"m4(m4)\", \"m2(m2)\"));\n+    }\n+\n+    @RunTest\n+    public void testFunction() throws Exception {\n+        Function<Method, Object[]> f = m ->\n+                switch (m.getName()) {\n+                    case \"m1\", \"m3\" -> new Object[]{};\n+                    case \"m2\", \"m4\" -> new Object[]{Path.of(m.getName().toUpperCase(Locale.ROOT))};\n+                    default -> throw new IllegalArgumentException(m.toString());\n+                };\n+        MainGroup g = new MainGroup();\n+        g.runTests(f);\n+        checkEqualUnordered(g.log, Set.of(\"m1()\", \"m2(M2)\", \"m3()\", \"m4(M4)\"));\n+    }\n+\n+    @RunTest\n+    public void testFunctionMethodNames() throws Exception {\n+        Function<Method, Object[]> f = m ->\n+                switch (m.getName()) {\n+                    case \"m1\", \"m3\" -> new Object[]{};\n+                    case \"m2\", \"m4\" -> new Object[]{Path.of(m.getName().toUpperCase(Locale.ROOT))};\n+                    default -> throw new IllegalArgumentException(m.toString());\n+                };\n+        MainGroup g = new MainGroup();\n+        g.runTests(f, \"m1\", \"m4\", \"m2\");\n+        checkEqualOrdered(g.log, List.of(\"m1()\", \"m4(M4)\", \"m2(M2)\"));\n+    }\n+\n+    @RunTest\n+    public void testMethodNotFound() throws Exception {\n+        MainGroup g = new MainGroup();\n+        try {\n+            g.runTests(\"m1\", \"m2\", \"mx\", \"m3\", \"m4\");\n+        } catch (IllegalArgumentException e) {\n+            g.log.add(e.toString());\n+        }\n+        \/\/ implicit in the following is that the error was detected before any test methods were executed\n+        checkEqualOrdered(g.log, List.of(\"java.lang.IllegalArgumentException: test method mx not found\"));\n+    }\n+\n+    @RunTest\n+    public void testInvalidSignature() throws Exception {\n+        InvalidSignatureGroup g = new InvalidSignatureGroup();\n+        try {\n+            g.runTests();\n+        } catch (IllegalArgumentException e) {\n+            g.log.add(e.toString());\n+        }\n+        \/\/ since the exception comes from the nested use of `getTestArgs`, it will be thrown\n+        \/\/ when the test method is being called, and so is not constrained to be thrown\n+        \/\/ before any test method is called\n+        checkContainsAll(g.log, List.of(\"java.lang.IllegalArgumentException: unknown signature for method \"\n+                + \"public void TestRunTests$InvalidSignatureGroup.invalidSignature(java.lang.Object)(class java.lang.Object)\"));\n+    }\n+\n+    @RunTest\n+    public void testOverloadedMethod() throws Exception {\n+        OverloadGroup g = new OverloadGroup();\n+        try {\n+            g.runTests(\"m1\");\n+        } catch (IllegalStateException e) {\n+            g.log.add(e.toString());\n+        }\n+        \/\/ implicit in the following is that the error was detected before any test methods were executed\n+        checkEqualOrdered(g.log, List.of(\"java.lang.IllegalStateException: test method m1 is overloaded\"));\n+    }\n+\n+    void checkContainsAll(List<String> found, List<String> expect) {\n+        if (!found.containsAll(expect)) {\n+            out.println(\"Found:  \" + found);\n+            out.println(\"Expect: \" + expect);\n+            error(\"Expected results not found\");\n+        }\n+    }\n+\n+    void checkEqualOrdered(List<String> found, List<String> expect) {\n+        if (!found.equals(expect)) {\n+            out.println(\"Found:  \" + found);\n+            out.println(\"Expect: \" + expect);\n+            error(\"Expected results not found\");\n+        }\n+    }\n+\n+    void checkEqualUnordered(List<String> found, Set<String> expect) {\n+        if (!(found.containsAll(expect) && expect.containsAll(found))) {\n+            out.println(\"Found:  \" + found);\n+            out.println(\"Expect: \" + expect);\n+            error(\"Expected results not found\");\n+        }\n+    }\n+\n+    void error(String message) {\n+        out.println(\"Error: \" + message);\n+        errors++;\n+    }\n+\n+    \/**\n+     * A group of tests to be executed by different overloads of {@code runTests}.\n+     *\/\n+    public static class MainGroup extends JavadocTester {\n+        List<String> log = new ArrayList<>();\n+\n+        @Test\n+        public void m1() {\n+            log.add(\"m1()\");\n+            checking(\"m1\");\n+            passed(\"OK\");\n+        }\n+\n+        @Test\n+        public void m2(Path p) {\n+            log.add(\"m2(\" + p.getFileName() + \")\");\n+            checking(\"m2\");\n+            passed(\"OK\");\n+        }\n+\n+        @Test\n+        public void m3() {\n+            log.add(\"m3()\");\n+            checking(\"m3\");\n+            passed(\"OK\");\n+        }\n+\n+        @Test\n+        public void m4(Path p) {\n+            log.add(\"m4(\" + p.getFileName() + \")\");\n+            checking(\"m4\");\n+            passed(\"OK\");\n+        }\n+    }\n+\n+    \/**\n+     * A group of tests containing one with an invalid (unrecognized) signature.\n+     * The invalid signature should cause an exception when trying to run that test.\n+     *\/\n+    public static class InvalidSignatureGroup extends JavadocTester {\n+        List<String> log = new ArrayList<>();\n+\n+        @Test\n+        public void m1() {\n+            log.add(\"m1()\");\n+            checking(\"m1\");\n+            passed(\"OK\");\n+        }\n+\n+        @Test\n+        public void invalidSignature(Object o) {\n+            log.add(\"invalidSignature(\" + o + \")\");\n+            checking(\"invalidSignature\");\n+            passed(\"OK\");\n+        }\n+    }\n+\n+    \/**\n+     * A group of tests including an overloaded test method.\n+     * The overload should cause an exception when trying to run that test by name.\n+     *\/\n+    public static class OverloadGroup extends JavadocTester {\n+        List<String> log = new ArrayList<>();\n+\n+        @Test\n+        public void m1() {\n+            log.add(\"m1()\");\n+            checking(\"m1\");\n+            passed(\"OK\");\n+        }\n+\n+        @Test\n+        public void m1(Path p) {\n+            log.add(\"m1(\" + p + \")\");\n+            checking(\"m1\");\n+            passed(\"OK\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/testJavadocTester\/TestRunTests.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -204,1 +204,1 @@\n-            \"script-dir\/jquery-3.5.1.min.js\",\n+            \"script-dir\/jquery-3.6.0.min.js\",\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/APITest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                DocumentationTask t = new JavadocTaskImpl(c, null, null, files);;\n+                DocumentationTask t = new JavadocTaskImpl(c, null, null, files);\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/JavadocTaskImplTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-        List<String> unr = getState().unresolvedDependencies((VarSnippet) undefKey).collect(toList());;\n+        List<String> unr = getState().unresolvedDependencies((VarSnippet) undefKey).collect(toList());\n","filename":"test\/langtools\/jdk\/jshell\/VariablesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                    PrintWriter pw = new PrintWriter(sw);;\n+                    PrintWriter pw = new PrintWriter(sw);\n","filename":"test\/langtools\/tools\/doclint\/RunTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @clean TestSyntheticNullChecks*\n+ * @clean *\n","filename":"test\/langtools\/tools\/javac\/8074306\/TestSyntheticNullChecks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @clean TestIndyStringConcat*\n+ * @clean *\n@@ -41,1 +41,1 @@\n- * @clean TestIndyStringConcat*\n+ * @clean *\n@@ -45,1 +45,1 @@\n- * @clean TestIndyStringConcat*\n+ * @clean *\n@@ -49,1 +49,1 @@\n- * @clean TestIndyStringConcat*\n+ * @clean *\n@@ -53,1 +53,1 @@\n- * @clean TestIndyStringConcat*\n+ * @clean *\n","filename":"test\/langtools\/tools\/javac\/StringConcat\/TestIndyStringConcat.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-        (cond?a:b).f();;\n-        (cond?a:b).g();;\n+        (cond?a:b).f();\n+        (cond?a:b).g();\n","filename":"test\/langtools\/tools\/javac\/generics\/inference\/4954546\/T4954546.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8222430\n+ * @bug 8222430 8282411\n@@ -41,1 +41,1 @@\n-        \/\/ isClass: Returns true if this is a kind of class: either CLASS or ENUM.\n+        \/\/ isClass: Returns true if this is a kind of class:CLASS, ENUM, or RECORD.\n@@ -48,1 +48,2 @@\n-        \/\/ isField: Returns true if this is a kind of field: either FIELD or ENUM_CONSTANT.\n+        \/\/ isField: Returns true if this is a kind of field: one of\n+        \/\/ FIELD or ENUM_CONSTANT.\n@@ -54,1 +55,2 @@\n-        \/\/ isInterface: Returns true if this is a kind of interface: either INTERFACE or ANNOTATION_TYPE.\n+        \/\/ isInterface: Returns true if this is a kind of interface:\n+        \/\/ either INTERFACE or ANNOTATION_TYPE.\n@@ -59,0 +61,38 @@\n+\n+        \/\/ isDeclaredType: Returns true if this is a kind of class or interface\n+        test(ALL_KINDS,\n+             (ElementKind k) -> Set.of(ElementKind.CLASS,\n+                                       ElementKind.ENUM,\n+                                       ElementKind.RECORD,\n+                                       ElementKind.INTERFACE,\n+                                       ElementKind.ANNOTATION_TYPE).contains(k),\n+             (ElementKind k) -> k.isDeclaredType(), \"isDeclaredType\");\n+\n+        \/\/ isExecutable: Returns true if this is a kind of executable: one of\n+        \/\/ METHOD, CONSTRUCTOR, STATIC_INIT, INSTANCE_INIT\n+        test(ALL_KINDS,\n+             (ElementKind k) -> Set.of(ElementKind.METHOD,\n+                                       ElementKind.CONSTRUCTOR,\n+                                       ElementKind.STATIC_INIT,\n+                                       ElementKind.INSTANCE_INIT).contains(k),\n+             (ElementKind k) -> k.isExecutable(), \"isExecutable\");\n+\n+        \/\/ isInitializer: Returns true if this is a kind of initializer: one of\n+        \/\/ STATIC_INIT, INSTANCE_INIT\n+        test(ALL_KINDS,\n+             (ElementKind k) -> Set.of(ElementKind.STATIC_INIT,\n+                                       ElementKind.INSTANCE_INIT).contains(k),\n+             (ElementKind k) -> k.isInitializer(), \"isInitializer\");\n+\n+        \/\/ isVariable: Returns true if this is a kind of variable: one of\n+        \/\/ ENUM_CONSTANT, FIELD, PARAMETER, LOCAL_VARIABLE, EXCEPTION_PARAMETER\n+        \/\/ RESOURCE_VARIABLE, BINDING_VARIABLE\n+        test(ALL_KINDS,\n+             (ElementKind k) -> Set.of(ElementKind.ENUM_CONSTANT,\n+                                       ElementKind.FIELD,\n+                                       ElementKind.PARAMETER,\n+                                       ElementKind.LOCAL_VARIABLE,\n+                                       ElementKind.EXCEPTION_PARAMETER,\n+                                       ElementKind.RESOURCE_VARIABLE,\n+                                       ElementKind.BINDING_VARIABLE).contains(k),\n+             (ElementKind k) -> k.isVariable(), \"isVariable\");\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestElementKindPredicates.java","additions":45,"deletions":5,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,2 +43,2 @@\n- * not block because of entropy scarcity. {@code -Jvm-options} is supported\n- * as an argument.\n+ * not block because of entropy scarcity. An argument can be a normal string,\n+ * {@code -Jvm-options}, or {@code $sysProp}.\n@@ -69,0 +69,2 @@\n+            } else if (arg.length() > 1 && arg.charAt(0) == '$') {\n+                launcher.addToolArg(System.getProperty(arg.substring(1)));\n","filename":"test\/lib\/jdk\/test\/lib\/SecurityTools.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,5 @@\n+    public CDSOptions addSuffix(ArrayList<String> suffix) {\n+        for (String s : suffix) this.suffix.add(s);\n+        return this;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSOptions.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,11 +25,1 @@\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.*;\n@@ -43,2 +33,2 @@\n-@Fork(value = 3)\n-@Warmup(iterations = 5, time = 2)\n+@Fork(value = 2)\n+@Warmup(iterations = 5, time = 3)\n@@ -49,1 +39,3 @@\n-    @Param({\"US-ASCII\", \"ISO-8859-1\", \"UTF-8\", \"MS932\", \"ISO-8859-6\", \"ISO-2022-KR\"})\n+    \/\/ Reduced by default to only UTF-8, previous coverage:\n+    \/\/ @Param({\"US-ASCII\", \"ISO-8859-1\", \"UTF-8\", \"MS932\", \"ISO-8859-6\", \"ISO-2022-KR\"})\n+    @Param({\"UTF-8\"})\n@@ -54,0 +46,1 @@\n+    private byte[] longAsciiString;\n@@ -55,1 +48,1 @@\n-    private byte[] longUtf16String;\n+    private byte[] longUtf16EndString;\n@@ -57,1 +50,5 @@\n-    private byte[] longLatin1String;\n+    private byte[] longUtf16OnlyString;\n+    private byte[] latin1String;\n+    private byte[] longLatin1EndString;\n+    private byte[] longLatin1StartString;\n+    private byte[] longLatin1OnlyString;\n@@ -59,6 +56,1 @@\n-    @Setup\n-    public void setup() {\n-        charset = Charset.forName(charsetName);\n-        asciiString = \"ascii string\".getBytes(charset);\n-        utf16String = \"UTF-\\uFF11\\uFF16 string\".getBytes(charset);\n-        longUtf16String = \"\"\"\n+    private static final String LOREM = \"\"\"\n@@ -73,49 +65,17 @@\n-             Suspendisse potenti.\n-\n-             Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n-             nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n-             sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n-             consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n-             Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n-             hendrerit sapien. \\uFF11Donec aliquam mattis lectus eu ultrices. Duis eu nisl\\uFF11\n-             euismod, blandit mauris vel, \\uFF11placerat urna. Etiam malesuada enim purus,\n-             tristique mollis odio blandit quis.\\uFF11 Vivamus posuere. \\uFF11\n-             \\uFF11\n-            \"\"\".getBytes(charset);\n-        longUtf16StartString = \"\"\"\n-             \\uFF11\n-             Lorem ipsum dolor sit amet, \\uFF11consectetur adipiscing elit. Aliquam ac sem eu\n-             urna egestas \\uFF11placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n-             Nulla \\uFF11nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n-             sapien in \\uFF11magna porta ultricies. \\uFF11Sed vel pellentesque nibh. Pellentesque dictum\n-             dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n-             per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n-             sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n-             efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n-             Suspendisse potenti.\n-\n-             Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n-             nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n-             sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n-             consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n-             Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n-             hendrerit sapien. Donec aliquam mattis lectus eu ultrices. Duis eu nisl\n-             euismod, blandit mauris vel, placerat urna. Etiam malesuada enim purus,\n-             tristique mollis odio blandit quis. Vivamus posuere.\n-            \"\"\".getBytes(charset);\n-\n-        longLatin1String = \"\"\"\n-             a\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             b\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             c\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             d\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             e\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             f\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             g\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             h\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             i\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             j\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             k\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\n-             l\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\n-             m\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\n-            \"\"\".getBytes(charset);\n+             Suspendisse potenti.\"\"\";\n+    private static final String UTF16_STRING = \"\\uFF11\".repeat(31);\n+    private static final String LATIN1_STRING = \"\\u00B6\".repeat(31);\n+\n+    @Setup\n+    public void setup() {\n+        charset = Charset.forName(charsetName);\n+        asciiString = LOREM.substring(0, 32).getBytes(charset);\n+        longAsciiString = LOREM.repeat(200).getBytes(charset);\n+        utf16String = \"UTF-\\uFF11\\uFF16 string\".getBytes(charset);\n+        longUtf16EndString = LOREM.repeat(4).concat(UTF16_STRING).getBytes(charset);\n+        longUtf16StartString = UTF16_STRING.concat(LOREM.repeat(4)).getBytes(charset);\n+        longUtf16OnlyString = UTF16_STRING.repeat(10).getBytes(charset);\n+        latin1String = LATIN1_STRING.getBytes(charset);\n+        longLatin1EndString = LOREM.repeat(4).concat(LATIN1_STRING).getBytes(charset);\n+        longLatin1StartString = LATIN1_STRING.concat(LOREM.repeat(4)).getBytes(charset);\n+        longLatin1OnlyString = LATIN1_STRING.repeat(10).getBytes(charset);\n@@ -125,2 +85,6 @@\n-    public String decodeAsciiCharsetName() throws Exception {\n-        return new String(asciiString, charsetName);\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeAsciiShort(Blackhole bh) throws Exception {\n+        bh.consume(new String(asciiString, charset));\n+        bh.consume(new String(longAsciiString, 0, 15, charset));\n+        bh.consume(new String(asciiString, 0, 3, charset));\n+        bh.consume(new String(longAsciiString, 512, 7, charset));\n@@ -130,2 +94,4 @@\n-    public String decodeAscii() throws Exception {\n-        return new String(asciiString, charset);\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeAsciiLong(Blackhole bh) throws Exception {\n+        bh.consume(new String(longAsciiString, charset));\n+        bh.consume(new String(longAsciiString, 0, 1024 + 31, charset));\n@@ -135,2 +101,6 @@\n-    public String decodeLatin1Long() throws Exception {\n-        return new String(longLatin1String, charset);\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeLatin1Short(Blackhole bh) throws Exception {\n+        bh.consume(new String(latin1String, charset));\n+        bh.consume(new String(latin1String, 0, 15, charset));\n+        bh.consume(new String(latin1String, 0, 3, charset));\n+        bh.consume(new String(longLatin1OnlyString, 512, 7, charset));\n@@ -140,2 +110,3 @@\n-    public String decodeUTF16Short() throws Exception {\n-        return new String(utf16String, charset);\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public String decodeLatin1LongStart() throws Exception {\n+        return new String(longLatin1StartString, charset);\n@@ -145,0 +116,31 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public String decodeLatin1LongEnd() throws Exception {\n+        return new String(longLatin1EndString, charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public String decodeLatin1LongOnly() throws Exception {\n+        return new String(longLatin1OnlyString, charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeLatin1Mixed(Blackhole bh) throws Exception {\n+        bh.consume(new String(longLatin1EndString, charset));\n+        bh.consume(new String(longLatin1StartString, charset));\n+        bh.consume(new String(latin1String, charset));\n+        bh.consume(new String(longLatin1OnlyString, charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeUTF16Short(Blackhole bh) throws Exception {\n+        bh.consume(new String(utf16String, charset));\n+        bh.consume(new String(utf16String, 0, 15, charset));\n+        bh.consume(new String(utf16String, 0, 3, charset));\n+        bh.consume(new String(utf16String, 0, 7, charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -146,1 +148,1 @@\n-        return new String(longUtf16String, charset);\n+        return new String(longUtf16EndString, charset);\n@@ -150,0 +152,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -155,1 +158,20 @@\n-    public void decodeUTF16LongMixed(Blackhole bh) throws Exception {\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public String decodeUTF16LongOnly() throws Exception {\n+        return new String(longUtf16OnlyString, charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeUTF16Mixed(Blackhole bh) throws Exception {\n+        bh.consume(new String(longUtf16StartString, charset));\n+        bh.consume(new String(longUtf16EndString, charset));\n+        bh.consume(new String(utf16String, charset));\n+        bh.consume(new String(longUtf16OnlyString, charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeAllMixed(Blackhole bh) throws Exception {\n+        bh.consume(new String(utf16String, charset));\n+        bh.consume(new String(longUtf16EndString, charset));\n+        bh.consume(new String(utf16String, 0, 15, charset));\n@@ -157,1 +179,26 @@\n-        bh.consume(new String(longUtf16String, charset));\n+        bh.consume(new String(asciiString, 0, 3, charset));\n+        bh.consume(new String(longUtf16OnlyString, charset));\n+        bh.consume(new String(latin1String, charset));\n+        bh.consume(new String(longLatin1EndString, charset));\n+        bh.consume(new String(longLatin1StartString, charset));\n+        bh.consume(new String(latin1String, 0, 7, charset));\n+        bh.consume(new String(longLatin1OnlyString, charset));\n+        bh.consume(new String(asciiString, charset));\n+        bh.consume(new String(longAsciiString, charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeShortMixed(Blackhole bh) throws Exception {\n+        bh.consume(new String(utf16String, 0, 15, charset));\n+        bh.consume(new String(latin1String, 0, 15, charset));\n+        bh.consume(new String(asciiString, charset));\n+        bh.consume(new String(utf16String, charset));\n+        bh.consume(new String(latin1String, 0, 3, charset));\n+        bh.consume(new String(asciiString, 0, 3, charset));\n+        bh.consume(new String(utf16String, 0, 7, charset));\n+        bh.consume(new String(latin1String, charset));\n+        bh.consume(new String(asciiString, 0, 7, charset));\n+        bh.consume(new String(utf16String, 0, 3, charset));\n+        bh.consume(new String(latin1String, 0, 7, charset));\n+        bh.consume(new String(asciiString, 0, 15, charset));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringDecode.java","additions":130,"deletions":83,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-@Fork(value = 3)\n-@Warmup(iterations = 5, time = 2)\n+@Fork(value = 2)\n+@Warmup(iterations = 5, time = 3)\n@@ -39,1 +39,3 @@\n-    @Param({\"US-ASCII\", \"ISO-8859-1\", \"UTF-8\", \"MS932\", \"ISO-8859-6\"})\n+    \/\/ Reduced by default to only UTF-8, previous coverage:\n+    \/\/ @Param({\"US-ASCII\", \"ISO-8859-1\", \"UTF-8\", \"MS932\", \"ISO-8859-6\", \"ISO-2022-KR\"})\n+    @Param({\"UTF-8\"})\n@@ -41,0 +43,1 @@\n+\n@@ -43,0 +46,5 @@\n+    private String asciiString3;\n+    private String asciiString7;\n+    private String asciiString15;\n+    private String longAsciiString;\n+    private String longAsciiString1055;\n@@ -44,1 +52,4 @@\n-    private String longUtf16String;\n+    private String utf16String3;\n+    private String utf16String7;\n+    private String utf16String15;\n+    private String longUtf16EndString;\n@@ -46,0 +57,21 @@\n+    private String longUtf16OnlyString;\n+    private String latin1String;\n+    private String latin1String3;\n+    private String latin1String7;\n+    private String latin1String15;\n+    private String longLatin1EndString;\n+    private String longLatin1StartString;\n+    private String longLatin1OnlyString;\n+\n+    private static final String LOREM = \"\"\"\n+             Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ac sem eu\n+             urna egestas placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n+             Nulla nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n+             sapien in magna porta ultricies. Sed vel pellentesque nibh. Pellentesque dictum\n+             dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n+             per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n+             sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n+             efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n+             Suspendisse potenti.\"\"\";\n+    private static final String UTF16_STRING = \"\\uFF11\".repeat(31);\n+    private static final String LATIN1_STRING = \"\\u00B6\".repeat(31);\n@@ -50,44 +82,20 @@\n-        asciiString = \"ascii string\";\n-        utf16String = \"UTF-\\uFF11\\uFF16 string\";\n-        longUtf16String = \"\"\"\n-                 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ac sem eu\n-                 urna egestas placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n-                 Nulla nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n-                 sapien in magna porta ultricies. Sed vel pellentesque nibh. Pellentesque dictum\n-                 dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n-                 per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n-                 sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n-                 efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n-                 Suspendisse potenti.\n-\n-                 Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n-                 nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n-                 sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n-                 consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n-                 Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n-                 hendrerit sapien. Donec aliquam mattis lectus eu ultrices. Duis eu nisl\n-                 euismod, blandit mauris vel, placerat urna. Etiam malesuada enim purus,\n-                 tristique mollis odio blandit quis. Vivamus posuere.\n-                 \\uFF11\n-                \"\"\";\n-        longUtf16StartString = \"\"\"\n-                 \\uFF11\n-                 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ac sem eu\n-                 urna egestas placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n-                 Nulla nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n-                 sapien in magna porta ultricies. Sed vel pellentesque nibh. Pellentesque dictum\n-                 dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n-                 per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n-                 sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n-                 efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n-                 Suspendisse potenti.\n-\n-                 Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n-                 nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n-                 sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n-                 consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n-                 Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n-                 hendrerit sapien. Donec aliquam mattis lectus eu ultrices. Duis eu nisl\n-                 euismod, blandit mauris vel, placerat urna. Etiam malesuada enim purus,\n-                 tristique mollis odio blandit quis. Vivamus posuere.\n-                \"\"\";\n+        asciiString = LOREM.substring(0, 32);\n+        asciiString3 = LOREM.substring(0, 3);\n+        asciiString7 = LOREM.substring(0, 7);\n+        asciiString15 = LOREM.substring(0, 15);\n+        longAsciiString = LOREM.repeat(200);\n+        longAsciiString1055 = longAsciiString.substring(0, 1055);\n+        utf16String = UTF16_STRING;\n+        utf16String3 = UTF16_STRING.substring(0, 3);\n+        utf16String7 = UTF16_STRING.substring(0, 7);\n+        utf16String15 = UTF16_STRING.substring(0, 15);\n+        longUtf16EndString = LOREM.repeat(4).concat(UTF16_STRING);\n+        longUtf16StartString = UTF16_STRING.concat(LOREM.repeat(4));\n+        longUtf16OnlyString = UTF16_STRING.repeat(10);\n+        latin1String = LATIN1_STRING;\n+        latin1String3 = LATIN1_STRING.substring(0, 3);\n+        latin1String7 = LATIN1_STRING.substring(0, 7);\n+        latin1String15 = LATIN1_STRING.substring(0, 15);\n+        longLatin1EndString = LOREM.repeat(4).concat(LATIN1_STRING);\n+        longLatin1StartString = LATIN1_STRING.concat(LOREM.repeat(4));\n+        longLatin1OnlyString = LATIN1_STRING.repeat(10);\n@@ -97,2 +105,6 @@\n-    public byte[] encodeAsciiCharsetName() throws Exception {\n-        return asciiString.getBytes(charset);\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeAsciiShort(Blackhole bh) throws Exception {\n+        bh.consume(asciiString.getBytes(charset));\n+        bh.consume(asciiString3.getBytes(charset));\n+        bh.consume(asciiString15.getBytes(charset));\n+        bh.consume(asciiString7.getBytes(charset));\n@@ -102,2 +114,4 @@\n-    public byte[] encodeAscii() throws Exception {\n-        return asciiString.getBytes(charset);\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeAsciiLong(Blackhole bh) throws Exception {\n+        bh.consume(longAsciiString.getBytes(charset));\n+        bh.consume(longAsciiString1055.getBytes(charset));\n@@ -107,2 +121,2 @@\n-    public void encodeMix(Blackhole bh) throws Exception {\n-        bh.consume(asciiString.getBytes(charset));\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeUTF16Short(Blackhole bh) throws Exception {\n@@ -110,0 +124,3 @@\n+        bh.consume(utf16String3.getBytes(charset));\n+        bh.consume(utf16String15.getBytes(charset));\n+        bh.consume(utf16String7.getBytes(charset));\n@@ -113,0 +130,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -114,1 +132,1 @@\n-        return longUtf16String.getBytes(charset);\n+        return longUtf16EndString.getBytes(charset);\n@@ -118,0 +136,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -123,2 +142,83 @@\n-    public byte[] encodeUTF16() throws Exception {\n-        return utf16String.getBytes(charset);\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte[] encodeUTF16LongOnly() throws Exception {\n+        return longUtf16OnlyString.getBytes(charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeUTF16Mixed(Blackhole bh) throws Exception {\n+        bh.consume(utf16String.getBytes(charset));\n+        bh.consume(longUtf16StartString.getBytes(charset));\n+        bh.consume(longUtf16EndString.getBytes(charset));\n+        bh.consume(longUtf16OnlyString.getBytes(charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeLatin1Short(Blackhole bh) throws Exception {\n+        bh.consume(latin1String.getBytes(charset));\n+        bh.consume(latin1String3.getBytes(charset));\n+        bh.consume(latin1String15.getBytes(charset));\n+        bh.consume(latin1String7.getBytes(charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte[] encodeLatin1LongOnly() throws Exception {\n+        return longLatin1OnlyString.getBytes(charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte[] encodeLatin1LongStart() throws Exception {\n+        return longLatin1StartString.getBytes(charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte[] encodeLatin1LongEnd() throws Exception {\n+        return longLatin1EndString.getBytes(charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeLatin1Mixed(Blackhole bh) throws Exception {\n+        bh.consume(longLatin1EndString.getBytes(charset));\n+        bh.consume(longLatin1StartString.getBytes(charset));\n+        bh.consume(longLatin1OnlyString.getBytes(charset));\n+        bh.consume(latin1String.getBytes(charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeAllMixed(Blackhole bh) throws Exception {\n+        bh.consume(utf16String.getBytes(charset));\n+        bh.consume(longUtf16StartString.getBytes(charset));\n+        bh.consume(asciiString7.getBytes(charset));\n+        bh.consume(longUtf16EndString.getBytes(charset));\n+        bh.consume(latin1String3.getBytes(charset));\n+        bh.consume(longUtf16OnlyString.getBytes(charset));\n+        bh.consume(longLatin1EndString.getBytes(charset));\n+        bh.consume(longLatin1StartString.getBytes(charset));\n+        bh.consume(utf16String15.getBytes(charset));\n+        bh.consume(longLatin1OnlyString.getBytes(charset));\n+        bh.consume(latin1String.getBytes(charset));\n+        bh.consume(asciiString.getBytes(charset));\n+        bh.consume(longAsciiString.getBytes(charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeShortMixed(Blackhole bh) throws Exception {\n+        bh.consume(utf16String3.getBytes(charset));\n+        bh.consume(latin1String7.getBytes(charset));\n+        bh.consume(asciiString15.getBytes(charset));\n+        bh.consume(utf16String.getBytes(charset));\n+        bh.consume(latin1String3.getBytes(charset));\n+        bh.consume(asciiString7.getBytes(charset));\n+        bh.consume(utf16String15.getBytes(charset));\n+        bh.consume(latin1String.getBytes(charset));\n+        bh.consume(asciiString3.getBytes(charset));\n+        bh.consume(utf16String7.getBytes(charset));\n+        bh.consume(latin1String15.getBytes(charset));\n+        bh.consume(asciiString.getBytes(charset));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringEncode.java","additions":157,"deletions":57,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1538,1 +1538,0 @@\n-\n@@ -1570,1 +1569,0 @@\n-\n@@ -1603,1 +1601,0 @@\n-\n@@ -1639,1 +1636,0 @@\n-\n@@ -1679,1 +1675,0 @@\n-\n@@ -1717,1 +1712,0 @@\n-\n@@ -1753,1 +1747,0 @@\n-\n@@ -1789,1 +1782,0 @@\n-\n@@ -1829,1 +1821,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -650,1 +650,0 @@\n-\n@@ -670,1 +669,0 @@\n-\n@@ -690,1 +688,0 @@\n-\n@@ -710,1 +707,0 @@\n-\n@@ -730,1 +726,0 @@\n-\n@@ -750,1 +745,0 @@\n-\n@@ -809,1 +803,0 @@\n-\n@@ -860,1 +853,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -650,1 +650,0 @@\n-\n@@ -670,1 +669,0 @@\n-\n@@ -690,1 +688,0 @@\n-\n@@ -710,1 +707,0 @@\n-\n@@ -730,1 +726,0 @@\n-\n@@ -750,1 +745,0 @@\n-\n@@ -809,1 +803,0 @@\n-\n@@ -860,1 +853,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -650,1 +650,0 @@\n-\n@@ -670,1 +669,0 @@\n-\n@@ -690,1 +688,0 @@\n-\n@@ -710,1 +707,0 @@\n-\n@@ -730,1 +726,0 @@\n-\n@@ -750,1 +745,0 @@\n-\n@@ -809,1 +803,0 @@\n-\n@@ -860,1 +853,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -650,1 +650,0 @@\n-\n@@ -670,1 +669,0 @@\n-\n@@ -690,1 +688,0 @@\n-\n@@ -710,1 +707,0 @@\n-\n@@ -730,1 +726,0 @@\n-\n@@ -750,1 +745,0 @@\n-\n@@ -809,1 +803,0 @@\n-\n@@ -860,1 +853,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -650,1 +650,0 @@\n-\n@@ -670,1 +669,0 @@\n-\n@@ -690,1 +688,0 @@\n-\n@@ -710,1 +707,0 @@\n-\n@@ -730,1 +726,0 @@\n-\n@@ -750,1 +745,0 @@\n-\n@@ -809,1 +803,0 @@\n-\n@@ -860,1 +853,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1151,1 +1151,0 @@\n-\n@@ -1183,1 +1182,0 @@\n-\n@@ -1220,1 +1218,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -650,1 +650,0 @@\n-\n@@ -670,1 +669,0 @@\n-\n@@ -690,1 +688,0 @@\n-\n@@ -710,1 +707,0 @@\n-\n@@ -730,1 +726,0 @@\n-\n@@ -750,1 +745,0 @@\n-\n@@ -809,1 +803,0 @@\n-\n@@ -860,1 +853,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -650,1 +650,0 @@\n-\n@@ -670,1 +669,0 @@\n-\n@@ -690,1 +688,0 @@\n-\n@@ -710,1 +707,0 @@\n-\n@@ -730,1 +726,0 @@\n-\n@@ -750,1 +745,0 @@\n-\n@@ -809,1 +803,0 @@\n-\n@@ -860,1 +853,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -650,1 +650,0 @@\n-\n@@ -670,1 +669,0 @@\n-\n@@ -690,1 +688,0 @@\n-\n@@ -710,1 +707,0 @@\n-\n@@ -730,1 +726,0 @@\n-\n@@ -750,1 +745,0 @@\n-\n@@ -809,1 +803,0 @@\n-\n@@ -860,1 +853,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -650,1 +650,0 @@\n-\n@@ -670,1 +669,0 @@\n-\n@@ -690,1 +688,0 @@\n-\n@@ -710,1 +707,0 @@\n-\n@@ -730,1 +726,0 @@\n-\n@@ -750,1 +745,0 @@\n-\n@@ -809,1 +803,0 @@\n-\n@@ -860,1 +853,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -650,1 +650,0 @@\n-\n@@ -670,1 +669,0 @@\n-\n@@ -690,1 +688,0 @@\n-\n@@ -710,1 +707,0 @@\n-\n@@ -730,1 +726,0 @@\n-\n@@ -750,1 +745,0 @@\n-\n@@ -809,1 +803,0 @@\n-\n@@ -860,1 +853,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1151,1 +1151,0 @@\n-\n@@ -1183,1 +1182,0 @@\n-\n@@ -1220,1 +1218,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1535,1 +1535,0 @@\n-\n@@ -1567,1 +1566,0 @@\n-\n@@ -1600,1 +1598,0 @@\n-\n@@ -1636,1 +1633,0 @@\n-\n@@ -1674,1 +1670,0 @@\n-\n@@ -1714,1 +1709,0 @@\n-\n@@ -1750,1 +1744,0 @@\n-\n@@ -1786,1 +1779,0 @@\n-\n@@ -1822,1 +1814,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1535,1 +1535,0 @@\n-\n@@ -1567,1 +1566,0 @@\n-\n@@ -1600,1 +1598,0 @@\n-\n@@ -1636,1 +1633,0 @@\n-\n@@ -1674,1 +1670,0 @@\n-\n@@ -1714,1 +1709,0 @@\n-\n@@ -1750,1 +1744,0 @@\n-\n@@ -1786,1 +1779,0 @@\n-\n@@ -1822,1 +1814,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1268,1 +1268,0 @@\n-\n@@ -1288,1 +1287,0 @@\n-\n@@ -1308,1 +1306,0 @@\n-\n@@ -1328,1 +1325,0 @@\n-\n@@ -1348,1 +1344,0 @@\n-\n@@ -1368,1 +1363,0 @@\n-\n@@ -1389,1 +1383,0 @@\n-\n@@ -1411,1 +1404,0 @@\n-\n@@ -1433,1 +1425,0 @@\n-\n@@ -1455,1 +1446,0 @@\n-\n@@ -1511,1 +1501,0 @@\n-\n@@ -1562,1 +1551,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1539,1 +1539,0 @@\n-\n@@ -1571,1 +1570,0 @@\n-\n@@ -1604,1 +1602,0 @@\n-\n@@ -1640,1 +1637,0 @@\n-\n@@ -1682,1 +1678,0 @@\n-\n@@ -1718,1 +1713,0 @@\n-\n@@ -1754,1 +1748,0 @@\n-\n@@ -1790,1 +1783,0 @@\n-\n@@ -1828,1 +1820,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class VectorShiftRight {\n+    @Param({\"1024\"})\n+    public int SIZE;\n+\n+    private byte[]  bytesA,  bytesB;\n+    private short[] shortsA, shortsB;\n+    private char[]  charsA,  charsB;\n+    private int[]   intsA,   intsB;\n+    private long[]  longsA,  longsB;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    @Param(\"3\")\n+    private int shiftCount;\n+\n+    @Setup\n+    public void init() {\n+        bytesA  = new byte[SIZE];\n+        shortsA = new short[SIZE];\n+        charsA  = new char[SIZE];\n+        intsA   = new int[SIZE];\n+        longsA  = new long[SIZE];\n+\n+        bytesB  = new byte[SIZE];\n+        shortsB = new short[SIZE];\n+        charsB  = new char[SIZE];\n+        intsB   = new int[SIZE];\n+        longsB  = new long[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            bytesA[i]  = (byte) r.nextInt();\n+            shortsA[i] = (short) r.nextInt();\n+            charsA[i]  = (char) r.nextInt();\n+            intsA[i]   = r.nextInt();\n+            longsA[i]  = r.nextLong();\n+       }\n+    }\n+\n+    @Benchmark\n+    public void rShiftByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytesB[i] = (byte) (bytesA[i] >> shiftCount);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void urShiftByte() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bytesB[i] = (byte) (bytesA[i] >>> shiftCount);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rShiftShort() {\n+        for (int i = 0; i < SIZE; i++) {\n+            shortsB[i] = (short) (shortsA[i] >> shiftCount);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void urShiftChar() {\n+        for (int i = 0; i < SIZE; i++) {\n+            charsB[i] = (char) (charsA[i] >>> shiftCount);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rShiftInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            intsB[i] = intsA[i] >> shiftCount;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void urShiftInt() {\n+        for (int i = 0; i < SIZE; i++) {\n+            intsB[i] = intsA[i] >>> shiftCount;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void rShiftLong() {\n+        for (int i = 0; i < SIZE; i++) {\n+            longsB[i] = longsA[i] >> shiftCount;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void urShiftLong() {\n+        for (int i = 0; i < SIZE; i++) {\n+            longsB[i] = longsA[i] >>> shiftCount;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorShiftRight.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/\/\n+\/\/ Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+package org.openjdk.bench.vm.gc;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MINUTES)\n+@State(Scope.Thread)\n+@Fork(jvmArgsAppend = {\"-Xmx256m\", \"-XX:+UseLargePages\", \"-XX:LargePageSizeInBytes=1g\", \"-Xlog:pagesize\"}, value = 5)\n+\n+public class MicroLargePages {\n+\n+    @Param({\"2097152\"})\n+    public int ARRAYSIZE;\n+\n+    @Param({\"1\", \"2\", \"4\"})\n+    public int NUM;\n+\n+    public long[][] INP;\n+    public long[][] OUT;\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        INP = new long[NUM][ARRAYSIZE];\n+        OUT = new long[NUM][ARRAYSIZE];\n+        for (int i = 0; i < NUM; i++) {\n+            Arrays.fill(INP[i], 10);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void micro_HOP_DIST_4KB() {\n+        for (int i = 0; i < NUM; i += 1) {\n+             for (int j = 0; j < ARRAYSIZE; j += 512) {\n+                 OUT[i][j] = INP[i][j];\n+             }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/MicroLargePages.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"}]}