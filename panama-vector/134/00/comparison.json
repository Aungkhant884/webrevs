{"files":[{"patch":"@@ -2709,1 +2709,1 @@\n-  \/\/ * (VectorStoreMask src)\n+  \/\/ StoreVector (VectorStoreMask src)\n@@ -2711,5 +2711,1 @@\n-      (UseSVE > 0 && m->Opcode() == Op_VectorStoreMask &&\n-       (n->Opcode() == Op_StoreVector ||\n-        n->Opcode() == Op_VectorMaskTrueCount ||\n-        n->Opcode() == Op_VectorMaskFirstTrue ||\n-        n->Opcode() == Op_VectorMaskLastTrue))) {\n+      (UseSVE > 0 && m->Opcode() == Op_VectorStoreMask && n->Opcode() == Op_StoreVector)) {\n@@ -5578,0 +5574,1 @@\n+  match(pRegGov);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -302,1 +302,1 @@\n-instruct loadV_partial(vReg dst, vmemA mem, pRegGov pTmp, rFlagsReg cr) %{\n+instruct loadV_partial(vReg dst, vmemA mem, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -306,1 +306,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -308,2 +308,2 @@\n-  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n-            \"sve_ldr $dst, $pTmp, $mem\\t# load vector partial\" %}\n+  format %{ \"sve_whilelo_zr_imm $pgtmp, vector_length\\n\\t\"\n+            \"sve_ldr $dst, $pgtmp, $mem\\t# load vector partial\" %}\n@@ -312,1 +312,1 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ elemType_to_regVariant(bt),\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n@@ -316,1 +316,1 @@\n-                          as_PRegister($pTmp$$reg), bt, bt, $mem->opcode(),\n+                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n@@ -322,1 +322,1 @@\n-instruct storeV_partial(vReg src, vmemA mem, pRegGov pTmp, rFlagsReg cr) %{\n+instruct storeV_partial(vReg src, vmemA mem, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -326,1 +326,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -328,2 +328,2 @@\n-  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n-            \"sve_str $src, $pTmp, $mem\\t# store vector partial\" %}\n+  format %{ \"sve_whilelo_zr_imm $pgtmp, vector_length\\n\\t\"\n+            \"sve_str $src, $pgtmp, $mem\\t# store vector partial\" %}\n@@ -332,1 +332,1 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ elemType_to_regVariant(bt),\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n@@ -336,1 +336,1 @@\n-                          as_PRegister($pTmp$$reg), bt, bt, $mem->opcode(),\n+                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n@@ -359,1 +359,1 @@\n-instruct loadV_masked_partial(vReg dst, vmemA mem, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n+instruct loadV_masked_partial(vReg dst, vmemA mem, pRegGov pg, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -363,1 +363,1 @@\n-  effect(TEMP ptmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -368,1 +368,1 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ elemType_to_regVariant(bt),\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n@@ -370,1 +370,1 @@\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n+    __ sve_and(as_PRegister($pgtmp$$reg), as_PRegister($pgtmp$$reg),\n@@ -373,1 +373,1 @@\n-                          as_PRegister($ptmp$$reg), bt, bt, $mem->opcode(),\n+                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n@@ -394,1 +394,1 @@\n-instruct storeV_masked_partial(vReg src, vmemA mem, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n+instruct storeV_masked_partial(vReg src, vmemA mem, pRegGov pg, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -398,1 +398,1 @@\n-  effect(TEMP ptmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -403,1 +403,1 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ elemType_to_regVariant(bt),\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n@@ -405,1 +405,1 @@\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n+    __ sve_and(as_PRegister($pgtmp$$reg), as_PRegister($pgtmp$$reg),\n@@ -408,1 +408,1 @@\n-                          as_PRegister($ptmp$$reg), bt, bt, $mem->opcode(),\n+                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n@@ -562,1 +562,1 @@\n-instruct reinterpretResize(vReg dst, vReg src, pRegGov pTmp, rFlagsReg cr) %{\n+instruct reinterpretResize(vReg dst, vReg src, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -566,1 +566,1 @@\n-  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n@@ -576,1 +576,1 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ B, length_in_bytes_resize);\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ B, length_in_bytes_resize);\n@@ -578,1 +578,1 @@\n-    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pTmp$$reg),\n+    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pgtmp$$reg),\n@@ -1780,19 +1780,2 @@\n-instruct vloadmaskS(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadMask src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vloadmaskS $dst, $src\\t# vector load mask (sve) (B to H)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ H,\n-               ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmaskI(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+instruct vloadmask_extend(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n@@ -1802,17 +1785,1 @@\n-  format %{ \"vloadmaskI $dst, $src\\t# vector load mask (sve) (B to S)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($tmp$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ S, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmaskL(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (VectorLoadMask src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"vloadmaskL $dst, $src\\t# vector load mask (sve) (B to D)\" %}\n+  format %{ \"vloadmask $dst, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n@@ -1820,4 +1787,4 @@\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($tmp$$reg));\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($tmp$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ D, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -1834,1 +1801,1 @@\n-  format %{ \"vstoremaskB $dst, $src\\t# vector store mask (sve) (B)\" %}\n+  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (B)\" %}\n@@ -1841,1 +1808,1 @@\n-instruct vstoremaskS(vReg dst, pRegGov src, vReg tmp, immI_2 size) %{\n+instruct vstoremask_narrow(vReg dst, pRegGov src, vReg tmp, immI_gt_1 size) %{\n@@ -1846,1 +1813,1 @@\n-  format %{ \"vstoremaskS $dst, $src\\t# vector store mask (sve) (H to B)\" %}\n+  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (H\/S\/D)\" %}\n@@ -1848,40 +1815,4 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ H, as_PRegister($src$$reg), 1, false);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremaskI(vReg dst, pRegGov src, vReg tmp, immI_4 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"vstoremaskI $dst, $src\\t# vector store mask (sve) (S to B)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($src$$reg), 1, false);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremaskL(vReg dst, pRegGov src, vReg tmp, immI_8 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"vstoremaskL $dst, $src\\t# vector store mask (sve) (D to B)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($src$$reg), 1, false);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant((int)$size$$constant);\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($src$$reg), 1, false);\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n+                         as_FloatRegister($dst$$reg), size, as_FloatRegister($tmp$$reg));\n@@ -4437,1 +4368,1 @@\n-instruct vcvtBtoS(vReg dst, vReg src)\n+instruct vcvtBtoX_extend(vReg dst, vReg src)\n@@ -4439,15 +4370,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastB2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, H, $src\\t# convert B to S vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtBtoI(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  predicate(UseSVE > 0);\n@@ -4456,2 +4373,1 @@\n-  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n-            \"sve_sunpklo  $dst, S, $dst\\t# convert B to I vector\" %}\n+  format %{ \"sve_vectorcast_b2x  $dst, $src\\t# convert B to X vector (extend)\" %}\n@@ -4459,55 +4375,6 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtBtoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastB2X src));\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n-            \"sve_sunpklo  $dst, S, $dst\\n\\t\"\n-            \"sve_sunpklo  $dst, D, $dst\\t# convert B to L vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtBtoF(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastB2X src));\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n-            \"sve_sunpklo  $dst, S, $dst\\n\\t\"\n-            \"sve_scvtf  $dst, S, $dst, S\\t# convert B to F vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtBtoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastB2X src));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n-            \"sve_sunpklo  $dst, S, $dst\\n\\t\"\n-            \"sve_sunpklo  $dst, D, $dst\\n\\t\"\n-            \"sve_scvtf  $dst, D, $dst, D\\t# convert B to D vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ B);\n+    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n+      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n+    }\n@@ -4525,2 +4392,1 @@\n-  format %{ \"sve_dup  $tmp, B, 0\\n\\t\"\n-            \"sve_uzp1  $dst, B, $src, tmp\\t# convert S to B vector\" %}\n+  format %{ \"sve_vectorcast_s2b  $dst, $src\\t# convert H to B vector\" %}\n@@ -4528,2 +4394,2 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n+                         as_FloatRegister($src$$reg), __ H, as_FloatRegister($tmp$$reg));\n@@ -4534,1 +4400,1 @@\n-instruct vcvtStoI(vReg dst, vReg src)\n+instruct vcvtStoX_extend(vReg dst, vReg src)\n@@ -4537,29 +4403,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastS2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, S, $src\\t# convert S to I vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtStoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastS2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n-            \"sve_sunpklo  $dst, D, $dst\\t# convert S to L vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtStoF(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 2);\n@@ -4568,18 +4406,1 @@\n-  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n-            \"sve_scvtf  $dst, S, $dst, S\\t# convert S to F vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtStoD(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastS2X src));\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n-            \"sve_sunpklo  $dst, D, $dst\\n\\t\"\n-            \"sve_scvtf  $dst, D, $dst, D\\t# convert S to D vector\" %}\n+  format %{ \"sve_vectorcast_s2x  $dst, $src\\t# convert H to X vector (extend)\" %}\n@@ -4587,3 +4408,6 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ H);\n+    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n+      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n+    }\n@@ -4601,3 +4425,1 @@\n-  format %{ \"sve_dup  $tmp, H, 0\\n\\t\"\n-            \"sve_uzp1  $dst, H, $src, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert I to B vector\" %}\n+  format %{ \"sve_vectorcast_i2b  $dst, $src\\t# convert I to B vector\" %}\n@@ -4605,3 +4427,2 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n+                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n@@ -4619,2 +4440,1 @@\n-  format %{ \"sve_dup  $tmp, H, 0\\n\\t\"\n-            \"sve_uzp1  $dst, H, $src, tmp\\t# convert I to S vector\" %}\n+  format %{ \"sve_vectorcast_i2s $dst, $src\\t# convert I to H vector\" %}\n@@ -4622,2 +4442,2 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ H,\n+                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n@@ -4634,1 +4454,1 @@\n-  format %{ \"sve_sunpklo  $dst, D, $src\\t# convert I to L vector\" %}\n+  format %{ \"sve_vectorcast_i2l  $dst, $src\\t# convert I to L vector\" %}\n@@ -4636,1 +4456,1 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n+    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n@@ -4647,1 +4467,1 @@\n-  format %{ \"sve_scvtf  $dst, S, $src, S\\t# convert I to F vector\" %}\n+  format %{ \"sve_vectorcast_i2f  $dst, $src\\t# convert I to F vector\" %}\n@@ -4660,2 +4480,1 @@\n-  format %{ \"sve_sunpklo  $dst, D, $src\\n\\t\"\n-            \"sve_scvtf  $dst, D, $dst, D\\t# convert I to D vector\" %}\n+  format %{ \"sve_vectorcast_i2d  $dst, $src\\t# convert I to D vector\" %}\n@@ -4669,1 +4488,1 @@\n-instruct vcvtLtoB(vReg dst, vReg src, vReg tmp)\n+instruct vcvtLtoX_narrow(vReg dst, vReg src, vReg tmp)\n@@ -4671,2 +4490,1 @@\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  predicate(UseSVE > 0 && is_integral_type(Matcher::vector_element_basic_type(n)));\n@@ -4675,38 +4493,0 @@\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $src, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert L to B vector\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoS(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $src, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t# convert L to S vector\" %}\n-  ins_encode %{\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtLtoI(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP tmp);\n@@ -4714,2 +4494,1 @@\n-  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $src, tmp\\t# convert L to I vector\" %}\n+  format %{ \"sve_vectorcast_l2x  $dst, $src\\t# convert L to B\/H\/S vector (narrow)\" %}\n@@ -4717,2 +4496,4 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n+                         as_FloatRegister($src$$reg), __ D, as_FloatRegister($tmp$$reg));\n@@ -4730,3 +4511,1 @@\n-  format %{ \"sve_scvtf  $dst, S, $src, D\\n\\t\"\n-            \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $dst, $tmp\\t# convert L to F vector\" %}\n+  format %{ \"sve_vectorcast_l2f  $dst, $src\\t# convert L to F vector\" %}\n@@ -4735,2 +4514,3 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n+                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n+\n@@ -4747,1 +4527,1 @@\n-  format %{ \"sve_scvtf  $dst, D, $src, D\\t# convert L to D vector\" %}\n+  format %{ \"sve_vectorcast_l2d  $dst, $src\\t# convert L to D vector\" %}\n@@ -4754,1 +4534,1 @@\n-instruct vcvtFtoB(vReg dst, vReg src, vReg tmp)\n+instruct vcvtFtoX_narrow(vReg dst, vReg src, vReg tmp)\n@@ -4757,21 +4537,2 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastF2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n-            \"sve_dup  $tmp, H, 0\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert F to B vector\" %}\n-  ins_encode %{\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoS(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT));\n@@ -4781,3 +4542,1 @@\n-  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n-            \"sve_dup  $tmp, H, 0\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\t# convert F to S vector\" %}\n+  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to B\/H vector\" %}\n@@ -4785,0 +4544,2 @@\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n@@ -4786,2 +4547,2 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n+                         as_FloatRegister($dst$$reg), __ S, as_FloatRegister($tmp$$reg));\n@@ -4792,1 +4553,1 @@\n-instruct vcvtFtoI(vReg dst, vReg src)\n+instruct vcvtFtoX_extend(vReg dst, vReg src)\n@@ -4795,1 +4556,2 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n@@ -4798,15 +4560,1 @@\n-  format %{ \"sve_fcvtzs  $dst, S, $src, S\\t# convert F to I vector\" %}\n-  ins_encode %{\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtFtoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n-            \"sve_sunpklo  $dst, D, $dst\\t# convert F to L vector\" %}\n+  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to I\/L vector\" %}\n@@ -4814,0 +4562,1 @@\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n@@ -4815,1 +4564,3 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+    if (to_bt == T_LONG) {\n+      __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg), __ S);\n+    }\n@@ -4826,2 +4577,1 @@\n-  format %{ \"sve_sunpklo  $dst, D, $src\\n\\t\"\n-            \"sve_fcvt  $dst, D, $dst, S\\t# convert F to D vector\" %}\n+  format %{ \"sve_vectorcast_f2d  $dst, $dst\\t# convert F to D vector\" %}\n@@ -4829,1 +4579,1 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n+    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n@@ -4835,43 +4585,1 @@\n-instruct vcvtDtoB(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_fcvtzs  $dst, D, $src, D\\n\\t\"\n-            \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $dst, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert D to B vector\" %}\n-  ins_encode %{\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtDtoS(vReg dst, vReg src, vReg tmp)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastD2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_fcvtzs  $dst, D, $src, D\\n\\t\"\n-            \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $dst, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t# convert D to S vector\" %}\n-  ins_encode %{\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtDtoI(vReg dst, vReg src, vReg tmp)\n+instruct vcvtDtoX_narrow(vReg dst, vReg src, vReg tmp)\n@@ -4880,1 +4588,3 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -4884,3 +4594,1 @@\n-  format %{ \"sve_fcvtzs  $dst, D, $src, D\\n\\t\"\n-            \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $dst, tmp\\t# convert D to I vector\" %}\n+  format %{ \"sve_vectorcast_d2x  $dst, $src\\t# convert D to X vector (narrow)\" %}\n@@ -4888,0 +4596,2 @@\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n@@ -4889,2 +4599,2 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n+                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n@@ -4901,1 +4611,1 @@\n-  format %{ \"sve_fcvtzs  $dst, D, $src, D\\t# convert D to L vector\" %}\n+  format %{ \"sve_vectorcast_d2l  $dst, $src\\t# convert D to L vector\" %}\n@@ -4915,3 +4625,1 @@\n-  format %{ \"sve_fcvt  $dst, S, $src, D\\n\\t\"\n-            \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $dst, $tmp\\t# convert D to F vector\" %}\n+  format %{ \"sve_vectorcast_d2f  $dst, S, $dst\\t# convert D to F vector\" %}\n@@ -4920,2 +4628,2 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n+                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n@@ -4925,0 +4633,1 @@\n+\n@@ -4927,1 +4636,1 @@\n-instruct extractB(iRegINoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct extractB(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -4931,1 +4640,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -4933,1 +4642,1 @@\n-  format %{ \"sve_extract $dst, B, $pTmp, $src, $idx\\n\\t\"\n+  format %{ \"sve_extract $dst, B, $pgtmp, $src, $idx\\n\\t\"\n@@ -4936,1 +4645,1 @@\n-    __ sve_extract(as_Register($dst$$reg), __ B, as_PRegister($pTmp$$reg),\n+    __ sve_extract(as_Register($dst$$reg), __ B, as_PRegister($pgtmp$$reg),\n@@ -4943,1 +4652,1 @@\n-instruct extractS(iRegINoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct extractS(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -4947,1 +4656,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -4949,1 +4658,1 @@\n-  format %{ \"sve_extract $dst, H, $pTmp, $src, $idx\\n\\t\"\n+  format %{ \"sve_extract $dst, H, $pgtmp, $src, $idx\\n\\t\"\n@@ -4952,1 +4661,1 @@\n-    __ sve_extract(as_Register($dst$$reg), __ H, as_PRegister($pTmp$$reg),\n+    __ sve_extract(as_Register($dst$$reg), __ H, as_PRegister($pgtmp$$reg),\n@@ -4960,1 +4669,1 @@\n-instruct extractI(iRegINoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct extractI(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -4964,1 +4673,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -4966,1 +4675,1 @@\n-  format %{ \"sve_extract $dst, S, $pTmp, $src, $idx\\t# extract from vector(I)\" %}\n+  format %{ \"sve_extract $dst, S, $pgtmp, $src, $idx\\t# extract from vector(I)\" %}\n@@ -4968,1 +4677,1 @@\n-    __ sve_extract(as_Register($dst$$reg), __ S, as_PRegister($pTmp$$reg),\n+    __ sve_extract(as_Register($dst$$reg), __ S, as_PRegister($pgtmp$$reg),\n@@ -4974,1 +4683,1 @@\n-instruct extractL(iRegLNoSp dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct extractL(iRegLNoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -4978,1 +4687,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -4980,1 +4689,1 @@\n-  format %{ \"sve_extract $dst, D, $pTmp, $src, $idx\\t# extract from vector(L)\" %}\n+  format %{ \"sve_extract $dst, D, $pgtmp, $src, $idx\\t# extract from vector(L)\" %}\n@@ -4982,1 +4691,1 @@\n-    __ sve_extract(as_Register($dst$$reg), __ D, as_PRegister($pTmp$$reg),\n+    __ sve_extract(as_Register($dst$$reg), __ D, as_PRegister($pgtmp$$reg),\n@@ -4988,1 +4697,1 @@\n-instruct extractF(vRegF dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct extractF(vRegF dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -4992,1 +4701,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -4994,1 +4703,1 @@\n-  format %{ \"sve_extract $dst, S, $pTmp, $src, $idx\\t# extract from vector(F)\" %}\n+  format %{ \"sve_extract $dst, S, $pgtmp, $src, $idx\\t# extract from vector(F)\" %}\n@@ -4996,1 +4705,1 @@\n-    __ sve_extract(as_FloatRegister($dst$$reg), __ S, as_PRegister($pTmp$$reg),\n+    __ sve_extract(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg),\n@@ -5002,1 +4711,1 @@\n-instruct extractD(vRegD dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct extractD(vRegD dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -5006,1 +4715,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -5008,1 +4717,1 @@\n-  format %{ \"sve_extract $dst, D, $pTmp, $src, $idx\\t# extract from vector(D)\" %}\n+  format %{ \"sve_extract $dst, D, $pgtmp, $src, $idx\\t# extract from vector(D)\" %}\n@@ -5010,1 +4719,1 @@\n-    __ sve_extract(as_FloatRegister($dst$$reg), __ D, as_PRegister($pTmp$$reg),\n+    __ sve_extract(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg),\n@@ -5098,1 +4807,1 @@\n-instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -5105,1 +4814,1 @@\n-  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n@@ -5107,2 +4816,2 @@\n-  format %{ \"sve_index $dst, -16, 1\\t# (B\/S\/I)\\n\\t\"\n-            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  format %{ \"sve_index $dst, -16, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -5110,1 +4819,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -5115,1 +4824,1 @@\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n@@ -5118,1 +4827,1 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n@@ -5123,1 +4832,1 @@\n-instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -5128,1 +4837,1 @@\n-  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n@@ -5131,1 +4840,1 @@\n-            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -5133,1 +4842,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n@@ -5136,1 +4845,1 @@\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n@@ -5139,1 +4848,1 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n@@ -5144,1 +4853,1 @@\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n@@ -5151,1 +4860,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n@@ -5153,3 +4862,3 @@\n-  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/S\/I)\\n\\t\"\n-            \"sve_dup $dst, $idx\\t# (B\/S\/I)\\n\\t\"\n-            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n+  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_dup $dst, $idx\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n@@ -5157,1 +4866,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -5163,1 +4872,1 @@\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n@@ -5166,1 +4875,1 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n@@ -5171,1 +4880,1 @@\n-instruct insertL(vReg dst, vReg src, iRegL val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct insertL(vReg dst, vReg src, iRegL val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -5176,1 +4885,1 @@\n-  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n@@ -5179,1 +4888,1 @@\n-            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -5181,1 +4890,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (L)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (L)\" %}\n@@ -5184,1 +4893,1 @@\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ D, ptrue,\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n@@ -5187,1 +4896,1 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n@@ -5192,1 +4901,1 @@\n-instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -5197,1 +4906,1 @@\n-  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n@@ -5200,1 +4909,1 @@\n-            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -5202,1 +4911,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (D)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n@@ -5205,1 +4914,1 @@\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ D, ptrue,\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n@@ -5208,1 +4917,1 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n@@ -5213,1 +4922,1 @@\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n@@ -5218,1 +4927,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n@@ -5222,1 +4931,1 @@\n-            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n@@ -5224,1 +4933,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n@@ -5228,1 +4937,1 @@\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n@@ -5234,1 +4943,1 @@\n-               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+               as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n@@ -5241,3 +4950,2 @@\n-instruct loadshuffleB(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+instruct loadshuffle(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0);\n@@ -5246,1 +4954,1 @@\n-  format %{ \"sve_orr $dst, $src, $src\\t# vector load shuffle (B)\" %}\n+  format %{ \"sve_loadshuffle $dst, $src\\t# vector load shuffle (B\/H\/S\/D)\" %}\n@@ -5248,4 +4956,9 @@\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ sve_orr(as_FloatRegister($dst$$reg),\n-                 as_FloatRegister($src$$reg),\n-                 as_FloatRegister($src$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                   as_FloatRegister($src$$reg));\n+      }\n+    } else {\n+      __ sve_vector_extend(as_FloatRegister($dst$$reg),  __ elemType_to_regVariant(bt),\n+                           as_FloatRegister($src$$reg), __ B);\n@@ -5257,46 +4970,0 @@\n-instruct loadshuffleS(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_uunpklo $dst, $src\\t# vector load shuffle (B to H)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadshuffleI(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n-            \"sve_uunpklo $dst, S, $dst\\t# vector load shuffle (B to S)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadshuffleL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n-            \"sve_uunpklo $dst, S, $dst\\n\\t\"\n-            \"sve_uunpklo $dst, D, $dst\\t# vector load shuffle (B to D)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -5347,2 +5014,2 @@\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), ptrue,\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), ptrue, as_Register($mem$$base),\n+                       as_FloatRegister($idx$$reg));\n@@ -5668,2 +5335,1 @@\n-\n-instruct vmask_truecount(iRegINoSp dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+instruct vmask_truecount(iRegINoSp dst, pReg src) %{\n@@ -5673,2 +5339,1 @@\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n+  ins_cost(SVE_COST);\n@@ -5677,2 +5342,3 @@\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B,\n-                           as_FloatRegister($src$$reg), ptrue, as_PRegister($ptmp$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($src$$reg));\n@@ -5683,1 +5349,1 @@\n-instruct vmask_firsttrue(iRegINoSp dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+instruct vmask_firsttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n@@ -5687,2 +5353,2 @@\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n+  effect(TEMP ptmp);\n+  ins_cost(2 * SVE_COST);\n@@ -5691,2 +5357,4 @@\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B,\n-                           as_FloatRegister($src$$reg), ptrue, as_PRegister($ptmp$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_brkb(as_PRegister($ptmp$$reg), ptrue, as_PRegister($src$$reg), false);\n+    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($ptmp$$reg));\n@@ -5697,1 +5365,1 @@\n-instruct vmask_lasttrue(iRegINoSp dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+instruct vmask_lasttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n@@ -5701,2 +5369,2 @@\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n+  effect(TEMP ptmp);\n+  ins_cost(3 * SVE_COST);\n@@ -5705,2 +5373,2 @@\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B,\n-                           as_FloatRegister($src$$reg), ptrue, as_PRegister($ptmp$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_vmask_lasttrue($dst$$Register, bt, as_PRegister($src$$reg), as_PRegister($ptmp$$reg));\n@@ -5711,1 +5379,1 @@\n-instruct vmask_truecount_partial(iRegINoSp dst, vReg src, pRegGov ptmp, rFlagsReg cr) %{\n+instruct vmask_truecount_partial(iRegINoSp dst, pReg src, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -5715,3 +5383,3 @@\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vmask_truecount $dst, $src\\t# vector mask truecount partial (sve)\" %}\n+  effect(TEMP pgtmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"vmask_truecount_partial $dst, $src\\t# vector mask truecount partial (sve)\" %}\n@@ -5719,4 +5387,4 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ B,\n-                          Matcher::vector_length(this, $src));\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B, as_FloatRegister($src$$reg),\n-                           as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), size, Matcher::vector_length(this, $src));\n+    __ sve_cntp($dst$$Register, size, as_PRegister($pgtmp$$reg), as_PRegister($src$$reg));\n@@ -5727,1 +5395,1 @@\n-instruct vmask_firsttrue_partial(iRegINoSp dst, vReg src, pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n+instruct vmask_firsttrue_partial(iRegINoSp dst, pReg src, pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n@@ -5732,2 +5400,2 @@\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"vmask_firsttrue $dst, $src\\t# vector mask firsttrue partial (sve)\" %}\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"vmask_firsttrue_partial $dst, $src\\t# vector mask firsttrue partial (sve)\" %}\n@@ -5735,1 +5403,3 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ B,\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), size,\n@@ -5737,2 +5407,2 @@\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B, as_FloatRegister($src$$reg),\n-                           as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg));\n+    __ sve_brkb(as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg), as_PRegister($src$$reg), false);\n+    __ sve_cntp($dst$$Register, size, as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg));\n@@ -5743,1 +5413,1 @@\n-instruct vmask_lasttrue_partial(iRegINoSp dst, vReg src, pRegGov ptmp, rFlagsReg cr) %{\n+instruct vmask_lasttrue_partial(iRegINoSp dst, pReg src, pReg ptmp, rFlagsReg cr) %{\n@@ -5749,112 +5419,1 @@\n-  format %{ \"vmask_lasttrue $dst, $src\\t# vector mask lasttrue partial (sve)\" %}\n-  ins_encode %{\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ B,\n-                          Matcher::vector_length(this, $src));\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B, as_FloatRegister($src$$reg),\n-                           as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\/\/ ----------------- Vector mask reductions combined with VectorMaskStore ---------------\n-\n-instruct vstoremask_truecount(iRegINoSp dst, pRegGov src, immI esize, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (VectorMaskTrueCount (VectorStoreMask src esize)));\n-  effect(KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"vstoremask_truecount $dst, $src\\t# vector mask truecount (sve)\" %}\n-  ins_encode %{\n-    unsigned size = $esize$$constant;\n-    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n-    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n-    __ sve_cntp($dst$$Register, variant, ptrue, as_PRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremask_firsttrue(iRegINoSp dst, pRegGov src, immI esize, pReg ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (VectorMaskFirstTrue (VectorStoreMask src esize)));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vstoremask_firsttrue $dst, $src\\t# vector mask firsttrue (sve)\" %}\n-  ins_encode %{\n-    unsigned size = $esize$$constant;\n-    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n-    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant,\n-                           as_PRegister($src$$reg), ptrue, as_PRegister($ptmp$$reg),\n-                           Matcher::vector_length(this, $src));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremask_lasttrue(iRegINoSp dst, pRegGov src, immI esize, pReg ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (VectorMaskLastTrue (VectorStoreMask src esize)));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vstoremask_lasttrue $dst, $src\\t# vector mask lasttrue (sve)\" %}\n-  ins_encode %{\n-    unsigned size = $esize$$constant;\n-    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n-    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant,\n-                           as_PRegister($src$$reg), ptrue, as_PRegister($ptmp$$reg),\n-                           Matcher::vector_length(this, $src));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremask_truecount_partial(iRegINoSp dst, pRegGov src, immI esize,\n-                               pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (VectorMaskTrueCount (VectorStoreMask src esize)));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vstoremask_truecount $dst, $src\\t# vector mask truecount partial (sve)\" %}\n-  ins_encode %{\n-    unsigned size = $esize$$constant;\n-    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n-    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg),\n-                          variant, Matcher::vector_length(this, $src));\n-    __ sve_cntp($dst$$Register, variant, as_PRegister($ptmp$$reg), as_PRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremask_firsttrue_partial(iRegINoSp dst, pRegGov src, immI esize,\n-                               pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (VectorMaskFirstTrue (VectorStoreMask src esize)));\n-  effect(TEMP pgtmp, TEMP ptmp, KILL cr);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"vstoremask_firsttrue $dst, $src\\t# vector mask firsttrue partial (sve)\" %}\n-  ins_encode %{\n-    unsigned size = $esize$$constant;\n-    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n-    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n-    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg),\n-                          variant, Matcher::vector_length(this, $src));\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant,\n-                           as_PRegister($src$$reg), as_PRegister($pgtmp$$reg),\n-                           as_PRegister($ptmp$$reg), MaxVectorSize \/ size);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremask_lasttrue_partial(iRegINoSp dst, pRegGov src, immI esize,\n-                               pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst (VectorMaskLastTrue (VectorStoreMask src esize)));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"vstoremask_lasttrue $dst, $src\\t# vector mask lasttrue partial (sve)\" %}\n+  format %{ \"vmask_lasttrue_partial $dst, $src\\t# vector mask lasttrue partial (sve)\" %}\n@@ -5862,10 +5421,5 @@\n-    unsigned size = $esize$$constant;\n-    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n-    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg),\n-                          variant, Matcher::vector_length(this, $src));\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($src$$reg), as_PRegister($src$$reg));\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant,\n-                           as_PRegister($ptmp$$reg), ptrue,\n-                           as_PRegister($ptmp$$reg), MaxVectorSize \/ size);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src));\n+    __ sve_and(as_PRegister($ptmp$$reg), ptrue, as_PRegister($ptmp$$reg), as_PRegister($src$$reg));\n+    __ sve_vmask_lasttrue($dst$$Register, bt, as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg));\n@@ -5874,1 +5428,1 @@\n-%}\n+%}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":233,"deletions":679,"binary":false,"changes":912,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-instruct loadV_partial(vReg dst, vmemA mem, pRegGov pTmp, rFlagsReg cr) %{\n+instruct loadV_partial(vReg dst, vmemA mem, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -243,1 +243,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -245,2 +245,2 @@\n-  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n-            \"sve_ldr $dst, $pTmp, $mem\\t# load vector partial\" %}\n+  format %{ \"sve_whilelo_zr_imm $pgtmp, vector_length\\n\\t\"\n+            \"sve_ldr $dst, $pgtmp, $mem\\t# load vector partial\" %}\n@@ -249,1 +249,1 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ elemType_to_regVariant(bt),\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n@@ -253,1 +253,1 @@\n-                          as_PRegister($pTmp$$reg), bt, bt, $mem->opcode(),\n+                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n@@ -259,1 +259,1 @@\n-instruct storeV_partial(vReg src, vmemA mem, pRegGov pTmp, rFlagsReg cr) %{\n+instruct storeV_partial(vReg src, vmemA mem, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -263,1 +263,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -265,2 +265,2 @@\n-  format %{ \"sve_whilelo_zr_imm $pTmp, vector_length\\n\\t\"\n-            \"sve_str $src, $pTmp, $mem\\t# store vector partial\" %}\n+  format %{ \"sve_whilelo_zr_imm $pgtmp, vector_length\\n\\t\"\n+            \"sve_str $src, $pgtmp, $mem\\t# store vector partial\" %}\n@@ -269,1 +269,1 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ elemType_to_regVariant(bt),\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n@@ -273,1 +273,1 @@\n-                          as_PRegister($pTmp$$reg), bt, bt, $mem->opcode(),\n+                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n@@ -296,1 +296,1 @@\n-instruct loadV_masked_partial(vReg dst, vmemA mem, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n+instruct loadV_masked_partial(vReg dst, vmemA mem, pRegGov pg, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -300,1 +300,1 @@\n-  effect(TEMP ptmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -305,1 +305,1 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ elemType_to_regVariant(bt),\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n@@ -307,1 +307,1 @@\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n+    __ sve_and(as_PRegister($pgtmp$$reg), as_PRegister($pgtmp$$reg),\n@@ -310,1 +310,1 @@\n-                          as_PRegister($ptmp$$reg), bt, bt, $mem->opcode(),\n+                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n@@ -331,1 +331,1 @@\n-instruct storeV_masked_partial(vReg src, vmemA mem, pRegGov pg, pRegGov ptmp, rFlagsReg cr) %{\n+instruct storeV_masked_partial(vReg src, vmemA mem, pRegGov pg, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -335,1 +335,1 @@\n-  effect(TEMP ptmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -340,1 +340,1 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), __ elemType_to_regVariant(bt),\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ elemType_to_regVariant(bt),\n@@ -342,1 +342,1 @@\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n+    __ sve_and(as_PRegister($pgtmp$$reg), as_PRegister($pgtmp$$reg),\n@@ -345,1 +345,1 @@\n-                          as_PRegister($ptmp$$reg), bt, bt, $mem->opcode(),\n+                          as_PRegister($pgtmp$$reg), bt, bt, $mem->opcode(),\n@@ -453,1 +453,1 @@\n-instruct reinterpretResize(vReg dst, vReg src, pRegGov pTmp, rFlagsReg cr) %{\n+instruct reinterpretResize(vReg dst, vReg src, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -457,1 +457,1 @@\n-  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n@@ -467,1 +467,1 @@\n-    __ sve_whilelo_zr_imm(as_PRegister($pTmp$$reg), __ B, length_in_bytes_resize);\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), __ B, length_in_bytes_resize);\n@@ -469,1 +469,1 @@\n-    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pTmp$$reg),\n+    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pgtmp$$reg),\n@@ -1061,19 +1061,2 @@\n-instruct vloadmaskS(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadMask src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"vloadmaskS $dst, $src\\t# vector load mask (sve) (B to H)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ H,\n-               ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmaskI(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n+instruct vloadmask_extend(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() != T_BYTE);\n@@ -1083,17 +1066,1 @@\n-  format %{ \"vloadmaskI $dst, $src\\t# vector load mask (sve) (B to S)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($tmp$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ S, ptrue, as_FloatRegister($tmp$$reg), 0);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vloadmaskL(pRegGov dst, vReg src, vReg tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (VectorLoadMask src));\n-  effect(TEMP tmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"vloadmaskL $dst, $src\\t# vector load mask (sve) (B to D)\" %}\n+  format %{ \"vloadmask $dst, $src\\t# vector load mask (sve) (H\/S\/D)\" %}\n@@ -1101,4 +1068,4 @@\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($tmp$$reg));\n-    __ sve_uunpklo(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($tmp$$reg));\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), __ D, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_vector_extend(as_FloatRegister($tmp$$reg), size, as_FloatRegister($src$$reg), __ B);\n+    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n@@ -1115,1 +1082,1 @@\n-  format %{ \"vstoremaskB $dst, $src\\t# vector store mask (sve) (B)\" %}\n+  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (B)\" %}\n@@ -1122,1 +1089,1 @@\n-instruct vstoremaskS(vReg dst, pRegGov src, vReg tmp, immI_2 size) %{\n+instruct vstoremask_narrow(vReg dst, pRegGov src, vReg tmp, immI_gt_1 size) %{\n@@ -1127,1 +1094,1 @@\n-  format %{ \"vstoremaskS $dst, $src\\t# vector store mask (sve) (H to B)\" %}\n+  format %{ \"vstoremask $dst, $src\\t# vector store mask (sve) (H\/S\/D)\" %}\n@@ -1129,40 +1096,4 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ H, as_PRegister($src$$reg), 1, false);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremaskI(vReg dst, pRegGov src, vReg tmp, immI_4 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"vstoremaskI $dst, $src\\t# vector store mask (sve) (S to B)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($src$$reg), 1, false);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vstoremaskL(vReg dst, pRegGov src, vReg tmp, immI_8 size) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (VectorStoreMask src size));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"vstoremaskL $dst, $src\\t# vector store mask (sve) (D to B)\" %}\n-  ins_encode %{\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($src$$reg), 1, false);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B,\n-                as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    Assembler::SIMD_RegVariant size = __ elemBytes_to_regVariant((int)$size$$constant);\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($src$$reg), 1, false);\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n+                         as_FloatRegister($dst$$reg), size, as_FloatRegister($tmp$$reg));\n@@ -2191,1 +2122,1 @@\n-define(`VECTOR_CAST_EXTEND1', `\n+define(`VECTOR_CAST_X2X', `\n@@ -2198,1 +2129,1 @@\n-  format %{ \"sve_$3  $dst, $4, $src\\t# convert $1 to $2 vector\" %}\n+  format %{ \"sve_vectorcast_$5  $dst, $src\\t# convert $1 to $2 vector\" %}\n@@ -2200,1 +2131,1 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n+    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n@@ -2204,0 +2135,1 @@\n+\n@@ -2205,0 +2137,1 @@\n+dnl Start of vector cast rules\n@@ -2206,2 +2139,1 @@\n-define(`VECTOR_CAST_EXTEND2', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src)\n+instruct vcvtBtoX_extend(vReg dst, vReg src)\n@@ -2209,3 +2141,2 @@\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorCastB2X src));\n@@ -2213,2 +2144,1 @@\n-  format %{ \"sve_$3  $dst, $4, $src\\n\\t\"\n-            \"sve_$3  $dst, $5, $dst\\t# convert $1 to $2 vector\" %}\n+  format %{ \"sve_vectorcast_b2x  $dst, $src\\t# convert B to X vector (extend)\" %}\n@@ -2216,2 +2146,6 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $5, as_FloatRegister($dst$$reg));\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ B);\n+    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n+      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n+    }\n@@ -2220,5 +2154,3 @@\n-%}')dnl\n-dnl\n-dnl\n-define(`VECTOR_CAST_EXTEND3', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src)\n+%}\n+\n+instruct vcvtStoB(vReg dst, vReg src, vReg tmp)\n@@ -2227,6 +2159,5 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_$3  $dst, $4, $src\\n\\t\"\n-            \"sve_$3  $dst, $5, $dst\\n\\t\"\n-            \"sve_$3  $dst, $6, $dst\\t# convert $1 to $2 vector\" %}\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorCastS2X src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_vectorcast_s2b  $dst, $src\\t# convert H to B vector\" %}\n@@ -2234,3 +2165,2 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $5, as_FloatRegister($dst$$reg));\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n+                         as_FloatRegister($src$$reg), __ H, as_FloatRegister($tmp$$reg));\n@@ -2239,5 +2169,3 @@\n-%}')dnl\n-dnl\n-dnl\n-define(`VECTOR_CAST_NARROW1', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%}\n+\n+instruct vcvtStoX_extend(vReg dst, vReg src)\n@@ -2246,3 +2174,2 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  effect(TEMP tmp);\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) > 2);\n+  match(Set dst (VectorCastS2X src));\n@@ -2250,2 +2177,1 @@\n-  format %{ \"sve_$3  $tmp, $4, 0\\n\\t\"\n-            \"sve_$5  $dst, $4, $src, tmp\\t# convert $1 to $2 vector\" %}\n+  format %{ \"sve_vectorcast_s2x  $dst, $src\\t# convert H to X vector (extend)\" %}\n@@ -2253,2 +2179,6 @@\n-    __ sve_$3(as_FloatRegister($tmp$$reg), __ $4, 0);\n-    __ sve_$5(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_vector_extend(as_FloatRegister($dst$$reg), to_size, as_FloatRegister($src$$reg), __ H);\n+    if (to_bt == T_FLOAT || to_bt == T_DOUBLE) {\n+      __ sve_scvtf(as_FloatRegister($dst$$reg), to_size, ptrue, as_FloatRegister($dst$$reg), to_size);\n+    }\n@@ -2257,5 +2187,3 @@\n-%}')dnl\n-dnl\n-dnl\n-define(`VECTOR_CAST_NARROW2', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%}\n+\n+instruct vcvtItoB(vReg dst, vReg src, vReg tmp)\n@@ -2264,2 +2192,2 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorCastI2X src));\n@@ -2268,3 +2196,1 @@\n-  format %{ \"sve_$3  $tmp, $4, 0\\n\\t\"\n-            \"sve_$5  $dst, $4, $src, tmp\\n\\t\"\n-            \"sve_$5  $dst, $6, $dst, tmp\\n\\t# convert $1 to $2 vector\" %}\n+  format %{ \"sve_vectorcast_i2b  $dst, $src\\t# convert I to B vector\" %}\n@@ -2272,3 +2198,2 @@\n-    __ sve_$3(as_FloatRegister($tmp$$reg), __ $4, 0);\n-    __ sve_$5(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_$5(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ B,\n+                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n@@ -2277,5 +2202,3 @@\n-%}')dnl\n-dnl\n-dnl\n-define(`VECTOR_CAST_NARROW3', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%}\n+\n+instruct vcvtItoS(vReg dst, vReg src, vReg tmp)\n@@ -2284,8 +2207,5 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_$3  $tmp, $4, 0\\n\\t\"\n-            \"sve_$5  $dst, $4, $src, tmp\\n\\t\"\n-            \"sve_$5  $dst, $6, $dst, tmp\\n\\t\"\n-            \"sve_$5  $dst, $7, $dst, tmp\\n\\t# convert $1 to $2 vector\" %}\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorCastI2X src));\n+  effect(TEMP tmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_vectorcast_i2s $dst, $src\\t# convert I to H vector\" %}\n@@ -2293,4 +2213,2 @@\n-    __ sve_$3(as_FloatRegister($tmp$$reg), __ $4, 0);\n-    __ sve_$5(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_$5(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_$5(as_FloatRegister($dst$$reg), __ $7, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ H,\n+                         as_FloatRegister($src$$reg), __ S, as_FloatRegister($tmp$$reg));\n@@ -2299,5 +2217,3 @@\n-%}')dnl\n-dnl\n-dnl\n-define(`VECTOR_CAST_I2F_EXTEND2', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src)\n+%}\n+\n+instruct vcvtItoL(vReg dst, vReg src)\n@@ -2306,6 +2222,4 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_$3  $dst, $4, $src\\n\\t\"\n-            \"sve_$3  $dst, $5, $dst\\n\\t\"\n-            \"sve_$6  $dst, $5, $dst, $5\\t# convert $1 to $2 vector\" %}\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorCastI2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_vectorcast_i2l  $dst, $src\\t# convert I to L vector\" %}\n@@ -2313,3 +2227,1 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $5, as_FloatRegister($dst$$reg));\n-    __ sve_$6(as_FloatRegister($dst$$reg), __ $5, ptrue, as_FloatRegister($dst$$reg), __ $5);\n+    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n@@ -2318,2 +2230,1 @@\n-%}')dnl\n-dnl\n+%}\n@@ -2321,2 +2232,4 @@\n-define(`VECTOR_CAST_I2F_EXTEND3', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src)\n+dnl vcvtItoF\n+VECTOR_CAST_X2X(I, F, scvtf, S, i2f)\n+\n+instruct vcvtItoD(vReg dst, vReg src)\n@@ -2325,7 +2238,4 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_$3  $dst, $4, $src\\n\\t\"\n-            \"sve_$3  $dst, $5, $dst\\n\\t\"\n-            \"sve_$3  $dst, $6, $dst\\n\\t\"\n-            \"sve_$7  $dst, $6, $dst, $6\\t# convert $1 to $2 vector\" %}\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorCastI2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_vectorcast_i2d  $dst, $src\\t# convert I to D vector\" %}\n@@ -2333,4 +2243,2 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $5, as_FloatRegister($dst$$reg));\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg));\n-    __ sve_$7(as_FloatRegister($dst$$reg), __ $6, ptrue, as_FloatRegister($dst$$reg), __ $6);\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n@@ -2339,5 +2247,3 @@\n-%}')dnl\n-dnl\n-dnl\n-define(`VECTOR_CAST_X2F_NARROW1', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%}\n+\n+instruct vcvtLtoX_narrow(vReg dst, vReg src, vReg tmp)\n@@ -2345,3 +2251,2 @@\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n+  predicate(UseSVE > 0 && is_integral_type(Matcher::vector_element_basic_type(n)));\n+  match(Set dst (VectorCastL2X src));\n@@ -2349,4 +2254,2 @@\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_$3  $dst, $4, $src, $5\\n\\t\"\n-            \"sve_$6  $tmp, $7, 0\\n\\t\"\n-            \"sve_$8  $dst, $7, $dst, $tmp\\t# convert $1 to $2 vector\" %}\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_vectorcast_l2x  $dst, $src\\t# convert L to B\/H\/S vector (narrow)\" %}\n@@ -2354,3 +2257,4 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $5);\n-    __ sve_$6(as_FloatRegister($tmp$$reg), __ $7, 0);\n-    __ sve_$8(as_FloatRegister($dst$$reg), __ $7, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n+                         as_FloatRegister($src$$reg), __ D, as_FloatRegister($tmp$$reg));\n@@ -2359,5 +2263,3 @@\n-%}')dnl\n-dnl\n-dnl\n-define(`VECTOR_CAST_X2X', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src)\n+%}\n+\n+instruct vcvtLtoF(vReg dst, vReg src, vReg tmp)\n@@ -2366,4 +2268,5 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_$3  $dst, $4, $src, $4\\t# convert $1 to $2 vector\" %}\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_vectorcast_l2f  $dst, $src\\t# convert L to F vector\" %}\n@@ -2371,1 +2274,4 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n+                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n+\n@@ -2374,2 +2280,1 @@\n-%}')dnl\n-dnl\n+%}\n@@ -2377,2 +2282,4 @@\n-define(`VECTOR_CAST_X2F_EXTEND1', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src)\n+dnl vcvtLtoD\n+VECTOR_CAST_X2X(L, D, scvtf, D, l2d)\n+\n+instruct vcvtFtoX_narrow(vReg dst, vReg src, vReg tmp)\n@@ -2381,5 +2288,6 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_$3  $dst, $4, $src\\n\\t\"\n-            \"sve_$5  $dst, $4, $dst, $6\\t# convert $1 to $2 vector\" %}\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT));\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to B\/H vector\" %}\n@@ -2387,2 +2295,5 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, as_FloatRegister($src$$reg));\n-    __ sve_$5(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($dst$$reg), __ $6);\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n+                         as_FloatRegister($dst$$reg), __ S, as_FloatRegister($tmp$$reg));\n@@ -2391,5 +2302,3 @@\n-%}')dnl\n-dnl\n-dnl\n-define(`VECTOR_CAST_F2X_NARROW1', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%}\n+\n+instruct vcvtFtoX_extend(vReg dst, vReg src)\n@@ -2398,7 +2307,5 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_$3  $dst, $4, $src, $4\\n\\t\"\n-            \"sve_$5  $tmp, $6, 0\\n\\t\"\n-            \"sve_$7  $dst, $6, $dst, tmp\\t# convert $1 to $2 vector\" %}\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_LONG));\n+  match(Set dst (VectorCastF2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_vectorcast_f2x  $dst, $src\\t# convert F to I\/L vector\" %}\n@@ -2406,3 +2313,5 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n-    __ sve_$5(as_FloatRegister($tmp$$reg), __ $6, 0);\n-    __ sve_$7(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n+    if (to_bt == T_LONG) {\n+      __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg), __ S);\n+    }\n@@ -2411,5 +2320,3 @@\n-%}')dnl\n-dnl\n-dnl\n-define(`VECTOR_CAST_F2X_NARROW2', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+%}\n+\n+instruct vcvtFtoD(vReg dst, vReg src)\n@@ -2418,8 +2325,4 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_$3  $dst, $4, $src, $4\\n\\t\"\n-            \"sve_$5  $tmp, $6, 0\\n\\t\"\n-            \"sve_$7  $dst, $6, $dst, tmp\\n\\t\"\n-            \"sve_$7  $dst, $8, $dst, tmp\\n\\t# convert $1 to $2 vector\" %}\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorCastF2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_vectorcast_f2d  $dst, $dst\\t# convert F to D vector\" %}\n@@ -2427,4 +2330,2 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n-    __ sve_$5(as_FloatRegister($tmp$$reg), __ $6, 0);\n-    __ sve_$7(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_$7(as_FloatRegister($dst$$reg), __ $8, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_vector_extend(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), __ S);\n+    __ sve_fcvt(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n@@ -2433,5 +2334,3 @@\n-%}')dnl\n-dnl\n-dnl\n-define(`VECTOR_CAST_F2X_EXTEND1', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src)\n+%}\n+\n+instruct vcvtDtoX_narrow(vReg dst, vReg src, vReg tmp)\n@@ -2440,5 +2339,7 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_$3  $dst, $4, $src, $4\\n\\t\"\n-            \"sve_$5  $dst, $6, $dst\\t# convert $1 to $2 vector\" %}\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_vectorcast_d2x  $dst, $src\\t# convert D to X vector (narrow)\" %}\n@@ -2446,2 +2347,5 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n-    __ sve_$5(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg));\n+    BasicType to_bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant to_size = __ elemType_to_regVariant(to_bt);\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), to_size,\n+                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n@@ -2450,2 +2354,1 @@\n-%}')dnl\n-dnl\n+%}\n@@ -2453,2 +2356,4 @@\n-define(`VECTOR_CAST_F2X_NARROW3', `\n-instruct vcvt$1to$2`'(vReg dst, vReg src, vReg tmp)\n+dnl vcvtDtoL\n+VECTOR_CAST_X2X(D, L, fcvtzs, D, d2l)\n+\n+instruct vcvtDtoF(vReg dst, vReg src, vReg tmp)\n@@ -2457,2 +2362,2 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n-  match(Set dst (VectorCast$1`'2X src));\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorCastD2X src));\n@@ -2460,6 +2365,2 @@\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_$3  $dst, $4, $src, $4\\n\\t\"\n-            \"sve_$5  $tmp, $6, 0\\n\\t\"\n-            \"sve_$7  $dst, $6, $dst, tmp\\n\\t\"\n-            \"sve_$7  $dst, $8, $dst, tmp\\n\\t\"\n-            \"sve_$7  $dst, $9, $dst, tmp\\n\\t# convert $1 to $2 vector\" %}\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_vectorcast_d2f  $dst, S, $dst\\t# convert D to F vector\" %}\n@@ -2467,5 +2368,3 @@\n-    __ sve_$3(as_FloatRegister($dst$$reg), __ $4, ptrue, as_FloatRegister($src$$reg), __ $4);\n-    __ sve_$5(as_FloatRegister($tmp$$reg), __ $6, 0);\n-    __ sve_$7(as_FloatRegister($dst$$reg), __ $6, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_$7(as_FloatRegister($dst$$reg), __ $8, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_$7(as_FloatRegister($dst$$reg), __ $9, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_fcvt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n+                         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($tmp$$reg));\n@@ -2474,37 +2373,2 @@\n-%}')dnl\n-dnl\n-VECTOR_CAST_EXTEND1(B, S, sunpklo, H)\n-VECTOR_CAST_EXTEND2(B, I, sunpklo, H, S)\n-VECTOR_CAST_EXTEND3(B, L, sunpklo, H, S, D)\n-VECTOR_CAST_I2F_EXTEND2(B, F, sunpklo, H, S, scvtf)\n-VECTOR_CAST_I2F_EXTEND3(B, D, sunpklo, H, S, D, scvtf)\n-dnl\n-VECTOR_CAST_NARROW1(S, B, dup, B, uzp1)\n-VECTOR_CAST_EXTEND1(S, I, sunpklo, S)\n-VECTOR_CAST_EXTEND2(S, L, sunpklo, S, D)\n-VECTOR_CAST_X2F_EXTEND1(S, F, sunpklo, S, scvtf, S)\n-VECTOR_CAST_I2F_EXTEND2(S, D, sunpklo, S, D, scvtf)\n-dnl\n-VECTOR_CAST_NARROW2(I, B, dup, H, uzp1, B)\n-VECTOR_CAST_NARROW1(I, S, dup, H, uzp1)\n-VECTOR_CAST_EXTEND1(I, L, sunpklo, D)\n-VECTOR_CAST_X2X(I, F, scvtf, S)\n-VECTOR_CAST_X2F_EXTEND1(I, D, sunpklo, D, scvtf, D)\n-dnl\n-VECTOR_CAST_NARROW3(L, B, dup, S, uzp1, H, B)\n-VECTOR_CAST_NARROW2(L, S, dup, S, uzp1, H)\n-VECTOR_CAST_NARROW1(L, I, dup, S, uzp1)\n-VECTOR_CAST_X2F_NARROW1(L, F, scvtf, S, D, dup, S, uzp1)\n-VECTOR_CAST_X2X(L, D, scvtf, D)\n-dnl\n-VECTOR_CAST_F2X_NARROW2(F, B, fcvtzs, S, dup, H, uzp1, B)\n-VECTOR_CAST_F2X_NARROW1(F, S, fcvtzs, S, dup, H, uzp1)\n-VECTOR_CAST_X2X(F, I, fcvtzs, S)\n-VECTOR_CAST_F2X_EXTEND1(F, L, fcvtzs, S, sunpklo, D)\n-VECTOR_CAST_X2F_EXTEND1(F, D, sunpklo, D, fcvt, S)\n-dnl\n-VECTOR_CAST_F2X_NARROW3(D, B, fcvtzs, D, dup, S, uzp1, H, B)\n-VECTOR_CAST_F2X_NARROW2(D, S, fcvtzs, D, dup, S, uzp1, H)\n-VECTOR_CAST_F2X_NARROW1(D, I, fcvtzs, D, dup, S, uzp1)\n-VECTOR_CAST_X2X(D, L, fcvtzs, D)\n-VECTOR_CAST_X2F_NARROW1(D, F, fcvt, S, D, dup, S, uzp1)\n+%}\n+\n@@ -2515,1 +2379,1 @@\n-instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -2519,1 +2383,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -2521,1 +2385,1 @@\n-  format %{ \"sve_extract $dst, $3, $pTmp, $src, $idx\\n\\t\"\n+  format %{ \"sve_extract $dst, $3, $pgtmp, $src, $idx\\n\\t\"\n@@ -2524,1 +2388,1 @@\n-    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pTmp$$reg),\n+    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pgtmp$$reg),\n@@ -2536,1 +2400,1 @@\n-instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -2540,1 +2404,1 @@\n-  effect(TEMP pTmp, KILL cr);\n+  effect(TEMP pgtmp, KILL cr);\n@@ -2542,1 +2406,1 @@\n-  format %{ \"sve_extract $dst, $3, $pTmp, $src, $idx\\t# extract from vector($1)\" %}\n+  format %{ \"sve_extract $dst, $3, $pgtmp, $src, $idx\\t# extract from vector($1)\" %}\n@@ -2544,1 +2408,1 @@\n-    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pTmp$$reg),\n+    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pgtmp$$reg),\n@@ -2623,1 +2487,1 @@\n-instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -2630,1 +2494,1 @@\n-  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n@@ -2632,2 +2496,2 @@\n-  format %{ \"sve_index $dst, -16, 1\\t# (B\/S\/I)\\n\\t\"\n-            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  format %{ \"sve_index $dst, -16, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -2635,1 +2499,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -2640,1 +2504,1 @@\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n@@ -2643,1 +2507,1 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n@@ -2648,1 +2512,1 @@\n-instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -2653,1 +2517,1 @@\n-  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n@@ -2656,1 +2520,1 @@\n-            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -2658,1 +2522,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n@@ -2661,1 +2525,1 @@\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n@@ -2664,1 +2528,1 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n@@ -2669,1 +2533,1 @@\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n@@ -2676,1 +2540,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n@@ -2678,3 +2542,3 @@\n-  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/S\/I)\\n\\t\"\n-            \"sve_dup $dst, $idx\\t# (B\/S\/I)\\n\\t\"\n-            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n+  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_dup $dst, $idx\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n@@ -2682,1 +2546,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -2688,1 +2552,1 @@\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), size, ptrue,\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n@@ -2691,1 +2555,1 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n@@ -2698,1 +2562,1 @@\n-instruct insert$1`'(vReg dst, vReg src, $2 val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct insert$1`'(vReg dst, vReg src, $2 val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n@@ -2703,1 +2567,1 @@\n-  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n@@ -2706,1 +2570,1 @@\n-            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -2708,1 +2572,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector ($1)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector ($1)\" %}\n@@ -2711,1 +2575,1 @@\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ $3, ptrue,\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ $3, ptrue,\n@@ -2714,1 +2578,1 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3, as_PRegister($pTmp$$reg), as_$4($val$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3, as_PRegister($pgtmp$$reg), as_$4($val$$reg));\n@@ -2722,1 +2586,1 @@\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n@@ -2727,1 +2591,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n@@ -2731,1 +2595,1 @@\n-            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n@@ -2733,1 +2597,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n@@ -2737,1 +2601,1 @@\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pTmp$$reg), __ S, ptrue,\n+    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n@@ -2743,1 +2607,1 @@\n-               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+               as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n@@ -2750,3 +2614,2 @@\n-instruct loadshuffleB(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+instruct loadshuffle(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0);\n@@ -2755,1 +2618,1 @@\n-  format %{ \"sve_orr $dst, $src, $src\\t# vector load shuffle (B)\" %}\n+  format %{ \"sve_loadshuffle $dst, $src\\t# vector load shuffle (B\/H\/S\/D)\" %}\n@@ -2757,4 +2620,9 @@\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ sve_orr(as_FloatRegister($dst$$reg),\n-                 as_FloatRegister($src$$reg),\n-                 as_FloatRegister($src$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (bt == T_BYTE) {\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                   as_FloatRegister($src$$reg));\n+      }\n+    } else {\n+      __ sve_vector_extend(as_FloatRegister($dst$$reg),  __ elemType_to_regVariant(bt),\n+                           as_FloatRegister($src$$reg), __ B);\n@@ -2766,46 +2634,0 @@\n-instruct loadshuffleS(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_uunpklo $dst, $src\\t# vector load shuffle (B to H)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadshuffleI(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT));\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n-            \"sve_uunpklo $dst, S, $dst\\t# vector load shuffle (B to S)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct loadshuffleL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-           (n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n-  match(Set dst (VectorLoadShuffle src));\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_uunpklo $dst, H, $src\\n\\t\"\n-            \"sve_uunpklo $dst, S, $dst\\n\\t\"\n-            \"sve_uunpklo $dst, D, $dst\\t# vector load shuffle (B to D)\" %}\n-  ins_encode %{\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n-    __ sve_uunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2856,2 +2678,2 @@\n-    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), ptrue,\n-                       as_Register($mem$$base), as_FloatRegister($idx$$reg));\n+    __ sve_ld1d_gather(as_FloatRegister($dst$$reg), ptrue, as_Register($mem$$base),\n+                       as_FloatRegister($idx$$reg));\n@@ -3162,5 +2984,2 @@\n-dnl\n-dnl VMASK_REDUCTION($1,     $2,      $3  )\n-dnl VMASK_REDUCTION(suffix, op_name, cost)\n-define(`VMASK_REDUCTION', `\n-instruct vmask_$1(iRegINoSp dst, vReg src, pReg ptmp, rFlagsReg cr) %{\n+\/\/ ---------------------------- Vector mask reductions ---------------------------\n+instruct vmask_truecount(iRegINoSp dst, pReg src) %{\n@@ -3169,4 +2988,3 @@\n-  match(Set dst ($2 src));\n-  effect(TEMP ptmp, KILL cr);\n-  ins_cost($3 * SVE_COST);\n-  format %{ \"vmask_$1 $dst, $src\\t# vector mask $1 (sve)\" %}\n+  match(Set dst (VectorMaskTrueCount src));\n+  ins_cost(SVE_COST);\n+  format %{ \"vmask_truecount $dst, $src\\t# vector mask truecount (sve)\" %}\n@@ -3174,2 +2992,3 @@\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B,\n-                           as_FloatRegister($src$$reg), ptrue, as_PRegister($ptmp$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($src$$reg));\n@@ -3178,11 +2997,33 @@\n-%}')dnl\n-dnl\n-\/\/ ---------------------------- Vector mask reductions ---------------------------\n-VMASK_REDUCTION(truecount, VectorMaskTrueCount, 2)\n-VMASK_REDUCTION(firsttrue, VectorMaskFirstTrue, 3)\n-VMASK_REDUCTION(lasttrue,  VectorMaskLastTrue, 4)\n-dnl\n-dnl VMASK_REDUCTION_PARTIAL($1,     $2,      $3  )\n-dnl VMASK_REDUCTION_PARTIAL(suffix, op_name, cost)\n-define(`VMASK_REDUCTION_PARTIAL', `\n-instruct vmask_$1_partial(iRegINoSp dst, vReg src, pRegGov ifelse($1, `firsttrue', `pgtmp, pReg ptmp', `ptmp'), rFlagsReg cr) %{\n+%}\n+\n+instruct vmask_firsttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(TEMP ptmp);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"vmask_firsttrue $dst, $src\\t# vector mask firsttrue (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_brkb(as_PRegister($ptmp$$reg), ptrue, as_PRegister($src$$reg), false);\n+    __ sve_cntp($dst$$Register, size, ptrue, as_PRegister($ptmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_lasttrue(iRegINoSp dst, pReg src, pReg ptmp) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (VectorMaskLastTrue src));\n+  effect(TEMP ptmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"vmask_lasttrue $dst, $src\\t# vector mask lasttrue (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ sve_vmask_lasttrue($dst$$Register, bt, as_PRegister($src$$reg), as_PRegister($ptmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmask_truecount_partial(iRegINoSp dst, pReg src, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -3191,4 +3032,4 @@\n-  match(Set dst ($2 src));\n-  effect(TEMP ifelse($1, `firsttrue', `pgtmp, TEMP ptmp', `ptmp'), KILL cr);\n-  ins_cost($3 * SVE_COST);\n-  format %{ \"vmask_$1 $dst, $src\\t# vector mask $1 partial (sve)\" %}\n+  match(Set dst (VectorMaskTrueCount src));\n+  effect(TEMP pgtmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"vmask_truecount_partial $dst, $src\\t# vector mask truecount partial (sve)\" %}\n@@ -3196,4 +3037,4 @@\n-    __ sve_whilelo_zr_imm(as_PRegister(ifelse($1, `firsttrue', `$pgtmp', `$ptmp')$$reg), __ B,\n-                          Matcher::vector_length(this, $src));\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, __ B, as_FloatRegister($src$$reg),\n-                           as_PRegister(ifelse($1, `firsttrue', `$pgtmp', `$ptmp')$$reg), as_PRegister($ptmp$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), size, Matcher::vector_length(this, $src));\n+    __ sve_cntp($dst$$Register, size, as_PRegister($pgtmp$$reg), as_PRegister($src$$reg));\n@@ -3202,5 +3043,1 @@\n-%}')dnl\n-dnl\n-VMASK_REDUCTION_PARTIAL(truecount, VectorMaskTrueCount, 3)\n-VMASK_REDUCTION_PARTIAL(firsttrue, VectorMaskFirstTrue, 4)\n-VMASK_REDUCTION_PARTIAL(lasttrue,  VectorMaskLastTrue, 5)\n+%}\n@@ -3208,5 +3045,1 @@\n-dnl\n-dnl VSTOREMASK_REDUCTION($1,     $2,      $3  )\n-dnl VSTOREMASK_REDUCTION(suffix, op_name, cost)\n-define(`VSTOREMASK_REDUCTION', `\n-instruct vstoremask_$1(iRegINoSp dst, pRegGov src, immI esize, ifelse($1, `truecount', `rFlagsReg cr', `pReg ptmp, rFlagsReg cr')) %{\n+instruct vmask_firsttrue_partial(iRegINoSp dst, pReg src, pRegGov pgtmp, pReg ptmp, rFlagsReg cr) %{\n@@ -3214,5 +3047,5 @@\n-            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst ($2 (VectorStoreMask src esize)));\n-  effect(ifelse($1, `truecount', `KILL cr', `TEMP ptmp, KILL cr'));\n-  ins_cost($3);\n-  format %{ \"vstoremask_$1 $dst, $src\\t# vector mask $1 (sve)\" %}\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (VectorMaskFirstTrue src));\n+  effect(TEMP pgtmp, TEMP ptmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"vmask_firsttrue_partial $dst, $src\\t# vector mask firsttrue partial (sve)\" %}\n@@ -3220,8 +3053,6 @@\n-    unsigned size = $esize$$constant;\n-    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n-    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);dnl\n-ifelse(`$1', `truecount', `\n-    __ sve_cntp($dst$$Register, variant, ptrue, as_PRegister($src$$reg));', `\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant,\n-                           as_PRegister($src$$reg), ptrue, as_PRegister($ptmp$$reg),\n-                           Matcher::vector_length(this, $src));')\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($pgtmp$$reg), size,\n+                          Matcher::vector_length(this, $src));\n+    __ sve_brkb(as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg), as_PRegister($src$$reg), false);\n+    __ sve_cntp($dst$$Register, size, as_PRegister($pgtmp$$reg), as_PRegister($ptmp$$reg));\n@@ -3230,35 +3061,15 @@\n-%}')dnl\n-dnl\n-\/\/ ----------------- Vector mask reductions combined with VectorMaskStore ---------------\n-VSTOREMASK_REDUCTION(truecount, VectorMaskTrueCount, SVE_COST)\n-VSTOREMASK_REDUCTION(firsttrue, VectorMaskFirstTrue, 2 * SVE_COST)\n-VSTOREMASK_REDUCTION(lasttrue,  VectorMaskLastTrue, 3 * SVE_COST)\n-dnl\n-dnl VSTOREMASK_REDUCTION_PARTIAL($1,     $2,      $3  )\n-dnl VSTOREMASK_REDUCTION_PARTIAL(suffix, op_name, cost)\n-define(`VSTOREMASK_REDUCTION_PARTIAL', `\n-instruct vstoremask_$1_partial(iRegINoSp dst, pRegGov src, immI esize,\n-                               pRegGov ifelse($1, `firsttrue', `pgtmp, pReg ptmp', `ptmp'), rFlagsReg cr) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(1)->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n-  match(Set dst ($2 (VectorStoreMask src esize)));\n-  effect(TEMP ifelse($1, `firsttrue', `pgtmp, TEMP ptmp', `ptmp'), KILL cr);\n-  ins_cost($3 * SVE_COST);\n-  format %{ \"vstoremask_$1 $dst, $src\\t# vector mask $1 partial (sve)\" %}\n-  ins_encode %{\n-    unsigned size = $esize$$constant;\n-    assert(size == 1 || size == 2 || size == 4 || size == 8, \"unsupported element size\");\n-    Assembler::SIMD_RegVariant variant = __ elemBytes_to_regVariant(size);\n-    __ sve_whilelo_zr_imm(as_PRegister(ifelse($1, `firsttrue', `$pgtmp', `$ptmp')$$reg),\n-                          variant, Matcher::vector_length(this, $src));dnl\n-ifelse($1, `truecount', `\n-    __ sve_cntp($dst$$Register, variant, as_PRegister($ptmp$$reg), as_PRegister($src$$reg));',\n-       $1, `firsttrue', `\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant,\n-                           as_PRegister($src$$reg), as_PRegister($pgtmp$$reg),\n-                           as_PRegister($ptmp$$reg), MaxVectorSize \/ size);', `\n-    __ sve_and(as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg),\n-               as_PRegister($src$$reg), as_PRegister($src$$reg));\n-    __ sve_vmask_reduction(this->ideal_Opcode(), $dst$$Register, variant,\n-                           as_PRegister($ptmp$$reg), ptrue,\n-                           as_PRegister($ptmp$$reg), MaxVectorSize \/ size);')\n+%}\n+\n+instruct vmask_lasttrue_partial(iRegINoSp dst, pReg src, pReg ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set dst (VectorMaskLastTrue src));\n+  effect(TEMP ptmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"vmask_lasttrue_partial $dst, $src\\t# vector mask lasttrue partial (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo_zr_imm(as_PRegister($ptmp$$reg), size, Matcher::vector_length(this, $src));\n+    __ sve_and(as_PRegister($ptmp$$reg), ptrue, as_PRegister($ptmp$$reg), as_PRegister($src$$reg));\n+    __ sve_vmask_lasttrue($dst$$Register, bt, as_PRegister($ptmp$$reg), as_PRegister($ptmp$$reg));\n@@ -3267,5 +3078,1 @@\n-%}')dnl\n-dnl\n-VSTOREMASK_REDUCTION_PARTIAL(truecount, VectorMaskTrueCount, 2)\n-VSTOREMASK_REDUCTION_PARTIAL(firsttrue, VectorMaskFirstTrue, 3)\n-VSTOREMASK_REDUCTION_PARTIAL(lasttrue,  VectorMaskLastTrue, 5)\n+%}dnl\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":337,"deletions":530,"binary":false,"changes":867,"status":"modified"},{"patch":"@@ -586,1 +586,1 @@\n-  static bool offset_ok_for_sve_immed(long offset, int shift, int vl \/* sve vector length *\/) {\n+  static bool offset_ok_for_sve_immed(int64_t offset, int shift, int vl \/* sve vector length *\/) {\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -975,6 +975,8 @@\n-void C2_MacroAssembler::sve_vmask_reduction(int opc, Register dst, SIMD_RegVariant size, FloatRegister src,\n-                                            PRegister pgtmp, PRegister ptmp) {\n-  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register\");\n-  \/\/ The condition flags will be clobbered by this function\n-  sve_cmp(Assembler::NE, ptmp, size, pgtmp, src, 0);\n-  sve_vmask_reduction(opc, dst, size, ptmp, pgtmp, ptmp, MaxVectorSize);\n+\/\/ Get index of the last mask lane that is set\n+void C2_MacroAssembler::sve_vmask_lasttrue(Register dst, BasicType bt, PRegister src, PRegister ptmp) {\n+  SIMD_RegVariant size = elemType_to_regVariant(bt);\n+  sve_rev(ptmp, size, src);\n+  sve_brkb(ptmp, ptrue, ptmp, false);\n+  sve_cntp(dst, size, ptrue, ptmp);\n+  movw(rscratch1, MaxVectorSize \/ type2aelembytes(bt) - 1);\n+  subw(dst, rscratch1, dst);\n@@ -983,6 +985,7 @@\n-void C2_MacroAssembler::sve_vmask_reduction(int opc, Register dst, SIMD_RegVariant size, PRegister src,\n-                                            PRegister pgtmp, PRegister ptmp, int length) {\n-  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register\");\n-  switch (opc) {\n-    case Op_VectorMaskTrueCount:\n-      sve_cntp(dst, size, pgtmp, src);\n+void C2_MacroAssembler::sve_vector_extend(FloatRegister dst, SIMD_RegVariant dst_size,\n+                                          FloatRegister src, SIMD_RegVariant src_size) {\n+  assert(dst_size > src_size && dst_size <= D && src_size <= S, \"invalid element size\");\n+  if (src_size == B) {\n+    switch (dst_size) {\n+    case H:\n+      sve_sunpklo(dst, H, src);\n@@ -990,3 +993,3 @@\n-    case Op_VectorMaskFirstTrue:\n-      sve_brkb(ptmp, pgtmp, src, false);\n-      sve_cntp(dst, size, pgtmp, ptmp);\n+    case S:\n+      sve_sunpklo(dst, H, src);\n+      sve_sunpklo(dst, S, dst);\n@@ -994,6 +997,4 @@\n-    case Op_VectorMaskLastTrue:\n-      sve_rev(ptmp, size, src);\n-      sve_brkb(ptmp, ptrue, ptmp, false);\n-      sve_cntp(dst, size, ptrue, ptmp);\n-      movw(rscratch1, length - 1);\n-      subw(dst, rscratch1, dst);\n+    case D:\n+      sve_sunpklo(dst, H, src);\n+      sve_sunpklo(dst, S, dst);\n+      sve_sunpklo(dst, D, dst);\n@@ -1002,1 +1003,0 @@\n-      assert(false, \"unsupported\");\n@@ -1004,0 +1004,46 @@\n+    }\n+  } else if (src_size == H) {\n+    if (dst_size == S) {\n+      sve_sunpklo(dst, S, src);\n+    } else { \/\/ D\n+      sve_sunpklo(dst, S, src);\n+      sve_sunpklo(dst, D, dst);\n+    }\n+  } else if (src_size == S) {\n+    sve_sunpklo(dst, D, src);\n+  }\n+}\n+\n+\/\/ Vector narrow from src to dst with specified element sizes.\n+\/\/ High part of dst vector will be filled with zero.\n+void C2_MacroAssembler::sve_vector_narrow(FloatRegister dst, SIMD_RegVariant dst_size,\n+                                          FloatRegister src, SIMD_RegVariant src_size,\n+                                          FloatRegister tmp) {\n+  assert(dst_size < src_size && dst_size <= S && src_size <= D, \"invalid element size\");\n+  sve_dup(tmp, src_size, 0);\n+  if (src_size == D) {\n+    switch (dst_size) {\n+    case S:\n+      sve_uzp1(dst, S, src, tmp);\n+      break;\n+    case H:\n+      sve_uzp1(dst, S, src, tmp);\n+      sve_uzp1(dst, H, dst, tmp);\n+      break;\n+    case B:\n+      sve_uzp1(dst, S, src, tmp);\n+      sve_uzp1(dst, H, dst, tmp);\n+      sve_uzp1(dst, B, dst, tmp);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+  } else if (src_size == S) {\n+    if (dst_size == H) {\n+      sve_uzp1(dst, H, src, tmp);\n+    } else { \/\/ B\n+      sve_uzp1(dst, H, src, tmp);\n+      sve_uzp1(dst, B, dst, tmp);\n+    }\n+  } else if (src_size == H) {\n+    sve_uzp1(dst, B, src, tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":68,"deletions":22,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-  void sve_vmask_reduction(int opc, Register dst, SIMD_RegVariant size, FloatRegister src,\n-                           PRegister pgtmp, PRegister ptmp);\n+  void sve_vmask_lasttrue(Register dst, BasicType bt, PRegister src, PRegister ptmp);\n@@ -67,2 +66,5 @@\n-  void sve_vmask_reduction(int opc, Register dst, SIMD_RegVariant size, PRegister src,\n-                           PRegister pgtmp, PRegister ptmp, int length);\n+  void sve_vector_extend(FloatRegister dst, SIMD_RegVariant dst_size,\n+                         FloatRegister src, SIMD_RegVariant src_size);\n+\n+  void sve_vector_narrow(FloatRegister dst, SIMD_RegVariant dst_size,\n+                         FloatRegister src, SIMD_RegVariant src_size, FloatRegister tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"}]}