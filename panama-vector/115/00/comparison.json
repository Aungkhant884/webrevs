{"files":[{"patch":"@@ -2079,0 +2079,32 @@\n+void Assembler::evpcompressd(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(src != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x8B);\n+  emit_operand(src, dst);\n+}\n+\n+void Assembler::evpcompressq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(src != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0x8B);\n+  emit_operand(src, dst);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1175,0 +1175,4 @@\n+  \/\/ Vector selective store\n+  void evpcompressd(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpcompressq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1430,0 +1430,14 @@\n+void C2_MacroAssembler::evcompress(BasicType type, Address dst, KRegister kmask, XMMRegister src, bool merge, int vector_len) {\n+  switch(type) {\n+  case T_INT:\n+    evpcompressd(dst, kmask, src, merge, vector_len);\n+    break;\n+  case T_LONG:\n+    evpcompressq(dst, kmask, src, merge, vector_len);\n+    break;\n+  default:\n+    assert(false,\"Should not reach here.\");\n+    break;\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -139,0 +139,3 @@\n+  \/\/ selective store\n+  void evcompress(BasicType type, Address dst, KRegister kmask, XMMRegister src, bool merge, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -8604,0 +8604,24 @@\n+instruct vselective_store(memory mem, vec src, kReg mask) %{\n+  match(Set mem (StoreVectorSelective mem (Binary src mask)));\n+  format %{ \"vector_selective_store $mem, $src, $mask \\t! vector selective store\" %}\n+  ins_encode %{\n+    const MachNode* src_node = static_cast<const MachNode*>(this->in(this->operand_index($src)));\n+    BasicType elmType =  src_node->bottom_type()->is_vect()->element_basic_type();\n+    int vector_len = vector_length_encoding(src_node);\n+    __ evcompress(elmType, $mem$$Address, $mask$$KRegister, $src$$XMMRegister, true, vector_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct kmask_truecount(rRegI dst, kReg mask, rRegL tmp) %{\n+  predicate(VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorMaskTrueCount mask));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"kmask_truecount_evex $mask \\t! kmask true count\" %}\n+  ins_encode %{\n+    __ kmovql($tmp$$Register, $mask$$KRegister);\n+    __ popcntq($dst$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -294,0 +294,1 @@\n+  if( strcmp(opType,\"StoreVectorSelective\")==0 )  return Form::idealV;\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3518,1 +3518,1 @@\n-    \"StoreVector\", \"LoadVector\", \"LoadVectorMasked\", \"StoreVectorMasked\",\n+    \"StoreVector\", \"LoadVector\", \"LoadVectorMasked\", \"StoreVectorMasked\", \"StoreVectorSelective\",\n@@ -4237,1 +4237,2 @@\n-    \"VectorMaskWrapper\", \"VectorMaskCmp\", \"VectorReinterpret\",\"LoadVectorMasked\",\"StoreVectorMasked\",\n+    \"VectorMaskWrapper\", \"VectorMaskCmp\", \"VectorReinterpret\",\n+    \"LoadVectorMasked\", \"StoreVectorMasked\", \"StoreVectorSelective\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -852,0 +852,6 @@\n+  do_intrinsic(_VectorSelectiveStoreOp, jdk_internal_vm_vector_VectorSupport, vector_selective_store_op_name, vector_selective_store_op_sig, F_S) \\\n+   do_signature(vector_selective_store_op_sig, \"(Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;JLjdk\/internal\/vm\/vector\/VectorSupport$Vector;\" \\\n+                                                \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljava\/lang\/Object;I\"                         \\\n+                                                \"Ljdk\/internal\/vm\/vector\/VectorSupport$SelectiveStoreVectorOperation;)I\")                      \\\n+   do_name(vector_selective_store_op_name,     \"selectiveStore\")                                                                               \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -684,0 +684,1 @@\n+  case vmIntrinsics::_VectorSelectiveStoreOp:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -424,0 +424,1 @@\n+macro(StoreVectorSelective)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3437,0 +3437,1 @@\n+  case Op_StoreVectorSelective:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -709,0 +709,1 @@\n+        case Op_StoreVectorSelective:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -651,1 +651,1 @@\n-    return inline_vector_mem_masked_operation(\/*is_store*\/false);\n+    return inline_vector_mem_masked_operation(\/*is_store*\/false, \/*is_selective=*\/false);\n@@ -655,1 +655,3 @@\n-    return inline_vector_mem_masked_operation(\/*is_store=*\/true);\n+    return inline_vector_mem_masked_operation(\/*is_store=*\/true, \/*is_selective=*\/false);\n+  case vmIntrinsics::_VectorSelectiveStoreOp:\n+    return inline_vector_mem_masked_operation(\/*is_store=*\/true, \/*is_selective=*\/true);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-  bool inline_vector_mem_masked_operation(bool is_store);\n+  bool inline_vector_mem_masked_operation(bool is_store, bool is_selective);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2386,1 +2386,2 @@\n-    case Op_StoreVectorMasked: {\n+    case Op_StoreVectorMasked:\n+    case Op_StoreVectorSelective: {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+class StoreVectorSelectiveNode;\n@@ -732,0 +733,1 @@\n+          DEFINE_CLASS_ID(StoreVectorSelective, StoreVector, 2)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1074,1 +1074,1 @@\n-bool LibraryCallKit::inline_vector_mem_masked_operation(bool is_store) {\n+bool LibraryCallKit::inline_vector_mem_masked_operation(bool is_store, bool is_selective) {\n@@ -1246,2 +1246,9 @@\n-    Node* vstore = gvn().transform(new StoreVectorMaskedNode(control(), memory(addr), addr, val, addr_type, mask));\n-    set_memory(vstore, addr_type);\n+    if (is_selective) {\n+      Node* vstore = gvn().transform(new StoreVectorSelectiveNode(control(), memory(addr), addr, val, addr_type, mask));\n+      Node* true_cnt = gvn().transform(new VectorMaskTrueCountNode(mask, TypeInt::INT));\n+      set_memory(vstore, addr_type);\n+      set_result(true_cnt);\n+    } else {\n+      Node* vstore = gvn().transform(new StoreVectorMaskedNode(control(), memory(addr), addr, val, addr_type, mask));\n+      set_memory(vstore, addr_type);\n+    }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -832,0 +832,19 @@\n+\/\/------------------------------StoreVectorSelectiveNode--------------------------------\n+\/\/ Selective Store Vector to memory under the influence of a predicate register(mask).\n+class StoreVectorSelectiveNode : public StoreVectorNode {\n+ public:\n+  StoreVectorSelectiveNode(Node* c, Node* mem, Node* dst, Node* src, const TypePtr* at, Node* mask)\n+   : StoreVectorNode(c, mem, dst, at, src) {\n+    assert(mask->bottom_type()->is_vectmask(), \"sanity\");\n+    init_class_id(Class_StoreVector);\n+    set_mismatched_access();\n+    add_req(mask);\n+  }\n+\n+  virtual int Opcode() const;\n+\n+  virtual uint match_edge(uint idx) const {\n+    return idx > 1;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -405,0 +405,17 @@\n+    public interface SelectiveStoreVectorOperation<C, V extends Vector<?>, M extends VectorMask<?>> {\n+        int selectiveStore(C container, int index, V v, M m);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <C, V extends Vector<?>,\n+     M extends VectorMask<?>>\n+    int selectiveStore(Class<?> vectorClass, Class<M> maskClass, Class<?> elementType,\n+                       int length, Object base, long offset,   \/\/ Unsafe addressing\n+                       V v, M m,\n+                       C container, int index,      \/\/ Arguments for default implementation\n+                       SelectiveStoreVectorOperation<C, V, M> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.selectiveStore(container, index, v, m);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -936,0 +936,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -968,0 +968,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1032,0 +1032,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -920,0 +920,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -906,0 +906,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -384,0 +384,1 @@\n+\n@@ -3660,0 +3661,1 @@\n+\n@@ -3940,0 +3942,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -890,0 +890,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -894,0 +894,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -902,0 +902,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -888,0 +888,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -887,0 +887,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -384,0 +384,1 @@\n+\n@@ -3219,0 +3220,1 @@\n+\n@@ -3554,0 +3556,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -894,0 +894,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -902,0 +902,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -918,0 +918,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -890,0 +890,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -887,0 +887,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -384,0 +384,1 @@\n+\n@@ -3206,0 +3207,1 @@\n+\n@@ -3504,0 +3506,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -905,0 +905,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    int selectiveIntoArray0(int[] a, int offset, VectorMask<Integer> m) {\n+        return super.selectiveIntoArray0Template(Int128Mask.class, a, offset, (Int128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -913,0 +913,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    int selectiveIntoArray0(int[] a, int offset, VectorMask<Integer> m) {\n+        return super.selectiveIntoArray0Template(Int256Mask.class, a, offset, (Int256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -929,0 +929,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    int selectiveIntoArray0(int[] a, int offset, VectorMask<Integer> m) {\n+        return super.selectiveIntoArray0Template(Int512Mask.class, a, offset, (Int512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -901,0 +901,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    int selectiveIntoArray0(int[] a, int offset, VectorMask<Integer> m) {\n+        return super.selectiveIntoArray0Template(Int64Mask.class, a, offset, (Int64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -910,0 +910,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    int selectiveIntoArray0(int[] a, int offset, VectorMask<Integer> m) {\n+        return super.selectiveIntoArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -384,0 +384,18 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> int selectiveStOp(M memory, int offset,\n+                          VectorMask<Integer> m,\n+                          FStOp<M> f) {\n+        \/\/ mask true count\n+        int mcnt = 0;\n+        int[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, mcnt++, vec[i]);\n+            }\n+        }\n+        return mcnt;\n+    }\n+\n@@ -3376,0 +3394,34 @@\n+    \/**\n+     * Selective stores this vector into an array of type\n+     * {@code int[]} starting at offset and using a mask.\n+     * <p>\n+     * The active elements (with their respective bit set in mask)\n+     * are contiguously stored into the array {@code a}.\n+     * Assume {@code N} is the true count of mask, the elements\n+     * starting from {@code a[offset+N]} till {@code a[offset+laneCount]}\n+     * are left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code int[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @return the number of elements store into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    int selectiveIntoArray(int[] a, int offset,\n+                           VectorMask<Integer> m) {\n+        IntSpecies vsp = vspecies();\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return selectiveIntoArray0(a, offset, m);\n+    }\n+\n@@ -3674,0 +3726,17 @@\n+    abstract\n+    int selectiveIntoArray0(int[] a, int offset, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    int selectiveIntoArray0Template(Class<M> maskClass, int[] a, int offset, M m) {\n+        m.check(species());\n+        IntSpecies vsp = vspecies();\n+        return VectorSupport.selectiveStore(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.selectiveStOp(arr, off, vm,\n+                               (arr_, off_, mc, e) -> arr_[off_ + mc] = e));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -891,0 +891,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    int selectiveIntoArray0(long[] a, int offset, VectorMask<Long> m) {\n+        return super.selectiveIntoArray0Template(Long128Mask.class, a, offset, (Long128Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -895,0 +895,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    int selectiveIntoArray0(long[] a, int offset, VectorMask<Long> m) {\n+        return super.selectiveIntoArray0Template(Long256Mask.class, a, offset, (Long256Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -903,0 +903,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    int selectiveIntoArray0(long[] a, int offset, VectorMask<Long> m) {\n+        return super.selectiveIntoArray0Template(Long512Mask.class, a, offset, (Long512Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -889,0 +889,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    int selectiveIntoArray0(long[] a, int offset, VectorMask<Long> m) {\n+        return super.selectiveIntoArray0Template(Long64Mask.class, a, offset, (Long64Mask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -889,0 +889,7 @@\n+    @ForceInline\n+    @Override\n+    final\n+    int selectiveIntoArray0(long[] a, int offset, VectorMask<Long> m) {\n+        return super.selectiveIntoArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -384,0 +384,18 @@\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> int selectiveStOp(M memory, int offset,\n+                          VectorMask<Long> m,\n+                          FStOp<M> f) {\n+        \/\/ mask true count\n+        int mcnt = 0;\n+        long[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, mcnt++, vec[i]);\n+            }\n+        }\n+        return mcnt;\n+    }\n+\n@@ -3274,0 +3292,34 @@\n+    \/**\n+     * Selective stores this vector into an array of type\n+     * {@code long[]} starting at offset and using a mask.\n+     * <p>\n+     * The active elements (with their respective bit set in mask)\n+     * are contiguously stored into the array {@code a}.\n+     * Assume {@code N} is the true count of mask, the elements\n+     * starting from {@code a[offset+N]} till {@code a[offset+laneCount]}\n+     * are left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code long[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @return the number of elements store into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    int selectiveIntoArray(long[] a, int offset,\n+                           VectorMask<Long> m) {\n+        LongSpecies vsp = vspecies();\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return selectiveIntoArray0(a, offset, m);\n+    }\n+\n@@ -3609,0 +3661,17 @@\n+    abstract\n+    int selectiveIntoArray0(long[] a, int offset, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    int selectiveIntoArray0Template(Class<M> maskClass, long[] a, int offset, M m) {\n+        m.check(species());\n+        LongSpecies vsp = vspecies();\n+        return VectorSupport.selectiveStore(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.selectiveStOp(arr, off, vm,\n+                               (arr_, off_, mc, e) -> arr_[off_ + mc] = e));\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -920,0 +920,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -936,0 +936,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -968,0 +968,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -912,0 +912,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -906,0 +906,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -384,0 +384,1 @@\n+\n@@ -3646,0 +3647,1 @@\n+\n@@ -3926,0 +3928,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -388,0 +388,20 @@\n+#if[intOrLong]\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> int selectiveStOp(M memory, int offset,\n+                          VectorMask<$Boxtype$> m,\n+                          FStOp<M> f) {\n+        \/\/ mask true count\n+        int mcnt = 0;\n+        $type$[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, mcnt++, vec[i]);\n+            }\n+        }\n+        return mcnt;\n+    }\n+#end[intOrLong]\n+\n@@ -4619,0 +4639,36 @@\n+#if[intOrLong]\n+    \/**\n+     * Selective stores this vector into an array of type\n+     * {@code $type$[]} starting at offset and using a mask.\n+     * <p>\n+     * The active elements (with their respective bit set in mask)\n+     * are contiguously stored into the array {@code a}.\n+     * Assume {@code N} is the true count of mask, the elements\n+     * starting from {@code a[offset+N]} till {@code a[offset+laneCount]}\n+     * are left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code $type$[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @return the number of elements store into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    int selectiveIntoArray($type$[] a, int offset,\n+                           VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = vspecies();\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return selectiveIntoArray0(a, offset, m);\n+    }\n+#end[intOrLong]\n+\n@@ -5076,0 +5132,19 @@\n+#if[intOrLong]\n+    abstract\n+    int selectiveIntoArray0($type$[] a, int offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    int selectiveIntoArray0Template(Class<M> maskClass, $type$[] a, int offset, M m) {\n+        m.check(species());\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.selectiveStore(\n+            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+            a, arrayAddress(a, offset),\n+            this, m, a, offset,\n+            (arr, off, v, vm)\n+            -> v.selectiveStOp(arr, off, vm,\n+                               (arr_, off_, mc, e) -> arr_[off_ + mc] = e));\n+    }\n+#end[intOrLong]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1237,0 +1237,9 @@\n+#if[intOrLong]\n+    @ForceInline\n+    @Override\n+    final\n+    int selectiveIntoArray0($type$[] a, int offset, VectorMask<$Boxtype$> m) {\n+        return super.selectiveIntoArray0Template($masktype$.class, a, offset, ($masktype$) m);  \/\/ specialize\n+    }\n+#end[intOrLong]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -298,0 +299,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -298,0 +299,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -298,0 +299,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -298,0 +299,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+\n@@ -307,0 +308,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+\n@@ -318,0 +319,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+\n@@ -318,0 +319,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,25 @@\n+    static void assertArraysEquals(int[] r, int[] a, boolean[] mask, int trueCount) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                if (mask[i % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[i]);\n+                    j++;\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i], \"at r's index #\" + j + \", at a's index #\" + i);\n+        }\n+\n+        Assert.assertEquals(j, trueCount, \"trueCount is not correct\");\n+\n+        try {\n+            \/\/ Verify the remaining elements are left unchanged\n+            for (; j < r.length; j++) {\n+                Assert.assertEquals(r[j], (int) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], (int) 0, \"Remaining part should be left unchanged\");\n+        }\n+    }\n+\n@@ -309,0 +334,5 @@\n+    @DontInline\n+    static int selectiveIntoArray(IntVector v, int[] a, int i, VectorMask<Integer> m) {\n+        return v.selectiveIntoArray(a, i, m);\n+    }\n+\n@@ -503,0 +533,18 @@\n+    @Test(dataProvider = \"intMaskProvider\")\n+    static void selectiveStoreMaskArray(IntFunction<int[]> fa,\n+                                        IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int trueCount = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            trueCount = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                trueCount += av.selectiveIntoArray(r, trueCount, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask, trueCount);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -70,0 +70,25 @@\n+    static void assertArraysEquals(int[] r, int[] a, boolean[] mask, int trueCount) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                if (mask[i % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[i]);\n+                    j++;\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i], \"at r's index #\" + j + \", at a's index #\" + i);\n+        }\n+\n+        Assert.assertEquals(j, trueCount, \"trueCount is not correct\");\n+\n+        try {\n+            \/\/ Verify the remaining elements are left unchanged\n+            for (; j < r.length; j++) {\n+                Assert.assertEquals(r[j], (int) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], (int) 0, \"Remaining part should be left unchanged\");\n+        }\n+    }\n+\n@@ -309,0 +334,5 @@\n+    @DontInline\n+    static int selectiveIntoArray(IntVector v, int[] a, int i, VectorMask<Integer> m) {\n+        return v.selectiveIntoArray(a, i, m);\n+    }\n+\n@@ -503,0 +533,18 @@\n+    @Test(dataProvider = \"intMaskProvider\")\n+    static void selectiveStoreMaskArray(IntFunction<int[]> fa,\n+                                        IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int trueCount = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            trueCount = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                trueCount += av.selectiveIntoArray(r, trueCount, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask, trueCount);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -70,0 +70,25 @@\n+    static void assertArraysEquals(int[] r, int[] a, boolean[] mask, int trueCount) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                if (mask[i % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[i]);\n+                    j++;\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i], \"at r's index #\" + j + \", at a's index #\" + i);\n+        }\n+\n+        Assert.assertEquals(j, trueCount, \"trueCount is not correct\");\n+\n+        try {\n+            \/\/ Verify the remaining elements are left unchanged\n+            for (; j < r.length; j++) {\n+                Assert.assertEquals(r[j], (int) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], (int) 0, \"Remaining part should be left unchanged\");\n+        }\n+    }\n+\n@@ -309,0 +334,5 @@\n+    @DontInline\n+    static int selectiveIntoArray(IntVector v, int[] a, int i, VectorMask<Integer> m) {\n+        return v.selectiveIntoArray(a, i, m);\n+    }\n+\n@@ -503,0 +533,18 @@\n+    @Test(dataProvider = \"intMaskProvider\")\n+    static void selectiveStoreMaskArray(IntFunction<int[]> fa,\n+                                        IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int trueCount = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            trueCount = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                trueCount += av.selectiveIntoArray(r, trueCount, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask, trueCount);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -70,0 +70,25 @@\n+    static void assertArraysEquals(int[] r, int[] a, boolean[] mask, int trueCount) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                if (mask[i % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[i]);\n+                    j++;\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i], \"at r's index #\" + j + \", at a's index #\" + i);\n+        }\n+\n+        Assert.assertEquals(j, trueCount, \"trueCount is not correct\");\n+\n+        try {\n+            \/\/ Verify the remaining elements are left unchanged\n+            for (; j < r.length; j++) {\n+                Assert.assertEquals(r[j], (int) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], (int) 0, \"Remaining part should be left unchanged\");\n+        }\n+    }\n+\n@@ -309,0 +334,5 @@\n+    @DontInline\n+    static int selectiveIntoArray(IntVector v, int[] a, int i, VectorMask<Integer> m) {\n+        return v.selectiveIntoArray(a, i, m);\n+    }\n+\n@@ -503,0 +533,18 @@\n+    @Test(dataProvider = \"intMaskProvider\")\n+    static void selectiveStoreMaskArray(IntFunction<int[]> fa,\n+                                        IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int trueCount = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            trueCount = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                trueCount += av.selectiveIntoArray(r, trueCount, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask, trueCount);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -79,0 +79,25 @@\n+    static void assertArraysEquals(int[] r, int[] a, boolean[] mask, int trueCount) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                if (mask[i % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[i]);\n+                    j++;\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i], \"at r's index #\" + j + \", at a's index #\" + i);\n+        }\n+\n+        Assert.assertEquals(j, trueCount, \"trueCount is not correct\");\n+\n+        try {\n+            \/\/ Verify the remaining elements are left unchanged\n+            for (; j < r.length; j++) {\n+                Assert.assertEquals(r[j], (int) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], (int) 0, \"Remaining part should be left unchanged\");\n+        }\n+    }\n+\n@@ -318,0 +343,5 @@\n+    @DontInline\n+    static int selectiveIntoArray(IntVector v, int[] a, int i, VectorMask<Integer> m) {\n+        return v.selectiveIntoArray(a, i, m);\n+    }\n+\n@@ -512,0 +542,18 @@\n+    @Test(dataProvider = \"intMaskProvider\")\n+    static void selectiveStoreMaskArray(IntFunction<int[]> fa,\n+                                        IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int trueCount = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            trueCount = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                trueCount += av.selectiveIntoArray(r, trueCount, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask, trueCount);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -70,0 +70,25 @@\n+    static void assertArraysEquals(long[] r, long[] a, boolean[] mask, int trueCount) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                if (mask[i % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[i]);\n+                    j++;\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i], \"at r's index #\" + j + \", at a's index #\" + i);\n+        }\n+\n+        Assert.assertEquals(j, trueCount, \"trueCount is not correct\");\n+\n+        try {\n+            \/\/ Verify the remaining elements are left unchanged\n+            for (; j < r.length; j++) {\n+                Assert.assertEquals(r[j], (long) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], (long) 0, \"Remaining part should be left unchanged\");\n+        }\n+    }\n+\n@@ -309,0 +334,5 @@\n+    @DontInline\n+    static int selectiveIntoArray(LongVector v, long[] a, int i, VectorMask<Long> m) {\n+        return v.selectiveIntoArray(a, i, m);\n+    }\n+\n@@ -503,0 +533,18 @@\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void selectiveStoreMaskArray(IntFunction<long[]> fa,\n+                                        IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int trueCount = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            trueCount = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                trueCount += av.selectiveIntoArray(r, trueCount, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask, trueCount);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -70,0 +70,25 @@\n+    static void assertArraysEquals(long[] r, long[] a, boolean[] mask, int trueCount) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                if (mask[i % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[i]);\n+                    j++;\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i], \"at r's index #\" + j + \", at a's index #\" + i);\n+        }\n+\n+        Assert.assertEquals(j, trueCount, \"trueCount is not correct\");\n+\n+        try {\n+            \/\/ Verify the remaining elements are left unchanged\n+            for (; j < r.length; j++) {\n+                Assert.assertEquals(r[j], (long) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], (long) 0, \"Remaining part should be left unchanged\");\n+        }\n+    }\n+\n@@ -309,0 +334,5 @@\n+    @DontInline\n+    static int selectiveIntoArray(LongVector v, long[] a, int i, VectorMask<Long> m) {\n+        return v.selectiveIntoArray(a, i, m);\n+    }\n+\n@@ -503,0 +533,18 @@\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void selectiveStoreMaskArray(IntFunction<long[]> fa,\n+                                        IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int trueCount = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            trueCount = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                trueCount += av.selectiveIntoArray(r, trueCount, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask, trueCount);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -70,0 +70,25 @@\n+    static void assertArraysEquals(long[] r, long[] a, boolean[] mask, int trueCount) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                if (mask[i % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[i]);\n+                    j++;\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i], \"at r's index #\" + j + \", at a's index #\" + i);\n+        }\n+\n+        Assert.assertEquals(j, trueCount, \"trueCount is not correct\");\n+\n+        try {\n+            \/\/ Verify the remaining elements are left unchanged\n+            for (; j < r.length; j++) {\n+                Assert.assertEquals(r[j], (long) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], (long) 0, \"Remaining part should be left unchanged\");\n+        }\n+    }\n+\n@@ -309,0 +334,5 @@\n+    @DontInline\n+    static int selectiveIntoArray(LongVector v, long[] a, int i, VectorMask<Long> m) {\n+        return v.selectiveIntoArray(a, i, m);\n+    }\n+\n@@ -503,0 +533,18 @@\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void selectiveStoreMaskArray(IntFunction<long[]> fa,\n+                                        IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int trueCount = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            trueCount = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                trueCount += av.selectiveIntoArray(r, trueCount, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask, trueCount);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -70,0 +70,25 @@\n+    static void assertArraysEquals(long[] r, long[] a, boolean[] mask, int trueCount) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                if (mask[i % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[i]);\n+                    j++;\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i], \"at r's index #\" + j + \", at a's index #\" + i);\n+        }\n+\n+        Assert.assertEquals(j, trueCount, \"trueCount is not correct\");\n+\n+        try {\n+            \/\/ Verify the remaining elements are left unchanged\n+            for (; j < r.length; j++) {\n+                Assert.assertEquals(r[j], (long) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], (long) 0, \"Remaining part should be left unchanged\");\n+        }\n+    }\n+\n@@ -309,0 +334,5 @@\n+    @DontInline\n+    static int selectiveIntoArray(LongVector v, long[] a, int i, VectorMask<Long> m) {\n+        return v.selectiveIntoArray(a, i, m);\n+    }\n+\n@@ -503,0 +533,18 @@\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void selectiveStoreMaskArray(IntFunction<long[]> fa,\n+                                        IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int trueCount = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            trueCount = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                trueCount += av.selectiveIntoArray(r, trueCount, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask, trueCount);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -79,0 +79,25 @@\n+    static void assertArraysEquals(long[] r, long[] a, boolean[] mask, int trueCount) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                if (mask[i % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[i]);\n+                    j++;\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i], \"at r's index #\" + j + \", at a's index #\" + i);\n+        }\n+\n+        Assert.assertEquals(j, trueCount, \"trueCount is not correct\");\n+\n+        try {\n+            \/\/ Verify the remaining elements are left unchanged\n+            for (; j < r.length; j++) {\n+                Assert.assertEquals(r[j], (long) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], (long) 0, \"Remaining part should be left unchanged\");\n+        }\n+    }\n+\n@@ -318,0 +343,5 @@\n+    @DontInline\n+    static int selectiveIntoArray(LongVector v, long[] a, int i, VectorMask<Long> m) {\n+        return v.selectiveIntoArray(a, i, m);\n+    }\n+\n@@ -512,0 +542,18 @@\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void selectiveStoreMaskArray(IntFunction<long[]> fa,\n+                                        IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int trueCount = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            trueCount = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                trueCount += av.selectiveIntoArray(r, trueCount, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask, trueCount);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+\n@@ -309,0 +310,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+\n@@ -318,0 +319,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,0 +96,27 @@\n+#if[intOrLong]\n+    static void assertArraysEquals($type$[] r, $type$[] a, boolean[] mask, int trueCount) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                if (mask[i % SPECIES.length()]) {\n+                    Assert.assertEquals(r[j], a[i]);\n+                    j++;\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], a[i], \"at r's index #\" + j + \", at a's index #\" + i);\n+        }\n+\n+        Assert.assertEquals(j, trueCount, \"trueCount is not correct\");\n+\n+        try {\n+            \/\/ Verify the remaining elements are left unchanged\n+            for (; j < r.length; j++) {\n+                Assert.assertEquals(r[j], ($type$) 0);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[j], ($type$) 0, \"Remaining part should be left unchanged\");\n+        }\n+    }\n+#end[intOrLong]\n+\n@@ -341,0 +368,7 @@\n+#if[intOrLong]\n+    @DontInline\n+    static int selectiveIntoArray($abstractvectortype$ v, $type$[] a, int i, VectorMask<$Boxtype$> m) {\n+        return v.selectiveIntoArray(a, i, m);\n+    }\n+#end[intOrLong]\n+\n@@ -535,0 +569,20 @@\n+#if[intOrLong]\n+    @Test(dataProvider = \"$type$MaskProvider\")\n+    static void selectiveStoreMaskArray(IntFunction<$type$[]> fa,\n+                                        IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        int trueCount = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            trueCount = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                trueCount += av.selectiveIntoArray(r, trueCount, vmask);\n+            }\n+        }\n+        assertArraysEquals(r, a, mask, trueCount);\n+    }\n+#end[intOrLong]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\", \"--add-exports\", \"java.base\/jdk.internal.vm.vector=ALL-UNNAMED\", \"-ea\"})\n+public class SelectiveStoreInt {\n+\n+  private static int ARRAY_LENGTH = 1024;\n+\n+  private static final VectorSpecies<Integer> INT_64_SPECIES =\n+    IntVector.SPECIES_64;\n+  private static final VectorSpecies<Integer> INT_128_SPECIES =\n+    IntVector.SPECIES_128;\n+  private static final VectorSpecies<Integer> INT_256_SPECIES =\n+    IntVector.SPECIES_256;\n+  private static final VectorSpecies<Integer> INT_512_SPECIES =\n+    IntVector.SPECIES_512;\n+  private static final VectorSpecies<Integer> INT_PREFERRED_SPECIES =\n+    IntVector.SPECIES_PREFERRED;\n+\n+  @State(Scope.Thread)\n+  public static class ThreadLocalData {\n+\n+    private int conflict_scalar_cnt = 0;\n+    private int conflict_vector_cnt = 0;\n+    private int[] int_index = new int[ARRAY_LENGTH];\n+    private int[] int_conflict_scalar = new int[ARRAY_LENGTH];\n+    private int[] int_conflict_vector = new int[ARRAY_LENGTH];\n+    private int[] int_input1 = new int[ARRAY_LENGTH];\n+    private int[] int_input2 = new int[ARRAY_LENGTH];\n+    private Random rand = new Random();\n+\n+    @Setup(Level.Trial)\n+    public void doSetup() {\n+      int conflict_id_each_5_elements = ThreadLocalRandom.current().nextInt(5);\n+\n+      for (int i = 0; i < ARRAY_LENGTH; i++) {\n+        int_index[i] = ThreadLocalRandom.current().nextInt(ARRAY_LENGTH);\n+        int_input1[i] = ThreadLocalRandom.current().nextInt();\n+        \/\/ Generate 20% conflict data\n+        int remainder = i % 5;\n+        if (remainder == conflict_id_each_5_elements) {\n+          int_input2[i] = ThreadLocalRandom.current().nextInt();\n+        } else {\n+          int_input2[i] = int_input1[i];\n+        }\n+\n+        int_conflict_scalar[i] = 0;\n+        int_conflict_vector[i] = 0;\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_int_scalar(ThreadLocalData tld) {\n+    tld.conflict_scalar_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      if (tld.int_input1[i] != tld.int_input2[i]) {\n+        tld.int_conflict_scalar[tld.conflict_scalar_cnt++] = tld.int_index[i];\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_int_vector_64(ThreadLocalData tld) {\n+    tld.conflict_vector_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += INT_64_SPECIES.length()) {\n+      IntVector av = IntVector.fromArray(INT_64_SPECIES, tld.int_input1, i);\n+      IntVector bv = IntVector.fromArray(INT_64_SPECIES, tld.int_input2, i);\n+      IntVector cv = IntVector.fromArray(INT_64_SPECIES, tld.int_index, i);\n+      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n+      tld.conflict_vector_cnt += cv.selectiveIntoArray(tld.int_conflict_vector, tld.conflict_vector_cnt, mask);\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_int_vector_128(ThreadLocalData tld) {\n+    tld.conflict_vector_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += INT_128_SPECIES.length()) {\n+      IntVector av = IntVector.fromArray(INT_128_SPECIES, tld.int_input1, i);\n+      IntVector bv = IntVector.fromArray(INT_128_SPECIES, tld.int_input2, i);\n+      IntVector cv = IntVector.fromArray(INT_128_SPECIES, tld.int_index, i);\n+      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n+      tld.conflict_vector_cnt += cv.selectiveIntoArray(tld.int_conflict_vector, tld.conflict_vector_cnt, mask);\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_int_vector_256(ThreadLocalData tld) {\n+    tld.conflict_vector_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += INT_256_SPECIES.length()) {\n+      IntVector av = IntVector.fromArray(INT_256_SPECIES, tld.int_input1, i);\n+      IntVector bv = IntVector.fromArray(INT_256_SPECIES, tld.int_input2, i);\n+      IntVector cv = IntVector.fromArray(INT_256_SPECIES, tld.int_index, i);\n+      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n+      tld.conflict_vector_cnt += cv.selectiveIntoArray(tld.int_conflict_vector, tld.conflict_vector_cnt, mask);\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_int_vector_512(ThreadLocalData tld) {\n+    tld.conflict_vector_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += INT_512_SPECIES.length()) {\n+      IntVector av = IntVector.fromArray(INT_512_SPECIES, tld.int_input1, i);\n+      IntVector bv = IntVector.fromArray(INT_512_SPECIES, tld.int_input2, i);\n+      IntVector cv = IntVector.fromArray(INT_512_SPECIES, tld.int_index, i);\n+      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n+      tld.conflict_vector_cnt += cv.selectiveIntoArray(tld.int_conflict_vector, tld.conflict_vector_cnt, mask);\n+    }\n+  }\n+\n+  public void selectiveStore_int_vector_preferred(ThreadLocalData tld) {\n+    tld.conflict_vector_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += INT_PREFERRED_SPECIES.length()) {\n+      IntVector av = IntVector.fromArray(INT_PREFERRED_SPECIES, tld.int_input1, i);\n+      IntVector bv = IntVector.fromArray(INT_PREFERRED_SPECIES, tld.int_input2, i);\n+      IntVector cv = IntVector.fromArray(INT_PREFERRED_SPECIES, tld.int_index, i);\n+      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n+      tld.conflict_vector_cnt += cv.selectiveIntoArray(tld.int_conflict_vector, tld.conflict_vector_cnt, mask);\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_int_verify(ThreadLocalData tld) {\n+    \/\/ Initialization\n+    int conflict_id_each_5_elements = ThreadLocalRandom.current().nextInt(5);\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      tld.int_index[i] = ThreadLocalRandom.current().nextInt(ARRAY_LENGTH);\n+      tld.int_input1[i] = ThreadLocalRandom.current().nextInt();\n+      \/\/ Generate 20% conflict data\n+      int remainder = i % 5;\n+      if (remainder == conflict_id_each_5_elements) {\n+        tld.int_input2[i] = ThreadLocalRandom.current().nextInt();\n+      } else {\n+        tld.int_input2[i] = tld.int_input1[i];\n+      }\n+      tld.int_conflict_scalar[i] = 0;\n+      tld.int_conflict_vector[i] = 0;\n+    }\n+    \/\/ Test\n+    selectiveStore_int_scalar(tld);\n+    selectiveStore_int_vector_preferred(tld);\n+    \/\/ Verify\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      assert(tld.int_conflict_scalar[i] == tld.int_conflict_vector[i]);\n+    }\n+    assert(tld.conflict_scalar_cnt == tld.conflict_vector_cnt);\n+  }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/SelectiveStoreInt.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\", \"--add-exports\", \"java.base\/jdk.internal.vm.vector=ALL-UNNAMED\", \"-ea\"})\n+public class SelectiveStoreLong {\n+\n+  private static int ARRAY_LENGTH = 512;\n+\n+  private static final VectorSpecies<Long> LONG_64_SPECIES =\n+    LongVector.SPECIES_64;\n+  private static final VectorSpecies<Long> LONG_128_SPECIES =\n+    LongVector.SPECIES_128;\n+  private static final VectorSpecies<Long> LONG_256_SPECIES =\n+    LongVector.SPECIES_256;\n+  private static final VectorSpecies<Long> LONG_512_SPECIES =\n+    LongVector.SPECIES_512;\n+  private static final VectorSpecies<Long> LONG_PREFERRED_SPECIES =\n+    LongVector.SPECIES_PREFERRED;\n+\n+  @State(Scope.Thread)\n+  public static class ThreadLocalData {\n+\n+    private int conflict_scalar_cnt = 0;\n+    private int conflict_vector_cnt = 0;\n+    private long[] long_index = new long[ARRAY_LENGTH];\n+    private long[] long_conflict_scalar = new long[ARRAY_LENGTH];\n+    private long[] long_conflict_vector = new long[ARRAY_LENGTH];\n+    private long[] long_input1 = new long[ARRAY_LENGTH];\n+    private long[] long_input2 = new long[ARRAY_LENGTH];\n+    private Random rand = new Random();\n+\n+    @Setup(Level.Trial)\n+    public void doSetup() {\n+      int conflict_id_each_5_elements = ThreadLocalRandom.current().nextInt(5);\n+\n+      for (int i = 0; i < ARRAY_LENGTH; i++) {\n+        long_index[i] = ThreadLocalRandom.current().nextInt(ARRAY_LENGTH);\n+        long_input1[i] = ThreadLocalRandom.current().nextLong();\n+        \/\/ Generate 20% conflict data\n+        int remainder = i % 5;\n+        if (remainder == conflict_id_each_5_elements) {\n+          long_input2[i] = ThreadLocalRandom.current().nextLong();\n+        } else {\n+          long_input2[i] = long_input1[i];\n+        }\n+\n+        long_conflict_scalar[i] = 0;\n+        long_conflict_vector[i] = 0;\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_long_scalar(ThreadLocalData tld) {\n+    tld.conflict_scalar_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      if (tld.long_input1[i] != tld.long_input2[i]) {\n+        tld.long_conflict_scalar[tld.conflict_scalar_cnt++] = tld.long_index[i];\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_long_vector_64(ThreadLocalData tld) {\n+    tld.conflict_vector_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += LONG_64_SPECIES.length()) {\n+      LongVector av = LongVector.fromArray(LONG_64_SPECIES, tld.long_input1, i);\n+      LongVector bv = LongVector.fromArray(LONG_64_SPECIES, tld.long_input2, i);\n+      LongVector cv = LongVector.fromArray(LONG_64_SPECIES, tld.long_index, i);\n+      VectorMask<Long> mask = av.compare(VectorOperators.NE, bv);\n+      tld.conflict_vector_cnt += cv.selectiveIntoArray(tld.long_conflict_vector, tld.conflict_vector_cnt, mask);\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_long_vector_128(ThreadLocalData tld) {\n+    tld.conflict_vector_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += LONG_128_SPECIES.length()) {\n+      LongVector av = LongVector.fromArray(LONG_128_SPECIES, tld.long_input1, i);\n+      LongVector bv = LongVector.fromArray(LONG_128_SPECIES, tld.long_input2, i);\n+      LongVector cv = LongVector.fromArray(LONG_128_SPECIES, tld.long_index, i);\n+      VectorMask<Long> mask = av.compare(VectorOperators.NE, bv);\n+      tld.conflict_vector_cnt += cv.selectiveIntoArray(tld.long_conflict_vector, tld.conflict_vector_cnt, mask);\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_long_vector_256(ThreadLocalData tld) {\n+    tld.conflict_vector_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += LONG_256_SPECIES.length()) {\n+      LongVector av = LongVector.fromArray(LONG_256_SPECIES, tld.long_input1, i);\n+      LongVector bv = LongVector.fromArray(LONG_256_SPECIES, tld.long_input2, i);\n+      LongVector cv = LongVector.fromArray(LONG_256_SPECIES, tld.long_index, i);\n+      VectorMask<Long> mask = av.compare(VectorOperators.NE, bv);\n+      tld.conflict_vector_cnt += cv.selectiveIntoArray(tld.long_conflict_vector, tld.conflict_vector_cnt, mask);\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_long_vector_512(ThreadLocalData tld) {\n+    tld.conflict_vector_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += LONG_512_SPECIES.length()) {\n+      LongVector av = LongVector.fromArray(LONG_512_SPECIES, tld.long_input1, i);\n+      LongVector bv = LongVector.fromArray(LONG_512_SPECIES, tld.long_input2, i);\n+      LongVector cv = LongVector.fromArray(LONG_512_SPECIES, tld.long_index, i);\n+      VectorMask<Long> mask = av.compare(VectorOperators.NE, bv);\n+      tld.conflict_vector_cnt += cv.selectiveIntoArray(tld.long_conflict_vector, tld.conflict_vector_cnt, mask);\n+    }\n+  }\n+\n+  public void selectiveStore_long_vector_preferred(ThreadLocalData tld) {\n+    tld.conflict_vector_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += LONG_PREFERRED_SPECIES.length()) {\n+      LongVector av = LongVector.fromArray(LONG_PREFERRED_SPECIES, tld.long_input1, i);\n+      LongVector bv = LongVector.fromArray(LONG_PREFERRED_SPECIES, tld.long_input2, i);\n+      LongVector cv = LongVector.fromArray(LONG_PREFERRED_SPECIES, tld.long_index, i);\n+      VectorMask<Long> mask = av.compare(VectorOperators.NE, bv);\n+      tld.conflict_vector_cnt += cv.selectiveIntoArray(tld.long_conflict_vector, tld.conflict_vector_cnt, mask);\n+    }\n+  }\n+\n+  @Benchmark\n+  @Threads(8)\n+  public void selectiveStore_long_verify(ThreadLocalData tld) {\n+    \/\/ Initialization\n+    int conflict_id_each_5_elements = ThreadLocalRandom.current().nextInt(5);\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      tld.long_index[i] = ThreadLocalRandom.current().nextInt(ARRAY_LENGTH);\n+      tld.long_input1[i] = ThreadLocalRandom.current().nextLong();\n+      \/\/ Generate 20% conflict data\n+      int remainder = i % 5;\n+      if (remainder == conflict_id_each_5_elements) {\n+        tld.long_input2[i] = ThreadLocalRandom.current().nextLong();\n+      } else {\n+        tld.long_input2[i] = tld.long_input1[i];\n+      }\n+      tld.long_conflict_scalar[i] = 0;\n+      tld.long_conflict_vector[i] = 0;\n+    }\n+    \/\/ Test\n+    selectiveStore_long_scalar(tld);\n+    selectiveStore_long_vector_preferred(tld);\n+    \/\/ Verify\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      assert(tld.long_conflict_scalar[i] == tld.long_conflict_vector[i]);\n+    }\n+    assert(tld.conflict_scalar_cnt == tld.conflict_vector_cnt);\n+  }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/SelectiveStoreLong.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"}]}