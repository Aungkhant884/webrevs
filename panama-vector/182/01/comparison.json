{"files":[{"patch":"@@ -9901,0 +9901,9 @@\n+void Assembler::vgf2p8affineqb(XMMRegister dst, int imm8, XMMRegister src2, XMMRegister src3, int vector_len) {\n+  assert(VM_Version::supports_gfni(), \"requires GFNI support\");\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src3->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0xCE, (unsigned char)(0xC0 | encode), imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2737,0 +2737,3 @@\n+  \/\/ Galois field affine transformation instructions.\n+  void vgf2p8affineqb(XMMRegister dst, int imm8, XMMRegister src2, XMMRegister src3, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4396,0 +4396,178 @@\n+\n+void C2_MacroAssembler::vector_reverse_bit_avx(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                               XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc) {\n+  vpcmpeqd(xtmp3, xtmp3, xtmp3, vec_enc);\n+\n+  \/\/ Shift based bit reversal.\n+  movl(rtmp, 0x0f0f0f0f);\n+  movq(dst, rtmp);\n+  vpbroadcastd(dst, dst, vec_enc);\n+  vpxor(xtmp2, xtmp3, dst, vec_enc);\n+\n+  vpand(dst, dst, src, vec_enc);\n+  vpsllq(dst, dst, 4, vec_enc);\n+  vpand(xtmp2, xtmp2, src, vec_enc);\n+  vpsrlq(xtmp2, xtmp2, 4, vec_enc);\n+  vpor(xtmp1, dst, xtmp2, vec_enc);\n+\n+  movl(rtmp, 0x33333333);\n+  movq(dst, rtmp);\n+  vpbroadcastd(dst, dst, vec_enc);\n+  vpxor(xtmp2, xtmp3, dst, vec_enc);\n+\n+  vpand(dst, dst, xtmp1, vec_enc);\n+  vpsllq(dst, dst, 2, vec_enc);\n+  vpand(xtmp2, xtmp2, xtmp1, vec_enc);\n+  vpsrlq(xtmp2, xtmp2, 2, vec_enc);\n+  vpor(xtmp1, dst, xtmp2, vec_enc);\n+\n+  movl(rtmp, 0x55555555);\n+  movq(dst, rtmp);\n+  vpbroadcastd(dst, dst, vec_enc);\n+  vpxor(xtmp2, xtmp3, dst, vec_enc);\n+\n+  vpand(dst, dst, xtmp1, vec_enc);\n+  vpsllq(dst, dst, 1, vec_enc);\n+  vpand(xtmp2, xtmp2, xtmp1, vec_enc);\n+  vpsrlq(xtmp2, xtmp2, 1, vec_enc);\n+  vpor(dst, dst, xtmp2, vec_enc);\n+\n+  if (bt != T_BYTE) {\n+    vector_reverse_byte_avx(bt, dst, dst, xtmp1, vec_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_reverse_bit_evex(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  \/\/ Shift based bit reversal.\n+  movl(rtmp, 0x0f0f0f0f);\n+  evpbroadcastd(xtmp1, rtmp, vec_enc);\n+  vpternlogd(xtmp2, 0x11, xtmp1, xtmp1, vec_enc);\n+\n+  vpandq(dst, xtmp1, src, vec_enc);\n+  vpsllq(dst, dst, 4, vec_enc);\n+  vpandq(xtmp2, xtmp2, src, vec_enc);\n+  vpsrlq(xtmp2, xtmp2, 4, vec_enc);\n+  vporq(xtmp1, dst, xtmp2, vec_enc);\n+\n+  movl(rtmp, 0x33333333);\n+  evpbroadcastd(dst, rtmp, vec_enc);\n+  vpternlogd(xtmp2, 0x11, dst, dst, vec_enc);\n+\n+  vpandq(dst, dst, xtmp1, vec_enc);\n+  vpsllq(dst, dst, 2, vec_enc);\n+  vpandq(xtmp2, xtmp2, xtmp1, vec_enc);\n+  vpsrlq(xtmp2, xtmp2, 2, vec_enc);\n+  vporq(xtmp1, dst, xtmp2, vec_enc);\n+\n+  movl(rtmp, 0x55555555);\n+  evpbroadcastd(dst, rtmp, vec_enc);\n+  vpternlogd(xtmp2, 0x11, dst, dst, vec_enc);\n+\n+  vpandq(dst, dst, xtmp1, vec_enc);\n+  vpsllq(dst, dst, 1, vec_enc);\n+  vpandq(xtmp2, xtmp2, xtmp1, vec_enc);\n+  vpsrlq(xtmp2, xtmp2, 1, vec_enc);\n+  vporq(dst, dst, xtmp2, vec_enc);\n+\n+  if (bt != T_BYTE) {\n+    vector_reverse_byte_evex(bt, dst, dst, xtmp1, xtmp2, rtmp, vec_enc);\n+  }\n+}\n+\n+#ifdef _LP64\n+void C2_MacroAssembler::vector_reverse_bit_gfni(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                XMMRegister xtmp, Register rtmp, int vec_enc) {\n+  \/\/ Galois field instruction based bit reversal.\n+  assert(VM_Version::supports_gfni(), \"\");\n+  mov64(rtmp, 0x8040201008040201L);\n+  movq(xtmp, rtmp);\n+  vpbroadcastq(xtmp, xtmp, vec_enc);\n+  vgf2p8affineqb(dst, 0, src, xtmp, vec_enc);\n+  if (bt != T_BYTE) {\n+    if (VM_Version::supports_avx512bw()) {\n+      vector_reverse_byte_evex(bt, dst, dst, xtmp, xnoreg, noreg, vec_enc);\n+    } else {\n+      assert(vec_enc < Assembler::AVX_512bit, \"\");\n+      vector_reverse_byte_avx(bt, dst, dst, xtmp, vec_enc);\n+    }\n+  }\n+}\n+#endif\n+\n+void C2_MacroAssembler::vector_reverse_byte_avx(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                XMMRegister xtmp, int vec_enc) {\n+  \/\/ Shift based bit reversal.\n+  vmovdqu(xtmp, src);\n+  switch(bt) {\n+    case T_LONG:\n+      vpsrlq(dst, xtmp, 32, vec_enc);\n+      vpsllq(xtmp, xtmp, 32, vec_enc);\n+      vpor(xtmp, dst, xtmp, vec_enc);\n+    case T_INT:\n+      vpsrld(dst, xtmp, 16, vec_enc);\n+      vpslld(xtmp, xtmp, 16, vec_enc);\n+      vpor(xtmp, dst, xtmp, vec_enc);\n+    case T_SHORT:\n+      vpsllw(dst, xtmp, 8, vec_enc);\n+      vpsrlw(xtmp, xtmp, 8, vec_enc);\n+      vpor(dst, dst, xtmp, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type\");\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_reverse_byte_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                 XMMRegister xtmp1, XMMRegister xtmp2, Register rtmp,\n+                                                 int vec_enc) {\n+  if (VM_Version::supports_avx512_vbmi()) {\n+    switch(bt) {\n+      case T_LONG:\n+        evmovdquq(xtmp1, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_long()),\n+                                         vec_enc, rtmp);\n+        break;\n+      case T_INT:\n+        evmovdquq(xtmp1, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_int()),\n+                                         vec_enc, rtmp);\n+        break;\n+      case T_SHORT:\n+        evmovdquq(xtmp1, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_short()),\n+                                        vec_enc, rtmp);\n+        break;\n+      default:\n+        fatal(\"Unsupported type\");\n+        break;\n+    }\n+    vpermb(dst, xtmp1, src, vec_enc);\n+  } else {\n+    \/\/ Shift based bit reversal.\n+    evmovdqul(xtmp1, k0, src, true, vec_enc);\n+    switch(bt) {\n+      case T_LONG:\n+        evprorq(xtmp1, k0, xtmp1, 32, true, vec_enc);\n+      case T_INT:\n+        evprord(xtmp1, k0, xtmp1, 16, true, vec_enc);\n+      case T_SHORT:\n+        if (VM_Version::supports_avx512bw()) {\n+          vpsllw(dst, xtmp1, 8, vec_enc);\n+          vpsrlw(xtmp1, xtmp1, 8, vec_enc);\n+          vporq(dst, dst, xtmp1, vec_enc);\n+        } else {\n+          movl(rtmp, 0x00FF00FF);\n+          evpbroadcastd(dst, rtmp, vec_enc);\n+          vpandq(xtmp2, dst, xtmp1, vec_enc);\n+          vpsllq(xtmp2, xtmp2, 8, vec_enc);\n+          vpternlogd(dst, 0x1, dst, dst, vec_enc);\n+          vpandq(xtmp1, dst, xtmp1, vec_enc);\n+          vpsrlq(dst, xtmp1, 8, vec_enc);\n+          vporq(dst, dst, xtmp2, vec_enc);\n+        }\n+        break;\n+      default:\n+        fatal(\"Unsupported type\");\n+        break;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -325,0 +325,17 @@\n+  void vector_reverse_byte_avx(BasicType bt, XMMRegister dst, XMMRegister src,\n+                               XMMRegister xtmp, int vec_enc);\n+\n+  void vector_reverse_byte_evex(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+#ifdef _LP64\n+  void vector_reverse_bit_gfni(BasicType bt, XMMRegister dst, XMMRegister src,\n+                               XMMRegister xtmp, Register rtmp, int vec_enc);\n+#endif\n+\n+  void vector_reverse_bit_avx(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                              XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc);\n+\n+  void vector_reverse_bit_evex(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                               XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -613,0 +613,68 @@\n+  address generate_vector_reverse_byte_perm_mask_long(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x14151617, relocInfo::none, 0);\n+    __ emit_data(0x10111213, relocInfo::none, 0);\n+    __ emit_data(0x1C1D1E1F, relocInfo::none, 0);\n+    __ emit_data(0x18191A1B, relocInfo::none, 0);\n+    __ emit_data(0x24252627, relocInfo::none, 0);\n+    __ emit_data(0x20212223, relocInfo::none, 0);\n+    __ emit_data(0x2C2D2E2F, relocInfo::none, 0);\n+    __ emit_data(0x28292A2B, relocInfo::none, 0);\n+    __ emit_data(0x34353637, relocInfo::none, 0);\n+    __ emit_data(0x30313233, relocInfo::none, 0);\n+    __ emit_data(0x3C3D3E3F, relocInfo::none, 0);\n+    __ emit_data(0x38393A3B, relocInfo::none, 0);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_int(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x10111213, relocInfo::none, 0);\n+    __ emit_data(0x14151617, relocInfo::none, 0);\n+    __ emit_data(0x18191A1B, relocInfo::none, 0);\n+    __ emit_data(0x1C1D1E1F, relocInfo::none, 0);\n+    __ emit_data(0x20212223, relocInfo::none, 0);\n+    __ emit_data(0x24252627, relocInfo::none, 0);\n+    __ emit_data(0x28292A2B, relocInfo::none, 0);\n+    __ emit_data(0x2C2D2E2F, relocInfo::none, 0);\n+    __ emit_data(0x30313233, relocInfo::none, 0);\n+    __ emit_data(0x34353637, relocInfo::none, 0);\n+    __ emit_data(0x38393A3B, relocInfo::none, 0);\n+    __ emit_data(0x3C3D3E3F, relocInfo::none, 0);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_short(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x02030001, relocInfo::none, 0);\n+    __ emit_data(0x06070405, relocInfo::none, 0);\n+    __ emit_data(0x0A0B0809, relocInfo::none, 0);\n+    __ emit_data(0x0E0F0C0D, relocInfo::none, 0);\n+    __ emit_data(0x12131011, relocInfo::none, 0);\n+    __ emit_data(0x16171415, relocInfo::none, 0);\n+    __ emit_data(0x1A1B1819, relocInfo::none, 0);\n+    __ emit_data(0x1E1F1C1D, relocInfo::none, 0);\n+    __ emit_data(0x22232021, relocInfo::none, 0);\n+    __ emit_data(0x26272425, relocInfo::none, 0);\n+    __ emit_data(0x2A2B2829, relocInfo::none, 0);\n+    __ emit_data(0x2E2F2C2D, relocInfo::none, 0);\n+    __ emit_data(0x32333031, relocInfo::none, 0);\n+    __ emit_data(0x36373435, relocInfo::none, 0);\n+    __ emit_data(0x3A3B3839, relocInfo::none, 0);\n+    __ emit_data(0x3E3F3C3D, relocInfo::none, 0);\n+    return start;\n+  }\n@@ -4006,0 +4074,3 @@\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long(\"perm_mask_long\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int(\"perm_mask_int\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short(\"perm_mask_short\");\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -813,0 +813,45 @@\n+  address generate_vector_reverse_byte_perm_mask_long(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0001020304050607, relocInfo::none);\n+    __ emit_data64(0x08090A0B0C0D0E0F, relocInfo::none);\n+    __ emit_data64(0x1011121314151617, relocInfo::none);\n+    __ emit_data64(0x18191A1B1C1D1E1F, relocInfo::none);\n+    __ emit_data64(0x2021222324252627, relocInfo::none);\n+    __ emit_data64(0x28292A2B2C2D2E2F, relocInfo::none);\n+    __ emit_data64(0x3031323334353637, relocInfo::none);\n+    __ emit_data64(0x38393A3B3C3D3E3F, relocInfo::none);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_int(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0405060700010203, relocInfo::none);\n+    __ emit_data64(0x0C0D0E0F08090A0B, relocInfo::none);\n+    __ emit_data64(0x1415161710111213, relocInfo::none);\n+    __ emit_data64(0x1C1D1E1F18191A1B, relocInfo::none);\n+    __ emit_data64(0x2425262720212223, relocInfo::none);\n+    __ emit_data64(0x2C2D2E2F28292A2B, relocInfo::none);\n+    __ emit_data64(0x3435363730313233, relocInfo::none);\n+    __ emit_data64(0x3C3D3E3F38393A3B, relocInfo::none);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_short(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0607040502030001, relocInfo::none);\n+    __ emit_data64(0x0E0F0C0D0A0B0809, relocInfo::none);\n+    __ emit_data64(0x1617141512131011, relocInfo::none);\n+    __ emit_data64(0x1E1F1C1D1A1B1819, relocInfo::none);\n+    __ emit_data64(0x2627242522232021, relocInfo::none);\n+    __ emit_data64(0x2E2F2C2D2A2B2829, relocInfo::none);\n+    __ emit_data64(0x3637343532333031, relocInfo::none);\n+    __ emit_data64(0x3E3F3C3D3A3B3839, relocInfo::none);\n+    return start;\n+  }\n+\n@@ -7715,0 +7760,3 @@\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long(\"perm_mask_long\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int(\"perm_mask_int\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short(\"perm_mask_short\");\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -62,0 +62,3 @@\n+address StubRoutines::x86::_vector_reverse_byte_perm_mask_long = NULL;\n+address StubRoutines::x86::_vector_reverse_byte_perm_mask_int = NULL;\n+address StubRoutines::x86::_vector_reverse_byte_perm_mask_short = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -180,0 +180,3 @@\n+  static address _vector_reverse_byte_perm_mask_long;\n+  static address _vector_reverse_byte_perm_mask_int;\n+  static address _vector_reverse_byte_perm_mask_short;\n@@ -343,0 +346,11 @@\n+  static address vector_reverse_byte_perm_mask_long() {\n+    return _vector_reverse_byte_perm_mask_long;\n+  }\n+\n+  static address vector_reverse_byte_perm_mask_int() {\n+    return _vector_reverse_byte_perm_mask_int;\n+  }\n+\n+  static address vector_reverse_byte_perm_mask_short() {\n+    return _vector_reverse_byte_perm_mask_short;\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -954,0 +954,1 @@\n+      _features &= ~CPU_GFNI;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -364,1 +364,2 @@\n-    decl(SERIALIZE,         \"serialize\",         47) \/* CPU SERIALIZE *\/\n+    decl(SERIALIZE,         \"serialize\",         47) \/* CPU SERIALIZE *\/ \\\n+    decl(GFNI,              \"gfni\",              48) \/* Vector AES instruction *\/\n@@ -594,0 +595,2 @@\n+        if (_cpuid_info.sef_cpuid7_ecx.bits.gfni != 0)\n+          result |= CPU_GFNI;\n@@ -900,0 +903,1 @@\n+  static bool supports_gfni()         { return (_features & CPU_GFNI) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1892,0 +1892,4 @@\n+    case Op_ReverseV:\n+      if (UseAVX < 2) {\n+        return false;\n+      }\n@@ -8937,0 +8941,50 @@\n+\/\/ -------------------------------- Bit Reversal Vector Operations ------------------------\n+\n+instruct vreverse_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegI rtmp) %{\n+  predicate(!VM_Version::supports_avx512vlbw() && !VM_Version::supports_gfni() && Matcher::vector_length_in_bytes(n) < 64);\n+  match(Set dst (ReverseV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp);\n+  format %{ \"vector_reverse_bit_avx $dst, $src!\\t using $xtmp1, $xtmp2, $xtmp3 and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vec_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_reverse_bit_avx(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                              $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vreverse_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, rRegI rtmp) %{\n+  predicate(((!VM_Version::supports_avx512vlbw() && Matcher::vector_length_in_bytes(n) == 64) ||\n+            (VM_Version::supports_avx512bw())) && !VM_Version::supports_gfni());\n+  match(Set dst (ReverseV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp);\n+  format %{ \"vector_reverse_bit_evex $dst, $src!\\t using $xtmp1, $xtmp2 and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vec_enc = vector_length_encoding(this);\n+    BasicType bt  = Matcher::vector_element_basic_type(this);\n+    __ vector_reverse_bit_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                               $xtmp2$$XMMRegister, $rtmp$$Register, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n+#ifdef _LP64\n+instruct vreverse_reg_gfni(vec dst, vec src, vec xtmp, rRegL rtmp) %{\n+  predicate(VM_Version::supports_gfni() &&\n+            ((!VM_Version::supports_avx512vlbw() && Matcher::vector_length_in_bytes(n) < 64) ||\n+              VM_Version::supports_avx512vlbw()));\n+  match(Set dst (ReverseV src));\n+  effect(TEMP dst, TEMP xtmp, TEMP rtmp);\n+  format %{ \"vector_reverse_bit_gfni $dst, $src!\\t using $xtmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vec_enc = vector_length_encoding(this);\n+    BasicType bt  = Matcher::vector_element_basic_type(this);\n+    __ vector_reverse_bit_gfni(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister,\n+                               $rtmp$$Register, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -4231,1 +4231,1 @@\n-    \"ReplicateB\",\"ReplicateS\",\"ReplicateI\",\"ReplicateL\",\"ReplicateF\",\"ReplicateD\",\n+    \"ReplicateB\",\"ReplicateS\",\"ReplicateI\",\"ReplicateL\",\"ReplicateF\",\"ReplicateD\", \"ReverseV\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,0 +285,1 @@\n+macro(ReverseV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3406,0 +3406,21 @@\n+  case Op_ReverseV: {\n+    if (n->in(1)->Opcode() == Op_ReverseV) {\n+      if (n->is_predicated_vector() && n->in(1)->is_predicated_vector() &&\n+          n->in(2) == n->in(1)->in(2)) {\n+        n->subsume_by(n->in(1)->in(1), this);\n+      } else {\n+        bool is_user_blend = false;\n+        for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+          if (n->fast_out(i)->Opcode() == Op_VectorBlend) {\n+            is_user_blend = true;\n+            break;\n+          }\n+        }\n+        if (!is_user_blend) {\n+          n->subsume_by(n->in(1)->in(1), this);\n+        }\n+      }\n+    }\n+    break;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -971,0 +971,1 @@\n+      case Op_ReverseV: body_size += 50; break;\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -160,2 +160,0 @@\n-    \/\/ Not implemented. Returning 0 temporarily\n-    return 0;\n@@ -163,2 +161,7 @@\n-    \/\/ Not implemented. Returning 0 temporarily\n-    return 0;\n+    switch (bt) {\n+    case T_BYTE:\n+    case T_SHORT:\n+    case T_INT:\n+    case T_LONG:   return Op_ReverseV;\n+    default:       return 0;\n+    }\n@@ -548,0 +551,2 @@\n+  case Op_ReverseV: return new ReverseVNode(n1, vt);\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1672,0 +1672,8 @@\n+\n+class ReverseVNode : public VectorNode {\n+public:\n+  ReverseVNode(Node* in, const TypeVect* vt)\n+  : VectorNode(in, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -224,0 +224,1 @@\n+        GFNI,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.amd64\/src\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}