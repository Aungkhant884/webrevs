{"files":[{"patch":"@@ -9967,1 +9967,1 @@\n-void Assembler::vgf2p8affineqb(XMMRegister dst, int imm8, XMMRegister src2, XMMRegister src3, int vector_len) {\n+void Assembler::vgf2p8affineqb(XMMRegister dst, XMMRegister src2, XMMRegister src3, int imm8, int vector_len) {\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2743,1 +2743,1 @@\n-  void vgf2p8affineqb(XMMRegister dst, int imm8, XMMRegister src2, XMMRegister src3, int vector_len);\n+  void vgf2p8affineqb(XMMRegister dst, XMMRegister src2, XMMRegister src3, int imm8, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4533,0 +4533,6 @@\n+\/\/ Bit reversal algorithm first reverses the bits of each byte followed by\n+\/\/ a byte level reversal for multi-byte primitive types (short\/int\/long).\n+\/\/ Algorithm performs a lookup table access to get reverse bit sequence\n+\/\/ corresponding to a 4 bit value. Thus a reverse bit sequence for a byte\n+\/\/ is obtained by swapping the reverse bit sequences of upper and lower\n+\/\/ nibble of a byte.\n@@ -4536,0 +4542,2 @@\n+\n+    \/\/ Get the reverse bit sequence of lower nibble of each byte.\n@@ -4539,1 +4547,0 @@\n-\n@@ -4544,0 +4551,1 @@\n+    \/\/ Get the reverse bit sequence of upper nibble of each byte.\n@@ -4549,0 +4557,2 @@\n+    \/\/ Perform logical OR operation b\/w left shifted reverse bit sequence of lower nibble and\n+    \/\/ right shifted reverse bit sequence of upper nibble to obtain the reverse bit sequence of each byte.\n@@ -4554,1 +4564,0 @@\n-    assert(bt == T_LONG || bt == T_INT, \"\");\n@@ -4556,0 +4565,1 @@\n+    assert(bt == T_LONG || bt == T_INT, \"\");\n@@ -4560,0 +4570,1 @@\n+    \/\/ Swap lower and upper nibble of each byte.\n@@ -4566,0 +4577,1 @@\n+    \/\/ Swap two least and most significant bits of each nibble.\n@@ -4569,1 +4581,0 @@\n-\n@@ -4576,0 +4587,1 @@\n+    \/\/ Swap adjacent pair of bits.\n@@ -4579,1 +4591,0 @@\n-\n@@ -4585,0 +4596,1 @@\n+\n@@ -4593,0 +4605,1 @@\n+    \/\/ Get the reverse bit sequence of lower nibble of each byte.\n@@ -4597,0 +4610,1 @@\n+    \/\/ Get the reverse bit sequence of upper nibble of each byte.\n@@ -4603,0 +4617,2 @@\n+    \/\/ Perform logical OR operation b\/w left shifted reverse bit sequence of lower nibble and\n+    \/\/ right shifted reverse bit sequence of upper nibble to obtain the reverse bit sequence of each byte.\n@@ -4611,0 +4627,2 @@\n+  \/\/ Please refer to following link for details on the algorithm.\n+  \/\/ http:\/\/0x80.pl\/articles\/avx512-galois-field-for-bit-shuffling.html\n@@ -4613,1 +4631,1 @@\n-  vgf2p8affineqb(xtmp, 0, src, xtmp, vec_enc);\n+  vgf2p8affineqb(xtmp, src, xtmp, 0, vec_enc);\n@@ -4624,0 +4642,1 @@\n+      \/\/ Swap upper and lower double word of each quad word.\n@@ -4626,0 +4645,1 @@\n+      \/\/ Swap upper and lower word of each double word.\n@@ -4628,0 +4648,1 @@\n+      \/\/ Swap upper and lower byte of each word.\n@@ -4632,0 +4653,2 @@\n+      \/\/ Flip the bits of mask by performing a logical NOT operation\n+      \/\/ implemented using ternary operation.\n@@ -4655,0 +4678,2 @@\n+  \/\/ Perform byte reversal by shuffling the bytes of a multi-byte primitive type using\n+  \/\/ pre-computed shuffle indices.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-    decl(GFNI,              \"gfni\",              48) \/* Vector AES instruction *\/\n+    decl(GFNI,              \"gfni\",              48) \/* Vector GFNI instructions *\/\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,7 +161,1 @@\n-    switch (bt) {\n-    case T_BYTE:\n-    case T_SHORT:\n-    case T_INT:\n-    case T_LONG:   return Op_ReverseV;\n-    default:       return 0;\n-    }\n+    return (is_integral_type(bt) ? Op_ReverseV : 0);\n@@ -171,7 +165,1 @@\n-    switch (bt) {\n-    case T_BYTE:\n-    case T_SHORT:\n-    case T_INT:\n-    case T_LONG:   return Op_ReverseBytesV;\n-    default:       return 0;\n-    }\n+    return (is_integral_type(bt) ? Op_ReverseBytesV : 0);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"}]}