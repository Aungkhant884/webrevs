{"files":[{"patch":"@@ -116,0 +116,12 @@\n+  static inline uint vector_length_in_bytes(const Node* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n+  static inline uint vector_length_in_bytes(const MachNode* use, MachOper* opnd) {\n+    uint def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n@@ -235,1 +247,0 @@\n-      case Op_VectorReinterpret:\n@@ -343,0 +354,56 @@\n+\/\/ vector reinterpret\n+\n+instruct reinterpret(vReg dst) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() ==\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \" # reinterpret $dst\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct reinterpretExpand(vReg dst, vReg src, iRegINoSp tmp, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() >\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src < dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP pTmp, TEMP tmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \" # reinterpretExpand $dst,$src\\t\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ mov(as_Register($tmp$$reg), vector_length_in_bytes(this, $src));\n+      __ sve_whilelo(as_PRegister($pTmp$$reg), __ B,\n+                     zr, as_Register($tmp$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretShrink(vReg dst, vReg src, iRegINoSp tmp, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() <\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src > dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP pTmp, TEMP tmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \" # reinterpretShrink $dst,$src\\t\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ mov(as_Register($tmp$$reg), vector_length_in_bytes(this));\n+      __ sve_whilelo(as_PRegister($pTmp$$reg), __ B,\n+                     zr, as_Register($tmp$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -32,0 +32,9 @@\n+dnl\n+define(`TYPE2DATATYPE',\n+`ifelse($1, `B', `BYTE',\n+        $1, `S', `SHORT',\n+        $1, `I', `INT',\n+        $1, `L', `LONG',\n+        $1, `F', `FLOAT',\n+        $1, `D', `DOUBLE',\n+        `error($1)')')dnl\n@@ -103,0 +112,12 @@\n+  static inline uint vector_length_in_bytes(const Node* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n+  static inline uint vector_length_in_bytes(const MachNode* use, MachOper* opnd) {\n+    uint def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n@@ -222,1 +243,0 @@\n-      case Op_VectorReinterpret:\n@@ -338,0 +358,58 @@\n+\/\/ vector reinterpret\n+dnl\n+define(`REINTERPRET', `\n+instruct reinterpret`'(vReg dst) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= $1 &&\n+            n->as_Vector()->length_in_bytes() ==\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \" # reinterpret $dst\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}')dnl\n+REINTERPRET(16)\n+\n+instruct reinterpretExpand(vReg dst, vReg src, iRegINoSp tmp, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() >\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src < dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP pTmp, TEMP tmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \" # reinterpretExpand $dst,$src\\t\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ mov(as_Register($tmp$$reg), vector_length_in_bytes(this, $src));\n+      __ sve_whilelo(as_PRegister($pTmp$$reg), __ B,\n+                     zr, as_Register($tmp$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretShrink(vReg dst, vReg src, iRegINoSp tmp, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() <\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src > dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP pTmp, TEMP tmp, KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \" # reinterpretShrink $dst,$src\\t\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ mov(as_Register($tmp$$reg), vector_length_in_bytes(this));\n+      __ sve_whilelo(as_PRegister($pTmp$$reg), __ B,\n+                     zr, as_Register($tmp$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":79,"deletions":1,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1836,1 +1836,1 @@\n-      int num_elem_for_resize = MAX2(num_elem_to, Matcher::min_vector_size(elem_bt_to));\n+      int num_elem_for_resize = MAX2(num_elem_to, Matcher::min_vector_size(elem_bt_from));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}