{"files":[{"patch":"@@ -116,1 +116,1 @@\n-  static inline uint vector_length_in_bytes(const Node* n) {\n+  static inline uint vector_length_in_bytes(const MachNode* n) {\n@@ -354,0 +354,1 @@\n+\n@@ -369,1 +370,1 @@\n-instruct reinterpretExpand(vReg dst, vReg src, iRegINoSp tmp, pRegGov pTmp, rFlagsReg cr) %{\n+instruct reinterpretResize(vReg dst, vReg src, iRegINoSp tmp, pRegGov pTmp, rFlagsReg cr) %{\n@@ -371,23 +372,3 @@\n-            n->as_Vector()->length_in_bytes() >\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src < dst\n-  match(Set dst (VectorReinterpret src));\n-  effect(TEMP pTmp, TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \" # reinterpretExpand $dst,$src\\t\" %}\n-  ins_encode %{\n-    \/\/ If register is the same, then move is not needed.\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ mov(as_Register($tmp$$reg), vector_length_in_bytes(this, $src));\n-      __ sve_whilelo(as_PRegister($pTmp$$reg), __ B,\n-                     zr, as_Register($tmp$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n-                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretShrink(vReg dst, vReg src, iRegINoSp tmp, pRegGov pTmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n-            n->as_Vector()->length_in_bytes() <\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src > dst\n+            n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() !=\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src != dst\n@@ -395,3 +376,3 @@\n-  effect(TEMP pTmp, TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \" # reinterpretShrink $dst,$src\\t\" %}\n+  effect(TEMP_DEF dst, TEMP pTmp, TEMP tmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \" # reinterpretResize $dst,$src\\t\" %}\n@@ -399,8 +380,10 @@\n-    \/\/ If register is the same, then move is not needed.\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ mov(as_Register($tmp$$reg), vector_length_in_bytes(this));\n-      __ sve_whilelo(as_PRegister($pTmp$$reg), __ B,\n-                     zr, as_Register($tmp$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n-                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n-    }\n+    uint length_in_bytes_src = vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = vector_length_in_bytes(this);\n+    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n+                            length_in_bytes_src : length_in_bytes_dst;\n+    __ mov(as_Register($tmp$$reg), length_in_bytes_resize);\n+    __ sve_whilelo(as_PRegister($pTmp$$reg), __ B,\n+                   zr, as_Register($tmp$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ B, ptrue, 0, false);\n+    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pTmp$$reg),\n+               as_FloatRegister($src$$reg), as_FloatRegister($dst$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":19,"deletions":36,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  static inline uint vector_length_in_bytes(const Node* n) {\n+  static inline uint vector_length_in_bytes(const MachNode* n) {\n@@ -358,0 +358,1 @@\n+\n@@ -375,1 +376,1 @@\n-instruct reinterpretExpand(vReg dst, vReg src, iRegINoSp tmp, pRegGov pTmp, rFlagsReg cr) %{\n+instruct reinterpretResize(vReg dst, vReg src, iRegINoSp tmp, pRegGov pTmp, rFlagsReg cr) %{\n@@ -377,2 +378,3 @@\n-            n->as_Vector()->length_in_bytes() >\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src < dst\n+            n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() !=\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src != dst\n@@ -380,3 +382,3 @@\n-  effect(TEMP pTmp, TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \" # reinterpretExpand $dst,$src\\t\" %}\n+  effect(TEMP_DEF dst, TEMP pTmp, TEMP tmp, KILL cr);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \" # reinterpretResize $dst,$src\\t\" %}\n@@ -384,29 +386,10 @@\n-    \/\/ If register is the same, then move is not needed.\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ mov(as_Register($tmp$$reg), vector_length_in_bytes(this, $src));\n-      __ sve_whilelo(as_PRegister($pTmp$$reg), __ B,\n-                     zr, as_Register($tmp$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n-                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reinterpretShrink(vReg dst, vReg src, iRegINoSp tmp, pRegGov pTmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n-            n->as_Vector()->length_in_bytes() <\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src > dst\n-  match(Set dst (VectorReinterpret src));\n-  effect(TEMP pTmp, TEMP tmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \" # reinterpretShrink $dst,$src\\t\" %}\n-  ins_encode %{\n-    \/\/ If register is the same, then move is not needed.\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ mov(as_Register($tmp$$reg), vector_length_in_bytes(this));\n-      __ sve_whilelo(as_PRegister($pTmp$$reg), __ B,\n-                     zr, as_Register($tmp$$reg));\n-      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n-                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n-    }\n+    uint length_in_bytes_src = vector_length_in_bytes(this, $src);\n+    uint length_in_bytes_dst = vector_length_in_bytes(this);\n+    uint length_in_bytes_resize = length_in_bytes_src < length_in_bytes_dst ?\n+                            length_in_bytes_src : length_in_bytes_dst;\n+    __ mov(as_Register($tmp$$reg), length_in_bytes_resize);\n+    __ sve_whilelo(as_PRegister($pTmp$$reg), __ B,\n+                   zr, as_Register($tmp$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ B, ptrue, 0, false);\n+    __ sve_sel(as_FloatRegister($dst$$reg), __ B, as_PRegister($pTmp$$reg),\n+               as_FloatRegister($src$$reg), as_FloatRegister($dst$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":19,"deletions":36,"binary":false,"changes":55,"status":"modified"}]}