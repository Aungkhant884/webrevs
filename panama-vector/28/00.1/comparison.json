{"files":[{"patch":"@@ -433,9 +433,16 @@\n-\t  $$(call ExecuteWithLog, $$@, $$(call MakeCommandRelative, \\\n-\t      $$($1_COMPILER) -showIncludes $$($1_COMPILE_OPTIONS))) \\\n-\t      | $(TR) -d '\\r' | $(GREP) -v -e \"^Note: including file:\" \\\n-\t          -e \"^$$($1_FILENAME)$$$$\" || test \"$$$$?\" = \"1\" ; \\\n-\t  $(ECHO) $$@: \\\\ > $$($1_DEPS_FILE) ; \\\n-\t  $(SED) $(WINDOWS_SHOWINCLUDE_SED_PATTERN) $$($1_OBJ).log \\\n-\t      | $(SORT) -u >> $$($1_DEPS_FILE) ; \\\n-\t  $(ECHO) >> $$($1_DEPS_FILE) ; \\\n-\t  $(SED) $(DEPENDENCY_TARGET_SED_PATTERN) $$($1_DEPS_FILE) > $$($1_DEPS_TARGETS_FILE)\n+          ifeq ($$(filter %.s, $$($1_FILENAME)), )\n+\t    $$(call ExecuteWithLog, $$@, $$(call MakeCommandRelative, \\\n+\t        $$($1_COMPILER) -showIncludes $$($1_COMPILE_OPTIONS))) \\\n+\t        | $(TR) -d '\\r' | $(GREP) -v -e \"^Note: including file:\" \\\n+\t            -e \"^$$($1_FILENAME)$$$$\" || test \"$$$$?\" = \"1\" ; \\\n+\t    $(ECHO) $$@: \\\\ > $$($1_DEPS_FILE) ; \\\n+\t    $(SED) $(WINDOWS_SHOWINCLUDE_SED_PATTERN) $$($1_OBJ).log \\\n+\t        | $(SORT) -u >> $$($1_DEPS_FILE) ; \\\n+\t    $(ECHO) >> $$($1_DEPS_FILE) ; \\\n+\t    $(SED) $(DEPENDENCY_TARGET_SED_PATTERN) $$($1_DEPS_FILE) > $$($1_DEPS_TARGETS_FILE)\n+          else\n+            # For assembler calls, no need to build dependency list.\n+\t    $$(call ExecuteWithLog, $$@, $$(call MakeCommandRelative, \\\n+\t        $$($1_COMPILER) $$($1_FLAGS) \\\n+\t          $(CC_OUT_OPTION)$$($1_OBJ) \/Ta $$($1_SRC_FILE)))\n+          endif\n","filename":"make\/common\/NativeCompilation.gmk","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2440,0 +2440,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n@@ -2484,0 +2498,4 @@\n+    if (bt == T_BOOLEAN) {\n+      \/\/ To support vector api load\/store mask.\n+      return MaxVectorSize \/ 8;\n+    }\n@@ -2511,1 +2529,1 @@\n-  if (UseSVE > 0 && 16 <= len && len <= 256) {\n+  if (UseSVE > 0 && 2 <= len && len <= 256) {\n@@ -16582,1 +16600,1 @@\n-  predicate(n->as_LoadVector()->memory_size() == 4);\n+  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 4);\n@@ -16593,1 +16611,1 @@\n-  predicate(n->as_LoadVector()->memory_size() == 8);\n+  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 8);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -855,0 +855,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -365,0 +365,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -927,0 +927,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1553,0 +1553,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -861,0 +861,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1031,0 +1031,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1136,0 +1136,25 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(num_bits == 64 || num_bits == 128 || num_bits == 256 || num_bits == 512,\n+         \"only certain vector sizes are supported for now\");\n+\n+  static const XMMRegister VEC_ArgReg[32] = {\n+     xmm0,  xmm1,  xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,\n+     xmm8,  xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,\n+    xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,\n+    xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31\n+  };\n+\n+  uint stk_args = 0;\n+  uint fp_args = 0;\n+\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[fp_args++]->as_VMReg();\n+    int next_val = num_bits == 64 ? 1 : (num_bits == 128 ? 3 : (num_bits  == 256 ? 7 : 15));\n+    regs[i].set_pair(vmreg->next(next_val), vmreg);\n+  }\n+\n+  return stk_args;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -716,0 +716,3 @@\n+  product(bool, IncrementalInlineVirtual, true, DIAGNOSTIC,                 \\\n+          \"do post parse inlining of virtual calls\")                        \\\n+                                                                            \\\n@@ -759,0 +762,3 @@\n+  product(bool, UseVectorStubs, false, EXPERIMENTAL,                        \\\n+          \"Use stubs for vector transcendental operations\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -124,0 +124,3 @@\n+protected:\n+  void set_call_node(CallStaticJavaNode* call) { _call_node = call; }\n+\n@@ -132,1 +135,8 @@\n-  CallStaticJavaNode* call_node() const { return _call_node; }\n+  virtual bool is_direct() const { return true; }\n+\n+  virtual CallNode* call_node() const { return _call_node; }\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    DirectCallGenerator* dcg = new DirectCallGenerator(method(), _separate_io_proj);\n+    dcg->set_call_node(call->as_CallStaticJava());\n+    return dcg;\n+  }\n@@ -182,0 +192,6 @@\n+  bool _separate_io_proj;\n+  CallDynamicJavaNode* _call_node;\n+\n+protected:\n+  void set_call_node(CallDynamicJavaNode* call) { _call_node = call; }\n+\n@@ -183,2 +199,2 @@\n-  VirtualCallGenerator(ciMethod* method, int vtable_index)\n-    : CallGenerator(method), _vtable_index(vtable_index)\n+  VirtualCallGenerator(ciMethod* method, int vtable_index, bool separate_io_proj)\n+    : CallGenerator(method), _vtable_index(vtable_index), _separate_io_proj(separate_io_proj), _call_node(NULL)\n@@ -191,0 +207,9 @@\n+\n+  virtual CallNode* call_node() const { return _call_node; }\n+  int vtable_index() const { return _vtable_index; }\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    VirtualCallGenerator* cg = new VirtualCallGenerator(method(), _vtable_index, _separate_io_proj);\n+    cg->set_call_node(call->as_CallDynamicJava());\n+    return cg;\n+  }\n@@ -253,0 +278,2 @@\n+  _call_node = call;  \/\/ Save the call node in case we need it later\n+\n@@ -254,2 +281,2 @@\n-  kit.set_edges_for_java_call(call);\n-  Node* ret = kit.set_results_for_java_call(call);\n+  kit.set_edges_for_java_call(call, false \/*must_throw*\/, _separate_io_proj);\n+  Node* ret = kit.set_results_for_java_call(call, _separate_io_proj);\n@@ -288,1 +315,1 @@\n-  return new VirtualCallGenerator(m, vtable_index);\n+  return new VirtualCallGenerator(m, vtable_index, false \/*separate_io_projs*\/);\n@@ -344,0 +371,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineCallGenerator* cg = new LateInlineCallGenerator(method(), _inline_cg, _is_pure_call);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -348,1 +381,1 @@\n-  CallStaticJavaNode* call = call_node();\n+  CallStaticJavaNode* call = call_node()->as_CallStaticJava();\n@@ -505,0 +538,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineMHCallGenerator* cg = new LateInlineMHCallGenerator(_caller, method(), _input_not_const);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -534,0 +573,230 @@\n+\/\/ Allow inlining decisions to be delayed\n+class LateInlineVirtualCallGenerator : public VirtualCallGenerator {\n+ private:\n+  jlong _unique_id;   \/\/ unique id for log compilation\n+  CallGenerator* _inline_cg;\n+  ciMethod* _callee;\n+  bool _is_pure_call;\n+  float _prof_factor;\n+ protected:\n+  virtual bool do_late_inline_check(Compile* C, JVMState* jvms);\n+\n+ public:\n+  LateInlineVirtualCallGenerator(ciMethod* method, int vtable_index, float prof_factor)\n+  : VirtualCallGenerator(method, vtable_index, true \/*separate_io_projs*\/), _unique_id(0), _inline_cg(NULL), _callee(NULL), _is_pure_call(false), _prof_factor(prof_factor) {}\n+\n+  virtual bool is_virtual_late_inline() const { return true; }\n+\n+  \/\/ Convert the CallDynamicJava into an inline\n+  virtual void do_late_inline();\n+\n+  virtual void set_callee_method(ciMethod* m) {\n+    assert(_callee == NULL, \"repeated inlining attempt\");\n+    _callee = m;\n+  }\n+\n+  virtual JVMState* generate(JVMState* jvms) {\n+    Compile* C = Compile::current();\n+\n+    \/\/ Emit the CallDynamicJava and request separate projections so\n+    \/\/ that the late inlining logic can distinguish between fall\n+    \/\/ through and exceptional uses of the memory and io projections\n+    \/\/ as is done for allocations and macro expansion.\n+    JVMState* new_jvms = VirtualCallGenerator::generate(jvms);\n+    if (call_node() != NULL) {\n+      call_node()->set_generator(this);\n+    }\n+    return new_jvms;\n+  }\n+\n+  virtual void print_inlining_late(const char* msg) {\n+    CallNode* call = call_node();\n+    Compile* C = Compile::current();\n+    C->print_inlining_assert_ready();\n+    C->print_inlining(method(), call->jvms()->depth()-1, call->jvms()->bci(), msg);\n+    C->print_inlining_move_to(this);\n+    C->print_inlining_update_delayed(this);\n+  }\n+\n+  virtual void set_unique_id(jlong id) {\n+    _unique_id = id;\n+  }\n+\n+  virtual jlong unique_id() const {\n+    return _unique_id;\n+  }\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineVirtualCallGenerator* cg = new LateInlineVirtualCallGenerator(method(), vtable_index(), _prof_factor);\n+    cg->set_call_node(call->as_CallDynamicJava());\n+    return cg;\n+  }\n+};\n+\n+bool LateInlineVirtualCallGenerator::do_late_inline_check(Compile* C, JVMState* jvms) {\n+  \/\/ Method handle linker case is handled in CallDynamicJavaNode::Ideal().\n+  \/\/ Unless inlining is performed, _override_symbolic_info bit will be set in DirectCallGenerator::generate().\n+\n+  bool allow_inline = C->inlining_incrementally();\n+  CallGenerator* cg = C->call_generator(_callee,\n+                                        vtable_index(),\n+                                        false \/*call_does_dispatch*\/,\n+                                        jvms,\n+                                        allow_inline,\n+                                        _prof_factor,\n+                                        NULL \/*speculative_receiver_type*\/,\n+                                        true \/*allow_intrinsics*\/);\n+\n+  Compile::current()->print_inlining_update_delayed(this);\n+\n+  if (cg != NULL) {\n+    assert(!cg->is_late_inline() || cg->is_mh_late_inline() || AlwaysIncrementalInline, \"we're doing late inlining\");\n+    _inline_cg = cg;\n+    return true;\n+  }\n+  call_node()->set_generator(this);\n+  return false;\n+}\n+\n+void LateInlineVirtualCallGenerator::do_late_inline() {\n+  assert(_callee != NULL, \"required\");\n+\n+  \/\/ Can't inline it\n+  CallDynamicJavaNode* call = call_node()->as_CallDynamicJava();\n+  if (call == NULL || call->outcnt() == 0 ||\n+      call->in(0) == NULL || call->in(0)->is_top()) {\n+    return;\n+  }\n+\n+  const TypeTuple *r = call->tf()->domain();\n+  for (int i1 = 0; i1 < method()->arg_size(); i1++) {\n+    if (call->in(TypeFunc::Parms + i1)->is_top() && r->field_at(TypeFunc::Parms + i1) != Type::HALF) {\n+      assert(Compile::current()->inlining_incrementally(), \"shouldn't happen during parsing\");\n+      return;\n+    }\n+  }\n+\n+  if (call->in(TypeFunc::Memory)->is_top()) {\n+    assert(Compile::current()->inlining_incrementally(), \"shouldn't happen during parsing\");\n+    return;\n+  }\n+\n+  \/\/ check for unreachable loop\n+  CallProjections callprojs;\n+  call->extract_projections(&callprojs, true);\n+  if ((callprojs.fallthrough_catchproj == call->in(0)) ||\n+      (callprojs.catchall_catchproj    == call->in(0)) ||\n+      (callprojs.fallthrough_memproj   == call->in(TypeFunc::Memory)) ||\n+      (callprojs.catchall_memproj      == call->in(TypeFunc::Memory)) ||\n+      (callprojs.fallthrough_ioproj    == call->in(TypeFunc::I_O)) ||\n+      (callprojs.catchall_ioproj       == call->in(TypeFunc::I_O)) ||\n+      (callprojs.resproj != NULL && call->find_edge(callprojs.resproj) != -1) ||\n+      (callprojs.exobj   != NULL && call->find_edge(callprojs.exobj) != -1)) {\n+    return;\n+  }\n+\n+  Compile* C = Compile::current();\n+  \/\/ Remove inlined methods from Compiler's lists.\n+  if (call->is_macro()) {\n+    C->remove_macro_node(call);\n+  }\n+\n+  bool result_not_used = (callprojs.resproj == NULL || callprojs.resproj->outcnt() == 0);\n+  if (_is_pure_call && result_not_used) {\n+    \/\/ The call is marked as pure (no important side effects), but result isn't used.\n+    \/\/ It's safe to remove the call.\n+    GraphKit kit(call->jvms());\n+    kit.replace_call(call, C->top(), true);\n+  } else {\n+    \/\/ Make a clone of the JVMState that appropriate to use for driving a parse\n+    JVMState* old_jvms = call->jvms();\n+    JVMState* jvms = old_jvms->clone_shallow(C);\n+    uint size = call->req();\n+    SafePointNode* map = new SafePointNode(size, jvms);\n+    for (uint i1 = 0; i1 < size; i1++) {\n+      map->init_req(i1, call->in(i1));\n+    }\n+\n+    \/\/ Make sure the state is a MergeMem for parsing.\n+    if (!map->in(TypeFunc::Memory)->is_MergeMem()) {\n+      Node* mem = MergeMemNode::make(map->in(TypeFunc::Memory));\n+      C->initial_gvn()->set_type_bottom(mem);\n+      map->set_req(TypeFunc::Memory, mem);\n+    }\n+\n+    uint nargs = method()->arg_size();\n+    \/\/ blow away old call arguments\n+    Node* top = C->top();\n+    for (uint i1 = 0; i1 < nargs; i1++) {\n+      map->set_req(TypeFunc::Parms + i1, top);\n+    }\n+    jvms->set_map(map);\n+\n+    \/\/ Make enough space in the expression stack to transfer\n+    \/\/ the incoming arguments and return value.\n+    map->ensure_stack(jvms, jvms->method()->max_stack());\n+    for (uint i1 = 0; i1 < nargs; i1++) {\n+      map->set_argument(jvms, i1, call->in(TypeFunc::Parms + i1));\n+    }\n+\n+    C->print_inlining_assert_ready();\n+\n+    C->print_inlining_move_to(this);\n+\n+    C->log_late_inline(this);\n+\n+    \/\/ This check is done here because for_method_handle_inline() method\n+    \/\/ needs jvms for inlined state.\n+    if (!do_late_inline_check(C, jvms)) {\n+      map->disconnect_inputs(C);\n+      return;\n+    }\n+\n+    \/\/ Setup default node notes to be picked up by the inlining\n+    Node_Notes* old_nn = C->node_notes_at(call->_idx);\n+    if (old_nn != NULL) {\n+      Node_Notes* entry_nn = old_nn->clone(C);\n+      entry_nn->set_jvms(jvms);\n+      C->set_default_node_notes(entry_nn);\n+    }\n+\n+    { \/\/ Virtual call sometimes involves implicit null check.\n+      GraphKit kit(jvms);\n+      kit.null_check_receiver();\n+      jvms = kit.transfer_exceptions_into_jvms();\n+    }\n+\n+    \/\/ Now perform the inlining using the synthesized JVMState\n+    JVMState* new_jvms = _inline_cg->generate(jvms);\n+    if (new_jvms == NULL)  return;  \/\/ no change\n+    if (C->failing())      return;\n+\n+    \/\/ Capture any exceptional control flow\n+    GraphKit kit(new_jvms);\n+\n+    \/\/ Find the result object\n+    Node* result = C->top();\n+    int   result_size = method()->return_type()->size();\n+    if (result_size != 0 && !kit.stopped()) {\n+      result = (result_size == 1) ? kit.pop() : kit.pop_pair();\n+    }\n+\n+    if (_inline_cg->is_inline()) {\n+      \/\/ TODO: is_inline() == true for intrinsics as well\n+      C->set_has_loops(C->has_loops() || _inline_cg->method()->has_loops());\n+      C->env()->notice_inlined_method(_inline_cg->method());\n+    } else {\n+      assert(_inline_cg->is_direct(), \"sanity\");\n+    }\n+    C->set_inlining_progress(true);\n+    C->set_do_cleanup(kit.stopped()); \/\/ path is dead; needs cleanup\n+    kit.replace_call(call, result, true);\n+  }\n+}\n+\n+CallGenerator* CallGenerator::for_late_inline_virtual(ciMethod* m, int vtable_index, float prof_factor) {\n+  assert(!m->is_static(), \"for_virtual_call mismatch\");\n+  assert(!m->is_method_handle_intrinsic(), \"should be a direct call\");\n+  return new LateInlineVirtualCallGenerator(m, vtable_index, prof_factor);\n+}\n+\n@@ -552,0 +821,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineStringCallGenerator* cg = new LateInlineStringCallGenerator(method(), _inline_cg);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -574,0 +849,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineBoxingCallGenerator* cg = new LateInlineBoxingCallGenerator(method(), _inline_cg);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -596,0 +877,6 @@\n+\n+  virtual CallGenerator* with_call_node(CallNode* call) {\n+    LateInlineVectorReboxingCallGenerator* cg = new LateInlineVectorReboxingCallGenerator(method(), _inline_cg);\n+    cg->set_call_node(call->as_CallStaticJava());\n+    return cg;\n+  }\n@@ -1063,1 +1350,1 @@\n-  virtual bool      is_inlined()   const    { return true; }\n+  virtual bool      is_inline()    const    { return true; }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":295,"deletions":8,"binary":false,"changes":303,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+macro(CallLeafVector)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -353,0 +353,17 @@\n+void Compile::remove_useless_late_inlines(GrowableArray<CallGenerator*>* inlines, Node* dead) {\n+  assert(dead != NULL && dead->is_Call(), \"sanity\");\n+  int shift = 0;\n+  for (int i = 0; i < inlines->length(); i++) {\n+    CallGenerator* cg = inlines->at(i);\n+    CallNode* call = cg->call_node();\n+    if (shift > 0) {\n+      inlines->at_put(i - shift, cg);\n+    }\n+    if (call == dead) {\n+      shift++;\n+    }\n+  }\n+  inlines->trunc_to(inlines->length() - shift);\n+  assert(shift <= 1, \"sanity\");\n+}\n+\n@@ -1863,0 +1880,1 @@\n+\n@@ -1865,2 +1883,2 @@\n-  int i = 0;\n-  for (; i <_late_inlines.length() && !inlining_progress(); i++) {\n+\n+  for (int i = 0; i < _late_inlines.length(); i++) {\n@@ -1869,0 +1887,1 @@\n+    assert(inlining_incrementally() || cg->is_virtual_late_inline(), \"no inlining allowed\");\n@@ -1870,5 +1889,8 @@\n-    if (failing())  return false;\n-  }\n-  int j = 0;\n-  for (; i < _late_inlines.length(); i++, j++) {\n-    _late_inlines.at_put(j, _late_inlines.at(i));\n+    assert(_late_inlines.at(i) == cg, \"no insertions before current position allowed\");\n+    if (failing()) {\n+      return false;\n+    } else if (inlining_progress()) {\n+      _late_inlines_pos = i+1; \/\/ restore the position in case new elements were inserted\n+      print_method(PHASE_INCREMENTAL_INLINE_STEP, cg->call_node(), 3);\n+      break; \/\/ process one call site at a time\n+    }\n@@ -1876,2 +1898,5 @@\n-  _late_inlines.trunc_to(j);\n-  assert(inlining_progress() || _late_inlines.length() == 0, \"\");\n+  \/\/ Remove processed elements.\n+  _late_inlines.truncate_to(_late_inlines_pos);\n+  _late_inlines_pos = 0;\n+\n+  assert(inlining_progress() || _late_inlines.length() == 0, \"no progress\");\n@@ -1899,0 +1924,1 @@\n+  print_method(PHASE_INCREMENTAL_INLINE_CLEANUP, 3);\n@@ -1940,0 +1966,4 @@\n+\n+    if (_late_inlines.length() == 0) {\n+      break; \/\/ no more progress\n+    }\n@@ -2086,1 +2116,2 @@\n-    for_igvn()->clear();\n+    Unique_Node_List* old_worklist = for_igvn();\n+    old_worklist->clear();\n@@ -2096,1 +2127,1 @@\n-    set_for_igvn(save_for_igvn);\n+    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n@@ -2238,0 +2269,25 @@\n+\n+  assert(_late_inlines.length() == 0 || IncrementalInlineVirtual, \"not empty\");\n+\n+  while (_late_inlines.length() > 0) {\n+    \/\/ More opportunities to optimize virtual calls.\n+    \/\/ Though it's maybe too late for inlining, strength-reducing them to direct calls is still an option.\n+\n+    \/\/ \"inlining_incrementally() == false\" is used to signal that no inlining is allowed.\n+    \/\/ Tracking and verification of modified nodes is disabled by _modified_nodes == NULL as if inlining_incrementally() were set.\n+    assert(inlining_incrementally() == false, \"not allowed\");\n+\n+    for_igvn()->clear();\n+    initial_gvn()->replace_with(&igvn);\n+\n+    DEBUG_ONLY( int late_inlines_before = _late_inlines.length(); )\n+\n+    while (inline_incrementally_one()) {\n+      assert(!failing(), \"inconsistent\");\n+    }\n+    if (failing())  return;\n+\n+    inline_incrementally_cleanup(igvn);\n+\n+    assert(_late_inlines.length() < late_inlines_before, \"no progress\");\n+  }\n@@ -2912,0 +2968,1 @@\n+  case Op_CallLeafVector:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":68,"deletions":11,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -945,0 +945,1 @@\n+  void remove_useless_late_inlines(GrowableArray<CallGenerator*>* inlines, Node* dead);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -277,1 +277,2 @@\n-            miss_cg = CallGenerator::for_virtual_call(callee, vtable_index);\n+            miss_cg = (IncrementalInlineVirtual ? CallGenerator::for_late_inline_virtual(callee, vtable_index, prof_factor)\n+                                                : CallGenerator::for_virtual_call(callee, vtable_index));\n@@ -345,8 +346,10 @@\n-  }\n-\n-  \/\/ Nothing claimed the intrinsic, we go with straight-forward inlining\n-  \/\/ for already discovered intrinsic.\n-  if (allow_inline && allow_intrinsics && cg_intrinsic != NULL) {\n-    assert(cg_intrinsic->does_virtual_dispatch(), \"sanity\");\n-    return cg_intrinsic;\n-  }\n+    \/\/ Nothing claimed the intrinsic, we go with straight-forward inlining\n+    \/\/ for already discovered intrinsic.\n+    if (allow_intrinsics && cg_intrinsic != NULL) {\n+      assert(cg_intrinsic->does_virtual_dispatch(), \"sanity\");\n+      return cg_intrinsic;\n+    }\n+    if (call_does_dispatch && IncrementalInlineVirtual) {\n+      return CallGenerator::for_late_inline_virtual(callee, vtable_index, prof_factor); \/\/ attempt to inline through virtual call later\n+    }\n+  } \/\/ allow_inline\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2502,0 +2502,3 @@\n+  } else  if (flags & RC_VECTOR){\n+    uint num_bits = call_type->range()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte;\n+    call = new CallLeafVectorNode(call_type, call_addr, call_name, adr_type, num_bits);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -328,0 +328,1 @@\n+  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"opto\/callGenerator.hpp\"\n@@ -557,1 +558,1 @@\n-  \/\/ cloning CallNode may need to clone JVMState\n+    \/\/ cloning CallNode may need to clone JVMState\n@@ -560,0 +561,6 @@\n+    \/\/ CallGenerator is linked to the original node.\n+    CallGenerator* cg = n->as_Call()->generator();\n+    if (cg != NULL) {\n+      CallGenerator* cloned_cg = cg->with_call_node(n->as_Call());\n+      n->as_Call()->set_generator(cloned_cg);\n+    }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1120,4 +1120,6 @@\n-  while (modified_list->size()) {\n-    Node* n = modified_list->pop();\n-    n->dump();\n-    assert(false, \"VerifyIterativeGVN: new modified node was added\");\n+  if (modified_list != NULL) {\n+    while (modified_list->size()) {\n+      Node* n = modified_list->pop();\n+      n->dump();\n+      assert(false, \"VerifyIterativeGVN: new modified node was added\");\n+    }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -242,0 +242,15 @@\n+  if (opc == Op_CallLeafVector) {\n+    if (!UseVectorStubs) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** vector stubs support is disabled\");\n+      }\n+      return false;\n+    }\n+    if (!Matcher::supports_vector_calling_convention()) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** no vector calling conventions supported\");\n+      }\n+      return false;\n+    }\n+  }\n+\n@@ -291,10 +306,22 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n-  switch (n) {\n-    case 1:\n-    case 2: {\n-      operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, vt));\n-      break;\n-    }\n-    case 3: {\n-      operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, opd3, vt));\n-      break;\n+  if (sopc == Op_CallLeafVector) {\n+    assert(UseVectorStubs, \"sanity\");\n+    operation = gen_call_to_svml(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n+    if (operation == NULL) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** svml call failed\");\n+      }\n+      return false;\n+     }\n+  } else {\n+    const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+    switch (n) {\n+      case 1:\n+      case 2: {\n+        operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, vt));\n+        break;\n+      }\n+      case 3: {\n+        operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, opd3, vt));\n+        break;\n+      }\n+      default: fatal(\"unsupported arity: %d\", n);\n@@ -302,1 +329,0 @@\n-    default: fatal(\"unsupported arity: %d\", n);\n@@ -354,0 +380,3 @@\n+  if (!arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed)) {\n+    return false;\n+  }\n@@ -385,1 +414,1 @@\n-    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(1));\n+    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ge));\n@@ -1206,0 +1235,417 @@\n+static void get_svml_address(int op, int bits, BasicType bt, const char** name_ptr, address* addr_ptr) {\n+  assert(UseVectorStubs, \"sanity\");\n+  assert(name_ptr != NULL, \"unexpected\");\n+  assert(addr_ptr != NULL, \"unexpected\");\n+\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+  \/\/ Since the addresses are resolved at runtime, using switch instead of table - otherwise might get NULL addresses.\n+  if (bt == T_FLOAT) {\n+    switch(op) {\n+      case VectorSupport::VECTOR_OP_EXP: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_exp_float64\";  *addr_ptr = StubRoutines::vector_exp_float64();  break;\n+            case 128: *name_ptr = \"vector_exp_float128\"; *addr_ptr = StubRoutines::vector_exp_float128(); break;\n+            case 256: *name_ptr = \"vector_exp_float256\"; *addr_ptr = StubRoutines::vector_exp_float256(); break;\n+            case 512: *name_ptr = \"vector_exp_float512\"; *addr_ptr = StubRoutines::vector_exp_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG1P: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log1p_float64\";  *addr_ptr = StubRoutines::vector_log1p_float64();  break;\n+            case 128: *name_ptr = \"vector_log1p_float128\"; *addr_ptr = StubRoutines::vector_log1p_float128(); break;\n+            case 256: *name_ptr = \"vector_log1p_float256\"; *addr_ptr = StubRoutines::vector_log1p_float256(); break;\n+            case 512: *name_ptr = \"vector_log1p_float512\"; *addr_ptr = StubRoutines::vector_log1p_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log_float64\";  *addr_ptr = StubRoutines::vector_log_float64();  break;\n+            case 128: *name_ptr = \"vector_log_float128\"; *addr_ptr = StubRoutines::vector_log_float128(); break;\n+            case 256: *name_ptr = \"vector_log_float256\"; *addr_ptr = StubRoutines::vector_log_float256(); break;\n+            case 512: *name_ptr = \"vector_log_float512\"; *addr_ptr = StubRoutines::vector_log_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG10: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log10_float64\";  *addr_ptr = StubRoutines::vector_log10_float64();  break;\n+            case 128: *name_ptr = \"vector_log10_float128\"; *addr_ptr = StubRoutines::vector_log10_float128(); break;\n+            case 256: *name_ptr = \"vector_log10_float256\"; *addr_ptr = StubRoutines::vector_log10_float256(); break;\n+            case 512: *name_ptr = \"vector_log10_float512\"; *addr_ptr = StubRoutines::vector_log10_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_EXPM1: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_expm1_float64\";  *addr_ptr = StubRoutines::vector_expm1_float64();  break;\n+            case 128: *name_ptr = \"vector_expm1_float128\"; *addr_ptr = StubRoutines::vector_expm1_float128(); break;\n+            case 256: *name_ptr = \"vector_expm1_float256\"; *addr_ptr = StubRoutines::vector_expm1_float256(); break;\n+            case 512: *name_ptr = \"vector_expm1_float512\"; *addr_ptr = StubRoutines::vector_expm1_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sin_float64\";  *addr_ptr = StubRoutines::vector_sin_float64();  break;\n+            case 128: *name_ptr = \"vector_sin_float128\"; *addr_ptr = StubRoutines::vector_sin_float128(); break;\n+            case 256: *name_ptr = \"vector_sin_float256\"; *addr_ptr = StubRoutines::vector_sin_float256(); break;\n+            case 512: *name_ptr = \"vector_sin_float512\"; *addr_ptr = StubRoutines::vector_sin_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cos_float64\";  *addr_ptr = StubRoutines::vector_cos_float64();  break;\n+            case 128: *name_ptr = \"vector_cos_float128\"; *addr_ptr = StubRoutines::vector_cos_float128(); break;\n+            case 256: *name_ptr = \"vector_cos_float256\"; *addr_ptr = StubRoutines::vector_cos_float256(); break;\n+            case 512: *name_ptr = \"vector_cos_float512\"; *addr_ptr = StubRoutines::vector_cos_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tan_float64\";  *addr_ptr = StubRoutines::vector_tan_float64();  break;\n+            case 128: *name_ptr = \"vector_tan_float128\"; *addr_ptr = StubRoutines::vector_tan_float128(); break;\n+            case 256: *name_ptr = \"vector_tan_float256\"; *addr_ptr = StubRoutines::vector_tan_float256(); break;\n+            case 512: *name_ptr = \"vector_tan_float512\"; *addr_ptr = StubRoutines::vector_tan_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SINH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sinh_float64\";  *addr_ptr = StubRoutines::vector_sinh_float64();  break;\n+            case 128: *name_ptr = \"vector_sinh_float128\"; *addr_ptr = StubRoutines::vector_sinh_float128(); break;\n+            case 256: *name_ptr = \"vector_sinh_float256\"; *addr_ptr = StubRoutines::vector_sinh_float256(); break;\n+            case 512: *name_ptr = \"vector_sinh_float512\"; *addr_ptr = StubRoutines::vector_sinh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COSH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cosh_float64\";  *addr_ptr = StubRoutines::vector_cosh_float64();  break;\n+            case 128: *name_ptr = \"vector_cosh_float128\"; *addr_ptr = StubRoutines::vector_cosh_float128(); break;\n+            case 256: *name_ptr = \"vector_cosh_float256\"; *addr_ptr = StubRoutines::vector_cosh_float256(); break;\n+            case 512: *name_ptr = \"vector_cosh_float512\"; *addr_ptr = StubRoutines::vector_cosh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TANH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tanh_float64\";  *addr_ptr = StubRoutines::vector_tanh_float64();  break;\n+            case 128: *name_ptr = \"vector_tanh_float128\"; *addr_ptr = StubRoutines::vector_tanh_float128(); break;\n+            case 256: *name_ptr = \"vector_tanh_float256\"; *addr_ptr = StubRoutines::vector_tanh_float256(); break;\n+            case 512: *name_ptr = \"vector_tanh_float512\"; *addr_ptr = StubRoutines::vector_tanh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ASIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_asin_float64\";  *addr_ptr = StubRoutines::vector_asin_float64();  break;\n+            case 128: *name_ptr = \"vector_asin_float128\"; *addr_ptr = StubRoutines::vector_asin_float128(); break;\n+            case 256: *name_ptr = \"vector_asin_float256\"; *addr_ptr = StubRoutines::vector_asin_float256(); break;\n+            case 512: *name_ptr = \"vector_asin_float512\"; *addr_ptr = StubRoutines::vector_asin_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ACOS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_acos_float64\";  *addr_ptr = StubRoutines::vector_acos_float64();  break;\n+            case 128: *name_ptr = \"vector_acos_float128\"; *addr_ptr = StubRoutines::vector_acos_float128(); break;\n+            case 256: *name_ptr = \"vector_acos_float256\"; *addr_ptr = StubRoutines::vector_acos_float256(); break;\n+            case 512: *name_ptr = \"vector_acos_float512\"; *addr_ptr = StubRoutines::vector_acos_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan_float64\";  *addr_ptr = StubRoutines::vector_atan_float64();  break;\n+            case 128: *name_ptr = \"vector_atan_float128\"; *addr_ptr = StubRoutines::vector_atan_float128(); break;\n+            case 256: *name_ptr = \"vector_atan_float256\"; *addr_ptr = StubRoutines::vector_atan_float256(); break;\n+            case 512: *name_ptr = \"vector_atan_float512\"; *addr_ptr = StubRoutines::vector_atan_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_CBRT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cbrt_float64\";  *addr_ptr = StubRoutines::vector_cbrt_float64();  break;\n+            case 128: *name_ptr = \"vector_cbrt_float128\"; *addr_ptr = StubRoutines::vector_cbrt_float128(); break;\n+            case 256: *name_ptr = \"vector_cbrt_float256\"; *addr_ptr = StubRoutines::vector_cbrt_float256(); break;\n+            case 512: *name_ptr = \"vector_cbrt_float512\"; *addr_ptr = StubRoutines::vector_cbrt_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+       case VectorSupport::VECTOR_OP_HYPOT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_hypot_float64\";  *addr_ptr = StubRoutines::vector_hypot_float64();  break;\n+            case 128: *name_ptr = \"vector_hypot_float128\"; *addr_ptr = StubRoutines::vector_hypot_float128(); break;\n+            case 256: *name_ptr = \"vector_hypot_float256\"; *addr_ptr = StubRoutines::vector_hypot_float256(); break;\n+            case 512: *name_ptr = \"vector_hypot_float512\"; *addr_ptr = StubRoutines::vector_hypot_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_POW: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_pow_float64\";  *addr_ptr = StubRoutines::vector_pow_float64();  break;\n+            case 128: *name_ptr = \"vector_pow_float128\"; *addr_ptr = StubRoutines::vector_pow_float128(); break;\n+            case 256: *name_ptr = \"vector_pow_float256\"; *addr_ptr = StubRoutines::vector_pow_float256(); break;\n+            case 512: *name_ptr = \"vector_pow_float512\"; *addr_ptr = StubRoutines::vector_pow_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN2: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan2_float64\";  *addr_ptr = StubRoutines::vector_atan2_float64();  break;\n+            case 128: *name_ptr = \"vector_atan2_float128\"; *addr_ptr = StubRoutines::vector_atan2_float128(); break;\n+            case 256: *name_ptr = \"vector_atan2_float256\"; *addr_ptr = StubRoutines::vector_atan2_float256(); break;\n+            case 512: *name_ptr = \"vector_atan2_float512\"; *addr_ptr = StubRoutines::vector_atan2_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      default:\n+        *name_ptr = \"invalid\";\n+        *addr_ptr = NULL;\n+        break;\n+    }\n+  } else {\n+    assert(bt == T_DOUBLE, \"must be FP type only\");\n+    switch(op) {\n+      case VectorSupport::VECTOR_OP_EXP: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_exp_double64\";  *addr_ptr = StubRoutines::vector_exp_double64();  break;\n+            case 128: *name_ptr = \"vector_exp_double128\"; *addr_ptr = StubRoutines::vector_exp_double128(); break;\n+            case 256: *name_ptr = \"vector_exp_double256\"; *addr_ptr = StubRoutines::vector_exp_double256(); break;\n+            case 512: *name_ptr = \"vector_exp_double512\"; *addr_ptr = StubRoutines::vector_exp_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG1P: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log1p_double64\";  *addr_ptr = StubRoutines::vector_log1p_double64();  break;\n+            case 128: *name_ptr = \"vector_log1p_double128\"; *addr_ptr = StubRoutines::vector_log1p_double128(); break;\n+            case 256: *name_ptr = \"vector_log1p_double256\"; *addr_ptr = StubRoutines::vector_log1p_double256(); break;\n+            case 512: *name_ptr = \"vector_log1p_double512\"; *addr_ptr = StubRoutines::vector_log1p_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log_double64\";  *addr_ptr = StubRoutines::vector_log_double64();  break;\n+            case 128: *name_ptr = \"vector_log_double128\"; *addr_ptr = StubRoutines::vector_log_double128(); break;\n+            case 256: *name_ptr = \"vector_log_double256\"; *addr_ptr = StubRoutines::vector_log_double256(); break;\n+            case 512: *name_ptr = \"vector_log_double512\"; *addr_ptr = StubRoutines::vector_log_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG10: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log10_double64\";  *addr_ptr = StubRoutines::vector_log10_double64();  break;\n+            case 128: *name_ptr = \"vector_log10_double128\"; *addr_ptr = StubRoutines::vector_log10_double128(); break;\n+            case 256: *name_ptr = \"vector_log10_double256\"; *addr_ptr = StubRoutines::vector_log10_double256(); break;\n+            case 512: *name_ptr = \"vector_log10_double512\"; *addr_ptr = StubRoutines::vector_log10_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_EXPM1: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_expm1_double64\";  *addr_ptr = StubRoutines::vector_expm1_double64();  break;\n+            case 128: *name_ptr = \"vector_expm1_double128\"; *addr_ptr = StubRoutines::vector_expm1_double128(); break;\n+            case 256: *name_ptr = \"vector_expm1_double256\"; *addr_ptr = StubRoutines::vector_expm1_double256(); break;\n+            case 512: *name_ptr = \"vector_expm1_double512\"; *addr_ptr = StubRoutines::vector_expm1_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sin_double64\";  *addr_ptr = StubRoutines::vector_sin_double64();  break;\n+            case 128: *name_ptr = \"vector_sin_double128\"; *addr_ptr = StubRoutines::vector_sin_double128(); break;\n+            case 256: *name_ptr = \"vector_sin_double256\"; *addr_ptr = StubRoutines::vector_sin_double256(); break;\n+            case 512: *name_ptr = \"vector_sin_double512\"; *addr_ptr = StubRoutines::vector_sin_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cos_double64\";  *addr_ptr = StubRoutines::vector_cos_double64();  break;\n+            case 128: *name_ptr = \"vector_cos_double128\"; *addr_ptr = StubRoutines::vector_cos_double128(); break;\n+            case 256: *name_ptr = \"vector_cos_double256\"; *addr_ptr = StubRoutines::vector_cos_double256(); break;\n+            case 512: *name_ptr = \"vector_cos_double512\"; *addr_ptr = StubRoutines::vector_cos_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tan_double64\";  *addr_ptr = StubRoutines::vector_tan_double64();  break;\n+            case 128: *name_ptr = \"vector_tan_double128\"; *addr_ptr = StubRoutines::vector_tan_double128(); break;\n+            case 256: *name_ptr = \"vector_tan_double256\"; *addr_ptr = StubRoutines::vector_tan_double256(); break;\n+            case 512: *name_ptr = \"vector_tan_double512\"; *addr_ptr = StubRoutines::vector_tan_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SINH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sinh_double64\";  *addr_ptr = StubRoutines::vector_sinh_double64();  break;\n+            case 128: *name_ptr = \"vector_sinh_double128\"; *addr_ptr = StubRoutines::vector_sinh_double128(); break;\n+            case 256: *name_ptr = \"vector_sinh_double256\"; *addr_ptr = StubRoutines::vector_sinh_double256(); break;\n+            case 512: *name_ptr = \"vector_sinh_double512\"; *addr_ptr = StubRoutines::vector_sinh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COSH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cosh_double64\";  *addr_ptr = StubRoutines::vector_cosh_double64();  break;\n+            case 128: *name_ptr = \"vector_cosh_double128\"; *addr_ptr = StubRoutines::vector_cosh_double128(); break;\n+            case 256: *name_ptr = \"vector_cosh_double256\"; *addr_ptr = StubRoutines::vector_cosh_double256(); break;\n+            case 512: *name_ptr = \"vector_cosh_double512\"; *addr_ptr = StubRoutines::vector_cosh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TANH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tanh_double64\";  *addr_ptr = StubRoutines::vector_tanh_double64();  break;\n+            case 128: *name_ptr = \"vector_tanh_double128\"; *addr_ptr = StubRoutines::vector_tanh_double128(); break;\n+            case 256: *name_ptr = \"vector_tanh_double256\"; *addr_ptr = StubRoutines::vector_tanh_double256(); break;\n+            case 512: *name_ptr = \"vector_tanh_double512\"; *addr_ptr = StubRoutines::vector_tanh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ASIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_asin_double64\";  *addr_ptr = StubRoutines::vector_asin_double64();  break;\n+            case 128: *name_ptr = \"vector_asin_double128\"; *addr_ptr = StubRoutines::vector_asin_double128(); break;\n+            case 256: *name_ptr = \"vector_asin_double256\"; *addr_ptr = StubRoutines::vector_asin_double256(); break;\n+            case 512: *name_ptr = \"vector_asin_double512\"; *addr_ptr = StubRoutines::vector_asin_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ACOS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_acos_double64\";  *addr_ptr = StubRoutines::vector_acos_double64();  break;\n+            case 128: *name_ptr = \"vector_acos_double128\"; *addr_ptr = StubRoutines::vector_acos_double128(); break;\n+            case 256: *name_ptr = \"vector_acos_double256\"; *addr_ptr = StubRoutines::vector_acos_double256(); break;\n+            case 512: *name_ptr = \"vector_acos_double512\"; *addr_ptr = StubRoutines::vector_acos_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan_double64\";  *addr_ptr = StubRoutines::vector_atan_double64();  break;\n+            case 128: *name_ptr = \"vector_atan_double128\"; *addr_ptr = StubRoutines::vector_atan_double128(); break;\n+            case 256: *name_ptr = \"vector_atan_double256\"; *addr_ptr = StubRoutines::vector_atan_double256(); break;\n+            case 512: *name_ptr = \"vector_atan_double512\"; *addr_ptr = StubRoutines::vector_atan_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_CBRT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cbrt_double64\";  *addr_ptr = StubRoutines::vector_cbrt_double64();  break;\n+            case 128: *name_ptr = \"vector_cbrt_double128\"; *addr_ptr = StubRoutines::vector_cbrt_double128(); break;\n+            case 256: *name_ptr = \"vector_cbrt_double256\"; *addr_ptr = StubRoutines::vector_cbrt_double256(); break;\n+            case 512: *name_ptr = \"vector_cbrt_double512\"; *addr_ptr = StubRoutines::vector_cbrt_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_HYPOT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_hypot_double64\";  *addr_ptr = StubRoutines::vector_hypot_double64();  break;\n+            case 128: *name_ptr = \"vector_hypot_double128\"; *addr_ptr = StubRoutines::vector_hypot_double128(); break;\n+            case 256: *name_ptr = \"vector_hypot_double256\"; *addr_ptr = StubRoutines::vector_hypot_double256(); break;\n+            case 512: *name_ptr = \"vector_hypot_double512\"; *addr_ptr = StubRoutines::vector_hypot_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_POW: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_pow_double64\";  *addr_ptr = StubRoutines::vector_pow_double64();  break;\n+            case 128: *name_ptr = \"vector_pow_double128\"; *addr_ptr = StubRoutines::vector_pow_double128(); break;\n+            case 256: *name_ptr = \"vector_pow_double256\"; *addr_ptr = StubRoutines::vector_pow_double256(); break;\n+            case 512: *name_ptr = \"vector_pow_double512\"; *addr_ptr = StubRoutines::vector_pow_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN2: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan2_double64\";  *addr_ptr = StubRoutines::vector_atan2_double64();  break;\n+            case 128: *name_ptr = \"vector_atan2_double128\"; *addr_ptr = StubRoutines::vector_atan2_double128(); break;\n+            case 256: *name_ptr = \"vector_atan2_double256\"; *addr_ptr = StubRoutines::vector_atan2_double256(); break;\n+            case 512: *name_ptr = \"vector_atan2_double512\"; *addr_ptr = StubRoutines::vector_atan2_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+\n+      default:\n+        *name_ptr = \"invalid\";\n+        *addr_ptr = NULL;\n+        break;\n+    }\n+  }\n+#else\n+  *name_ptr = \"invalid\";\n+  *addr_ptr = NULL;\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+}\n+\n+Node* LibraryCallKit::gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n+  assert(UseVectorStubs, \"sanity\");\n+  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_SVML_START && vector_api_op_id <= VectorSupport::VECTOR_OP_SVML_END, \"need valid op id\");\n+  assert(opd1 != NULL, \"must not be null\");\n+  const TypeVect* vt = TypeVect::make(bt, num_elem);\n+  const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(opd2 != NULL ? 2 : 1, vt, vt);\n+  const char* name = NULL;\n+  address addr = NULL;\n+\n+  \/\/ Get address for svml method.\n+  get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, &name, &addr);\n+\n+  if (addr == NULL) {\n+    return NULL;\n+  }\n+\n+  assert(name != NULL, \"name must not be null\");\n+  Node* operation = make_runtime_call(RC_VECTOR,\n+                                      call_type,\n+                                      addr,\n+                                      name,\n+                                      TypePtr::BOTTOM,\n+                                      opd1,\n+                                      opd2);\n+  return _gvn.transform(new ProjNode(_gvn.transform(operation), TypeFunc::Parms));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":458,"deletions":12,"binary":false,"changes":470,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1114,0 +1114,1 @@\n+    assert((BoolTest::mask)predicate_node->get_int() == predicate, \"Unmatched predicates\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -353,0 +353,19 @@\n+    case VECTOR_OP_TAN:\n+    case VECTOR_OP_TANH:\n+    case VECTOR_OP_SIN:\n+    case VECTOR_OP_SINH:\n+    case VECTOR_OP_COS:\n+    case VECTOR_OP_COSH:\n+    case VECTOR_OP_ASIN:\n+    case VECTOR_OP_ACOS:\n+    case VECTOR_OP_ATAN:\n+    case VECTOR_OP_ATAN2:\n+    case VECTOR_OP_CBRT:\n+    case VECTOR_OP_LOG:\n+    case VECTOR_OP_LOG10:\n+    case VECTOR_OP_LOG1P:\n+    case VECTOR_OP_POW:\n+    case VECTOR_OP_EXP:\n+    case VECTOR_OP_EXPM1:\n+    case VECTOR_OP_HYPOT:\n+      return Op_CallLeafVector;\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -4139,0 +4139,5 @@\n+\n+    if (!FLAG_IS_DEFAULT(UseVectorStubs) && UseVectorStubs) {\n+      warning(\"Disabling UseVectorStubs since EnableVectorSupport is turned off.\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorStubs, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/globalDefinitions_vecApi.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -552,31 +552,0 @@\n-            if (op == SIN) {\n-                return uOp((i, a) -> (double) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> (double) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> (double) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> (double) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> (double) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> (double) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> (double) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> (double) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> (double) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> (double) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> (double) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> (double) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> (double) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> (double) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> (double) Math.log1p(a));\n-            }\n@@ -594,0 +563,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log10(a));\n@@ -596,0 +583,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log1p(a));\n@@ -642,7 +641,0 @@\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> (double) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> (double) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> (double) Math.hypot(a, b));\n-            }\n@@ -668,0 +660,6 @@\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.hypot(a, b));\n@@ -2732,0 +2730,1 @@\n+\n@@ -2864,1 +2863,1 @@\n-     * Stores this vector into an array of {@code double}\n+     * Stores this vector into an array of type {@code double[]}\n@@ -3021,0 +3020,1 @@\n+\n@@ -3127,0 +3127,1 @@\n+\n@@ -3262,0 +3263,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":41,"deletions":39,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -552,31 +552,0 @@\n-            if (op == SIN) {\n-                return uOp((i, a) -> (float) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> (float) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> (float) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> (float) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> (float) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> (float) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> (float) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> (float) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> (float) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> (float) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> (float) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> (float) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> (float) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> (float) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> (float) Math.log1p(a));\n-            }\n@@ -594,0 +563,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log10(a));\n@@ -596,0 +583,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log1p(a));\n@@ -642,7 +641,0 @@\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> (float) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> (float) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> (float) Math.hypot(a, b));\n-            }\n@@ -668,0 +660,6 @@\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.hypot(a, b));\n@@ -2738,0 +2736,1 @@\n+\n@@ -2870,1 +2869,1 @@\n-     * Stores this vector into an array of {@code float}\n+     * Stores this vector into an array of type {@code float[]}\n@@ -3008,0 +3007,1 @@\n+\n@@ -3114,0 +3114,1 @@\n+\n@@ -3249,0 +3250,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":41,"deletions":39,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -572,33 +572,0 @@\n-#if[FP]\n-            if (op == SIN) {\n-                return uOp((i, a) -> ($type$) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> ($type$) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> ($type$) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> ($type$) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> ($type$) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> ($type$) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> ($type$) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> ($type$) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> ($type$) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> ($type$) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> ($type$) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> ($type$) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> ($type$) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> ($type$) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> ($type$) Math.log1p(a));\n-            }\n-#end[FP]\n@@ -617,0 +584,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log10(a));\n@@ -619,0 +604,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log1p(a));\n@@ -692,9 +689,0 @@\n-#if[FP]\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.hypot(a, b));\n-            }\n-#end[FP]\n@@ -734,0 +722,8 @@\n+#if[FP]\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.hypot(a, b));\n+#end[FP]\n@@ -3365,0 +3361,152 @@\n+#if[short]\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            $abstractvectortype$ zero = vsp.zero();\n+            return zero.blend(zero.fromCharArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (short) a[offset + i]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+#end[short]\n+\n@@ -3503,1 +3651,1 @@\n-     * Stores this vector into an array of {@code $type$}\n+     * Stores this vector into an array of type {@code $type$[]}\n@@ -3694,0 +3842,154 @@\n+#if[short]\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        $Type$Species vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<$Boxtype$> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+#end[short]\n+\n@@ -3800,0 +4102,17 @@\n+#if[short]\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromCharArray0Template(char[] a, int offset) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+#end[short]\n+\n@@ -3937,0 +4256,12 @@\n+#if[short]\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+#end[short]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":374,"deletions":43,"binary":false,"changes":417,"status":"modified"}]}