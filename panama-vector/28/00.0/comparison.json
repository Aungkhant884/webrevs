{"files":[{"patch":"@@ -243,1 +243,8 @@\n-  # leading spaces.\n+  # leading spaces. There may also be multiple entries on the same line, so start\n+  # with splitting such lines.\n+  # Non GNU sed (BSD on macosx) cannot substitue in literal \\n using regex.\n+  # Instead use a bash escaped literal newline. To avoid having unmatched quotes\n+  # ruin the ability for an editor to properly syntax highlight this file, define\n+  # that newline sequence as a separate variable and add the closing quote behind\n+  # a comment.\n+  sed_newline := \\'$$'\\n''#'\n@@ -246,3 +253,6 @@\n-\t    -e 's|^\\([ ]*\\)\\.\/|\\1|' \\\n-\t    -e '\/^[ ]*[^\/ ]\/s|^\\([ ]*\\)|\\1$(WORKSPACE_ROOT)\/|' \\\n-\t    $1.tmp > $1\n+\t    -e 's|\\([^ ]\\) \\{1,\\}\\([^\\\\:]\\)|\\1 \\\\$(sed_newline) \\2|g' \\\n+\t    $1.tmp \\\n+\t    | $(SED) \\\n+\t        -e 's|^\\([ ]*\\)\\.\/|\\1|' \\\n+\t        -e '\/^[ ]*[^\/ ]\/s|^\\([ ]*\\)|\\1$(WORKSPACE_ROOT)\/|' \\\n+\t        > $1\n","filename":"make\/common\/NativeCompilation.gmk","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1241,0 +1241,1 @@\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1209,1 +1209,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -712,1 +712,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1632,1 +1632,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1328,0 +1328,2 @@\n+#include \"oops\/klass.inline.hpp\"\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -931,1 +931,1 @@\n-              \"special_dispatch=%d\", special_dispatch);\n+              \"special_dispatch=%d\", vmIntrinsics::as_int(special_dispatch));\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1299,1 +1299,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1674,1 +1674,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -722,0 +722,3 @@\n+  product(bool, IncrementalInlineForceCleanup, false, DIAGNOSTIC,           \\\n+          \"do cleanup after every iteration of incremental inlining\")       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -399,0 +399,6 @@\n+  if (call->in(TypeFunc::Memory)->is_MergeMem()) {\n+    MergeMemNode* merge_mem = call->in(TypeFunc::Memory)->as_MergeMem();\n+    if (merge_mem->base_memory() == merge_mem->empty_memory()) {\n+      return; \/\/ dead path\n+    }\n+  }\n@@ -1321,1 +1327,1 @@\n-    fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -148,0 +148,2 @@\n+macro(LongCountedLoop)\n+macro(LongCountedLoopEnd)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,2 +172,6 @@\n-juint  Compile::_intrinsic_hist_count[vmIntrinsics::ID_LIMIT] = {0};\n-jubyte Compile::_intrinsic_hist_flags[vmIntrinsics::ID_LIMIT] = {0};\n+juint  Compile::_intrinsic_hist_count[vmIntrinsics::number_of_intrinsics()] = {0};\n+jubyte Compile::_intrinsic_hist_flags[vmIntrinsics::number_of_intrinsics()] = {0};\n+\n+inline int as_int(vmIntrinsics::ID id) {\n+  return vmIntrinsics::as_int(id);\n+}\n@@ -177,1 +181,1 @@\n-  int oflags = _intrinsic_hist_flags[id];\n+  int oflags = _intrinsic_hist_flags[as_int(id)];\n@@ -184,1 +188,1 @@\n-    juint count = (_intrinsic_hist_count[id] += 1);\n+    juint count = (_intrinsic_hist_count[as_int(id)] += 1);\n@@ -189,1 +193,1 @@\n-    _intrinsic_hist_count[vmIntrinsics::_none] += 1;\n+    _intrinsic_hist_count[as_int(vmIntrinsics::_none)] += 1;\n@@ -205,1 +209,1 @@\n-    _intrinsic_hist_flags[id] = (jubyte) (oflags | flags);\n+    _intrinsic_hist_flags[as_int(id)] = (jubyte) (oflags | flags);\n@@ -208,1 +212,1 @@\n-  _intrinsic_hist_flags[vmIntrinsics::_none] |= (jubyte) flags;\n+  _intrinsic_hist_flags[as_int(vmIntrinsics::_none)] |= (jubyte) flags;\n@@ -229,1 +233,1 @@\n-  juint total = _intrinsic_hist_count[vmIntrinsics::_none];\n+  juint total = _intrinsic_hist_count[as_int(vmIntrinsics::_none)];\n@@ -233,4 +237,4 @@\n-  for (int index = 1 + (int)vmIntrinsics::_none; index < (int)vmIntrinsics::ID_LIMIT; index++) {\n-    vmIntrinsics::ID id = (vmIntrinsics::ID) index;\n-    int   flags = _intrinsic_hist_flags[id];\n-    juint count = _intrinsic_hist_count[id];\n+  for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n+    vmIntrinsicID id = *it;\n+    int   flags = _intrinsic_hist_flags[as_int(id)];\n+    juint count = _intrinsic_hist_count[as_int(id)];\n@@ -241,1 +245,1 @@\n-  PRINT_STAT_LINE(\"total\", total, format_flags(_intrinsic_hist_flags[vmIntrinsics::_none], flagsbuf));\n+  PRINT_STAT_LINE(\"total\", total, format_flags(_intrinsic_hist_flags[as_int(vmIntrinsics::_none)], flagsbuf));\n@@ -256,1 +260,1 @@\n-  if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {\n+  if (_intrinsic_hist_flags[as_int(vmIntrinsics::_none)] != 0) {\n@@ -1905,1 +1909,2 @@\n-  return (_late_inlines.length() > 0) && !needs_cleanup;\n+  bool force_cleanup = directive()->IncrementalInlineForceCleanupOption;\n+  return (_late_inlines.length() > 0) && !needs_cleanup && !force_cleanup;\n@@ -3452,0 +3457,1 @@\n+  case Op_LongCountedLoop:\n@@ -3770,1 +3776,1 @@\n-    if (n->is_OuterStripMinedLoopEnd()) {\n+    if (n->is_OuterStripMinedLoopEnd() || n->is_LongCountedLoopEnd()) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1087,2 +1087,2 @@\n-  static juint  _intrinsic_hist_count[vmIntrinsics::ID_LIMIT];\n-  static jubyte _intrinsic_hist_flags[vmIntrinsics::ID_LIMIT];\n+  static juint  _intrinsic_hist_count[];\n+  static jubyte _intrinsic_hist_flags[];\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -361,1 +361,3 @@\n-    if (PrintInlining) print_inlining(callee, jvms->depth() - 1, jvms->bci(), msg);\n+    if (C->print_inlining()) {\n+      print_inlining(callee, jvms->depth() - 1, jvms->bci(), msg);\n+    }\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1463,0 +1463,1 @@\n+  assert(p != mem->empty_memory(), \"empty\");\n@@ -3317,1 +3318,7 @@\n-        return null_assert(obj);\n+        if (!objtp->maybe_null()) {\n+          builtin_throw(Deoptimization::Reason_class_check, makecon(TypeKlassPtr::make(objtp->klass())));\n+          return top();\n+        } else if (!too_many_traps_or_recompiles(Deoptimization::Reason_null_assert)) {\n+          return null_assert(obj);\n+        }\n+        break; \/\/ Fall through to full check\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1517,0 +1517,10 @@\n+const TypeInteger* Node::find_integer_type(BasicType bt) const {\n+  if (this->is_Type()) {\n+    return this->as_Type()->type()->isa_integer(bt);\n+  } else if (this->is_Con()) {\n+    assert(is_Mach(), \"should be ConNode(TypeNode) or else a MachNode\");\n+    return this->bottom_type()->isa_integer(bt);\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -790,0 +790,10 @@\n+ConNode* PhaseTransform::integercon(jlong l, BasicType bt) {\n+  if (bt == T_INT) {\n+    jint int_con = (jint)l;\n+    assert(((long)int_con) == l, \"not an int\");\n+    return intcon(int_con);\n+  }\n+  assert(bt == T_LONG, \"not an integer\");\n+  return longcon(l);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -200,4 +200,4 @@\n-  const TypeInt* opr              = gvn().type(argument(0))->is_int();\n-  const TypeInstPtr* vector_klass = gvn().type(argument(1))->is_instptr();\n-  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->is_instptr();\n-  const TypeInt* vlen             = gvn().type(argument(3))->is_int();\n+  const TypeInt*     opr          = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n@@ -205,1 +205,2 @@\n-  if (!opr->is_con() || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (opr == NULL || vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n+      !opr->is_con() || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n@@ -232,0 +233,6 @@\n+  if (sopc == 0) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n+    }\n+    return false; \/\/ operation not supported\n+  }\n@@ -334,7 +341,8 @@\n-  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->is_instptr();\n-  const TypeInt* vlen             = gvn().type(argument(3))->is_int();\n-  Node* start                     = argument(4);\n-  const TypeInt* start_val        = gvn().type(start)->is_int();\n-  Node* step                      = argument(5);\n-  const TypeInt* step_val         = gvn().type(step)->is_int();\n-  const TypeInt* wrap             = gvn().type(argument(6))->is_int();\n+  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n+  const TypeInt*     start_val     = gvn().type(argument(4))->isa_int();\n+  const TypeInt*     step_val      = gvn().type(argument(5))->isa_int();\n+  const TypeInt*     wrap          = gvn().type(argument(6))->isa_int();\n+\n+  Node* start = argument(4);\n+  Node* step  = argument(5);\n@@ -342,0 +350,3 @@\n+  if (shuffle_klass == NULL || vlen == NULL || start_val == NULL || step_val == NULL || wrap == NULL) {\n+    return false; \/\/ dead code\n+  }\n@@ -428,5 +439,5 @@\n-  const TypeInstPtr* vector_klass  = gvn().type(argument(0))->is_instptr();\n-  const TypeInstPtr* elem_klass    = gvn().type(argument(1))->is_instptr();\n-  const TypeInstPtr* shuffle_klass = gvn().type(argument(2))->is_instptr();\n-  Node* shuffle                    = argument(3);\n-  const TypeInt* vlen              = gvn().type(argument(4))->is_int();\n+  const TypeInstPtr* vector_klass  = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass    = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* shuffle_klass = gvn().type(argument(2))->isa_instptr();\n+  Node*              shuffle       = argument(3);\n+  const TypeInt*     vlen          = gvn().type(argument(4))->isa_int();\n@@ -434,0 +445,3 @@\n+  if (vector_klass == NULL || elem_klass == NULL || shuffle_klass == NULL || shuffle->is_top() || vlen == NULL) {\n+    return false; \/\/ dead code\n+  }\n@@ -483,3 +497,3 @@\n-  const TypeInstPtr* vector_klass = gvn().type(argument(0))->is_instptr();\n-  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->is_instptr();\n-  const TypeInt* vlen             = gvn().type(argument(2))->is_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n@@ -487,1 +501,2 @@\n-  if (vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n+      vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n@@ -578,3 +593,3 @@\n-  const TypeInstPtr* vector_klass = gvn().type(argument(0))->is_instptr();\n-  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->is_instptr();\n-  const TypeInt* vlen             = gvn().type(argument(2))->is_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n@@ -582,1 +597,2 @@\n-  if (vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n+      vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n@@ -740,4 +756,4 @@\n-  const TypeInstPtr* vector_klass     = gvn().type(argument(0))->is_instptr();\n-  const TypeInstPtr* elem_klass       = gvn().type(argument(1))->is_instptr();\n-  const TypeInt* vlen                 = gvn().type(argument(2))->is_int();\n-  const TypeInstPtr* vector_idx_klass = gvn().type(argument(3))->is_instptr();\n+  const TypeInstPtr* vector_klass     = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass       = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen             = gvn().type(argument(2))->isa_int();\n+  const TypeInstPtr* vector_idx_klass = gvn().type(argument(3))->isa_instptr();\n@@ -745,1 +761,2 @@\n-  if (vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || vector_idx_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (vector_klass == NULL || elem_klass == NULL || vector_idx_klass == NULL || vlen == NULL ||\n+      vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || vector_idx_klass->const_oop() == NULL || !vlen->is_con()) {\n@@ -844,4 +861,4 @@\n-  const TypeInt* opr              = gvn().type(argument(0))->is_int();\n-  const TypeInstPtr* vector_klass = gvn().type(argument(1))->is_instptr();\n-  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->is_instptr();\n-  const TypeInt* vlen             = gvn().type(argument(3))->is_int();\n+  const TypeInt*     opr          = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n@@ -849,1 +866,2 @@\n-  if (!opr->is_con() || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (opr == NULL || vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n+      !opr->is_con() || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n@@ -931,4 +949,4 @@\n-  const TypeInt* cond             = gvn().type(argument(0))->is_int();\n-  const TypeInstPtr* vector_klass = gvn().type(argument(1))->is_instptr();\n-  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->is_instptr();\n-  const TypeInt* vlen             = gvn().type(argument(3))->is_int();\n+  const TypeInt*     cond         = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n@@ -936,1 +954,2 @@\n-  if (!cond->is_con() || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (cond == NULL || vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n+      !cond->is_con() || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n@@ -994,4 +1013,4 @@\n-  const TypeInstPtr* vector_klass = gvn().type(argument(0))->is_instptr();\n-  const TypeInstPtr* mask_klass   = gvn().type(argument(1))->is_instptr();\n-  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->is_instptr();\n-  const TypeInt*     vlen         = gvn().type(argument(3))->is_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* mask_klass   = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n@@ -999,0 +1018,3 @@\n+  if (mask_klass == NULL || vector_klass == NULL || elem_klass == NULL || vlen == NULL) {\n+    return false; \/\/ dead code\n+  }\n@@ -1064,5 +1086,5 @@\n-  const TypeInt*     cond         = gvn().type(argument(0))->is_int();\n-  const TypeInstPtr* vector_klass = gvn().type(argument(1))->is_instptr();\n-  const TypeInstPtr* mask_klass   = gvn().type(argument(2))->is_instptr();\n-  const TypeInstPtr* elem_klass   = gvn().type(argument(3))->is_instptr();\n-  const TypeInt*     vlen         = gvn().type(argument(4))->is_int();\n+  const TypeInt*     cond         = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n@@ -1070,0 +1092,3 @@\n+  if (cond == NULL || vector_klass == NULL || mask_klass == NULL || elem_klass == NULL || vlen == NULL) {\n+    return false; \/\/ dead code\n+  }\n@@ -1139,4 +1164,4 @@\n-  const TypeInstPtr* vector_klass = gvn().type(argument(0))->is_instptr();\n-  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->is_instptr();\n-  const TypeInstPtr* elem_klass = gvn().type(argument(2))->is_instptr();\n-  const TypeInt*     vlen = gvn().type(argument(3))->is_int();\n+  const TypeInstPtr* vector_klass  = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* elem_klass    = gvn().type(argument(2))->isa_instptr();\n+  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n@@ -1144,0 +1169,3 @@\n+  if (vector_klass == NULL || shuffle_klass == NULL || elem_klass == NULL || vlen == NULL) {\n+    return false; \/\/ dead code\n+  }\n@@ -1631,4 +1659,4 @@\n-  const TypeInt* opr              = gvn().type(argument(0))->is_int();\n-  const TypeInstPtr* vector_klass = gvn().type(argument(1))->is_instptr();\n-  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->is_instptr();\n-  const TypeInt* vlen             = gvn().type(argument(3))->is_int();\n+  const TypeInt*     opr          = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(3))->isa_int();\n@@ -1636,0 +1664,3 @@\n+  if (opr == NULL || vector_klass == NULL || elem_klass == NULL || vlen == NULL) {\n+    return false; \/\/ dead code\n+  }\n@@ -1662,0 +1693,6 @@\n+  if (opc == 0 || !VectorNode::is_shift_opcode(opc)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** operation not supported: op=%d bt=%s\", opr->get_con(), type2name(elem_bt));\n+    }\n+    return false; \/\/ operation not supported\n+  }\n@@ -1663,0 +1700,6 @@\n+  if (sopc == 0) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** operation not supported: opc=%s bt=%s\", NodeClassNames[opc], type2name(elem_bt));\n+    }\n+    return false; \/\/ operation not supported\n+  }\n@@ -1696,1 +1739,1 @@\n-  const TypeInt*     opr               = gvn().type(argument(0))->is_int();\n+  const TypeInt*     opr               = gvn().type(argument(0))->isa_int();\n@@ -1698,3 +1741,3 @@\n-  const TypeInstPtr* vector_klass_from = gvn().type(argument(1))->is_instptr();\n-  const TypeInstPtr* elem_klass_from   = gvn().type(argument(2))->is_instptr();\n-  const TypeInt*     vlen_from         = gvn().type(argument(3))->is_int();\n+  const TypeInstPtr* vector_klass_from = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* elem_klass_from   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInt*     vlen_from         = gvn().type(argument(3))->isa_int();\n@@ -1702,3 +1745,3 @@\n-  const TypeInstPtr* vector_klass_to   = gvn().type(argument(4))->is_instptr();\n-  const TypeInstPtr* elem_klass_to     = gvn().type(argument(5))->is_instptr();\n-  const TypeInt*     vlen_to           = gvn().type(argument(6))->is_int();\n+  const TypeInstPtr* vector_klass_to   = gvn().type(argument(4))->isa_instptr();\n+  const TypeInstPtr* elem_klass_to     = gvn().type(argument(5))->isa_instptr();\n+  const TypeInt*     vlen_to           = gvn().type(argument(6))->isa_int();\n@@ -1706,0 +1749,5 @@\n+  if (opr == NULL ||\n+      vector_klass_from == NULL || elem_klass_from == NULL || vlen_from == NULL ||\n+      vector_klass_to   == NULL || elem_klass_to   == NULL || vlen_to   == NULL) {\n+    return false; \/\/ dead code\n+  }\n@@ -1880,4 +1928,4 @@\n-  const TypeInstPtr* vector_klass = gvn().type(argument(0))->is_instptr();\n-  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->is_instptr();\n-  const TypeInt* vlen             = gvn().type(argument(2))->is_int();\n-  const TypeInt* idx              = gvn().type(argument(4))->is_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     idx          = gvn().type(argument(4))->isa_int();\n@@ -1885,0 +1933,3 @@\n+  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL || idx == NULL) {\n+    return false; \/\/ dead code\n+  }\n@@ -1970,4 +2021,4 @@\n-  const TypeInstPtr* vector_klass = gvn().type(argument(0))->is_instptr();\n-  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->is_instptr();\n-  const TypeInt* vlen             = gvn().type(argument(2))->is_int();\n-  const TypeInt* idx              = gvn().type(argument(4))->is_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(0))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(1))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(2))->isa_int();\n+  const TypeInt*     idx          = gvn().type(argument(4))->isa_int();\n@@ -1975,0 +2026,3 @@\n+  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL || idx == NULL) {\n+    return false; \/\/ dead code\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":126,"deletions":72,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+  static bool is_shift_opcode(int opc);\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"oops\/klass.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -560,0 +560,16 @@\n+  { \"PrintSharedSpaces\",             JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceBiasedLocking\",            JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceClassLoading\",             JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceClassLoadingPreorder\",     JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceClassPaths\",               JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceClassResolution\",          JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceClassUnloading\",           JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceExceptions\",               JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceInvokeDynamic\",            JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceLoaderConstraints\",        JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceMethodHandles\",            JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceMonitorInflation\",         JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceSafepointCleanupTime\",     JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceJVMTIObjectTagging\",       JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"TraceRedefineClasses\",          JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"PrintJNIResolving\",             JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n@@ -587,38 +603,0 @@\n-\/\/ NOTE: A compatibility request will be necessary for each alias to be removed.\n-static AliasedLoggingFlag const aliased_logging_flags[] = {\n-  { \"PrintSharedSpaces\",         LogLevel::Info,  true,  LOG_TAGS(cds) },\n-  { \"TraceBiasedLocking\",        LogLevel::Info,  true,  LOG_TAGS(biasedlocking) },\n-  { \"TraceClassLoading\",         LogLevel::Info,  true,  LOG_TAGS(class, load) },\n-  { \"TraceClassLoadingPreorder\", LogLevel::Debug, true,  LOG_TAGS(class, preorder) },\n-  { \"TraceClassPaths\",           LogLevel::Info,  true,  LOG_TAGS(class, path) },\n-  { \"TraceClassResolution\",      LogLevel::Debug, true,  LOG_TAGS(class, resolve) },\n-  { \"TraceClassUnloading\",       LogLevel::Info,  true,  LOG_TAGS(class, unload) },\n-  { \"TraceExceptions\",           LogLevel::Info,  true,  LOG_TAGS(exceptions) },\n-  { \"TraceInvokeDynamic\",        LogLevel::Debug, true,  LOG_TAGS(methodhandles, indy) },\n-  { \"TraceLoaderConstraints\",    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },\n-  { \"TraceMethodHandles\",        LogLevel::Info,  true,  LOG_TAGS(methodhandles) },\n-  { \"TraceMonitorInflation\",     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },\n-  { \"TraceSafepointCleanupTime\", LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },\n-  { \"TraceJVMTIObjectTagging\",   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },\n-  { \"TraceRedefineClasses\",      LogLevel::Info,  false, LOG_TAGS(redefine, class) },\n-  { \"PrintJNIResolving\",         LogLevel::Debug, true,  LOG_TAGS(jni, resolve) },\n-  { NULL,                        LogLevel::Off,   false, LOG_TAGS(_NO_TAG) }\n-};\n-\n-#ifndef PRODUCT\n-\/\/ These options are removed in jdk9. Remove this code for jdk10.\n-static AliasedFlag const removed_develop_logging_flags[] = {\n-  { \"TraceClassInitialization\",   \"-Xlog:class+init\" },\n-  { \"TraceClassLoaderData\",       \"-Xlog:class+loader+data\" },\n-  { \"TraceDefaultMethods\",        \"-Xlog:defaultmethods=debug\" },\n-  { \"TraceItables\",               \"-Xlog:itables=debug\" },\n-  { \"TraceMonitorMismatch\",       \"-Xlog:monitormismatch=info\" },\n-  { \"TraceSafepoint\",             \"-Xlog:safepoint=debug\" },\n-  { \"TraceStartupTime\",           \"-Xlog:startuptime\" },\n-  { \"TraceVMOperation\",           \"-Xlog:vmoperation=debug\" },\n-  { \"PrintVtables\",               \"-Xlog:vtables=debug\" },\n-  { \"VerboseVerification\",        \"-Xlog:verification\" },\n-  { NULL, NULL }\n-};\n-#endif \/\/PRODUCT\n-\n@@ -688,12 +666,0 @@\n-#ifndef PRODUCT\n-const char* Arguments::removed_develop_logging_flag_name(const char* name){\n-  for (size_t i = 0; removed_develop_logging_flags[i].alias_name != NULL; i++) {\n-    const AliasedFlag& flag = removed_develop_logging_flags[i];\n-    if (strcmp(flag.alias_name, name) == 0) {\n-      return flag.real_name;\n-    }\n-  }\n-  return NULL;\n-}\n-#endif \/\/ PRODUCT\n-\n@@ -1017,38 +983,0 @@\n-void log_deprecated_flag(const char* name, bool on, AliasedLoggingFlag alf) {\n-  LogTagType tagSet[] = {alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5};\n-  \/\/ Set tagset string buffer at max size of 256, large enough for any alias tagset\n-  const int max_tagset_size = 256;\n-  int max_tagset_len = max_tagset_size - 1;\n-  char tagset_buffer[max_tagset_size];\n-  tagset_buffer[0] = '\\0';\n-\n-  \/\/ Write tag-set for aliased logging option, in string list form\n-  int max_tags = sizeof(tagSet)\/sizeof(tagSet[0]);\n-  for (int i = 0; i < max_tags && tagSet[i] != LogTag::__NO_TAG; i++) {\n-    if (i > 0) {\n-      strncat(tagset_buffer, \"+\", max_tagset_len - strlen(tagset_buffer));\n-    }\n-    strncat(tagset_buffer, LogTag::name(tagSet[i]), max_tagset_len - strlen(tagset_buffer));\n-  }\n-  if (!alf.exactMatch) {\n-      strncat(tagset_buffer, \"*\", max_tagset_len - strlen(tagset_buffer));\n-  }\n-  log_warning(arguments)(\"-XX:%s%s is deprecated. Will use -Xlog:%s=%s instead.\",\n-                         (on) ? \"+\" : \"-\",\n-                         name,\n-                         tagset_buffer,\n-                         (on) ? LogLevel::name(alf.level) : \"off\");\n-}\n-\n-AliasedLoggingFlag Arguments::catch_logging_aliases(const char* name, bool on){\n-  for (size_t i = 0; aliased_logging_flags[i].alias_name != NULL; i++) {\n-    const AliasedLoggingFlag& alf = aliased_logging_flags[i];\n-    if (strcmp(alf.alias_name, name) == 0) {\n-      log_deprecated_flag(name, on, alf);\n-      return alf;\n-    }\n-  }\n-  AliasedLoggingFlag a = {NULL, LogLevel::Off, false, LOG_TAGS(_NO_TAG)};\n-  return a;\n-}\n-\n@@ -1066,5 +994,0 @@\n-    AliasedLoggingFlag alf = catch_logging_aliases(name, false);\n-    if (alf.alias_name != NULL){\n-      LogConfiguration::configure_stdout(LogLevel::Off, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);\n-      return true;\n-    }\n@@ -1079,5 +1002,0 @@\n-    AliasedLoggingFlag alf = catch_logging_aliases(name, true);\n-    if (alf.alias_name != NULL){\n-      LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);\n-      return true;\n-    }\n@@ -1097,5 +1015,0 @@\n-    AliasedLoggingFlag alf = catch_logging_aliases(name, true);\n-    if (alf.alias_name != NULL) {\n-      LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);\n-      return true;\n-    }\n@@ -1300,11 +1213,0 @@\n-#ifndef PRODUCT\n-    else {\n-      const char* replacement;\n-      if ((replacement = removed_develop_logging_flag_name(stripped_argname)) != NULL){\n-        log_warning(arguments)(\"%s has been removed. Please use %s instead.\",\n-                               stripped_argname,\n-                               replacement);\n-        return false;\n-      }\n-    }\n-#endif \/\/PRODUCT\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":16,"deletions":114,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -722,0 +722,16 @@\n+inline jlong max_signed_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return max_jint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return max_jlong;\n+}\n+\n+inline jlong min_signed_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return min_jint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return min_jlong;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -660,2 +660,0 @@\n-                case VECTOR_OP_OR: return (v0, v1) ->\n-                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n@@ -2320,2 +2318,0 @@\n-              case VECTOR_OP_OR: return v ->\n-                      toBits(v.rOp((double)0, (i, a, b) -> fromBits(toBits(a) | toBits(b))));\n@@ -2337,2 +2333,0 @@\n-                case VECTOR_OP_OR:\n-                case VECTOR_OP_XOR:\n@@ -2342,2 +2336,0 @@\n-                case VECTOR_OP_AND:\n-                    return v -> v.broadcast(-1);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -660,2 +660,0 @@\n-                case VECTOR_OP_OR: return (v0, v1) ->\n-                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n@@ -2340,2 +2338,0 @@\n-              case VECTOR_OP_OR: return v ->\n-                      toBits(v.rOp((float)0, (i, a, b) -> fromBits(toBits(a) | toBits(b))));\n@@ -2357,2 +2353,0 @@\n-                case VECTOR_OP_OR:\n-                case VECTOR_OP_XOR:\n@@ -2362,2 +2356,0 @@\n-                case VECTOR_OP_AND:\n-                    return v -> v.broadcast(-1);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -723,2 +723,0 @@\n-                case VECTOR_OP_OR: return (v0, v1) ->\n-                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n@@ -2833,4 +2831,0 @@\n-#if[FP]\n-              case VECTOR_OP_OR: return v ->\n-                      toBits(v.rOp(($type$)0, (i, a, b) -> fromBits(toBits(a) | toBits(b))));\n-#end[FP]\n@@ -2852,0 +2846,1 @@\n+#if[BITWISE]\n@@ -2854,0 +2849,1 @@\n+#end[BITWISE]\n@@ -2857,0 +2853,1 @@\n+#if[BITWISE]\n@@ -2859,0 +2856,1 @@\n+#end[BITWISE]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"}]}