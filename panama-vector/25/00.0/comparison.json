{"files":[{"patch":"@@ -804,1 +804,1 @@\n-            (self.reg.number, self.adr.base.number) = random.sample(range(31), 2)\n+            (self.reg.number, self.adr.base.number) = random.sample(list(set(range(31)) - set([18])), 2)\n@@ -844,1 +844,1 @@\n-                  (self.reg[0].number, self.reg[1].number, self.base.number) = random.sample(range(31), 3)\n+                  (self.reg[0].number, self.reg[1].number, self.base.number) = random.sample(list(set(range(31)) - set([18])), 3)\n@@ -846,1 +846,1 @@\n-                  self.base.number = random.choice(list(set(range(31)) - set([self.reg[0].number, self.reg[1].number])))\n+                  self.base.number = random.choice(list(set(range(31)) - set([self.reg[0].number, self.reg[1].number, 18])))\n@@ -848,1 +848,1 @@\n-              (self.reg[0].number, self.reg[1].number) = random.sample(range(31), 2)\n+              (self.reg[0].number, self.reg[1].number) = random.sample(list(set(range(31)) - set([18])), 2)\n@@ -1337,4 +1337,3 @@\n-         [[\"fmuls\", \"sss\"], [\"fdivs\", \"sss\"], [\"fadds\", \"sss\"], [\"fsubs\", \"sss\"],\n-          [\"fmuls\", \"sss\"],\n-          [\"fmuld\", \"ddd\"], [\"fdivd\", \"ddd\"], [\"faddd\", \"ddd\"], [\"fsubd\", \"ddd\"],\n-          [\"fmuld\", \"ddd\"]])\n+         [[\"fabds\", \"sss\"], [\"fmuls\", \"sss\"], [\"fdivs\", \"sss\"], [\"fadds\", \"sss\"], [\"fsubs\", \"sss\"],\n+          [\"fabdd\", \"ddd\"], [\"fmuld\", \"ddd\"], [\"fdivd\", \"ddd\"], [\"faddd\", \"ddd\"], [\"fsubd\", \"ddd\"],\n+          ])\n@@ -1440,0 +1439,2 @@\n+          [\"fabd\", \"fabd\", \"2S\"], [\"fabd\", \"fabd\", \"4S\"],\n+          [\"fabd\", \"fabd\", \"2D\"],\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64-asmtest.py","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1756,1 +1756,3 @@\n-  \/\/   far_call(addr)\n+  \/\/   bl(addr)\n+  \/\/ or with far branches\n+  \/\/   bl(trampoline_stub)\n@@ -1765,1 +1767,1 @@\n-    return MacroAssembler::far_branch_size();\n+    return 1 * NativeInstruction::instruction_size;\n@@ -2535,5 +2537,0 @@\n-\/\/ AES support not yet implemented\n-const bool Matcher::pass_original_key_for_aes() {\n-  return false;\n-}\n-\n@@ -4123,7 +4120,0 @@\n-  \/\/ Number of stack slots between incoming argument block and the start of\n-  \/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n-  \/\/ EPILOG must remove this many slots. aarch64 needs two slots for\n-  \/\/ return address and fp.\n-  \/\/ TODO think this is correct but check\n-  in_preserve_stack_slots(4);\n-\n@@ -4148,19 +4138,0 @@\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots.  Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count.  Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE.  Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-\n-  calling_convention\n-  %{\n-    \/\/ No difference between ingoing\/outgoing just pass false\n-    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);\n-  %}\n-\n-  c_calling_convention\n-  %{\n-    \/\/ This is obviously always outgoing\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, NULL, length);\n-  %}\n-\n@@ -8910,0 +8881,11 @@\n+instruct castLL(iRegL dst)\n+%{\n+  match(Set dst (CastLL dst));\n+\n+  size(0);\n+  format %{ \"# castLL of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n@@ -12425,1 +12407,1 @@\n- \n+\n@@ -12732,1 +12714,1 @@\n-\/\/ Rotations \n+\/\/ Rotations\n@@ -12807,3 +12789,1 @@\n-\n-\/\/ rol expander\n-instruct rolL_rReg(iRegLNoSp dst, iRegL src, iRegI shift, rFlagsReg cr)\n+instruct rorI_imm(iRegINoSp dst, iRegI src, immI shift)\n@@ -12811,1 +12791,1 @@\n-  effect(DEF dst, USE src, USE shift);\n+  match(Set dst (RotateRight src shift));\n@@ -12813,17 +12793,2 @@\n-  format %{ \"rol    $dst, $src, $shift\" %}\n-  ins_cost(INSN_COST * 3);\n-  ins_encode %{\n-    __ subw(rscratch1, zr, as_Register($shift$$reg));\n-    __ rorv(as_Register($dst$$reg), as_Register($src$$reg),\n-            rscratch1);\n-    %}\n-  ins_pipe(ialu_reg_reg_vshift);\n-%}\n-\n-\/\/ This pattern is automatically generated from aarch64_ad.m4\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-\n-\/\/ rol expander\n-instruct rolI_rReg(iRegINoSp dst, iRegI src, iRegI shift, rFlagsReg cr)\n-%{\n-  effect(DEF dst, USE src, USE shift);\n+  ins_cost(INSN_COST);\n+  format %{ \"ror    $dst, $src, $shift\" %}\n@@ -12831,28 +12796,2 @@\n-  format %{ \"rol    $dst, $src, $shift\" %}\n-  ins_cost(INSN_COST * 3);\n-    __ subw(rscratch1, zr, as_Register($shift$$reg));\n-    __ rorvw(as_Register($dst$$reg), as_Register($src$$reg),\n-            rscratch1);\n-    %}\n-  ins_pipe(ialu_reg_reg_vshift);\n-%}\n-\n-\/\/ This pattern is automatically generated from aarch64_ad.m4\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct rolL_rReg_Var_C_64(iRegLNoSp dst, iRegL src, iRegI shift, immI_64 c_64, rFlagsReg cr)\n-%{\n-  match(Set dst (OrL (LShiftL src shift) (URShiftL src (SubI c_64 shift))));\n-\n-  expand %{\n-    rolL_rReg(dst, src, shift, cr);\n-  %}\n-%}\n-\n-\/\/ This pattern is automatically generated from aarch64_ad.m4\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct rolL_rReg_Var_C0(iRegLNoSp dst, iRegL src, iRegI shift, immI0 c0, rFlagsReg cr)\n-%{\n-  match(Set dst (OrL (LShiftL src shift) (URShiftL src (SubI c0 shift))));\n-\n-  expand %{\n-    rolL_rReg(dst, src, shift, cr);\n+     __ extrw(as_Register($dst$$reg), as_Register($src$$reg), as_Register($src$$reg),\n+               $shift$$constant & 0x1f);\n@@ -12861,0 +12800,1 @@\n+  ins_pipe(ialu_reg_reg_vshift);\n@@ -12865,1 +12805,1 @@\n-instruct rolI_rReg_Var_C_32(iRegINoSp dst, iRegI src, iRegI shift, immI_32 c_32, rFlagsReg cr)\n+instruct rorL_imm(iRegLNoSp dst, iRegL src, immI shift)\n@@ -12867,6 +12807,1 @@\n-  match(Set dst (OrI (LShiftI src shift) (URShiftI src (SubI c_32 shift))));\n-\n-  expand %{\n-    rolI_rReg(dst, src, shift, cr);\n-  %}\n-%}\n+  match(Set dst (RotateRight src shift));\n@@ -12874,5 +12809,2 @@\n-\/\/ This pattern is automatically generated from aarch64_ad.m4\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct rolI_rReg_Var_C0(iRegINoSp dst, iRegI src, iRegI shift, immI0 c0, rFlagsReg cr)\n-%{\n-  match(Set dst (OrI (LShiftI src shift) (URShiftI src (SubI c0 shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ror    $dst, $src, $shift\" %}\n@@ -12880,2 +12812,3 @@\n-  expand %{\n-    rolI_rReg(dst, src, shift, cr);\n+  ins_encode %{\n+     __ extr(as_Register($dst$$reg), as_Register($src$$reg), as_Register($src$$reg),\n+               $shift$$constant & 0x3f);\n@@ -12883,0 +12816,1 @@\n+  ins_pipe(ialu_reg_reg_vshift);\n@@ -12887,3 +12821,1 @@\n-\n-\/\/ ror expander\n-instruct rorL_rReg(iRegLNoSp dst, iRegL src, iRegI shift, rFlagsReg cr)\n+instruct rorI_reg(iRegINoSp dst, iRegI src, iRegI shift)\n@@ -12891,1 +12823,1 @@\n-  effect(DEF dst, USE src, USE shift);\n+  match(Set dst (RotateRight src shift));\n@@ -12893,1 +12825,2 @@\n-  format %{ \"ror    $dst, $src, $shift\" %}\n+  format %{ \"ror    $dst, $src, $shift\" %}\n+\n@@ -12896,3 +12829,2 @@\n-    __ rorv(as_Register($dst$$reg), as_Register($src$$reg),\n-            as_Register($shift$$reg));\n-    %}\n+     __ rorvw(as_Register($dst$$reg), as_Register($src$$reg), as_Register($shift$$reg));\n+  %}\n@@ -12904,3 +12836,1 @@\n-\n-\/\/ ror expander\n-instruct rorI_rReg(iRegINoSp dst, iRegI src, iRegI shift, rFlagsReg cr)\n+instruct rorL_reg(iRegLNoSp dst, iRegL src, iRegI shift)\n@@ -12908,1 +12838,1 @@\n-  effect(DEF dst, USE src, USE shift);\n+  match(Set dst (RotateRight src shift));\n@@ -12910,1 +12840,2 @@\n-  format %{ \"ror    $dst, $src, $shift\" %}\n+  format %{ \"ror    $dst, $src, $shift\" %}\n+\n@@ -12913,3 +12844,2 @@\n-    __ rorvw(as_Register($dst$$reg), as_Register($src$$reg),\n-            as_Register($shift$$reg));\n-    %}\n+     __ rorv(as_Register($dst$$reg), as_Register($src$$reg), as_Register($shift$$reg));\n+  %}\n@@ -12921,1 +12851,1 @@\n-instruct rorL_rReg_Var_C_64(iRegLNoSp dst, iRegL src, iRegI shift, immI_64 c_64, rFlagsReg cr)\n+instruct rolI_reg(iRegINoSp dst, iRegI src, iRegI shift)\n@@ -12923,6 +12853,1 @@\n-  match(Set dst (OrL (URShiftL src shift) (LShiftL src (SubI c_64 shift))));\n-\n-  expand %{\n-    rorL_rReg(dst, src, shift, cr);\n-  %}\n-%}\n+  match(Set dst (RotateLeft src shift));\n@@ -12930,5 +12855,2 @@\n-\/\/ This pattern is automatically generated from aarch64_ad.m4\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct rorL_rReg_Var_C0(iRegLNoSp dst, iRegL src, iRegI shift, immI0 c0, rFlagsReg cr)\n-%{\n-  match(Set dst (OrL (URShiftL src shift) (LShiftL src (SubI c0 shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"rol    $dst, $src, $shift\" %}\n@@ -12936,2 +12858,3 @@\n-  expand %{\n-    rorL_rReg(dst, src, shift, cr);\n+  ins_encode %{\n+     __ subw(rscratch1, zr, as_Register($shift$$reg));\n+     __ rorvw(as_Register($dst$$reg), as_Register($src$$reg), rscratch1);\n@@ -12939,0 +12862,1 @@\n+  ins_pipe(ialu_reg_reg_vshift);\n@@ -12943,1 +12867,1 @@\n-instruct rorI_rReg_Var_C_32(iRegINoSp dst, iRegI src, iRegI shift, immI_32 c_32, rFlagsReg cr)\n+instruct rolL_reg(iRegLNoSp dst, iRegL src, iRegI shift)\n@@ -12945,6 +12869,1 @@\n-  match(Set dst (OrI (URShiftI src shift) (LShiftI src (SubI c_32 shift))));\n-\n-  expand %{\n-    rorI_rReg(dst, src, shift, cr);\n-  %}\n-%}\n+  match(Set dst (RotateLeft src shift));\n@@ -12952,5 +12871,2 @@\n-\/\/ This pattern is automatically generated from aarch64_ad.m4\n-\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n-instruct rorI_rReg_Var_C0(iRegINoSp dst, iRegI src, iRegI shift, immI0 c0, rFlagsReg cr)\n-%{\n-  match(Set dst (OrI (URShiftI src shift) (LShiftI src (SubI c0 shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"rol    $dst, $src, $shift\" %}\n@@ -12958,2 +12874,3 @@\n-  expand %{\n-    rorI_rReg(dst, src, shift, cr);\n+  ins_encode %{\n+     __ subw(rscratch1, zr, as_Register($shift$$reg));\n+     __ rorv(as_Register($dst$$reg), as_Register($src$$reg), rscratch1);\n@@ -12961,0 +12878,1 @@\n+  ins_pipe(ialu_reg_reg_vshift);\n@@ -13997,0 +13915,28 @@\n+instruct absdF_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (AbsF (SubF src1 src2)));\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{ \"fabds   $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fabds(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_uop_s);\n+%}\n+\n+instruct absdD_reg(vRegD dst, vRegD src1, vRegD src2) %{\n+  match(Set dst (AbsD (SubD src1 src2)));\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{ \"fabdd   $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fabdd(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src1$$reg),\n+             as_FloatRegister($src2$$reg));\n+  %}\n+\n+  ins_pipe(fp_uop_d);\n+%}\n+\n@@ -17975,123 +17921,0 @@\n-\/\/ --------------------------------- ABS --------------------------------------\n-\n-instruct vabs8B(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4 ||\n-            n->as_Vector()->length() == 8);\n-  match(Set dst (AbsVB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (8B)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T8B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs16B(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 16);\n-  match(Set dst (AbsVB src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (16B)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T16B, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs4S(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (4H)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T4H, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs8S(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 8);\n-  match(Set dst (AbsVS src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (8H)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T8H, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2I(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical64);\n-%}\n-\n-instruct vabs4I(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVI src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2L(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVL src));\n-  ins_cost(INSN_COST);\n-  format %{ \"abs  $dst, $src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ absr(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vlogical128);\n-%}\n-\n-instruct vabs2F(vecD dst, vecD src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst,$src\\t# vector (2S)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T2S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp64);\n-%}\n-\n-instruct vabs4F(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 4);\n-  match(Set dst (AbsVF src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst,$src\\t# vector (4S)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n-instruct vabs2D(vecX dst, vecX src)\n-%{\n-  predicate(n->as_Vector()->length() == 2);\n-  match(Set dst (AbsVD src));\n-  ins_cost(INSN_COST * 3);\n-  format %{ \"fabs  $dst,$src\\t# vector (2D)\" %}\n-  ins_encode %{\n-    __ fabs(as_FloatRegister($dst$$reg), __ T2D, as_FloatRegister($src$$reg));\n-  %}\n-  ins_pipe(vunop_fp128);\n-%}\n-\n@@ -18943,0 +18766,210 @@\n+instruct vsraa8B_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (8B)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 8) sh = 7;\n+    __ ssra(as_FloatRegister($dst$$reg), __ T8B,\n+           as_FloatRegister($src$$reg), sh);\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsraa16B_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 16);\n+  match(Set dst (AddVB dst (RShiftVB src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (16B)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 8) sh = 7;\n+    __ ssra(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src$$reg), sh);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsraa4S_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (4H)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 16) sh = 15;\n+    __ ssra(as_FloatRegister($dst$$reg), __ T4H,\n+           as_FloatRegister($src$$reg), sh);\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsraa8S_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (AddVS dst (RShiftVS src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (8H)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 16) sh = 15;\n+    __ ssra(as_FloatRegister($dst$$reg), __ T8H,\n+           as_FloatRegister($src$$reg), sh);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsraa2I_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (2S)\" %}\n+  ins_encode %{\n+    __ ssra(as_FloatRegister($dst$$reg), __ T2S,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsraa4I_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (AddVI dst (RShiftVI src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (4S)\" %}\n+  ins_encode %{\n+    __ ssra(as_FloatRegister($dst$$reg), __ T4S,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsraa2L_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (AddVL dst (RShiftVL src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"ssra    $dst, $src, $shift\\t# vector (2D)\" %}\n+  ins_encode %{\n+    __ ssra(as_FloatRegister($dst$$reg), __ T2D,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsrla8B_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (8B)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 8) {\n+      __ eor(as_FloatRegister($src$$reg), __ T8B,\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    } else {\n+      __ usra(as_FloatRegister($dst$$reg), __ T8B,\n+             as_FloatRegister($src$$reg), sh);\n+    }\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsrla16B_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 16);\n+  match(Set dst (AddVB dst (URShiftVB src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (16B)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 8) {\n+      __ eor(as_FloatRegister($src$$reg), __ T16B,\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    } else {\n+      __ usra(as_FloatRegister($dst$$reg), __ T16B,\n+             as_FloatRegister($src$$reg), sh);\n+    }\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsrla4S_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (4H)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 16) {\n+      __ eor(as_FloatRegister($src$$reg), __ T8B,\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    } else {\n+      __ ushr(as_FloatRegister($dst$$reg), __ T4H,\n+             as_FloatRegister($src$$reg), sh);\n+    }\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsrla8S_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 8);\n+  match(Set dst (AddVS dst (URShiftVS src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (8H)\" %}\n+  ins_encode %{\n+    int sh = (int)$shift$$constant;\n+    if (sh >= 16) {\n+      __ eor(as_FloatRegister($src$$reg), __ T16B,\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    } else {\n+      __ usra(as_FloatRegister($dst$$reg), __ T8H,\n+             as_FloatRegister($src$$reg), sh);\n+    }\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsrla2I_imm(vecD dst, vecD src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (2S)\" %}\n+  ins_encode %{\n+    __ usra(as_FloatRegister($dst$$reg), __ T2S,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift64_imm);\n+%}\n+\n+instruct vsrla4I_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 4);\n+  match(Set dst (AddVI dst (URShiftVI src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (4S)\" %}\n+  ins_encode %{\n+    __ usra(as_FloatRegister($dst$$reg), __ T4S,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n+instruct vsrla2L_imm(vecX dst, vecX src, immI shift) %{\n+  predicate(n->as_Vector()->length() == 2);\n+  match(Set dst (AddVL dst (URShiftVL src (RShiftCntV shift))));\n+  ins_cost(INSN_COST);\n+  format %{ \"usra    $dst, $src, $shift\\t# vector (2D)\" %}\n+  ins_encode %{\n+    __ usra(as_FloatRegister($dst$$reg), __ T2D,\n+            as_FloatRegister($src$$reg),\n+            (int)$shift$$constant);\n+  %}\n+  ins_pipe(vshift128_imm);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":298,"deletions":265,"binary":false,"changes":563,"status":"modified"},{"patch":"@@ -2089,1 +2089,1 @@\n-  match(Set dst (RShiftVB src shift));\n+  match(Set dst (RShiftVB src (RShiftCntV shift)));\n@@ -2108,1 +2108,1 @@\n-  match(Set dst (RShiftVS src shift));\n+  match(Set dst (RShiftVS src (RShiftCntV shift)));\n@@ -2127,1 +2127,1 @@\n-  match(Set dst (RShiftVI src shift));\n+  match(Set dst (RShiftVI src (RShiftCntV shift)));\n@@ -2145,1 +2145,1 @@\n-  match(Set dst (RShiftVL src shift));\n+  match(Set dst (RShiftVL src (RShiftCntV shift)));\n@@ -2163,1 +2163,1 @@\n-  match(Set dst (URShiftVB src shift));\n+  match(Set dst (URShiftVB src (RShiftCntV shift)));\n@@ -2186,1 +2186,1 @@\n-  match(Set dst (URShiftVS src shift));\n+  match(Set dst (URShiftVS src (RShiftCntV shift)));\n@@ -2196,1 +2196,1 @@\n-    if (con >= 8) {\n+    if (con >= 16) {\n@@ -2209,1 +2209,1 @@\n-  match(Set dst (URShiftVI src shift));\n+  match(Set dst (URShiftVI src (RShiftCntV shift)));\n@@ -2227,1 +2227,1 @@\n-  match(Set dst (URShiftVL src shift));\n+  match(Set dst (URShiftVL src (RShiftCntV shift)));\n@@ -2245,1 +2245,1 @@\n-  match(Set dst (LShiftVB src shift));\n+  match(Set dst (LShiftVB src (LShiftCntV shift)));\n@@ -2263,1 +2263,1 @@\n-  match(Set dst (LShiftVS src shift));\n+  match(Set dst (LShiftVS src (LShiftCntV shift)));\n@@ -2268,1 +2268,1 @@\n-    if (con >= 8) {\n+    if (con >= 16) {\n@@ -2281,1 +2281,1 @@\n-  match(Set dst (LShiftVI src shift));\n+  match(Set dst (LShiftVI src (LShiftCntV shift)));\n@@ -2294,1 +2294,1 @@\n-  match(Set dst (LShiftVL src shift));\n+  match(Set dst (LShiftVL src (LShiftCntV shift)));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1298,2 +1298,2 @@\n-dnl VSHIFT_IMM_UNPREDICATE($1,        $2,      $3,   $4,          $5  )\n-dnl VSHIFT_IMM_UNPREDICATE(insn_name, op_name, size, min_vec_len, insn)\n+dnl VSHIFT_IMM_UNPREDICATE($1,        $2,      $3,       $4,   $5,          $6  )\n+dnl VSHIFT_IMM_UNPREDICATE(insn_name, op_name, op_name2, size, min_vec_len, insn)\n@@ -1302,2 +1302,2 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() >= $4);\n-  match(Set dst ($2 src shift));\n+  predicate(UseSVE > 0 && n->as_Vector()->length() >= $5);\n+  match(Set dst ($2 src ($3 shift)));\n@@ -1305,1 +1305,1 @@\n-  format %{ \"$5 $dst, $src, $shift\\t# vector (sve) ($3)\" %}\n+  format %{ \"$6 $dst, $src, $shift\\t# vector (sve) ($4)\" %}\n@@ -1314,2 +1314,2 @@\n-ifelse(eval(index(`$1', `vasr') == 0), 1, `ifelse(eval(index(`$3', `B') == 0), 1, `\n-    if (con >= 8) con = 7;')ifelse(eval(index(`$3', `H') == 0), 1, `\n+ifelse(eval(index(`$1', `vasr') == 0), 1, `ifelse(eval(index(`$4', `B') == 0), 1, `\n+    if (con >= 8) con = 7;')ifelse(eval(index(`$4', `H') == 0), 1, `\n@@ -1317,1 +1317,1 @@\n-ifelse(eval((index(`$1', `vlsl') == 0 || index(`$1', `vlsr') == 0) && (index(`$3', `B') == 0 || index(`$3', `H') == 0)), 1, `\n+ifelse(eval(index(`$1', `vlsl') == 0  || index(`$1', `vlsr') == 0), 1, `ifelse(eval(index(`$4', `B') == 0), 1, `\n@@ -1322,2 +1322,7 @@\n-    }')\n-    __ $5(as_FloatRegister($dst$$reg), __ $3,\n+    }')ifelse(eval(index(`$4', `H') == 0), 1, `\n+    if (con >= 16) {\n+      __ sve_eor(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+      return;\n+    }')')\n+    __ $6(as_FloatRegister($dst$$reg), __ $4,\n@@ -1357,12 +1362,12 @@\n-VSHIFT_IMM_UNPREDICATE(vasrB_imm, RShiftVB,  B, 16, sve_asr)\n-VSHIFT_IMM_UNPREDICATE(vasrS_imm, RShiftVS,  H,  8, sve_asr)\n-VSHIFT_IMM_UNPREDICATE(vasrI_imm, RShiftVI,  S,  4, sve_asr)\n-VSHIFT_IMM_UNPREDICATE(vasrL_imm, RShiftVL,  D,  2, sve_asr)\n-VSHIFT_IMM_UNPREDICATE(vlsrB_imm, URShiftVB, B, 16, sve_lsr)\n-VSHIFT_IMM_UNPREDICATE(vlsrS_imm, URShiftVS, H,  8, sve_lsr)\n-VSHIFT_IMM_UNPREDICATE(vlsrI_imm, URShiftVI, S,  4, sve_lsr)\n-VSHIFT_IMM_UNPREDICATE(vlsrL_imm, URShiftVL, D,  2, sve_lsr)\n-VSHIFT_IMM_UNPREDICATE(vlslB_imm, LShiftVB,  B, 16, sve_lsl)\n-VSHIFT_IMM_UNPREDICATE(vlslS_imm, LShiftVS,  H,  8, sve_lsl)\n-VSHIFT_IMM_UNPREDICATE(vlslI_imm, LShiftVI,  S,  4, sve_lsl)\n-VSHIFT_IMM_UNPREDICATE(vlslL_imm, LShiftVL,  D,  2, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vasrB_imm, RShiftVB,  RShiftCntV, B, 16, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrS_imm, RShiftVS,  RShiftCntV, H,  8, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrI_imm, RShiftVI,  RShiftCntV, S,  4, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vasrL_imm, RShiftVL,  RShiftCntV, D,  2, sve_asr)\n+VSHIFT_IMM_UNPREDICATE(vlsrB_imm, URShiftVB, RShiftCntV, B, 16, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrS_imm, URShiftVS, RShiftCntV, H,  8, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrI_imm, URShiftVI, RShiftCntV, S,  4, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlsrL_imm, URShiftVL, RShiftCntV, D,  2, sve_lsr)\n+VSHIFT_IMM_UNPREDICATE(vlslB_imm, LShiftVB,  LShiftCntV, B, 16, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslS_imm, LShiftVS,  LShiftCntV, H,  8, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslI_imm, LShiftVI,  LShiftCntV, S,  4, sve_lsl)\n+VSHIFT_IMM_UNPREDICATE(vlslL_imm, LShiftVL,  LShiftCntV, D,  2, sve_lsl)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-    __ str(r11, Address(__ pre(r0, 8)));               \/\/       str     x11, [x0, 8]!\n+    __ str(r10, Address(__ pre(r0, 8)));               \/\/       str     x10, [x0, 8]!\n@@ -342,3 +342,3 @@\n-    __ strb(r11, Address(__ pre(r14, 9)));             \/\/       strb    w11, [x14, 9]!\n-    __ strh(r29, Address(__ pre(r24, -3)));            \/\/       strh    w29, [x24, -3]!\n-    __ ldr(r13, Address(__ pre(r17, -144)));           \/\/       ldr     x13, [x17, -144]!\n+    __ strb(r10, Address(__ pre(r14, 9)));             \/\/       strb    w10, [x14, 9]!\n+    __ strh(r29, Address(__ pre(r25, -3)));            \/\/       strh    w29, [x25, -3]!\n+    __ ldr(r12, Address(__ pre(r16, -144)));           \/\/       ldr     x12, [x16, -144]!\n@@ -346,1 +346,1 @@\n-    __ ldrb(r13, Address(__ pre(r12, -10)));           \/\/       ldrb    w13, [x12, -10]!\n+    __ ldrb(r13, Address(__ pre(r11, -10)));           \/\/       ldrb    w13, [x11, -10]!\n@@ -348,1 +348,1 @@\n-    __ ldrsb(r23, Address(__ pre(r7, 4)));             \/\/       ldrsb   x23, [x7, 4]!\n+    __ ldrsb(r23, Address(__ pre(r6, 4)));             \/\/       ldrsb   x23, [x6, 4]!\n@@ -350,2 +350,2 @@\n-    __ ldrshw(r28, Address(__ pre(r5, -7)));           \/\/       ldrsh   w28, [x5, -7]!\n-    __ ldrsw(r24, Address(__ pre(r9, -18)));           \/\/       ldrsw   x24, [x9, -18]!\n+    __ ldrshw(r28, Address(__ pre(r4, -7)));           \/\/       ldrsh   w28, [x4, -7]!\n+    __ ldrsw(r24, Address(__ pre(r8, -18)));           \/\/       ldrsw   x24, [x8, -18]!\n@@ -359,2 +359,2 @@\n-    __ str(r4, Address(__ post(r28, -94)));            \/\/       str     x4, [x28], -94\n-    __ strw(r12, Address(__ post(r7, -54)));           \/\/       str     w12, [x7], -54\n+    __ str(r3, Address(__ post(r28, -94)));            \/\/       str     x3, [x28], -94\n+    __ strw(r11, Address(__ post(r7, -54)));           \/\/       str     w11, [x7], -54\n@@ -362,4 +362,4 @@\n-    __ strh(r6, Address(__ post(r8, 27)));             \/\/       strh    w6, [x8], 27\n-    __ ldr(r14, Address(__ post(r10, -202)));          \/\/       ldr     x14, [x10], -202\n-    __ ldrw(r16, Address(__ post(r5, -41)));           \/\/       ldr     w16, [x5], -41\n-    __ ldrb(r2, Address(__ post(r14, 9)));             \/\/       ldrb    w2, [x14], 9\n+    __ strh(r6, Address(__ post(r7, 27)));             \/\/       strh    w6, [x7], 27\n+    __ ldr(r13, Address(__ post(r10, -202)));          \/\/       ldr     x13, [x10], -202\n+    __ ldrw(r15, Address(__ post(r5, -41)));           \/\/       ldr     w15, [x5], -41\n+    __ ldrb(r2, Address(__ post(r13, 9)));             \/\/       ldrb    w2, [x13], 9\n@@ -513,10 +513,10 @@\n-    __ fmuls(v27, v10, v3);                            \/\/       fmul    s27, s10, s3\n-    __ fdivs(v0, v7, v25);                             \/\/       fdiv    s0, s7, s25\n-    __ fadds(v9, v6, v15);                             \/\/       fadd    s9, s6, s15\n-    __ fsubs(v29, v15, v10);                           \/\/       fsub    s29, s15, s10\n-    __ fmuls(v2, v17, v7);                             \/\/       fmul    s2, s17, s7\n-    __ fmuld(v11, v11, v23);                           \/\/       fmul    d11, d11, d23\n-    __ fdivd(v7, v29, v23);                            \/\/       fdiv    d7, d29, d23\n-    __ faddd(v14, v27, v11);                           \/\/       fadd    d14, d27, d11\n-    __ fsubd(v11, v4, v24);                            \/\/       fsub    d11, d4, d24\n-    __ fmuld(v12, v15, v14);                           \/\/       fmul    d12, d15, d14\n+    __ fabds(v27, v10, v3);                            \/\/       fabd    s27, s10, s3\n+    __ fmuls(v0, v7, v25);                             \/\/       fmul    s0, s7, s25\n+    __ fdivs(v9, v6, v15);                             \/\/       fdiv    s9, s6, s15\n+    __ fadds(v29, v15, v10);                           \/\/       fadd    s29, s15, s10\n+    __ fsubs(v2, v17, v7);                             \/\/       fsub    s2, s17, s7\n+    __ fabdd(v11, v11, v23);                           \/\/       fabd    d11, d11, d23\n+    __ fmuld(v7, v29, v23);                            \/\/       fmul    d7, d29, d23\n+    __ fdivd(v14, v27, v11);                           \/\/       fdiv    d14, d27, d11\n+    __ faddd(v11, v4, v24);                            \/\/       fadd    d11, d4, d24\n+    __ fsubd(v12, v15, v14);                           \/\/       fsub    d12, d15, d14\n@@ -569,1 +569,1 @@\n-    __ ldpsw(r17, r10, Address(r11, -80));             \/\/       ldpsw   x17, x10, [x11, #-80]\n+    __ ldpsw(r16, r10, Address(r11, -80));             \/\/       ldpsw   x16, x10, [x11, #-80]\n@@ -575,2 +575,2 @@\n-    __ ldpw(r30, r16, Address(__ pre(r2, -144)));      \/\/       ldp     w30, w16, [x2, #-144]!\n-    __ ldpsw(r4, r1, Address(__ pre(r26, -144)));      \/\/       ldpsw   x4, x1, [x26, #-144]!\n+    __ ldpw(r30, r15, Address(__ pre(r2, -144)));      \/\/       ldp     w30, w15, [x2, #-144]!\n+    __ ldpsw(r4, r1, Address(__ pre(r27, -144)));      \/\/       ldpsw   x4, x1, [x27, #-144]!\n@@ -583,2 +583,2 @@\n-    __ ldpsw(r17, r6, Address(__ post(r1, -80)));      \/\/       ldpsw   x17, x6, [x1], #-80\n-    __ stp(r13, r20, Address(__ post(r21, -208)));     \/\/       stp     x13, x20, [x21], #-208\n+    __ ldpsw(r16, r5, Address(__ post(r1, -80)));      \/\/       ldpsw   x16, x5, [x1], #-80\n+    __ stp(r13, r20, Address(__ post(r22, -208)));     \/\/       stp     x13, x20, [x22], #-208\n@@ -689,3 +689,6 @@\n-    __ fmul(v24, __ T2S, v25, v26);                    \/\/       fmul    v24.2S, v25.2S, v26.2S\n-    __ fmul(v0, __ T4S, v1, v2);                       \/\/       fmul    v0.4S, v1.4S, v2.4S\n-    __ fmul(v27, __ T2D, v28, v29);                    \/\/       fmul    v27.2D, v28.2D, v29.2D\n+    __ fabd(v24, __ T2S, v25, v26);                    \/\/       fabd    v24.2S, v25.2S, v26.2S\n+    __ fabd(v0, __ T4S, v1, v2);                       \/\/       fabd    v0.4S, v1.4S, v2.4S\n+    __ fabd(v27, __ T2D, v28, v29);                    \/\/       fabd    v27.2D, v28.2D, v29.2D\n+    __ fmul(v29, __ T2S, v30, v31);                    \/\/       fmul    v29.2S, v30.2S, v31.2S\n+    __ fmul(v5, __ T4S, v6, v7);                       \/\/       fmul    v5.4S, v6.4S, v7.4S\n+    __ fmul(v5, __ T2D, v6, v7);                       \/\/       fmul    v5.2D, v6.2D, v7.2D\n@@ -693,50 +696,50 @@\n-    __ mlav(v5, __ T8H, v6, v7);                       \/\/       mla     v5.8H, v6.8H, v7.8H\n-    __ mlav(v5, __ T2S, v6, v7);                       \/\/       mla     v5.2S, v6.2S, v7.2S\n-    __ mlav(v29, __ T4S, v30, v31);                    \/\/       mla     v29.4S, v30.4S, v31.4S\n-    __ fmla(v11, __ T2S, v12, v13);                    \/\/       fmla    v11.2S, v12.2S, v13.2S\n-    __ fmla(v25, __ T4S, v26, v27);                    \/\/       fmla    v25.4S, v26.4S, v27.4S\n-    __ fmla(v0, __ T2D, v1, v2);                       \/\/       fmla    v0.2D, v1.2D, v2.2D\n-    __ mlsv(v30, __ T4H, v31, v0);                     \/\/       mls     v30.4H, v31.4H, v0.4H\n-    __ mlsv(v0, __ T8H, v1, v2);                       \/\/       mls     v0.8H, v1.8H, v2.8H\n-    __ mlsv(v17, __ T2S, v18, v19);                    \/\/       mls     v17.2S, v18.2S, v19.2S\n-    __ mlsv(v28, __ T4S, v29, v30);                    \/\/       mls     v28.4S, v29.4S, v30.4S\n-    __ fmls(v25, __ T2S, v26, v27);                    \/\/       fmls    v25.2S, v26.2S, v27.2S\n-    __ fmls(v9, __ T4S, v10, v11);                     \/\/       fmls    v9.4S, v10.4S, v11.4S\n-    __ fmls(v25, __ T2D, v26, v27);                    \/\/       fmls    v25.2D, v26.2D, v27.2D\n-    __ fdiv(v12, __ T2S, v13, v14);                    \/\/       fdiv    v12.2S, v13.2S, v14.2S\n-    __ fdiv(v15, __ T4S, v16, v17);                    \/\/       fdiv    v15.4S, v16.4S, v17.4S\n-    __ fdiv(v11, __ T2D, v12, v13);                    \/\/       fdiv    v11.2D, v12.2D, v13.2D\n-    __ maxv(v10, __ T8B, v11, v12);                    \/\/       smax    v10.8B, v11.8B, v12.8B\n-    __ maxv(v17, __ T16B, v18, v19);                   \/\/       smax    v17.16B, v18.16B, v19.16B\n-    __ maxv(v24, __ T4H, v25, v26);                    \/\/       smax    v24.4H, v25.4H, v26.4H\n-    __ maxv(v21, __ T8H, v22, v23);                    \/\/       smax    v21.8H, v22.8H, v23.8H\n-    __ maxv(v23, __ T2S, v24, v25);                    \/\/       smax    v23.2S, v24.2S, v25.2S\n-    __ maxv(v0, __ T4S, v1, v2);                       \/\/       smax    v0.4S, v1.4S, v2.4S\n-    __ fmax(v16, __ T2S, v17, v18);                    \/\/       fmax    v16.2S, v17.2S, v18.2S\n-    __ fmax(v10, __ T4S, v11, v12);                    \/\/       fmax    v10.4S, v11.4S, v12.4S\n-    __ fmax(v6, __ T2D, v7, v8);                       \/\/       fmax    v6.2D, v7.2D, v8.2D\n-    __ minv(v28, __ T8B, v29, v30);                    \/\/       smin    v28.8B, v29.8B, v30.8B\n-    __ minv(v6, __ T16B, v7, v8);                      \/\/       smin    v6.16B, v7.16B, v8.16B\n-    __ minv(v5, __ T4H, v6, v7);                       \/\/       smin    v5.4H, v6.4H, v7.4H\n-    __ minv(v5, __ T8H, v6, v7);                       \/\/       smin    v5.8H, v6.8H, v7.8H\n-    __ minv(v20, __ T2S, v21, v22);                    \/\/       smin    v20.2S, v21.2S, v22.2S\n-    __ minv(v17, __ T4S, v18, v19);                    \/\/       smin    v17.4S, v18.4S, v19.4S\n-    __ fmin(v15, __ T2S, v16, v17);                    \/\/       fmin    v15.2S, v16.2S, v17.2S\n-    __ fmin(v17, __ T4S, v18, v19);                    \/\/       fmin    v17.4S, v18.4S, v19.4S\n-    __ fmin(v29, __ T2D, v30, v31);                    \/\/       fmin    v29.2D, v30.2D, v31.2D\n-    __ cmeq(v26, __ T8B, v27, v28);                    \/\/       cmeq    v26.8B, v27.8B, v28.8B\n-    __ cmeq(v28, __ T16B, v29, v30);                   \/\/       cmeq    v28.16B, v29.16B, v30.16B\n-    __ cmeq(v1, __ T4H, v2, v3);                       \/\/       cmeq    v1.4H, v2.4H, v3.4H\n-    __ cmeq(v27, __ T8H, v28, v29);                    \/\/       cmeq    v27.8H, v28.8H, v29.8H\n-    __ cmeq(v0, __ T2S, v1, v2);                       \/\/       cmeq    v0.2S, v1.2S, v2.2S\n-    __ cmeq(v20, __ T4S, v21, v22);                    \/\/       cmeq    v20.4S, v21.4S, v22.4S\n-    __ cmeq(v28, __ T2D, v29, v30);                    \/\/       cmeq    v28.2D, v29.2D, v30.2D\n-    __ fcmeq(v15, __ T2S, v16, v17);                   \/\/       fcmeq   v15.2S, v16.2S, v17.2S\n-    __ fcmeq(v12, __ T4S, v13, v14);                   \/\/       fcmeq   v12.4S, v13.4S, v14.4S\n-    __ fcmeq(v10, __ T2D, v11, v12);                   \/\/       fcmeq   v10.2D, v11.2D, v12.2D\n-    __ cmgt(v28, __ T8B, v29, v30);                    \/\/       cmgt    v28.8B, v29.8B, v30.8B\n-    __ cmgt(v28, __ T16B, v29, v30);                   \/\/       cmgt    v28.16B, v29.16B, v30.16B\n-    __ cmgt(v19, __ T4H, v20, v21);                    \/\/       cmgt    v19.4H, v20.4H, v21.4H\n-    __ cmgt(v22, __ T8H, v23, v24);                    \/\/       cmgt    v22.8H, v23.8H, v24.8H\n-    __ cmgt(v10, __ T2S, v11, v12);                    \/\/       cmgt    v10.2S, v11.2S, v12.2S\n-    __ cmgt(v4, __ T4S, v5, v6);                       \/\/       cmgt    v4.4S, v5.4S, v6.4S\n+    __ mlav(v11, __ T8H, v12, v13);                    \/\/       mla     v11.8H, v12.8H, v13.8H\n+    __ mlav(v25, __ T2S, v26, v27);                    \/\/       mla     v25.2S, v26.2S, v27.2S\n+    __ mlav(v0, __ T4S, v1, v2);                       \/\/       mla     v0.4S, v1.4S, v2.4S\n+    __ fmla(v30, __ T2S, v31, v0);                     \/\/       fmla    v30.2S, v31.2S, v0.2S\n+    __ fmla(v0, __ T4S, v1, v2);                       \/\/       fmla    v0.4S, v1.4S, v2.4S\n+    __ fmla(v17, __ T2D, v18, v19);                    \/\/       fmla    v17.2D, v18.2D, v19.2D\n+    __ mlsv(v28, __ T4H, v29, v30);                    \/\/       mls     v28.4H, v29.4H, v30.4H\n+    __ mlsv(v25, __ T8H, v26, v27);                    \/\/       mls     v25.8H, v26.8H, v27.8H\n+    __ mlsv(v9, __ T2S, v10, v11);                     \/\/       mls     v9.2S, v10.2S, v11.2S\n+    __ mlsv(v25, __ T4S, v26, v27);                    \/\/       mls     v25.4S, v26.4S, v27.4S\n+    __ fmls(v12, __ T2S, v13, v14);                    \/\/       fmls    v12.2S, v13.2S, v14.2S\n+    __ fmls(v15, __ T4S, v16, v17);                    \/\/       fmls    v15.4S, v16.4S, v17.4S\n+    __ fmls(v11, __ T2D, v12, v13);                    \/\/       fmls    v11.2D, v12.2D, v13.2D\n+    __ fdiv(v10, __ T2S, v11, v12);                    \/\/       fdiv    v10.2S, v11.2S, v12.2S\n+    __ fdiv(v17, __ T4S, v18, v19);                    \/\/       fdiv    v17.4S, v18.4S, v19.4S\n+    __ fdiv(v24, __ T2D, v25, v26);                    \/\/       fdiv    v24.2D, v25.2D, v26.2D\n+    __ maxv(v21, __ T8B, v22, v23);                    \/\/       smax    v21.8B, v22.8B, v23.8B\n+    __ maxv(v23, __ T16B, v24, v25);                   \/\/       smax    v23.16B, v24.16B, v25.16B\n+    __ maxv(v0, __ T4H, v1, v2);                       \/\/       smax    v0.4H, v1.4H, v2.4H\n+    __ maxv(v16, __ T8H, v17, v18);                    \/\/       smax    v16.8H, v17.8H, v18.8H\n+    __ maxv(v10, __ T2S, v11, v12);                    \/\/       smax    v10.2S, v11.2S, v12.2S\n+    __ maxv(v6, __ T4S, v7, v8);                       \/\/       smax    v6.4S, v7.4S, v8.4S\n+    __ fmax(v28, __ T2S, v29, v30);                    \/\/       fmax    v28.2S, v29.2S, v30.2S\n+    __ fmax(v6, __ T4S, v7, v8);                       \/\/       fmax    v6.4S, v7.4S, v8.4S\n+    __ fmax(v5, __ T2D, v6, v7);                       \/\/       fmax    v5.2D, v6.2D, v7.2D\n+    __ minv(v5, __ T8B, v6, v7);                       \/\/       smin    v5.8B, v6.8B, v7.8B\n+    __ minv(v20, __ T16B, v21, v22);                   \/\/       smin    v20.16B, v21.16B, v22.16B\n+    __ minv(v17, __ T4H, v18, v19);                    \/\/       smin    v17.4H, v18.4H, v19.4H\n+    __ minv(v15, __ T8H, v16, v17);                    \/\/       smin    v15.8H, v16.8H, v17.8H\n+    __ minv(v17, __ T2S, v18, v19);                    \/\/       smin    v17.2S, v18.2S, v19.2S\n+    __ minv(v29, __ T4S, v30, v31);                    \/\/       smin    v29.4S, v30.4S, v31.4S\n+    __ fmin(v26, __ T2S, v27, v28);                    \/\/       fmin    v26.2S, v27.2S, v28.2S\n+    __ fmin(v28, __ T4S, v29, v30);                    \/\/       fmin    v28.4S, v29.4S, v30.4S\n+    __ fmin(v1, __ T2D, v2, v3);                       \/\/       fmin    v1.2D, v2.2D, v3.2D\n+    __ cmeq(v27, __ T8B, v28, v29);                    \/\/       cmeq    v27.8B, v28.8B, v29.8B\n+    __ cmeq(v0, __ T16B, v1, v2);                      \/\/       cmeq    v0.16B, v1.16B, v2.16B\n+    __ cmeq(v20, __ T4H, v21, v22);                    \/\/       cmeq    v20.4H, v21.4H, v22.4H\n+    __ cmeq(v28, __ T8H, v29, v30);                    \/\/       cmeq    v28.8H, v29.8H, v30.8H\n+    __ cmeq(v15, __ T2S, v16, v17);                    \/\/       cmeq    v15.2S, v16.2S, v17.2S\n+    __ cmeq(v12, __ T4S, v13, v14);                    \/\/       cmeq    v12.4S, v13.4S, v14.4S\n+    __ cmeq(v10, __ T2D, v11, v12);                    \/\/       cmeq    v10.2D, v11.2D, v12.2D\n+    __ fcmeq(v28, __ T2S, v29, v30);                   \/\/       fcmeq   v28.2S, v29.2S, v30.2S\n+    __ fcmeq(v28, __ T4S, v29, v30);                   \/\/       fcmeq   v28.4S, v29.4S, v30.4S\n+    __ fcmeq(v19, __ T2D, v20, v21);                   \/\/       fcmeq   v19.2D, v20.2D, v21.2D\n+    __ cmgt(v22, __ T8B, v23, v24);                    \/\/       cmgt    v22.8B, v23.8B, v24.8B\n+    __ cmgt(v10, __ T16B, v11, v12);                   \/\/       cmgt    v10.16B, v11.16B, v12.16B\n+    __ cmgt(v4, __ T4H, v5, v6);                       \/\/       cmgt    v4.4H, v5.4H, v6.4H\n+    __ cmgt(v30, __ T8H, v31, v0);                     \/\/       cmgt    v30.8H, v31.8H, v0.8H\n+    __ cmgt(v20, __ T2S, v21, v22);                    \/\/       cmgt    v20.2S, v21.2S, v22.2S\n+    __ cmgt(v8, __ T4S, v9, v10);                      \/\/       cmgt    v8.4S, v9.4S, v10.4S\n@@ -744,13 +747,13 @@\n-    __ fcmgt(v20, __ T2S, v21, v22);                   \/\/       fcmgt   v20.2S, v21.2S, v22.2S\n-    __ fcmgt(v8, __ T4S, v9, v10);                     \/\/       fcmgt   v8.4S, v9.4S, v10.4S\n-    __ fcmgt(v30, __ T2D, v31, v0);                    \/\/       fcmgt   v30.2D, v31.2D, v0.2D\n-    __ cmge(v17, __ T8B, v18, v19);                    \/\/       cmge    v17.8B, v18.8B, v19.8B\n-    __ cmge(v10, __ T16B, v11, v12);                   \/\/       cmge    v10.16B, v11.16B, v12.16B\n-    __ cmge(v27, __ T4H, v28, v29);                    \/\/       cmge    v27.4H, v28.4H, v29.4H\n-    __ cmge(v2, __ T8H, v3, v4);                       \/\/       cmge    v2.8H, v3.8H, v4.8H\n-    __ cmge(v24, __ T2S, v25, v26);                    \/\/       cmge    v24.2S, v25.2S, v26.2S\n-    __ cmge(v4, __ T4S, v5, v6);                       \/\/       cmge    v4.4S, v5.4S, v6.4S\n-    __ cmge(v3, __ T2D, v4, v5);                       \/\/       cmge    v3.2D, v4.2D, v5.2D\n-    __ fcmge(v8, __ T2S, v9, v10);                     \/\/       fcmge   v8.2S, v9.2S, v10.2S\n-    __ fcmge(v22, __ T4S, v23, v24);                   \/\/       fcmge   v22.4S, v23.4S, v24.4S\n-    __ fcmge(v17, __ T2D, v18, v19);                   \/\/       fcmge   v17.2D, v18.2D, v19.2D\n+    __ fcmgt(v17, __ T2S, v18, v19);                   \/\/       fcmgt   v17.2S, v18.2S, v19.2S\n+    __ fcmgt(v10, __ T4S, v11, v12);                   \/\/       fcmgt   v10.4S, v11.4S, v12.4S\n+    __ fcmgt(v27, __ T2D, v28, v29);                   \/\/       fcmgt   v27.2D, v28.2D, v29.2D\n+    __ cmge(v2, __ T8B, v3, v4);                       \/\/       cmge    v2.8B, v3.8B, v4.8B\n+    __ cmge(v24, __ T16B, v25, v26);                   \/\/       cmge    v24.16B, v25.16B, v26.16B\n+    __ cmge(v4, __ T4H, v5, v6);                       \/\/       cmge    v4.4H, v5.4H, v6.4H\n+    __ cmge(v3, __ T8H, v4, v5);                       \/\/       cmge    v3.8H, v4.8H, v5.8H\n+    __ cmge(v8, __ T2S, v9, v10);                      \/\/       cmge    v8.2S, v9.2S, v10.2S\n+    __ cmge(v22, __ T4S, v23, v24);                    \/\/       cmge    v22.4S, v23.4S, v24.4S\n+    __ cmge(v17, __ T2D, v18, v19);                    \/\/       cmge    v17.2D, v18.2D, v19.2D\n+    __ fcmge(v13, __ T2S, v14, v15);                   \/\/       fcmge   v13.2S, v14.2S, v15.2S\n+    __ fcmge(v4, __ T4S, v5, v6);                      \/\/       fcmge   v4.4S, v5.4S, v6.4S\n+    __ fcmge(v28, __ T2D, v29, v30);                   \/\/       fcmge   v28.2D, v29.2D, v30.2D\n@@ -889,9 +892,9 @@\n-    __ swp(Assembler::xword, r13, r5, r29);            \/\/       swp     x13, x5, [x29]\n-    __ ldadd(Assembler::xword, r24, r21, r26);         \/\/       ldadd   x24, x21, [x26]\n-    __ ldbic(Assembler::xword, r24, r3, r24);          \/\/       ldclr   x24, x3, [x24]\n-    __ ldeor(Assembler::xword, r26, r23, r15);         \/\/       ldeor   x26, x23, [x15]\n-    __ ldorr(Assembler::xword, r21, r3, r24);          \/\/       ldset   x21, x3, [x24]\n-    __ ldsmin(Assembler::xword, r8, r25, r20);         \/\/       ldsmin  x8, x25, [x20]\n-    __ ldsmax(Assembler::xword, r16, r17, r2);         \/\/       ldsmax  x16, x17, [x2]\n-    __ ldumin(Assembler::xword, r1, r0, r24);          \/\/       ldumin  x1, x0, [x24]\n-    __ ldumax(Assembler::xword, r4, r3, r12);          \/\/       ldumax  x4, x3, [x12]\n+    __ swp(Assembler::xword, r24, r21, r26);           \/\/       swp     x24, x21, [x26]\n+    __ ldadd(Assembler::xword, r24, r3, r24);          \/\/       ldadd   x24, x3, [x24]\n+    __ ldbic(Assembler::xword, r26, r23, r15);         \/\/       ldclr   x26, x23, [x15]\n+    __ ldeor(Assembler::xword, r21, r3, r24);          \/\/       ldeor   x21, x3, [x24]\n+    __ ldorr(Assembler::xword, r8, r25, r20);          \/\/       ldset   x8, x25, [x20]\n+    __ ldsmin(Assembler::xword, r16, r17, r2);         \/\/       ldsmin  x16, x17, [x2]\n+    __ ldsmax(Assembler::xword, r1, r0, r24);          \/\/       ldsmax  x1, x0, [x24]\n+    __ ldumin(Assembler::xword, r4, r3, r12);          \/\/       ldumin  x4, x3, [x12]\n+    __ ldumax(Assembler::xword, zr, r28, r10);         \/\/       ldumax  xzr, x28, [x10]\n@@ -900,9 +903,9 @@\n-    __ swpa(Assembler::xword, zr, r28, r10);           \/\/       swpa    xzr, x28, [x10]\n-    __ ldadda(Assembler::xword, r26, r2, r12);         \/\/       ldadda  x26, x2, [x12]\n-    __ ldbica(Assembler::xword, r16, zr, r1);          \/\/       ldclra  x16, xzr, [x1]\n-    __ ldeora(Assembler::xword, r13, r29, r0);         \/\/       ldeora  x13, x29, [x0]\n-    __ ldorra(Assembler::xword, r19, r12, r17);        \/\/       ldseta  x19, x12, [x17]\n-    __ ldsmina(Assembler::xword, r22, r13, r28);       \/\/       ldsmina x22, x13, [x28]\n-    __ ldsmaxa(Assembler::xword, r30, zr, r1);         \/\/       ldsmaxa x30, xzr, [x1]\n-    __ ldumina(Assembler::xword, r26, r28, r4);        \/\/       ldumina x26, x28, [x4]\n-    __ ldumaxa(Assembler::xword, r30, r4, r6);         \/\/       ldumaxa x30, x4, [x6]\n+    __ swpa(Assembler::xword, r26, r2, r12);           \/\/       swpa    x26, x2, [x12]\n+    __ ldadda(Assembler::xword, r16, zr, r1);          \/\/       ldadda  x16, xzr, [x1]\n+    __ ldbica(Assembler::xword, r13, r29, r0);         \/\/       ldclra  x13, x29, [x0]\n+    __ ldeora(Assembler::xword, r19, r12, r17);        \/\/       ldeora  x19, x12, [x17]\n+    __ ldorra(Assembler::xword, r22, r13, r28);        \/\/       ldseta  x22, x13, [x28]\n+    __ ldsmina(Assembler::xword, r30, zr, r1);         \/\/       ldsmina x30, xzr, [x1]\n+    __ ldsmaxa(Assembler::xword, r26, r28, r4);        \/\/       ldsmaxa x26, x28, [x4]\n+    __ ldumina(Assembler::xword, r30, r4, r6);         \/\/       ldumina x30, x4, [x6]\n+    __ ldumaxa(Assembler::xword, r30, r26, r15);       \/\/       ldumaxa x30, x26, [x15]\n@@ -911,9 +914,9 @@\n-    __ swpal(Assembler::xword, r30, r26, r15);         \/\/       swpal   x30, x26, [x15]\n-    __ ldaddal(Assembler::xword, r9, r8, r12);         \/\/       ldaddal x9, x8, [x12]\n-    __ ldbical(Assembler::xword, r0, r20, r1);         \/\/       ldclral x0, x20, [x1]\n-    __ ldeoral(Assembler::xword, r24, r2, r0);         \/\/       ldeoral x24, x2, [x0]\n-    __ ldorral(Assembler::xword, r9, r24, r26);        \/\/       ldsetal x9, x24, [x26]\n-    __ ldsminal(Assembler::xword, r16, r30, r3);       \/\/       ldsminal        x16, x30, [x3]\n-    __ ldsmaxal(Assembler::xword, r10, r23, r10);      \/\/       ldsmaxal        x10, x23, [x10]\n-    __ lduminal(Assembler::xword, r4, r16, r2);        \/\/       lduminal        x4, x16, [x2]\n-    __ ldumaxal(Assembler::xword, r11, r8, r10);       \/\/       ldumaxal        x11, x8, [x10]\n+    __ swpal(Assembler::xword, r9, r8, r12);           \/\/       swpal   x9, x8, [x12]\n+    __ ldaddal(Assembler::xword, r0, r20, r1);         \/\/       ldaddal x0, x20, [x1]\n+    __ ldbical(Assembler::xword, r24, r2, r0);         \/\/       ldclral x24, x2, [x0]\n+    __ ldeoral(Assembler::xword, r9, r24, r26);        \/\/       ldeoral x9, x24, [x26]\n+    __ ldorral(Assembler::xword, r16, r30, r3);        \/\/       ldsetal x16, x30, [x3]\n+    __ ldsminal(Assembler::xword, r10, r23, r10);      \/\/       ldsminal        x10, x23, [x10]\n+    __ ldsmaxal(Assembler::xword, r4, r16, r2);        \/\/       ldsmaxal        x4, x16, [x2]\n+    __ lduminal(Assembler::xword, r11, r8, r10);       \/\/       lduminal        x11, x8, [x10]\n+    __ ldumaxal(Assembler::xword, r15, r17, r2);       \/\/       ldumaxal        x15, x17, [x2]\n@@ -922,9 +925,9 @@\n-    __ swpl(Assembler::xword, r15, r17, r2);           \/\/       swpl    x15, x17, [x2]\n-    __ ldaddl(Assembler::xword, r10, r12, r12);        \/\/       ldaddl  x10, x12, [x12]\n-    __ ldbicl(Assembler::xword, r15, r13, r2);         \/\/       ldclrl  x15, x13, [x2]\n-    __ ldeorl(Assembler::xword, r7, r20, r26);         \/\/       ldeorl  x7, x20, [x26]\n-    __ ldorrl(Assembler::xword, r16, r4, r2);          \/\/       ldsetl  x16, x4, [x2]\n-    __ ldsminl(Assembler::xword, r4, r12, r15);        \/\/       ldsminl x4, x12, [x15]\n-    __ ldsmaxl(Assembler::xword, r21, r16, r15);       \/\/       ldsmaxl x21, x16, [x15]\n-    __ lduminl(Assembler::xword, r11, r21, r23);       \/\/       lduminl x11, x21, [x23]\n-    __ ldumaxl(Assembler::xword, r12, r26, r23);       \/\/       ldumaxl x12, x26, [x23]\n+    __ swpl(Assembler::xword, r10, r12, r12);          \/\/       swpl    x10, x12, [x12]\n+    __ ldaddl(Assembler::xword, r15, r13, r2);         \/\/       ldaddl  x15, x13, [x2]\n+    __ ldbicl(Assembler::xword, r7, r20, r26);         \/\/       ldclrl  x7, x20, [x26]\n+    __ ldeorl(Assembler::xword, r16, r4, r2);          \/\/       ldeorl  x16, x4, [x2]\n+    __ ldorrl(Assembler::xword, r4, r12, r15);         \/\/       ldsetl  x4, x12, [x15]\n+    __ ldsminl(Assembler::xword, r21, r16, r15);       \/\/       ldsminl x21, x16, [x15]\n+    __ ldsmaxl(Assembler::xword, r11, r21, r23);       \/\/       ldsmaxl x11, x21, [x23]\n+    __ lduminl(Assembler::xword, r12, r26, r23);       \/\/       lduminl x12, x26, [x23]\n+    __ ldumaxl(Assembler::xword, r28, r14, r11);       \/\/       ldumaxl x28, x14, [x11]\n@@ -933,9 +936,9 @@\n-    __ swp(Assembler::word, r28, r14, r11);            \/\/       swp     w28, w14, [x11]\n-    __ ldadd(Assembler::word, r24, r1, r12);           \/\/       ldadd   w24, w1, [x12]\n-    __ ldbic(Assembler::word, zr, r10, r16);           \/\/       ldclr   wzr, w10, [x16]\n-    __ ldeor(Assembler::word, r7, r2, r3);             \/\/       ldeor   w7, w2, [x3]\n-    __ ldorr(Assembler::word, r13, r19, r17);          \/\/       ldset   w13, w19, [x17]\n-    __ ldsmin(Assembler::word, r16, r3, r1);           \/\/       ldsmin  w16, w3, [x1]\n-    __ ldsmax(Assembler::word, r11, r30, r5);          \/\/       ldsmax  w11, w30, [x5]\n-    __ ldumin(Assembler::word, r8, r15, r29);          \/\/       ldumin  w8, w15, [x29]\n-    __ ldumax(Assembler::word, r30, r0, r20);          \/\/       ldumax  w30, w0, [x20]\n+    __ swp(Assembler::word, r24, r1, r12);             \/\/       swp     w24, w1, [x12]\n+    __ ldadd(Assembler::word, zr, r10, r16);           \/\/       ldadd   wzr, w10, [x16]\n+    __ ldbic(Assembler::word, r7, r2, r3);             \/\/       ldclr   w7, w2, [x3]\n+    __ ldeor(Assembler::word, r13, r19, r17);          \/\/       ldeor   w13, w19, [x17]\n+    __ ldorr(Assembler::word, r16, r3, r1);            \/\/       ldset   w16, w3, [x1]\n+    __ ldsmin(Assembler::word, r11, r30, r5);          \/\/       ldsmin  w11, w30, [x5]\n+    __ ldsmax(Assembler::word, r8, r15, r29);          \/\/       ldsmax  w8, w15, [x29]\n+    __ ldumin(Assembler::word, r30, r0, r20);          \/\/       ldumin  w30, w0, [x20]\n+    __ ldumax(Assembler::word, r7, r20, r23);          \/\/       ldumax  w7, w20, [x23]\n@@ -944,9 +947,9 @@\n-    __ swpa(Assembler::word, r7, r20, r23);            \/\/       swpa    w7, w20, [x23]\n-    __ ldadda(Assembler::word, r28, r21, r27);         \/\/       ldadda  w28, w21, [x27]\n-    __ ldbica(Assembler::word, r25, r5, r1);           \/\/       ldclra  w25, w5, [x1]\n-    __ ldeora(Assembler::word, r23, r16, sp);          \/\/       ldeora  w23, w16, [sp]\n-    __ ldorra(Assembler::word, r5, r12, r9);           \/\/       ldseta  w5, w12, [x9]\n-    __ ldsmina(Assembler::word, r28, r15, r29);        \/\/       ldsmina w28, w15, [x29]\n-    __ ldsmaxa(Assembler::word, r22, zr, r19);         \/\/       ldsmaxa w22, wzr, [x19]\n-    __ ldumina(Assembler::word, zr, r5, r14);          \/\/       ldumina wzr, w5, [x14]\n-    __ ldumaxa(Assembler::word, r16, zr, r15);         \/\/       ldumaxa w16, wzr, [x15]\n+    __ swpa(Assembler::word, r28, r21, r27);           \/\/       swpa    w28, w21, [x27]\n+    __ ldadda(Assembler::word, r25, r5, r1);           \/\/       ldadda  w25, w5, [x1]\n+    __ ldbica(Assembler::word, r23, r16, sp);          \/\/       ldclra  w23, w16, [sp]\n+    __ ldeora(Assembler::word, r5, r12, r9);           \/\/       ldeora  w5, w12, [x9]\n+    __ ldorra(Assembler::word, r28, r15, r29);         \/\/       ldseta  w28, w15, [x29]\n+    __ ldsmina(Assembler::word, r22, zr, r19);         \/\/       ldsmina w22, wzr, [x19]\n+    __ ldsmaxa(Assembler::word, zr, r5, r14);          \/\/       ldsmaxa wzr, w5, [x14]\n+    __ ldumina(Assembler::word, r16, zr, r15);         \/\/       ldumina w16, wzr, [x15]\n+    __ ldumaxa(Assembler::word, r27, r20, r16);        \/\/       ldumaxa w27, w20, [x16]\n@@ -955,9 +958,9 @@\n-    __ swpal(Assembler::word, r27, r20, r16);          \/\/       swpal   w27, w20, [x16]\n-    __ ldaddal(Assembler::word, r12, r11, r9);         \/\/       ldaddal w12, w11, [x9]\n-    __ ldbical(Assembler::word, r6, r30, r17);         \/\/       ldclral w6, w30, [x17]\n-    __ ldeoral(Assembler::word, r27, r28, r30);        \/\/       ldeoral w27, w28, [x30]\n-    __ ldorral(Assembler::word, r7, r10, r20);         \/\/       ldsetal w7, w10, [x20]\n-    __ ldsminal(Assembler::word, r10, r4, r24);        \/\/       ldsminal        w10, w4, [x24]\n-    __ ldsmaxal(Assembler::word, r17, r17, r22);       \/\/       ldsmaxal        w17, w17, [x22]\n-    __ lduminal(Assembler::word, r3, r29, r15);        \/\/       lduminal        w3, w29, [x15]\n-    __ ldumaxal(Assembler::word, r22, r19, r19);       \/\/       ldumaxal        w22, w19, [x19]\n+    __ swpal(Assembler::word, r12, r11, r9);           \/\/       swpal   w12, w11, [x9]\n+    __ ldaddal(Assembler::word, r6, r30, r17);         \/\/       ldaddal w6, w30, [x17]\n+    __ ldbical(Assembler::word, r27, r28, r30);        \/\/       ldclral w27, w28, [x30]\n+    __ ldeoral(Assembler::word, r7, r10, r20);         \/\/       ldeoral w7, w10, [x20]\n+    __ ldorral(Assembler::word, r10, r4, r24);         \/\/       ldsetal w10, w4, [x24]\n+    __ ldsminal(Assembler::word, r17, r17, r22);       \/\/       ldsminal        w17, w17, [x22]\n+    __ ldsmaxal(Assembler::word, r3, r29, r15);        \/\/       ldsmaxal        w3, w29, [x15]\n+    __ lduminal(Assembler::word, r22, r19, r19);       \/\/       lduminal        w22, w19, [x19]\n+    __ ldumaxal(Assembler::word, r22, r2, r15);        \/\/       ldumaxal        w22, w2, [x15]\n@@ -966,9 +969,9 @@\n-    __ swpl(Assembler::word, r22, r2, r15);            \/\/       swpl    w22, w2, [x15]\n-    __ ldaddl(Assembler::word, r6, r12, r16);          \/\/       ldaddl  w6, w12, [x16]\n-    __ ldbicl(Assembler::word, r11, r13, r23);         \/\/       ldclrl  w11, w13, [x23]\n-    __ ldeorl(Assembler::word, r1, r30, r19);          \/\/       ldeorl  w1, w30, [x19]\n-    __ ldorrl(Assembler::word, r5, r17, r2);           \/\/       ldsetl  w5, w17, [x2]\n-    __ ldsminl(Assembler::word, r16, r22, r13);        \/\/       ldsminl w16, w22, [x13]\n-    __ ldsmaxl(Assembler::word, r10, r21, r29);        \/\/       ldsmaxl w10, w21, [x29]\n-    __ lduminl(Assembler::word, r27, r12, r27);        \/\/       lduminl w27, w12, [x27]\n-    __ ldumaxl(Assembler::word, r3, r1, sp);           \/\/       ldumaxl w3, w1, [sp]\n+    __ swpl(Assembler::word, r6, r12, r16);            \/\/       swpl    w6, w12, [x16]\n+    __ ldaddl(Assembler::word, r11, r13, r23);         \/\/       ldaddl  w11, w13, [x23]\n+    __ ldbicl(Assembler::word, r1, r30, r19);          \/\/       ldclrl  w1, w30, [x19]\n+    __ ldeorl(Assembler::word, r5, r17, r2);           \/\/       ldeorl  w5, w17, [x2]\n+    __ ldorrl(Assembler::word, r16, r22, r13);         \/\/       ldsetl  w16, w22, [x13]\n+    __ ldsminl(Assembler::word, r10, r21, r29);        \/\/       ldsminl w10, w21, [x29]\n+    __ ldsmaxl(Assembler::word, r27, r12, r27);        \/\/       ldsmaxl w27, w12, [x27]\n+    __ lduminl(Assembler::word, r3, r1, sp);           \/\/       lduminl w3, w1, [sp]\n+    __ ldumaxl(Assembler::word, r24, r19, r17);        \/\/       ldumaxl w24, w19, [x17]\n@@ -977,4 +980,4 @@\n-    __ bcax(v23, __ T16B, v19, v17, v9);               \/\/       bcax            v23.16B, v19.16B, v17.16B, v9.16B\n-    __ eor3(v27, __ T16B, v26, v14, v6);               \/\/       eor3            v27.16B, v26.16B, v14.16B, v6.16B\n-    __ rax1(v20, __ T2D, v22, v30);                    \/\/       rax1            v20.2D, v22.2D, v30.2D\n-    __ xar(v24, __ T2D, v2, v30, 54);                  \/\/       xar             v24.2D, v2.2D, v30.2D, #54\n+    __ bcax(v9, __ T16B, v27, v26, v14);               \/\/       bcax            v9.16B, v27.16B, v26.16B, v14.16B\n+    __ eor3(v6, __ T16B, v20, v22, v30);               \/\/       eor3            v6.16B, v20.16B, v22.16B, v30.16B\n+    __ rax1(v24, __ T2D, v2, v30);                     \/\/       rax1            v24.2D, v2.2D, v30.2D\n+    __ xar(v26, __ T2D, v17, v10, 46);                 \/\/       xar             v26.2D, v17.2D, v10.2D, #46\n@@ -983,4 +986,4 @@\n-    __ sha512h(v17, __ T2D, v10, v22);                 \/\/       sha512h         q17, q10, v22.2D\n-    __ sha512h2(v17, __ T2D, v2, v17);                 \/\/       sha512h2                q17, q2, v17.2D\n-    __ sha512su0(v0, __ T2D, v24);                     \/\/       sha512su0               v0.2D, v24.2D\n-    __ sha512su1(v25, __ T2D, v22, v2);                \/\/       sha512su1               v25.2D, v22.2D, v2.2D\n+    __ sha512h(v17, __ T2D, v2, v17);                  \/\/       sha512h         q17, q2, v17.2D\n+    __ sha512h2(v0, __ T2D, v24, v25);                 \/\/       sha512h2                q0, q24, v25.2D\n+    __ sha512su0(v22, __ T2D, v2);                     \/\/       sha512su0               v22.2D, v2.2D\n+    __ sha512su1(v17, __ T2D, v12, v3);                \/\/       sha512su1               v17.2D, v12.2D, v3.2D\n@@ -1029,0 +1032,38 @@\n+    __ sve_add(z27, __ S, z29, z28);                   \/\/       add     z27.s, z29.s, z28.s\n+    __ sve_sub(z26, __ D, z6, z9);                     \/\/       sub     z26.d, z6.d, z9.d\n+    __ sve_fadd(z17, __ S, z7, z4);                    \/\/       fadd    z17.s, z7.s, z4.s\n+    __ sve_fmul(z15, __ S, z9, z22);                   \/\/       fmul    z15.s, z9.s, z22.s\n+    __ sve_fsub(z2, __ D, z27, z20);                   \/\/       fsub    z2.d, z27.d, z20.d\n+    __ sve_abs(z5, __ S, p6, z0);                      \/\/       abs     z5.s, p6\/m, z0.s\n+    __ sve_add(z14, __ H, p1, z25);                    \/\/       add     z14.h, p1\/m, z14.h, z25.h\n+    __ sve_asr(z27, __ D, p5, z26);                    \/\/       asr     z27.d, p5\/m, z27.d, z26.d\n+    __ sve_cnt(z24, __ B, p5, z0);                     \/\/       cnt     z24.b, p5\/m, z0.b\n+    __ sve_lsl(z6, __ B, p4, z0);                      \/\/       lsl     z6.b, p4\/m, z6.b, z0.b\n+    __ sve_lsr(z15, __ B, p0, z9);                     \/\/       lsr     z15.b, p0\/m, z15.b, z9.b\n+    __ sve_mul(z5, __ B, p2, z27);                     \/\/       mul     z5.b, p2\/m, z5.b, z27.b\n+    __ sve_neg(z20, __ B, p5, z20);                    \/\/       neg     z20.b, p5\/m, z20.b\n+    __ sve_not(z10, __ D, p2, z16);                    \/\/       not     z10.d, p2\/m, z16.d\n+    __ sve_smax(z6, __ H, p4, z2);                     \/\/       smax    z6.h, p4\/m, z6.h, z2.h\n+    __ sve_smin(z29, __ D, p7, z2);                    \/\/       smin    z29.d, p7\/m, z29.d, z2.d\n+    __ sve_sub(z22, __ H, p7, z14);                    \/\/       sub     z22.h, p7\/m, z22.h, z14.h\n+    __ sve_fabs(z27, __ S, p4, z23);                   \/\/       fabs    z27.s, p4\/m, z23.s\n+    __ sve_fadd(z2, __ D, p3, z10);                    \/\/       fadd    z2.d, p3\/m, z2.d, z10.d\n+    __ sve_fdiv(z10, __ S, p6, z22);                   \/\/       fdiv    z10.s, p6\/m, z10.s, z22.s\n+    __ sve_fmax(z3, __ S, p5, z16);                    \/\/       fmax    z3.s, p5\/m, z3.s, z16.s\n+    __ sve_fmin(z1, __ D, p4, z16);                    \/\/       fmin    z1.d, p4\/m, z1.d, z16.d\n+    __ sve_fmul(z12, __ S, p3, z12);                   \/\/       fmul    z12.s, p3\/m, z12.s, z12.s\n+    __ sve_fneg(z16, __ D, p0, z20);                   \/\/       fneg    z16.d, p0\/m, z20.d\n+    __ sve_frintm(z5, __ D, p1, z7);                   \/\/       frintm  z5.d, p1\/m, z7.d\n+    __ sve_frintn(z12, __ D, p7, z16);                 \/\/       frintn  z12.d, p7\/m, z16.d\n+    __ sve_frintp(z6, __ S, p0, z28);                  \/\/       frintp  z6.s, p0\/m, z28.s\n+    __ sve_fsqrt(z4, __ D, p1, z17);                   \/\/       fsqrt   z4.d, p1\/m, z17.d\n+    __ sve_fsub(z13, __ S, p3, z19);                   \/\/       fsub    z13.s, p3\/m, z13.s, z19.s\n+    __ sve_fmla(z24, __ S, p5, z17, z0);               \/\/       fmla    z24.s, p5\/m, z17.s, z0.s\n+    __ sve_fmls(z23, __ S, p1, z19, z30);              \/\/       fmls    z23.s, p1\/m, z19.s, z30.s\n+    __ sve_fnmla(z16, __ S, p1, z0, z7);               \/\/       fnmla   z16.s, p1\/m, z0.s, z7.s\n+    __ sve_fnmls(z17, __ D, p6, z8, z10);              \/\/       fnmls   z17.d, p6\/m, z8.d, z10.d\n+    __ sve_mla(z20, __ B, p5, z27, z2);                \/\/       mla     z20.b, p5\/m, z27.b, z2.b\n+    __ sve_mls(z15, __ B, p4, z20, z7);                \/\/       mls     z15.b, p4\/m, z20.b, z7.b\n+    __ sve_and(z28, z7, z0);                           \/\/       and     z28.d, z7.d, z0.d\n+    __ sve_eor(z16, z19, z22);                         \/\/       eor     z16.d, z19.d, z22.d\n+    __ sve_orr(z15, z9, z22);                          \/\/       orr     z15.d, z9.d, z22.d\n@@ -1097,6 +1138,6 @@\n-    0xbc1951b7,     0xf8008c0b,     0xb801dc03,     0x38009dcb,\n-    0x781fdf1d,     0xf8570e2d,     0xb85faecc,     0x385f6d8d,\n-    0x785ebea0,     0x38804cf7,     0x789cbce3,     0x78df9cbc,\n-    0xb89eed38,     0xfc40cd6e,     0xbc5bdd93,     0xfc103c14,\n-    0xbc040c08,     0xf81a2784,     0xb81ca4ec,     0x381e855b,\n-    0x7801b506,     0xf853654e,     0xb85d74b0,     0x384095c2,\n+    0xbc1951b7,     0xf8008c0a,     0xb801dc03,     0x38009dca,\n+    0x781fdf3d,     0xf8570e0c,     0xb85faecc,     0x385f6d6d,\n+    0x785ebea0,     0x38804cd7,     0x789cbce3,     0x78df9c9c,\n+    0xb89eed18,     0xfc40cd6e,     0xbc5bdd93,     0xfc103c14,\n+    0xbc040c08,     0xf81a2783,     0xb81ca4eb,     0x381e855b,\n+    0x7801b4e6,     0xf853654d,     0xb85d74af,     0x384095a2,\n@@ -1131,3 +1172,3 @@\n-    0x1e23095b,     0x1e3918e0,     0x1e2f28c9,     0x1e2a39fd,\n-    0x1e270a22,     0x1e77096b,     0x1e771ba7,     0x1e6b2b6e,\n-    0x1e78388b,     0x1e6e09ec,     0x1f1c3574,     0x1f17f98b,\n+    0x7ea3d55b,     0x1e3908e0,     0x1e2f18c9,     0x1e2a29fd,\n+    0x1e273a22,     0x7ef7d56b,     0x1e770ba7,     0x1e6b1b6e,\n+    0x1e78288b,     0x1e6e39ec,     0x1f1c3574,     0x1f17f98b,\n@@ -1142,2 +1183,2 @@\n-    0x293c19f4,     0x2966387b,     0x69762971,     0xa9041dc7,\n-    0xa9475c0c,     0x29b61ccd,     0x29ee405e,     0x69ee0744,\n+    0x293c19f4,     0x2966387b,     0x69762970,     0xa9041dc7,\n+    0xa9475c0c,     0x29b61ccd,     0x29ee3c5e,     0x69ee0764,\n@@ -1145,1 +1186,1 @@\n-    0x68f61831,     0xa8b352ad,     0xa8c56d5e,     0x28024565,\n+    0x68f61430,     0xa8b352cd,     0xa8c56d5e,     0x28024565,\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":228,"deletions":187,"binary":false,"changes":415,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-    guarantee(val < (1U << nbits), \"Field too big for insn\");\n+    guarantee(val < (1ULL << nbits), \"Field too big for insn\");\n@@ -448,2 +448,2 @@\n-    guarantee((_mode == base_plus_offset | _mode == base_plus_offset_reg\n-               | _mode == post | _mode == post_reg),\n+    guarantee((_mode == base_plus_offset || _mode == base_plus_offset_reg\n+               || _mode == post || _mode == post_reg),\n@@ -1952,1 +1952,1 @@\n-    f(type, 23, 22), f(1, 21), f(opcode, 15, 12), f(0b10, 11, 10);\n+    f(type, 23, 22), f(1, 21), f(opcode, 15, 10);\n@@ -1961,7 +1961,8 @@\n-  INSN(fmuls, 0b000, 0b00, 0b0000);\n-  INSN(fdivs, 0b000, 0b00, 0b0001);\n-  INSN(fadds, 0b000, 0b00, 0b0010);\n-  INSN(fsubs, 0b000, 0b00, 0b0011);\n-  INSN(fmaxs, 0b000, 0b00, 0b0100);\n-  INSN(fmins, 0b000, 0b00, 0b0101);\n-  INSN(fnmuls, 0b000, 0b00, 0b1000);\n+  INSN(fabds,  0b011, 0b10, 0b110101);\n+  INSN(fmuls,  0b000, 0b00, 0b000010);\n+  INSN(fdivs,  0b000, 0b00, 0b000110);\n+  INSN(fadds,  0b000, 0b00, 0b001010);\n+  INSN(fsubs,  0b000, 0b00, 0b001110);\n+  INSN(fmaxs,  0b000, 0b00, 0b010010);\n+  INSN(fmins,  0b000, 0b00, 0b010110);\n+  INSN(fnmuls, 0b000, 0b00, 0b100010);\n@@ -1969,7 +1970,8 @@\n-  INSN(fmuld, 0b000, 0b01, 0b0000);\n-  INSN(fdivd, 0b000, 0b01, 0b0001);\n-  INSN(faddd, 0b000, 0b01, 0b0010);\n-  INSN(fsubd, 0b000, 0b01, 0b0011);\n-  INSN(fmaxd, 0b000, 0b01, 0b0100);\n-  INSN(fmind, 0b000, 0b01, 0b0101);\n-  INSN(fnmuld, 0b000, 0b01, 0b1000);\n+  INSN(fabdd,  0b011, 0b11, 0b110101);\n+  INSN(fmuld,  0b000, 0b01, 0b000010);\n+  INSN(fdivd,  0b000, 0b01, 0b000110);\n+  INSN(faddd,  0b000, 0b01, 0b001010);\n+  INSN(fsubd,  0b000, 0b01, 0b001110);\n+  INSN(fmaxd,  0b000, 0b01, 0b010010);\n+  INSN(fmind,  0b000, 0b01, 0b010110);\n+  INSN(fnmuld, 0b000, 0b01, 0b100010);\n@@ -2485,0 +2487,1 @@\n+  INSN(fabd, 1, 1, 0b110101);\n@@ -2691,0 +2694,2 @@\n+  INSN(usra, 1, 0b000101, \/* isSHR = *\/ true);\n+  INSN(ssra, 0, 0b000101, \/* isSHR = *\/ true);\n@@ -3350,7 +3355,0 @@\n-  virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,\n-                                                Register tmp,\n-                                                int offset) {\n-    ShouldNotCallThis();\n-    return RegisterOrConstant();\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -279,2 +279,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -377,1 +376,4 @@\n-  __ maybe_isb();\n+\n+  \/\/ Explicit isb required because fixup_callers_callsite may change the code\n+  \/\/ stream.\n+  __ safepoint_isb();\n@@ -1162,1 +1164,0 @@\n-    __ maybe_isb();\n@@ -1509,1 +1510,1 @@\n-    __ bang_stack_with_offset(StackOverflow::stack_shadow_zone_size());\n+    __ bang_stack_with_offset(checked_cast<int>(StackOverflow::stack_shadow_zone_size()));\n@@ -1869,1 +1870,1 @@\n-  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n+  \/\/ Check for safepoint operation in progress and\/or pending suspend requests.\n@@ -2093,1 +2094,1 @@\n-    __ maybe_isb();\n+\n@@ -2456,1 +2457,1 @@\n-  __ mov(rscratch1, (address)0xDEADDEAD);        \/\/ Make a recognizable pattern\n+  __ mov(rscratch1, (uint64_t)0xDEADDEAD);        \/\/ Make a recognizable pattern\n@@ -2533,0 +2534,9 @@\n+\/\/ Number of stack slots between incoming argument block and the start of\n+\/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n+\/\/ EPILOG must remove this many slots. aarch64 needs two slots for\n+\/\/ return address and fp.\n+\/\/ TODO think this is correct but check\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return 4;\n+}\n+\n@@ -2790,1 +2800,0 @@\n-  __ maybe_isb();\n@@ -2897,2 +2906,0 @@\n-  __ maybe_isb();\n-\n@@ -3020,1 +3027,2 @@\n-  __ maybe_isb();\n+  \/\/ handle_exception_C is a special VM call which does not require an explicit\n+  \/\/ instruction sync afterwards.\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1058,5 +1058,0 @@\n-\/\/ ARM doesn't support AES intrinsics\n-const bool Matcher::pass_original_key_for_aes() {\n-  return false;\n-}\n-\n@@ -1695,6 +1690,0 @@\n-  \/\/ Number of stack slots between incoming argument block and the start of\n-  \/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n-  \/\/ EPILOG must remove this many slots.\n-  \/\/ FP + LR\n-  in_preserve_stack_slots(2 * VMRegImpl::slots_per_word);\n-\n@@ -1717,16 +1706,0 @@\n-  \/\/ Body of function which returns an OptoRegs array locating\n-  \/\/ arguments either in registers or in stack slots for calling\n-  \/\/ java\n-  calling_convention %{\n-    (void) SharedRuntime::java_calling_convention(sig_bt, regs, length, is_outgoing);\n-\n-  %}\n-\n-  \/\/ Body of function which returns an OptoRegs array locating\n-  \/\/ arguments either in registers or in stack slots for callin\n-  \/\/ C.\n-  c_calling_convention %{\n-    \/\/ This is obviously always outgoing\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, \/*regs2=*\/NULL, length);\n-  %}\n-\n@@ -5321,0 +5294,8 @@\n+instruct castLL( iRegL dst ) %{\n+  match(Set dst (CastLL dst));\n+  format %{ \"! castLL of $dst\" %}\n+  ins_encode( \/*empty encoding*\/ );\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n@@ -8484,0 +8465,15 @@\n+instruct cmovLL_reg_LTGE_U(cmpOpL cmp, flagsRegUL_LTGE xcc, iRegL dst, iRegL src) %{\n+  match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));\n+  predicate(_kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge );\n+\n+  ins_cost(150);\n+  size(8);\n+  format %{ \"MOV$cmp  $dst.lo,$src.lo\\t! long\\n\\t\"\n+            \"MOV$cmp  $dst,$src.hi\" %}\n+  ins_encode %{\n+    __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));\n+    __ mov($dst$$Register->successor(), $src$$Register->successor(), (AsmCondition)($cmp$$cmpcode));\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8514,0 +8510,15 @@\n+instruct cmovLL_reg_LEGT_U(cmpOpL_commute cmp, flagsRegUL_LEGT xcc, iRegL dst, iRegL src) %{\n+  match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));\n+  predicate(_kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt );\n+\n+  ins_cost(150);\n+  size(8);\n+  format %{ \"MOV$cmp  $dst.lo,$src.lo\\t! long\\n\\t\"\n+            \"MOV$cmp  $dst,$src.hi\" %}\n+  ins_encode %{\n+    __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));\n+    __ mov($dst$$Register->successor(), $src$$Register->successor(), (AsmCondition)($cmp$$cmpcode));\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -8517,0 +8528,14 @@\n+  ins_cost(140);\n+  size(8);\n+  format %{ \"MOV$cmp  $dst.lo,0\\t! long\\n\\t\"\n+            \"MOV$cmp  $dst,0\" %}\n+  ins_encode %{\n+    __ mov($dst$$Register, 0, (AsmCondition)($cmp$$cmpcode));\n+    __ mov($dst$$Register->successor(), 0, (AsmCondition)($cmp$$cmpcode));\n+  %}\n+  ins_pipe(ialu_imm);\n+%}\n+\n+instruct cmovLL_imm_LTGE_U(cmpOpL cmp, flagsRegUL_LTGE xcc, iRegL dst, immL0 src) %{\n+  match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));\n+  predicate(_kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge );\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":52,"deletions":27,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -375,2 +375,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -381,1 +380,0 @@\n-  (void) is_outgoing;\n@@ -1382,0 +1380,8 @@\n+\/\/ Number of stack slots between incoming argument block and the start of\n+\/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n+\/\/ EPILOG must remove this many slots.\n+\/\/ FP + LR\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return 2 * VMRegImpl::slots_per_word;\n+}\n+\n@@ -1386,1 +1392,0 @@\n-\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2065,2 +2065,3 @@\n-  if (!has_match_rule(opcode))\n-    return false;\n+  if (!has_match_rule(opcode)) {\n+    return false; \/\/ no match rule present\n+  }\n@@ -2068,73 +2069,57 @@\n-  bool ret_value = true;\n-  case Op_SqrtD:\n-    return VM_Version::has_fsqrt();\n-  case Op_CountLeadingZerosI:\n-  case Op_CountLeadingZerosL:\n-    if (!UseCountLeadingZerosInstructionsPPC64)\n-      return false;\n-    break;\n-  case Op_CountTrailingZerosI:\n-  case Op_CountTrailingZerosL:\n-    if (!UseCountLeadingZerosInstructionsPPC64 &&\n-        !UseCountTrailingZerosInstructionsPPC64)\n-      return false;\n-    break;\n-\n-  case Op_PopCountI:\n-  case Op_PopCountL:\n-    return (UsePopCountInstruction && VM_Version::has_popcntw());\n-\n-  case Op_StrComp:\n-    return SpecialStringCompareTo;\n-  case Op_StrEquals:\n-    return SpecialStringEquals;\n-  case Op_StrIndexOf:\n-  case Op_StrIndexOfChar:\n-    return SpecialStringIndexOf;\n-  case Op_AddVB:\n-  case Op_AddVS:\n-  case Op_AddVI:\n-  case Op_AddVF:\n-  case Op_AddVD:\n-  case Op_SubVB:\n-  case Op_SubVS:\n-  case Op_SubVI:\n-  case Op_SubVF:\n-  case Op_SubVD:\n-  case Op_MulVS:\n-  case Op_MulVF:\n-  case Op_MulVD:\n-  case Op_DivVF:\n-  case Op_DivVD:\n-  case Op_AbsVF:\n-  case Op_AbsVD:\n-  case Op_NegVF:\n-  case Op_NegVD:\n-  case Op_SqrtVF:\n-  case Op_SqrtVD:\n-  case Op_AddVL:\n-  case Op_SubVL:\n-  case Op_MulVI:\n-  case Op_RoundDoubleModeV:\n-    return SuperwordUseVSX;\n-  case Op_PopCountVI:\n-    return (SuperwordUseVSX && UsePopCountInstruction);\n-  case Op_FmaVF:\n-  case Op_FmaVD:\n-    return (SuperwordUseVSX && UseFMA);\n-  case Op_Digit:\n-    return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isDigit);\n-  case Op_LowerCase:\n-    return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isLowerCase);\n-  case Op_UpperCase:\n-    return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isUpperCase);\n-  case Op_Whitespace:\n-    return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isWhitespace);\n-\n-  case Op_CacheWB:\n-  case Op_CacheWBPreSync:\n-  case Op_CacheWBPostSync:\n-    if (!VM_Version::supports_data_cache_line_flush()) {\n-      ret_value = false;\n-    }\n-    break;\n+    case Op_SqrtD:\n+      return VM_Version::has_fsqrt();\n+    case Op_CountLeadingZerosI:\n+    case Op_CountLeadingZerosL:\n+      return UseCountLeadingZerosInstructionsPPC64;\n+    case Op_CountTrailingZerosI:\n+    case Op_CountTrailingZerosL:\n+      return (UseCountLeadingZerosInstructionsPPC64 || UseCountTrailingZerosInstructionsPPC64);\n+    case Op_PopCountI:\n+    case Op_PopCountL:\n+      return (UsePopCountInstruction && VM_Version::has_popcntw());\n+\n+    case Op_AddVB:\n+    case Op_AddVS:\n+    case Op_AddVI:\n+    case Op_AddVF:\n+    case Op_AddVD:\n+    case Op_SubVB:\n+    case Op_SubVS:\n+    case Op_SubVI:\n+    case Op_SubVF:\n+    case Op_SubVD:\n+    case Op_MulVS:\n+    case Op_MulVF:\n+    case Op_MulVD:\n+    case Op_DivVF:\n+    case Op_DivVD:\n+    case Op_AbsVF:\n+    case Op_AbsVD:\n+    case Op_NegVF:\n+    case Op_NegVD:\n+    case Op_SqrtVF:\n+    case Op_SqrtVD:\n+    case Op_AddVL:\n+    case Op_SubVL:\n+    case Op_MulVI:\n+    case Op_RoundDoubleModeV:\n+      return SuperwordUseVSX;\n+    case Op_PopCountVI:\n+      return (SuperwordUseVSX && UsePopCountInstruction);\n+    case Op_FmaVF:\n+    case Op_FmaVD:\n+      return (SuperwordUseVSX && UseFMA);\n+\n+    case Op_Digit:\n+      return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isDigit);\n+    case Op_LowerCase:\n+      return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isLowerCase);\n+    case Op_UpperCase:\n+      return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isUpperCase);\n+    case Op_Whitespace:\n+      return vmIntrinsics::is_intrinsic_available(vmIntrinsics::_isWhitespace);\n+\n+    case Op_CacheWB:\n+    case Op_CacheWBPreSync:\n+    case Op_CacheWBPostSync:\n+      return VM_Version::supports_data_cache_line_flush();\n@@ -2144,1 +2129,1 @@\n-  return ret_value;  \/\/ Per default match rules are supported.\n+  return true; \/\/ Per default match rules are supported.\n@@ -2148,8 +2133,4 @@\n-\n-  \/\/ TODO\n-  \/\/ identify extra cases that we might want to provide match rules for\n-  \/\/ e.g. Op_ vector nodes and other intrinsics while guarding with vlen\n-  bool ret_value = match_rule_supported(opcode);\n-  \/\/ Add rules here.\n-\n-  return ret_value;  \/\/ Per default match rules are supported.\n+  if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n+    return false;\n+  }\n+  return true; \/\/ Per default match rules are supported.\n@@ -2236,5 +2217,0 @@\n-\/\/ PPC AES support not yet implemented\n-const bool Matcher::pass_original_key_for_aes() {\n-  return false;\n-}\n-\n@@ -3889,2 +3865,0 @@\n-  in_preserve_stack_slots((frame::jit_in_preserve_size \/ VMRegImpl::stack_slot_size));\n-\n@@ -3915,34 +3889,0 @@\n-  \/\/ This is the body of the function\n-  \/\/\n-  \/\/ void Matcher::calling_convention(OptoRegPair* sig, \/\/ array of ideal regs\n-  \/\/                                  uint length,      \/\/ length of array\n-  \/\/                                  bool is_outgoing)\n-  \/\/\n-  \/\/ The `sig' array is to be updated. sig[j] represents the location\n-  \/\/ of the j-th argument, either a register or a stack slot.\n-\n-  \/\/ Comment taken from i486.ad:\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots. Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count. Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE. Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  calling_convention %{\n-    \/\/ No difference between ingoing\/outgoing. Just pass false.\n-    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);\n-  %}\n-\n-  \/\/ Comment taken from i486.ad:\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots. Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count. Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE. Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  c_calling_convention %{\n-    \/\/ This is obviously always outgoing.\n-    \/\/ C argument in register AND stack slot.\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, \/*regs2=*\/NULL, length);\n-  %}\n-\n@@ -6586,0 +6526,17 @@\n+\/\/ Reinterpret: only one vector size used: either L or X\n+instruct reinterpretL(iRegLdst dst) %{\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \"reinterpret $dst\" %}\n+  ins_encode( \/*empty*\/ );\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct reinterpretX(vecX dst) %{\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \"reinterpret $dst\" %}\n+  ins_encode( \/*empty*\/ );\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n@@ -10408,0 +10365,8 @@\n+instruct castLL(iRegLdst dst) %{\n+  match(Set dst (CastLL dst));\n+  format %{ \" -- \\t\/\/ castLL of $dst\" %}\n+  size(0);\n+  ins_encode( \/*empty*\/ );\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -11437,4 +11402,6 @@\n-instruct cmovI_conIvalueMinus1_conIvalue1(iRegIdst dst, flagsRegSrc crx) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx);\n-  predicate(false);\n+\/\/ Manifest a CmpL3 result in an integer register.\n+instruct cmpL3_reg_reg(iRegIdst dst, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{\n+  match(Set dst (CmpL3 src1 src2));\n+  effect(KILL cr0);\n+  ins_cost(DEFAULT_COST * 5);\n+  size(VM_Version::has_brw() ? 16 : 20);\n@@ -11442,1 +11409,1 @@\n-  ins_variable_size_depending_on_alignment(true);\n+  format %{ \"cmpL3_reg_reg $dst, $src1, $src2\" %}\n@@ -11444,75 +11411,2 @@\n-  format %{ \"cmovI   $crx, $dst, -1, 0, +1\" %}\n-  \/\/ Worst case is branch + move + branch + move + stop, no stop without scheduler.\n-  size(16);\n-    Label done;\n-    \/\/ li(Rdst, 0);              \/\/ equal -> 0\n-    __ beq($crx$$CondRegister, done);\n-    __ li($dst$$Register, 1);    \/\/ greater -> +1\n-    __ bgt($crx$$CondRegister, done);\n-    __ li($dst$$Register, -1);   \/\/ unordered or less -> -1\n-    __ bind(done);\n-  %}\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-instruct cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(iRegIdst dst, flagsRegSrc crx) %{\n-  \/\/ no match-rule, false predicate\n-  effect(DEF dst, USE crx);\n-  predicate(false);\n-\n-  format %{ \"CmovI    $crx, $dst, -1, 0, +1 \\t\/\/ postalloc expanded\" %}\n-  postalloc_expand %{\n-    \/\/\n-    \/\/ replaces\n-    \/\/\n-    \/\/   region  crx\n-    \/\/    \\       |\n-    \/\/     dst=cmovI_conIvalueMinus1_conIvalue0_conIvalue1\n-    \/\/\n-    \/\/ with\n-    \/\/\n-    \/\/   region\n-    \/\/    \\\n-    \/\/     dst=loadConI16(0)\n-    \/\/      |\n-    \/\/      ^  region  crx\n-    \/\/      |   \\       |\n-    \/\/      dst=cmovI_conIvalueMinus1_conIvalue1\n-    \/\/\n-\n-    \/\/ Create new nodes.\n-    MachNode *m1 = new loadConI16Node();\n-    MachNode *m2 = new cmovI_conIvalueMinus1_conIvalue1Node();\n-\n-    \/\/ inputs for new nodes\n-    m1->add_req(n_region);\n-    m2->add_req(n_region, n_crx);\n-    m2->add_prec(m1);\n-\n-    \/\/ operands for new nodes\n-    m1->_opnds[0] = op_dst;\n-    m1->_opnds[1] = new immI16Oper(0);\n-    m2->_opnds[0] = op_dst;\n-    m2->_opnds[1] = op_crx;\n-\n-    \/\/ registers for new nodes\n-    ra_->set_pair(m1->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-    ra_->set_pair(m2->_idx, ra_->get_reg_second(this), ra_->get_reg_first(this)); \/\/ dst\n-\n-    \/\/ Insert new nodes.\n-    nodes->push(m1);\n-    nodes->push(m2);\n-  %}\n-%}\n-\n-\/\/ Manifest a CmpL3 result in an integer register. Very painful.\n-\/\/ This is the test to avoid.\n-\/\/ (src1 < src2) ? -1 : ((src1 > src2) ? 1 : 0)\n-instruct cmpL3_reg_reg_ExEx(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{\n-  match(Set dst (CmpL3 src1 src2));\n-  ins_cost(DEFAULT_COST*5+BRANCH_COST);\n-\n-  expand %{\n-    flagsReg tmp1;\n-    cmpL_reg_reg(tmp1, src1, src2);\n-    cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);\n+    __ cmpd(CCR0, $src1$$Register, $src2$$Register);\n+    __ set_cmp3($dst$$Register);\n@@ -11521,0 +11415,1 @@\n+  ins_pipe(pipe_class_default);\n@@ -11843,1 +11738,1 @@\n-instruct cmpF3_reg_reg_ExEx(iRegIdst dst, regF src1, regF src2) %{\n+instruct cmpF3_reg_reg(iRegIdst dst, regF src1, regF src2, flagsRegCR0 cr0) %{\n@@ -11845,1 +11740,3 @@\n-  ins_cost(DEFAULT_COST*5+BRANCH_COST);\n+  effect(KILL cr0);\n+  ins_cost(DEFAULT_COST * 6);\n+  size(VM_Version::has_brw() ? 20 : 24);\n@@ -11847,4 +11744,5 @@\n-  expand %{\n-    flagsReg tmp1;\n-    cmpFUnordered_reg_reg(tmp1, src1, src2);\n-    cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);\n+  format %{ \"cmpF3_reg_reg $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fcmpu(CCR0, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ set_cmpu3($dst$$Register, true); \/\/ C2 requires unordered to get treated like less\n@@ -11852,0 +11750,1 @@\n+  ins_pipe(pipe_class_default);\n@@ -11923,1 +11822,1 @@\n-instruct cmpD3_reg_reg_ExEx(iRegIdst dst, regD src1, regD src2) %{\n+instruct cmpD3_reg_reg(iRegIdst dst, regD src1, regD src2, flagsRegCR0 cr0) %{\n@@ -11925,1 +11824,3 @@\n-  ins_cost(DEFAULT_COST*5+BRANCH_COST);\n+  effect(KILL cr0);\n+  ins_cost(DEFAULT_COST * 6);\n+  size(VM_Version::has_brw() ? 20 : 24);\n@@ -11927,4 +11828,5 @@\n-  expand %{\n-    flagsReg tmp1;\n-    cmpDUnordered_reg_reg(tmp1, src1, src2);\n-    cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);\n+  format %{ \"cmpD3_reg_reg $dst, $src1, $src2\" %}\n+\n+  ins_encode %{\n+    __ fcmpu(CCR0, $src1$$FloatRegister, $src2$$FloatRegister);\n+    __ set_cmpu3($dst$$Register, true); \/\/ C2 requires unordered to get treated like less\n@@ -11932,0 +11834,1 @@\n+  ins_pipe(pipe_class_default);\n@@ -12616,0 +12519,1 @@\n+  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U);\n@@ -12618,1 +12522,1 @@\n-  format %{ \"String IndexOfChar $haystack[0..$haycnt], $ch\"\n+  format %{ \"StringUTF16 IndexOfChar $haystack[0..$haycnt], $ch\"\n@@ -12629,0 +12533,19 @@\n+instruct indexOfChar_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,\n+                       iRegIsrc ch, iRegIdst tmp1, iRegIdst tmp2,\n+                       flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{\n+  match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);\n+  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L);\n+  ins_cost(180);\n+\n+  format %{ \"StringLatin1 IndexOfChar $haystack[0..$haycnt], $ch\"\n+            \" -> $result \\t\/\/ KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1\" %}\n+  ins_encode %{\n+    __ string_indexof_char($result$$Register,\n+                           $haystack$$Register, $haycnt$$Register,\n+                           $ch$$Register, 0 \/* this is not used if the character is already in a register *\/,\n+                           $tmp1$$Register, $tmp2$$Register, true \/*is_byte*\/);\n+  %}\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":141,"deletions":218,"binary":false,"changes":359,"status":"modified"},{"patch":"@@ -636,2 +636,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -2522,0 +2521,4 @@\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return frame::jit_in_preserve_size \/ VMRegImpl::stack_slot_size;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1514,1 +1514,3 @@\n-  if (!has_match_rule(opcode)) return false;\n+  if (!has_match_rule(opcode)) {\n+    return false; \/\/ no match rule present\n+  }\n@@ -1517,7 +1519,0 @@\n-    case Op_CountLeadingZerosI:\n-    case Op_CountLeadingZerosL:\n-    case Op_CountTrailingZerosI:\n-    case Op_CountTrailingZerosL:\n-      \/\/ Implementation requires FLOGR instruction, which is available since z9.\n-      return true;\n-\n@@ -1527,2 +1522,0 @@\n-\n-    \/\/ PopCount supported by H\/W from z\/Architecture G5 (z196) on.\n@@ -1531,23 +1524,2 @@\n-      return UsePopCountInstruction && VM_Version::has_PopCount();\n-\n-    case Op_StrComp:\n-      return SpecialStringCompareTo;\n-    case Op_StrEquals:\n-      return SpecialStringEquals;\n-    case Op_StrIndexOf:\n-    case Op_StrIndexOfChar:\n-      return SpecialStringIndexOf;\n-\n-    case Op_GetAndAddI:\n-    case Op_GetAndAddL:\n-      return true;\n-      \/\/ return VM_Version::has_AtomicMemWithImmALUOps();\n-    case Op_GetAndSetI:\n-    case Op_GetAndSetL:\n-    case Op_GetAndSetP:\n-    case Op_GetAndSetN:\n-      return true;  \/\/ General CAS implementation, always available.\n-\n-    default:\n-      return true;  \/\/ Per default match rules are supported.\n-                    \/\/ BUT: make sure match rule is not disabled by a false predicate!\n+      \/\/ PopCount supported by H\/W from z\/Architecture G5 (z196) on.\n+      return (UsePopCountInstruction && VM_Version::has_PopCount());\n@@ -1556,2 +1528,1 @@\n-  return true;  \/\/ Per default match rules are supported.\n-                \/\/ BUT: make sure match rule is not disabled by a false predicate!\n+  return true; \/\/ Per default match rules are supported.\n@@ -1561,7 +1532,4 @@\n-  \/\/ TODO\n-  \/\/ Identify extra cases that we might want to provide match rules for\n-  \/\/ e.g. Op_ vector nodes and other intrinsics while guarding with vlen.\n-  bool ret_value = match_rule_supported(opcode);\n-  \/\/ Add rules here.\n-\n-  return ret_value;  \/\/ Per default match rules are supported.\n+  if (!match_rule_supported(opcode) || !vector_size_supported(bt, vlen)) {\n+    return false;\n+  }\n+  return true; \/\/ Per default match rules are supported.\n@@ -1637,5 +1605,0 @@\n-\/\/ Not yet ported to z\/Architecture.\n-const bool Matcher::pass_original_key_for_aes() {\n-  return false;\n-}\n-\n@@ -2503,2 +2466,0 @@\n-  in_preserve_stack_slots(frame::jit_in_preserve_size_in_4_byte_units);\n-\n@@ -2519,32 +2480,0 @@\n-  \/\/ This is the body of the function\n-  \/\/\n-  \/\/ void Matcher::calling_convention(OptoRegPair* sig \/* array of ideal regs *\/,\n-  \/\/                                  uint length      \/* length of array *\/,\n-  \/\/                                  bool is_outgoing)\n-  \/\/\n-  \/\/ The `sig' array is to be updated. Sig[j] represents the location\n-  \/\/ of the j-th argument, either a register or a stack slot.\n-\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots. Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count. Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE. Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  calling_convention %{\n-    \/\/ No difference between ingoing\/outgoing just pass false.\n-    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);\n-  %}\n-\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots. Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count. Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE. Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  c_calling_convention %{\n-    \/\/ This is obviously always outgoing.\n-    \/\/ C argument must be in register AND stack slot.\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, \/*regs2=*\/NULL, length);\n-  %}\n-\n@@ -5433,0 +5362,7 @@\n+instruct castLL(iRegL dst) %{\n+  match(Set dst (CastLL dst));\n+  size(0);\n+  format %{ \"# castLL of $dst\" %}\n+  ins_encode(\/*empty*\/);\n+  ins_pipe(pipe_class_dummy);\n+%}\n@@ -10171,0 +10107,1 @@\n+  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U);\n@@ -10172,1 +10109,1 @@\n-  format %{ \"String IndexOfChar [0..$haycnt]($haystack), $ch -> $result\" %}\n+  format %{ \"StringUTF16 IndexOfChar [0..$haycnt]($haystack), $ch -> $result\" %}\n@@ -10182,0 +10119,15 @@\n+instruct indexOfChar_L(iRegP haystack, iRegI haycnt, iRegI ch, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{\n+  match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));\n+  effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); \/\/ R0, R1 are killed, too.\n+  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L);\n+  ins_cost(200);\n+  format %{ \"StringLatin1 IndexOfChar [0..$haycnt]($haystack), $ch -> $result\" %}\n+  ins_encode %{\n+    __ string_indexof_char($result$$Register,\n+                           $haystack$$Register, $haycnt$$Register,\n+                           $ch$$Register, 0 \/* unused, ch is in register *\/,\n+                           $oddReg$$Register, $evenReg$$Register, true \/*is_byte*\/);\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n@@ -10808,1 +10760,1 @@\n-\/\/ Store\n+\/\/ Load\/Store vector\n@@ -10822,2 +10774,0 @@\n-\/\/ Load\n-\n@@ -10835,0 +10785,9 @@\n+\/\/ Reinterpret: only one vector size used\n+instruct reinterpret(iRegL dst) %{\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \"reinterpret $dst\" %}\n+  ins_encode( \/*empty*\/ );\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":44,"deletions":85,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -652,2 +652,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -2590,0 +2589,4 @@\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return frame::jit_in_preserve_size_in_4_byte_units;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -421,2 +421,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -2210,0 +2209,8 @@\n+\/\/ Number of stack slots between incoming argument block and the start of\n+\/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n+\/\/ EPILOG must remove this many slots.  Intel needs one slot for\n+\/\/ return address and one for rbp, (must save rbp)\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return 2+VerifyStackAtCalls;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -454,2 +454,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n@@ -2620,0 +2619,9 @@\n+\n+\/\/ Number of stack slots between incoming argument block and the start of\n+\/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n+\/\/ EPILOG must remove this many slots.  amd64 needs two slots for\n+\/\/ return address.\n+uint SharedRuntime::in_preserve_stack_slots() {\n+  return 4 + 2 * VerifyStackAtCalls;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7131,1 +7131,3 @@\n-    StubRoutines::_verify_oop_subroutine_entry = generate_verify_oop();\n+    if (VerifyOops) {\n+      StubRoutines::_verify_oop_subroutine_entry = generate_verify_oop();\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1907,6 +1907,0 @@\n-\/\/ x86 AES instructions are compatible with SunJCE expanded\n-\/\/ keys, hence we do not need to pass the original key to stubs\n-const bool Matcher::pass_original_key_for_aes() {\n-  return false;\n-}\n-\n@@ -4432,3 +4426,2 @@\n-instruct reductionI(rRegI dst, rRegI src1, vec src2, vec vtmp1, vec vtmp2) %{\n-  predicate(vector_element_basic_type(n->in(2)) == T_INT &&\n-            vector_length(n->in(2)) < 16); \/\/ src2\n+instruct reductionI(rRegI dst, rRegI src1, legVec src2, legVec vtmp1, legVec vtmp2) %{\n+  predicate(vector_element_basic_type(n->in(2)) == T_INT); \/\/ src2\n@@ -4452,20 +4445,0 @@\n-instruct reduction16I(rRegI dst, rRegI src1, legVec src2, legVec vtmp1, legVec vtmp2) %{\n-  predicate(vector_element_basic_type(n->in(2)) == T_INT &&\n-            vector_length(n->in(2)) == 16); \/\/ src2\n-  match(Set dst (AddReductionVI src1 src2));\n-  match(Set dst (MulReductionVI src1 src2));\n-  match(Set dst (AndReductionV  src1 src2));\n-  match(Set dst ( OrReductionV  src1 src2));\n-  match(Set dst (XorReductionV  src1 src2));\n-  match(Set dst (MinReductionV  src1 src2));\n-  match(Set dst (MaxReductionV  src1 src2));\n-  effect(TEMP vtmp1, TEMP vtmp2);\n-  format %{ \"vector_reduction_int $dst,$src1,$src2 ; using $vtmp1, $vtmp2 as TEMP\" %}\n-  ins_encode %{\n-    int opcode = this->ideal_Opcode();\n-    int vlen = vector_length(this, $src2);\n-    __ reduceI(opcode, vlen, $dst$$Register, $src1$$Register, $src2$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);\n-%}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -4475,3 +4448,2 @@\n-instruct reductionL(rRegL dst, rRegL src1, vec src2, vec vtmp1, vec vtmp2) %{\n-  predicate(vector_element_basic_type(n->in(2)) == T_LONG &&\n-            vector_length(n->in(2)) < 8); \/\/ src2\n+instruct reductionL(rRegL dst, rRegL src1, legVec src2, legVec vtmp1, legVec vtmp2) %{\n+  predicate(vector_element_basic_type(n->in(2)) == T_LONG && !VM_Version::supports_avx512dq());\n@@ -4495,3 +4467,2 @@\n-instruct reduction8L(rRegL dst, rRegL src1, legVec src2, legVec vtmp1, legVec vtmp2) %{\n-  predicate(vector_element_basic_type(n->in(2)) == T_LONG &&\n-            vector_length(n->in(2)) == 8); \/\/ src2\n+instruct reductionL_avx512dq(rRegL dst, rRegL src1, vec src2, vec vtmp1, vec vtmp2) %{\n+  predicate(vector_element_basic_type(n->in(2)) == T_LONG && VM_Version::supports_avx512dq());\n@@ -4607,3 +4578,2 @@\n-instruct reductionB(rRegI dst, rRegI src1, vec src2, vec vtmp1, vec vtmp2) %{\n-  predicate(vector_element_basic_type(n->in(2)) == T_BYTE &&\n-            vector_length(n->in(2)) <= 32); \/\/ src2\n+instruct reductionB(rRegI dst, rRegI src1, legVec src2, legVec vtmp1, legVec vtmp2) %{\n+  predicate(vector_element_basic_type(n->in(2)) == T_BYTE && !VM_Version::supports_avx512bw());\n@@ -4626,3 +4596,2 @@\n-instruct reduction64B(rRegI dst, rRegI src1, legVec src2, legVec vtmp1, legVec vtmp2) %{\n-  predicate(vector_element_basic_type(n->in(2)) == T_BYTE &&\n-            vector_length(n->in(2)) == 64); \/\/ src2\n+instruct reductionB_avx512bw(rRegI dst, rRegI src1, vec src2, vec vtmp1, vec vtmp2) %{\n+  predicate(vector_element_basic_type(n->in(2)) == T_BYTE && VM_Version::supports_avx512bw());\n@@ -4649,2 +4618,1 @@\n-  predicate(vector_element_basic_type(n->in(2)) == T_SHORT &&\n-            vector_length(n->in(2)) <= 32); \/\/ src2\n+  predicate(vector_element_basic_type(n->in(2)) == T_SHORT); \/\/ src2\n@@ -5480,1 +5448,1 @@\n-instruct mul2L_reg(vec dst, vec src2, vec tmp) %{\n+instruct mul2L_reg(vec dst, vec src2, legVec tmp) %{\n@@ -5506,1 +5474,1 @@\n-instruct vmul4L_reg_avx(vec dst, vec src1, vec src2, vec tmp, vec tmp1) %{\n+instruct vmul4L_reg_avx(vec dst, vec src1, vec src2, legVec tmp, legVec tmp1) %{\n@@ -5821,1 +5789,1 @@\n-  effect(USE a, USE b, TEMP atmp, TEMP btmp);\n+  effect(TEMP dst, USE a, USE b, TEMP atmp, TEMP btmp);\n@@ -6991,0 +6959,1 @@\n+  format %{ \"extractI $dst,$src,$idx\\t!\" %}\n@@ -7009,0 +6978,1 @@\n+  format %{ \"vextractI $dst,$src,$idx\\t! using $vtmp as TEMP\" %}\n@@ -7023,0 +6993,1 @@\n+  format %{ \"extractL $dst,$src,$idx\\t!\" %}\n@@ -7037,0 +7008,1 @@\n+  format %{ \"vextractL $dst,$src,$idx\\t! using $vtmp as TEMP\" %}\n@@ -7051,0 +7023,1 @@\n+  format %{ \"extractF $dst,$src,$idx\\t! using $tmp, $vtmp as TEMP\" %}\n@@ -7064,0 +7037,1 @@\n+  format %{ \"vextractF $dst,$src,$idx\\t! using $tmp, $vtmp as TEMP\" %}\n@@ -7076,0 +7050,1 @@\n+  format %{ \"extractD $dst,$src,$idx\\t!\" %}\n@@ -7089,0 +7064,1 @@\n+  format %{ \"vextractD $dst,$src,$idx\\t! using $vtmp as TEMP\" %}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":22,"deletions":46,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -656,2 +656,3 @@\n-    st->print(\"TEST   PollPage,EAX\\t! Poll Safepoint\");\n-    st->cr(); st->print(\"\\t\");\n+    st->print(\"CMPL     rsp, poll_offset[thread]  \\n\\t\"\n+              \"JA       #safepoint_stub\\t\"\n+              \"# Safepoint: poll for GC\");\n@@ -700,1 +701,1 @@\n-    Register pollReg = as_Register(EBX_enc);\n+    Register thread = as_Register(EBX_enc);\n@@ -702,4 +703,8 @@\n-    masm.get_thread(pollReg);\n-    masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));\n-    masm.relocate(relocInfo::poll_return_type);\n-    masm.testl(rax, Address(pollReg, 0));\n+    __ get_thread(thread);\n+    Label dummy_label;\n+    Label* code_stub = &dummy_label;\n+    if (!C->output()->in_scratch_emit_size()) {\n+      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+    }\n+    __ relocate(relocInfo::poll_return_type);\n+    __ safepoint_poll(*code_stub, thread, true \/* at_return *\/, true \/* in_nmethod *\/);\n@@ -3171,6 +3176,0 @@\n-  \/\/ Number of stack slots between incoming argument block and the start of\n-  \/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n-  \/\/ EPILOG must remove this many slots.  Intel needs one slot for\n-  \/\/ return address and one for rbp, (must save rbp)\n-  in_preserve_stack_slots(2+VerifyStackAtCalls);\n-\n@@ -3192,23 +3191,0 @@\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots.  Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count.  Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE.  Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  calling_convention %{\n-    \/\/ No difference between ingoing\/outgoing just pass false\n-    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);\n-  %}\n-\n-\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots.  Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count.  Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE.  Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-  c_calling_convention %{\n-    \/\/ This is obviously always outgoing\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, \/*regs2=*\/NULL, length);\n-  %}\n-\n@@ -7188,0 +7164,8 @@\n+instruct castLL( eRegL dst ) %{\n+  match(Set dst (CastLL dst));\n+  format %{ \"#castLL of $dst\" %}\n+  ins_encode( \/*empty encoding*\/ );\n+  ins_cost(0);\n+  ins_pipe( empty );\n+%}\n+\n@@ -13114,0 +13098,22 @@\n+instruct cmovLL_reg_LEGT_U(cmpOpU_commute cmp, flagsReg_ulong_LEGT flags, eRegL dst, eRegL src) %{\n+  match(Set dst (CMoveL (Binary cmp flags) (Binary dst src)));\n+  predicate(VM_Version::supports_cmov() && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt ));\n+  ins_cost(400);\n+  format %{ \"CMOV$cmp $dst.lo,$src.lo\\n\\t\"\n+            \"CMOV$cmp $dst.hi,$src.hi\" %}\n+  opcode(0x0F,0x40);\n+  ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );\n+  ins_pipe( pipe_cmov_reg_long );\n+%}\n+\n+instruct cmovLL_mem_LEGT_U(cmpOpU_commute cmp, flagsReg_ulong_LEGT flags, eRegL dst, load_long_memory src) %{\n+  match(Set dst (CMoveL (Binary cmp flags) (Binary dst (LoadL src))));\n+  predicate(VM_Version::supports_cmov() && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt ));\n+  ins_cost(500);\n+  format %{ \"CMOV$cmp $dst.lo,$src.lo\\n\\t\"\n+            \"CMOV$cmp $dst.hi,$src.hi+4\" %}\n+  opcode(0x0F,0x40);\n+  ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );\n+  ins_pipe( pipe_cmov_reg_long );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":42,"deletions":36,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -933,2 +933,2 @@\n-    st->print_cr(\"cmpq    poll_offset[r15_thread], rsp\\n\\t\"\n-                 \"ja      #safepoint_stub\\t\"\n+    st->print_cr(\"cmpq     rsp, poll_offset[r15_thread] \\n\\t\"\n+                 \"ja       #safepoint_stub\\t\"\n@@ -2776,6 +2776,0 @@\n-  \/\/ Number of stack slots between incoming argument block and the start of\n-  \/\/ a new frame.  The PROLOG must add this many slots to the stack.  The\n-  \/\/ EPILOG must remove this many slots.  amd64 needs two slots for\n-  \/\/ return address.\n-  in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);\n-\n@@ -2797,19 +2791,0 @@\n-  \/\/ Body of function which returns an integer array locating\n-  \/\/ arguments either in registers or in stack slots.  Passed an array\n-  \/\/ of ideal registers called \"sig\" and a \"length\" count.  Stack-slot\n-  \/\/ offsets are based on outgoing arguments, i.e. a CALLER setting up\n-  \/\/ arguments for a CALLEE.  Incoming stack arguments are\n-  \/\/ automatically biased by the preserve_stack_slots field above.\n-\n-  calling_convention\n-  %{\n-    \/\/ No difference between ingoing\/outgoing just pass false\n-    SharedRuntime::java_calling_convention(sig_bt, regs, length, false);\n-  %}\n-\n-  c_calling_convention\n-  %{\n-    \/\/ This is obviously always outgoing\n-    (void) SharedRuntime::c_calling_convention(sig_bt, regs, \/*regs2=*\/NULL, length);\n-  %}\n-\n@@ -7490,0 +7465,11 @@\n+instruct castLL(rRegL dst)\n+%{\n+  match(Set dst (CastLL dst));\n+\n+  size(0);\n+  format %{ \"# castLL of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":13,"deletions":27,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -54,2 +54,1 @@\n-                                           int total_args_passed,\n-                                           int is_outgoing) {\n+                                           int total_args_passed) {\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-          range(0, max_jint)                                                \\\n+          range(1, max_jint)                                                \\\n@@ -100,1 +100,1 @@\n-          range(0, max_jint)                                                \\\n+          range(1, max_jint)                                                \\\n@@ -363,3 +363,0 @@\n-  product(bool, UseRDPCForConstantTableBase, false,                         \\\n-          \"Use Sparc RDPC instruction for the constant table base.\")        \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -68,2 +69,2 @@\n-void StartNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n-  Matcher::calling_convention( sig_bt, parm_regs, argcnt, false );\n+void StartNode::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {\n+  SharedRuntime::java_calling_convention(sig_bt, parm_regs, argcnt);\n@@ -700,1 +701,1 @@\n-void CallNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n+void CallNode::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {\n@@ -702,1 +703,1 @@\n-  Matcher::calling_convention( sig_bt, parm_regs, argcnt, true );\n+  SharedRuntime::java_calling_convention(sig_bt, parm_regs, argcnt);\n@@ -726,2 +727,2 @@\n-        ? match->c_return_value(ideal_reg,true)    \/\/ Calls into C runtime\n-        : match->return_value(ideal_reg, true);    \/\/ Calls into compiled Java code\n+        ? match->c_return_value(ideal_reg)  \/\/ Calls into C runtime\n+        : match->  return_value(ideal_reg); \/\/ Calls into compiled Java code\n@@ -1185,2 +1186,2 @@\n-void CallRuntimeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n-  Matcher::c_calling_convention( sig_bt, parm_regs, argcnt );\n+void CallRuntimeNode::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {\n+  SharedRuntime::c_calling_convention(sig_bt, parm_regs, \/*regs2=*\/nullptr, argcnt);\n@@ -1302,2 +1303,6 @@\n-  if( phase->type(in(0)) == Type::TOP ) return Type::TOP;\n-  if( phase->eqv( in(0), this ) ) return Type::TOP; \/\/ Dead infinite loop\n+  if (phase->type(in(0)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  if (in(0) == this) {\n+    return Type::TOP; \/\/ Dead infinite loop\n+  }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -720,2 +720,0 @@\n-    _is_scalar_replaceable = false;\n-    _is_non_escaping = false;\n@@ -729,2 +727,0 @@\n-    _is_scalar_replaceable = false;\n-    _is_non_escaping = false;\n@@ -734,4 +730,0 @@\n-  \/\/ Result of Escape Analysis\n-  bool _is_scalar_replaceable;\n-  bool _is_non_escaping;\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+macro(CastLL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -949,2 +949,0 @@\n-  set_do_count_invocations(false);\n-  set_do_method_data_update(false);\n@@ -1150,2 +1148,1 @@\n-  if (_modified_nodes != NULL && !_inlining_incrementally &&\n-      n->outcnt() != 0 && !n->is_Con()) {\n+  if (_modified_nodes != NULL && !_inlining_incrementally && !n->is_Con()) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -285,2 +286,0 @@\n-  bool                  _do_count_invocations;  \/\/ True if we generate code to count invocations\n-  bool                  _do_method_data_update; \/\/ True if we generate code to update MethodData*s\n@@ -574,4 +573,0 @@\n-  bool              do_count_invocations() const{ return _do_count_invocations; }\n-  void          set_do_count_invocations(bool z){ _do_count_invocations = z; }\n-  bool              do_method_data_update() const { return _do_method_data_update; }\n-  void          set_do_method_data_update(bool z) { _do_method_data_update = z; }\n@@ -1043,1 +1038,3 @@\n-  uint in_preserve_stack_slots();\n+  uint in_preserve_stack_slots() {\n+    return SharedRuntime::in_preserve_stack_slots();\n+  }\n@@ -1048,3 +1045,3 @@\n-  \/\/ On Sparc this describes the words reserved for storing a register window\n-  \/\/ when an interrupt occurs.\n-  static uint out_preserve_stack_slots();\n+  static uint out_preserve_stack_slots() {\n+    return SharedRuntime::out_preserve_stack_slots();\n+  }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -649,4 +649,0 @@\n-  \/\/ Bump method data counters (We profile *before* the call is made\n-  \/\/ because exceptions don't return to the call site.)\n-  profile_call(receiver);\n-\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -249,3 +249,0 @@\n-    if (n->is_CallStaticJava()) {\n-      n->as_CallStaticJava()->_is_non_escaping = noescape;\n-    }\n@@ -1081,0 +1078,1 @@\n+                  strcmp(call->as_CallLeaf()->_name, \"decodeBlock\") == 0 ||\n@@ -3072,5 +3070,0 @@\n-        if (alloc->is_CallStaticJava()) {\n-          \/\/ Set the scalar_replaceable flag for boxing method\n-          \/\/ so it could be eliminated if it has no uses.\n-          alloc->as_CallStaticJava()->_is_scalar_replaceable = true;\n-        }\n@@ -3125,5 +3118,0 @@\n-      if (alloc->is_CallStaticJava()) {\n-        \/\/ Set the scalar_replaceable flag for boxing method\n-        \/\/ so it could be eliminated.\n-        alloc->as_CallStaticJava()->_is_scalar_replaceable = true;\n-      }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -106,0 +106,7 @@\n+  Node* integercon(jlong con, BasicType bt)   const {\n+    if (bt == T_INT) {\n+      return intcon(checked_cast<jint>(con));\n+    }\n+    assert(bt == T_LONG, \"basic type not an int or long\");\n+    return longcon(con);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -433,1 +433,1 @@\n-    tmp->destruct();\n+    tmp->destruct(NULL);\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-  bool inline_preconditions_checkIndex();\n+  bool inline_preconditions_checkIndex(BasicType bt);\n@@ -276,1 +276,0 @@\n-  Node* get_original_key_start_from_aescrypt_object(Node* aescrypt_object);\n@@ -279,0 +278,1 @@\n+  bool inline_base64_decodeBlock();\n@@ -348,0 +348,2 @@\n+\n+  bool inline_getObjectSize();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    OptoRegPair regs = return_value(ireg, false);\n+    OptoRegPair regs = return_value(ireg);\n@@ -751,1 +751,1 @@\n-  OptoReg::Name reg = find_receiver(false);\n+  OptoReg::Name reg = find_receiver();\n@@ -1467,5 +1467,7 @@\n-  for( i = 0; i < NUM_OPERANDS; i++ ) {\n-    if( s->valid(i) &&                \/\/ valid entry and\n-        s->_cost[i] < cost &&         \/\/ low cost and\n-        s->_rule[i] >= NUM_OPERANDS ) \/\/ not an operand\n-      cost = s->_cost[mincost=i];\n+  for (i = 0; i < NUM_OPERANDS; i++) {\n+    if (s->valid(i) &&               \/\/ valid entry and\n+        s->cost(i) < cost &&         \/\/ low cost and\n+        s->rule(i) >= NUM_OPERANDS) {\/\/ not an operand\n+      mincost = i;\n+      cost = s->cost(i);\n+    }\n@@ -1482,1 +1484,1 @@\n-  MachNode *m = ReduceInst( s, s->_rule[mincost], mem );\n+  MachNode *m = ReduceInst(s, s->rule(mincost), mem);\n@@ -1850,1 +1852,1 @@\n-void Matcher::ReduceInst_Chain_Rule( State *s, int rule, Node *&mem, MachNode *mach ) {\n+void Matcher::ReduceInst_Chain_Rule(State* s, int rule, Node* &mem, MachNode* mach) {\n@@ -1855,1 +1857,1 @@\n-  int opnd_class_instance = s->_rule[op];\n+  unsigned int opnd_class_instance = s->rule(op);\n@@ -1860,1 +1862,1 @@\n-  int newrule = s->_rule[catch_op];\n+  unsigned int newrule = s->rule(catch_op);\n@@ -1862,1 +1864,1 @@\n-  if( newrule < NUM_OPERANDS ) {\n+  if (newrule < NUM_OPERANDS) {\n@@ -1864,2 +1866,1 @@\n-    assert( 0 <= opnd_class_instance && opnd_class_instance < NUM_OPERANDS,\n-            \"Bad AD file: Instruction chain rule must chain from operand\");\n+    assert(opnd_class_instance < NUM_OPERANDS, \"Bad AD file: Instruction chain rule must chain from operand\");\n@@ -1869,1 +1870,1 @@\n-    ReduceOper( s, newrule, mem, mach );\n+    ReduceOper(s, newrule, mem, mach);\n@@ -1872,1 +1873,1 @@\n-    assert( newrule >= _LAST_MACH_OPER, \"Do NOT chain from internal operand\");\n+    assert(newrule >= _LAST_MACH_OPER, \"Do NOT chain from internal operand\");\n@@ -1910,1 +1911,1 @@\n-    int opnd_class_instance = newstate->_rule[op];\n+    int opnd_class_instance = newstate->rule(op);\n@@ -1915,1 +1916,1 @@\n-    int newrule = newstate->_rule[catch_op];\n+    int newrule = newstate->rule(catch_op);\n@@ -1917,1 +1918,1 @@\n-    if( newrule < NUM_OPERANDS ) { \/\/ Operand\/operandClass or internalOp\/instruction?\n+    if (newrule < NUM_OPERANDS) { \/\/ Operand\/operandClass or internalOp\/instruction?\n@@ -1921,1 +1922,1 @@\n-      ReduceOper( newstate, newrule, mem, mach );\n+      ReduceOper(newstate, newrule, mem, mach);\n@@ -1924,1 +1925,1 @@\n-      if( newrule < _LAST_MACH_OPER ) { \/\/ internal operand or instruction?\n+      if (newrule < _LAST_MACH_OPER) { \/\/ internal operand or instruction?\n@@ -1927,1 +1928,1 @@\n-        num_opnds = ReduceInst_Interior( newstate, newrule, mem, mach, num_opnds );\n+        num_opnds = ReduceInst_Interior(newstate, newrule, mem, mach, num_opnds);\n@@ -1979,1 +1980,1 @@\n-  for( uint i=0; kid != NULL && i<2; kid = s->_kids[1], i++ ) {   \/\/ binary tree\n+  for (uint i = 0; kid != NULL && i < 2; kid = s->_kids[1], i++) {   \/\/ binary tree\n@@ -1981,4 +1982,5 @@\n-    if( i == 0)\n-      newrule = kid->_rule[_leftOp[rule]];\n-    else\n-      newrule = kid->_rule[_rightOp[rule]];\n+    if( i == 0) {\n+      newrule = kid->rule(_leftOp[rule]);\n+    } else {\n+      newrule = kid->rule(_rightOp[rule]);\n+    }\n@@ -1986,1 +1988,1 @@\n-    if( newrule < _LAST_MACH_OPER ) { \/\/ Operand or instruction?\n+    if (newrule < _LAST_MACH_OPER) { \/\/ Operand or instruction?\n@@ -1988,1 +1990,1 @@\n-      ReduceOper( kid, newrule, mem, mach );\n+      ReduceOper(kid, newrule, mem, mach);\n@@ -2008,1 +2010,1 @@\n-OptoReg::Name Matcher::find_receiver( bool is_outgoing ) {\n+OptoReg::Name Matcher::find_receiver() {\n@@ -2011,1 +2013,1 @@\n-  calling_convention(&sig_bt, &regs, 1, is_outgoing);\n+  SharedRuntime::java_calling_convention(&sig_bt, &regs, 1);\n@@ -2822,1 +2824,1 @@\n-State::State(void) {\n+State::State(void) : _rule() {\n@@ -2827,3 +2829,0 @@\n-  \/\/memset(_cost, -1, sizeof(_cost));\n-  \/\/memset(_rule, -1, sizeof(_rule));\n-  memset(_valid, 0, sizeof(_valid));\n@@ -2851,1 +2850,1 @@\n-  for( int j = 0; j < depth; j++ )\n+  for (int j = 0; j < depth; j++) {\n@@ -2853,0 +2852,1 @@\n+  }\n@@ -2856,1 +2856,1 @@\n-  for( i = 0; i < _LAST_MACH_OPER; i++ )\n+  for (i = 0; i < _LAST_MACH_OPER; i++) {\n@@ -2858,2 +2858,2 @@\n-    if( valid(i) ) {\n-      for( int j = 0; j < depth; j++ )\n+    if (valid(i)) {\n+      for (int j = 0; j < depth; j++) {\n@@ -2861,4 +2861,6 @@\n-        assert(_cost[i] != max_juint, \"cost must be a valid value\");\n-        assert(_rule[i] < _last_Mach_Node, \"rule[i] must be valid rule\");\n-        tty->print_cr(\"%s  %d  %s\",\n-                      ruleName[i], _cost[i], ruleName[_rule[i]] );\n+      assert(cost(i) != max_juint, \"cost must be a valid value\");\n+      assert(rule(i) < _last_Mach_Node, \"rule[i] must be valid rule\");\n+      tty->print_cr(\"%s  %d  %s\",\n+                    ruleName[i], cost(i), ruleName[rule(i)] );\n+    }\n+  }\n@@ -2868,3 +2870,5 @@\n-  for( i=0; i<2; i++ )\n-    if( _kids[i] )\n-      _kids[i]->dump(depth+1);\n+  for (i = 0; i < 2; i++) {\n+    if (_kids[i]) {\n+      _kids[i]->dump(depth + 1);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":50,"deletions":46,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -354,3 +354,0 @@\n-  \/\/ Should original key array reference be passed to AES stubs\n-  static const bool pass_original_key_for_aes();\n-\n@@ -376,4 +373,0 @@\n-  \/\/ Array mapping arguments to registers.  Argument 0 is usually the 'this'\n-  \/\/ pointer.  Registers can include stack-slots and regular registers.\n-  static void calling_convention( BasicType *, VMRegPair *, uint len, bool is_outgoing );\n-\n@@ -382,1 +375,1 @@\n-  static OptoReg::Name  find_receiver( bool is_outgoing );\n+  static OptoReg::Name  find_receiver();\n@@ -387,3 +380,3 @@\n-  \/\/ Return value register.  On Intel it is EAX.  On Sparc i0\/o0.\n-  static OptoRegPair   return_value(uint ideal_reg, bool is_outgoing);\n-  static OptoRegPair c_return_value(uint ideal_reg, bool is_outgoing);\n+  \/\/ Return value register.  On Intel it is EAX.\n+  static OptoRegPair   return_value(uint ideal_reg);\n+  static OptoRegPair c_return_value(uint ideal_reg);\n@@ -427,3 +420,0 @@\n-  \/\/ Array mapping arguments to registers.  Argument 0 is usually the 'this'\n-  \/\/ pointer.  Registers can include stack-slots and regular registers.\n-  static void c_calling_convention( BasicType*, VMRegPair *, uint );\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -591,2 +591,5 @@\n-void Node::destruct() {\n-  Compile* compile = Compile::current();\n+void Node::destruct(PhaseValues* phase) {\n+  Compile* compile = (phase != NULL) ? phase->C : Compile::current();\n+  if (phase != NULL && phase->is_IterGVN()) {\n+    phase->is_IterGVN()->_worklist.remove(this);\n+  }\n@@ -664,1 +667,1 @@\n-void Node::grow( uint len ) {\n+void Node::grow(uint len) {\n@@ -1409,1 +1412,0 @@\n-      igvn->C->remove_modified_node(dead);\n@@ -1445,0 +1447,1 @@\n+      igvn->C->remove_modified_node(dead);\n@@ -2270,18 +2273,0 @@\n-\/\/------------------------------walk-------------------------------------------\n-\/\/ Graph walk, with both pre-order and post-order functions\n-void Node::walk(NFunc pre, NFunc post, void *env) {\n-  VectorSet visited; \/\/ Setup for local walk\n-  walk_(pre, post, env, visited);\n-}\n-\n-void Node::walk_(NFunc pre, NFunc post, void *env, VectorSet &visited) {\n-  if( visited.test_set(_idx) ) return;\n-  pre(*this,env);               \/\/ Call the pre-order walk function\n-  for( uint i=0; i<_max; i++ )\n-    if( in(i) )                 \/\/ Input exists and is not walked?\n-      in(i)->walk_(pre,post,env,visited); \/\/ Walk it with pre & post functions\n-  post(*this,env);              \/\/ Call the post-order walk function\n-}\n-\n-void Node::nop(Node &, void*) {}\n-\n@@ -2295,1 +2280,0 @@\n-static RegMask _not_used_at_all;\n@@ -2299,1 +2283,1 @@\n-  return _not_used_at_all;\n+  return RegMask::Empty;\n@@ -2304,10 +2288,1 @@\n-  return _not_used_at_all;\n-}\n-\n-\/\/=============================================================================\n-\/\/-----------------------------------------------------------------------------\n-void Node_Array::reset( Arena *new_arena ) {\n-  _a->Afree(_nodes,_max*sizeof(Node*));\n-  _max   = 0;\n-  _nodes = NULL;\n-  _a     = new_arena;\n+  return RegMask::Empty;\n@@ -2316,1 +2291,0 @@\n-\/\/------------------------------clear------------------------------------------\n@@ -2322,7 +2296,2 @@\n-\/\/-----------------------------------------------------------------------------\n-void Node_Array::grow( uint i ) {\n-  if( !_max ) {\n-    _max = 1;\n-    _nodes = (Node**)_a->Amalloc( _max * sizeof(Node*) );\n-    _nodes[0] = NULL;\n-  }\n+void Node_Array::grow(uint i) {\n+  assert(_max > 0, \"invariant\");\n@@ -2335,4 +2304,5 @@\n-\/\/-----------------------------------------------------------------------------\n-void Node_Array::insert( uint i, Node *n ) {\n-  if( _nodes[_max-1] ) grow(_max);      \/\/ Get more space if full\n-  Copy::conjoint_words_to_higher((HeapWord*)&_nodes[i], (HeapWord*)&_nodes[i+1], ((_max-i-1)*sizeof(Node*)));\n+void Node_Array::insert(uint i, Node* n) {\n+  if (_nodes[_max - 1]) {\n+    grow(_max);\n+  }\n+  Copy::conjoint_words_to_higher((HeapWord*)&_nodes[i], (HeapWord*)&_nodes[i + 1], ((_max - i - 1) * sizeof(Node*)));\n@@ -2342,4 +2312,3 @@\n-\/\/-----------------------------------------------------------------------------\n-void Node_Array::remove( uint i ) {\n-  Copy::conjoint_words_to_lower((HeapWord*)&_nodes[i+1], (HeapWord*)&_nodes[i], ((_max-i-1)*sizeof(Node*)));\n-  _nodes[_max-1] = NULL;\n+void Node_Array::remove(uint i) {\n+  Copy::conjoint_words_to_lower((HeapWord*)&_nodes[i + 1], (HeapWord*)&_nodes[i], ((_max - i - 1) * sizeof(Node*)));\n+  _nodes[_max - 1] = NULL;\n@@ -2348,6 +2317,0 @@\n-\/\/-----------------------------------------------------------------------------\n-void Node_Array::sort( C_sort_func_t func) {\n-  qsort( _nodes, _max, sizeof( Node* ), func );\n-}\n-\n-\/\/-----------------------------------------------------------------------------\n@@ -2356,3 +2319,3 @@\n-  for( uint i = 0; i < _max; i++ ) {\n-    Node *nn = _nodes[i];\n-    if( nn != NULL ) {\n+  for (uint i = 0; i < _max; i++) {\n+    Node* nn = _nodes[i];\n+    if (nn != NULL) {\n@@ -2421,1 +2384,3 @@\n-      if (found != NULL) return NULL;\n+      if (found != NULL) {\n+        return NULL;\n+      }\n@@ -2464,2 +2429,2 @@\n-  for( i = 0; i < _cnt; i++ )\n-    if( _nodes[i] == n )\n+  for (i = 0; i < _cnt; i++) {\n+    if (_nodes[i] == n) {\n@@ -2467,0 +2432,2 @@\n+    }\n+  }\n@@ -2468,1 +2435,1 @@\n-  if( i < _cnt )\n+  if (i < _cnt) {\n@@ -2470,0 +2437,1 @@\n+  }\n@@ -2475,3 +2443,3 @@\n-  for( uint i = 0; i < _cnt; i++ )\n-    if( _nodes[i] ) {\n-      tty->print(\"%5d--> \",i);\n+  for (uint i = 0; i < _cnt; i++) {\n+    if (_nodes[i]) {\n+      tty->print(\"%5d--> \", i);\n@@ -2480,0 +2448,1 @@\n+  }\n@@ -2485,1 +2454,1 @@\n-  for( uint i = 0; i < _cnt; i++ )\n+  for (uint i = 0; i < _cnt; i++) {\n@@ -2491,0 +2460,1 @@\n+  }\n@@ -2512,1 +2482,0 @@\n-\n@@ -2518,5 +2487,1 @@\n-      map(i,Node_List::pop());\n-      \/\/ Node *replacement = Node_List::pop();\n-      \/\/ if( i != size() ) { \/\/ Check if removing last entry\n-      \/\/   _nodes[i] = replacement;\n-      \/\/ }\n+      map(i, Node_List::pop());\n@@ -2542,2 +2507,2 @@\n-  for (uint i=0; i < sz; i++) {\n-    if (idx == index_at(i) )\n+  for (uint i = 0; i < sz; i++) {\n+    if (idx == index_at(i)) {\n@@ -2545,0 +2510,1 @@\n+    }\n@@ -2553,1 +2519,1 @@\n-  if( !Verbose && !WizardMode ) {\n+  if (!Verbose && !WizardMode) {\n@@ -2567,3 +2533,4 @@\n-bool TypeNode::cmp( const Node &n ) const\n-{ return !Type::cmp( _type, ((TypeNode&)n)._type ); }\n-const Type *TypeNode::bottom_type() const { return _type; }\n+bool TypeNode::cmp(const Node& n) const {\n+  return !Type::cmp(_type, ((TypeNode&)n)._type);\n+}\n+const Type* TypeNode::bottom_type() const { return _type; }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":46,"deletions":79,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -752,1 +752,1 @@\n-    x->destruct();              \/\/ Hit, destroy duplicate constant\n+    x->destruct(this);          \/\/ Hit, destroy duplicate constant\n@@ -1072,1 +1072,1 @@\n-    if (n->outcnt() != 0 && !n->is_Con() && !_worklist.member(n)) {\n+    if (!n->is_Con() && !_worklist.member(n)) {\n@@ -1074,1 +1074,1 @@\n-      assert(false, \"modified node is not on IGVN._worklist\");\n+      fatal(\"modified node is not on IGVN._worklist\");\n@@ -1086,1 +1086,1 @@\n-    if (n->outcnt() != 0 && !n->is_Con()) { \/\/ skip dead and Con nodes\n+    if (!n->is_Con()) { \/\/ skip Con nodes\n@@ -1088,1 +1088,1 @@\n-      assert(false, \"modified node was not processed by IGVN.transform_old()\");\n+      fatal(\"modified node was not processed by IGVN.transform_old()\");\n@@ -1477,2 +1477,1 @@\n-  _worklist.remove(temp);   \/\/ this can be necessary\n-  temp->destruct();         \/\/ reuse the _idx of this little guy\n+  temp->destruct(this);     \/\/ reuse the _idx of this little guy\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -807,3 +808,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    num_args = 4;\n-  }\n@@ -816,3 +814,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ original k array\n-  }\n@@ -900,3 +895,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    num_args = 6;\n-  }\n@@ -911,3 +903,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ original k array\n-  }\n@@ -928,3 +917,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-     num_args = 5;\n-  }\n@@ -938,3 +924,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-     fields[argp++] = TypePtr::NOTNULL;    \/\/ original k array\n-  }\n@@ -955,3 +938,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    num_args = 8;\n-  }\n@@ -968,3 +948,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    fields[argp++] = TypePtr::NOTNULL; \/\/ original k array\n-  }\n@@ -1216,0 +1193,21 @@\n+\/\/ Base64 decode function\n+const TypeFunc* OptoRuntime::base64_decodeBlock_Type() {\n+  int argcnt = 6;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ src array\n+  fields[argp++] = TypeInt::INT;        \/\/ src offset\n+  fields[argp++] = TypeInt::INT;        \/\/ src length\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ dest array\n+  fields[argp++] = TypeInt::INT;        \/\/ dest offset\n+  fields[argp++] = TypeInt::BOOL;       \/\/ isURL\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ count of bytes written to dst\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+  return TypeFunc::make(domain, range);\n+}\n@@ -1232,54 +1230,0 @@\n-\/\/-------------- methodData update helpers\n-\n-const TypeFunc* OptoRuntime::profile_receiver_type_Type() {\n-  \/\/ create input type (domain)\n-  const Type **fields = TypeTuple::fields(2);\n-  fields[TypeFunc::Parms+0] = TypeAryPtr::NOTNULL;    \/\/ methodData pointer\n-  fields[TypeFunc::Parms+1] = TypeInstPtr::BOTTOM;    \/\/ receiver oop\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n-\n-  \/\/ create result type\n-  fields = TypeTuple::fields(1);\n-  fields[TypeFunc::Parms+0] = NULL; \/\/ void\n-  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);\n-  return TypeFunc::make(domain,range);\n-}\n-\n-JRT_LEAF(void, OptoRuntime::profile_receiver_type_C(DataLayout* data, oopDesc* receiver))\n-  if (receiver == NULL) return;\n-  Klass* receiver_klass = receiver->klass();\n-\n-  intptr_t* mdp = ((intptr_t*)(data)) + DataLayout::header_size_in_cells();\n-  int empty_row = -1;           \/\/ free row, if any is encountered\n-\n-  \/\/ ReceiverTypeData* vc = new ReceiverTypeData(mdp);\n-  for (uint row = 0; row < ReceiverTypeData::row_limit(); row++) {\n-    \/\/ if (vc->receiver(row) == receiver_klass)\n-    int receiver_off = ReceiverTypeData::receiver_cell_index(row);\n-    intptr_t row_recv = *(mdp + receiver_off);\n-    if (row_recv == (intptr_t) receiver_klass) {\n-      \/\/ vc->set_receiver_count(row, vc->receiver_count(row) + DataLayout::counter_increment);\n-      int count_off = ReceiverTypeData::receiver_count_cell_index(row);\n-      *(mdp + count_off) += DataLayout::counter_increment;\n-      return;\n-    } else if (row_recv == 0) {\n-      \/\/ else if (vc->receiver(row) == NULL)\n-      empty_row = (int) row;\n-    }\n-  }\n-\n-  if (empty_row != -1) {\n-    int receiver_off = ReceiverTypeData::receiver_cell_index(empty_row);\n-    \/\/ vc->set_receiver(empty_row, receiver_klass);\n-    *(mdp + receiver_off) = (intptr_t) receiver_klass;\n-    \/\/ vc->set_receiver_count(empty_row, DataLayout::counter_increment);\n-    int count_off = ReceiverTypeData::receiver_count_cell_index(empty_row);\n-    *(mdp + count_off) = DataLayout::counter_increment;\n-  } else {\n-    \/\/ Receiver did not match any saved receiver and there is no empty row for it.\n-    \/\/ Increment total counter to indicate polymorphic case.\n-    intptr_t* count_p = (intptr_t*)(((uint8_t*)(data)) + in_bytes(CounterData::count_offset()));\n-    *count_p += DataLayout::counter_increment;\n-  }\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":22,"deletions":78,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -232,3 +232,0 @@\n-  \/\/ Leaf routines helping with method data update\n-  static void profile_receiver_type_C(DataLayout* data, oopDesc* receiver);\n-\n@@ -299,0 +296,1 @@\n+  static const TypeFunc* base64_decodeBlock_Type();\n@@ -308,3 +306,0 @@\n-  \/\/ leaf methodData routine types\n-  static const TypeFunc* profile_receiver_type_Type();\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,1 +103,4 @@\n-  assert(vec_klass->const_oop()->as_instance()->java_lang_Class_klass(), \"klass instance expected\");\n+  if (vec_klass->const_oop() == NULL) {\n+    return false; \/\/ uninitialized or some kind of unsafe access\n+  }\n+  assert(vec_klass->const_oop()->as_instance()->java_lang_Class_klass() != NULL, \"klass instance expected\");\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -524,11 +524,9 @@\n-  { \"UseBiasedLocking\",             JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"BiasedLockingStartupDelay\",    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"PrintBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"BiasedLockingBulkRebiasThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"BiasedLockingBulkRevokeThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"BiasedLockingDecayTime\",              JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"UseOptoBiasInlining\",                 JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"PrintPreciseBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"InitialBootClassLoaderMetaspaceSize\", JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"UseLargePagesInMetaspace\",            JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n-  { \"CriticalJNINatives\",                  JDK_Version::jdk(16), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"CriticalJNINatives\",           JDK_Version::jdk(16), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"UseBiasedLocking\",             JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingStartupDelay\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"PrintBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingBulkRebiasThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingBulkRevokeThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingDecayTime\",              JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"UseOptoBiasInlining\",                 JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"PrintPreciseBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n@@ -556,0 +554,2 @@\n+  { \"InitialBootClassLoaderMetaspaceSize\", JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"UseLargePagesInMetaspace\",            JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n@@ -558,0 +558,2 @@\n+  { \"UseRDPCForConstantTableBase\",   JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"VerifyMergedCPBytecodes\",       JDK_Version::undefined(), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n@@ -880,1 +882,1 @@\n-static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlag::Flags origin) {\n+static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlagOrigin origin) {\n@@ -888,1 +890,1 @@\n-static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {\n+static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n@@ -902,1 +904,1 @@\n-static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {\n+static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n@@ -955,1 +957,1 @@\n-static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlag::Flags origin) {\n+static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlagOrigin origin) {\n@@ -962,1 +964,1 @@\n-static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlag::Flags origin) {\n+static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlagOrigin origin) {\n@@ -1063,1 +1065,1 @@\n-bool Arguments::parse_argument(const char* arg, JVMFlag::Flags origin) {\n+bool Arguments::parse_argument(const char* arg, JVMFlagOrigin origin) {\n@@ -1278,1 +1280,1 @@\n-                                 JVMFlag::Flags origin) {\n+                                 JVMFlagOrigin origin) {\n@@ -1407,1 +1409,1 @@\n-        result &= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);\n+        result &= process_argument(token, ignore_unrecognized, JVMFlagOrigin::CONFIG_FILE);\n@@ -1425,1 +1427,1 @@\n-    result &= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);\n+    result &= process_argument(token, ignore_unrecognized, JVMFlagOrigin::CONFIG_FILE);\n@@ -1662,4 +1664,0 @@\n-\n-  if (SurvivorAlignmentInBytes == 0) {\n-    SurvivorAlignmentInBytes = ObjectAlignmentInBytes;\n-  }\n@@ -2166,2 +2164,0 @@\n-  status = status && GCArguments::check_args_consistency();\n-\n@@ -2295,1 +2291,1 @@\n-  jint result = parse_each_vm_init_arg(vm_options_args, &patch_mod_javabase, JVMFlag::JIMAGE_RESOURCE);\n+  jint result = parse_each_vm_init_arg(vm_options_args, &patch_mod_javabase, JVMFlagOrigin::JIMAGE_RESOURCE);\n@@ -2302,1 +2298,1 @@\n-  result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlag::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2308,1 +2304,1 @@\n-  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlag::COMMAND_LINE);\n+  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlagOrigin::COMMAND_LINE);\n@@ -2315,1 +2311,1 @@\n-  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlag::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2459,1 +2455,1 @@\n-jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlag::Flags origin) {\n+jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin) {\n@@ -3220,0 +3216,5 @@\n+#ifdef ZERO\n+  \/\/ Zero always runs in interpreted mode\n+  set_mode_flags(_int);\n+#endif\n+\n@@ -3286,0 +3287,19 @@\n+#if !INCLUDE_AOT\n+  UNSUPPORTED_OPTION(UseAOT);\n+  UNSUPPORTED_OPTION(PrintAOT);\n+  UNSUPPORTED_OPTION(UseAOTStrictLoading);\n+  UNSUPPORTED_OPTION_NULL(AOTLibrary);\n+\n+  UNSUPPORTED_OPTION_INIT(Tier3AOTInvocationThreshold, 0);\n+  UNSUPPORTED_OPTION_INIT(Tier3AOTMinInvocationThreshold, 0);\n+  UNSUPPORTED_OPTION_INIT(Tier3AOTCompileThreshold, 0);\n+  UNSUPPORTED_OPTION_INIT(Tier3AOTBackEdgeThreshold, 0);\n+  UNSUPPORTED_OPTION_INIT(Tier0AOTInvocationThreshold, 0);\n+  UNSUPPORTED_OPTION_INIT(Tier0AOTMinInvocationThreshold, 0);\n+  UNSUPPORTED_OPTION_INIT(Tier0AOTCompileThreshold, 0);\n+  UNSUPPORTED_OPTION_INIT(Tier0AOTBackEdgeThreshold, 0);\n+#ifndef PRODUCT\n+  UNSUPPORTED_OPTION(PrintAOTStatistics);\n+#endif\n+#endif\n+\n@@ -3905,0 +3925,4 @@\n+  if (ReplayCompiles) {\n+    FLAG_SET_ERGO_IF_DEFAULT(UseDebuggerErgo, true);\n+  }\n+\n@@ -4061,1 +4085,0 @@\n-  UNSUPPORTED_OPTION_NULL(AllocateOldGenAt);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":55,"deletions":32,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -371,3 +371,1 @@\n-  \/\/ 4-bytes higher. So for sparc because the register window save area is at\n-  \/\/ the bottom of the frame the first 16 words will be skipped and SharedInfo::stack0\n-  \/\/ will be just above it. (\n+  \/\/ 4-bytes higher.\n@@ -375,1 +373,1 @@\n-  static int java_calling_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed, int is_outgoing);\n+  static int java_calling_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed);\n@@ -468,0 +466,5 @@\n+  \/\/ Stack slots that may be unused by the calling convention but must\n+  \/\/ otherwise be preserved.  On Intel this includes the return address.\n+  \/\/ On PowerPC it includes the 4 words holding the old TOC & LR glue.\n+  static uint in_preserve_stack_slots();\n+\n@@ -686,14 +689,0 @@\n-\/\/ This class is used only with DumpSharedSpaces==true. It holds extra information\n-\/\/ that's used only during CDS dump time.\n-\/\/ For details, see comments around Method::link_method()\n-class CDSAdapterHandlerEntry: public AdapterHandlerEntry {\n-  address               _c2i_entry_trampoline;   \/\/ allocated from shared spaces \"MC\" region\n-  AdapterHandlerEntry** _adapter_trampoline;     \/\/ allocated from shared spaces \"MD\" region\n-\n-public:\n-  address get_c2i_entry_trampoline()             const { return _c2i_entry_trampoline; }\n-  AdapterHandlerEntry** get_adapter_trampoline() const { return _adapter_trampoline; }\n-  void init() NOT_CDS_RETURN;\n-};\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -114,2 +114,0 @@\n-address StubRoutines::_zero_aligned_words = CAST_FROM_FN_PTR(address, Copy::zero_to_words);\n-\n@@ -140,0 +138,1 @@\n+address StubRoutines::_base64_decodeBlock                  = NULL;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -210,3 +210,0 @@\n-  \/\/ zero heap space aligned to jlong (8 bytes)\n-  static address _zero_aligned_words;\n-\n@@ -222,0 +219,1 @@\n+  static address _base64_decodeBlock;\n@@ -570,0 +568,1 @@\n+  static address base64_decodeBlock()    { return _base64_decodeBlock; }\n@@ -611,2 +610,0 @@\n-  static address zero_aligned_words()  { return _zero_aligned_words; }\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/javaThreadStatus.hpp\"\n@@ -89,0 +90,1 @@\n+#include \"runtime\/monitorDeflationThread.hpp\"\n@@ -575,0 +577,1 @@\n+     static_field(StubRoutines,                _base64_decodeBlock,                           address)                               \\\n@@ -890,1 +893,0 @@\n-  static_field(ObjectSynchronizer,             g_block_list,                                  PaddedObjectMonitor*)                  \\\n@@ -1341,0 +1343,1 @@\n+        declare_type(MonitorDeflationThread, JavaThread)                  \\\n@@ -1465,1 +1468,0 @@\n-  declare_toplevel_type(PaddedObjectMonitor)                              \\\n@@ -1968,2 +1970,2 @@\n-  declare_toplevel_type(BreakpointInfo)                                   \\\n-  declare_toplevel_type(BreakpointInfo*)                                  \\\n+  JVMTI_ONLY(declare_toplevel_type(BreakpointInfo))                       \\\n+  JVMTI_ONLY(declare_toplevel_type(BreakpointInfo*))                      \\\n@@ -1997,1 +1999,0 @@\n-  declare_toplevel_type(PaddedObjectMonitor*)                             \\\n@@ -2261,1 +2262,0 @@\n-  declare_preprocessor_constant(\"FIELDINFO_TAG_MASK\", FIELDINFO_TAG_MASK) \\\n@@ -2336,1 +2336,1 @@\n-  \/* java_lang_Thread::ThreadStatus enum *\/                               \\\n+  \/* JavaThreadStatus enum               *\/                               \\\n@@ -2339,9 +2339,9 @@\n-  declare_constant(java_lang_Thread::NEW)                                 \\\n-  declare_constant(java_lang_Thread::RUNNABLE)                            \\\n-  declare_constant(java_lang_Thread::SLEEPING)                            \\\n-  declare_constant(java_lang_Thread::IN_OBJECT_WAIT)                      \\\n-  declare_constant(java_lang_Thread::IN_OBJECT_WAIT_TIMED)                \\\n-  declare_constant(java_lang_Thread::PARKED)                              \\\n-  declare_constant(java_lang_Thread::PARKED_TIMED)                        \\\n-  declare_constant(java_lang_Thread::BLOCKED_ON_MONITOR_ENTER)            \\\n-  declare_constant(java_lang_Thread::TERMINATED)                          \\\n+  declare_constant(JavaThreadStatus::NEW)                                 \\\n+  declare_constant(JavaThreadStatus::RUNNABLE)                            \\\n+  declare_constant(JavaThreadStatus::SLEEPING)                            \\\n+  declare_constant(JavaThreadStatus::IN_OBJECT_WAIT)                      \\\n+  declare_constant(JavaThreadStatus::IN_OBJECT_WAIT_TIMED)                \\\n+  declare_constant(JavaThreadStatus::PARKED)                              \\\n+  declare_constant(JavaThreadStatus::PARKED_TIMED)                        \\\n+  declare_constant(JavaThreadStatus::BLOCKED_ON_MONITOR_ENTER)            \\\n+  declare_constant(JavaThreadStatus::TERMINATED)                          \\\n@@ -2527,6 +2527,0 @@\n-  \/* ObjectSynchronizer *\/                                                \\\n-  \/**********************\/                                                \\\n-                                                                          \\\n-  declare_constant(ObjectSynchronizer::_BLOCKSIZE)                        \\\n-                                                                          \\\n-  \/**********************\/                                                \\\n@@ -2604,9 +2598,9 @@\n-  declare_constant(JVMFlag::DEFAULT)                                      \\\n-  declare_constant(JVMFlag::COMMAND_LINE)                                 \\\n-  declare_constant(JVMFlag::ENVIRON_VAR)                                  \\\n-  declare_constant(JVMFlag::CONFIG_FILE)                                  \\\n-  declare_constant(JVMFlag::MANAGEMENT)                                   \\\n-  declare_constant(JVMFlag::ERGONOMIC)                                    \\\n-  declare_constant(JVMFlag::ATTACH_ON_DEMAND)                             \\\n-  declare_constant(JVMFlag::INTERNAL)                                     \\\n-  declare_constant(JVMFlag::JIMAGE_RESOURCE)                              \\\n+  declare_constant(JVMFlagOrigin::DEFAULT)                                \\\n+  declare_constant(JVMFlagOrigin::COMMAND_LINE)                           \\\n+  declare_constant(JVMFlagOrigin::ENVIRON_VAR)                            \\\n+  declare_constant(JVMFlagOrigin::CONFIG_FILE)                            \\\n+  declare_constant(JVMFlagOrigin::MANAGEMENT)                             \\\n+  declare_constant(JVMFlagOrigin::ERGONOMIC)                              \\\n+  declare_constant(JVMFlagOrigin::ATTACH_ON_DEMAND)                       \\\n+  declare_constant(JVMFlagOrigin::INTERNAL)                               \\\n+  declare_constant(JVMFlagOrigin::JIMAGE_RESOURCE)                        \\\n@@ -2614,1 +2608,1 @@\n-  declare_constant(JVMFlag::ORIG_COMMAND_LINE)\n+  declare_constant(JVMFlag::WAS_SET_ON_COMMAND_LINE)\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":26,"deletions":32,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -450,0 +450,15 @@\n+\/\/ In many places we've added C-style casts to silence compiler\n+\/\/ warnings, for example when truncating a size_t to an int when we\n+\/\/ know the size_t is a small struct. Such casts are risky because\n+\/\/ they effectively disable useful compiler warnings. We can make our\n+\/\/ lives safer with this function, which ensures that any cast is\n+\/\/ reversible without loss of information. It doesn't check\n+\/\/ everything: it isn't intended to make sure that pointer types are\n+\/\/ compatible, for example.\n+template <typename T2, typename T1>\n+T2 checked_cast(T1 thing) {\n+  T2 result = static_cast<T2>(thing);\n+  assert(static_cast<T1>(result) == thing, \"must be\");\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,0 +40,11 @@\n+\/*\n+ * @test VectorConversionPPC64\n+ * @bug 8256479\n+ * @requires os.arch ==\"ppc64\" | os.arch == \"ppc64le\"\n+ * @summary VectorConversion on PPC64 without Vector Register usage\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm  -XX:-SuperwordUseVSX -XX:-TieredCompilation --add-opens jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED\n+ * Vector64ConversionTests\n+ *\/\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector64ConversionTests.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}