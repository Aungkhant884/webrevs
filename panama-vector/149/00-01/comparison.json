{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.util.concurrent.ThreadLocalRandom;\n@@ -41,1 +40,1 @@\n-@Warmup(iterations = 5, time = 1)\n+@Warmup(iterations = 10, time = 1)\n@@ -43,1 +42,1 @@\n-@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\", \"--add-exports\", \"java.base\/jdk.internal.vm.vector=ALL-UNNAMED\", \"-ea\"})\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n@@ -46,1 +45,2 @@\n-  private static int ARRAY_LENGTH = 1024;\n+  @Param(\"1024\")\n+  int ARRAY_LENGTH;\n@@ -48,0 +48,2 @@\n+  private static final VectorSpecies<Integer> INT_64_SPECIES =\n+    IntVector.SPECIES_64;\n@@ -57,29 +59,25 @@\n-  @State(Scope.Thread)\n-  public static class ThreadLocalData {\n-\n-    private int conflict_scalar_cnt = 0;\n-    private int conflict_vector_cnt = 0;\n-    private int[] index = new int[ARRAY_LENGTH];\n-    private int[] conflict_scalar = new int[ARRAY_LENGTH];\n-    private int[] conflict_vector = new int[ARRAY_LENGTH];\n-    private int[] input1 = new int[ARRAY_LENGTH];\n-    private int[] input2 = new int[ARRAY_LENGTH];\n-    private Random rand = new Random();\n-\n-    @Setup(Level.Trial)\n-    public void doSetup() {\n-      int conflict_id_each_5_elements = ThreadLocalRandom.current().nextInt(5);\n-\n-      for (int i = 0; i < ARRAY_LENGTH; i++) {\n-        index[i] = ThreadLocalRandom.current().nextInt(ARRAY_LENGTH);\n-        input1[i] = ThreadLocalRandom.current().nextInt();\n-        \/\/ Generate 20% conflict data\n-        int remainder = i % 5;\n-        if (remainder == conflict_id_each_5_elements) {\n-          input2[i] = ThreadLocalRandom.current().nextInt();\n-        } else {\n-          input2[i] = input1[i];\n-        }\n-\n-        conflict_scalar[i] = 0;\n-        conflict_vector[i] = 0;\n+  private int conflict_cnt;\n+  private int[] index;\n+  private int[] input1;\n+  private int[] input2;\n+  private int[] conflict_array;\n+\n+  @Setup\n+  public void init() {\n+    index = new int[ARRAY_LENGTH];\n+    input1 = new int[ARRAY_LENGTH];\n+    input2 = new int[ARRAY_LENGTH];\n+    conflict_array = new int[ARRAY_LENGTH];\n+\n+    Random rand = new Random();\n+    int conflict_id_each_5_elements = rand.nextInt(5);\n+\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      index[i] = rand.nextInt(ARRAY_LENGTH);\n+      input1[i] = rand.nextInt();\n+      \/\/ Generate 20% conflict data\n+      int remainder = i % 5;\n+      if (remainder == conflict_id_each_5_elements) {\n+        input2[i] = rand.nextInt();\n+      } else {\n+        input2[i] = input1[i];\n@@ -87,0 +85,14 @@\n+      conflict_array[i] = 0;\n+    }\n+  }\n+\n+  private void selectiveStore(VectorSpecies<Integer> species) {\n+    conflict_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += species.length()) {\n+      IntVector av = IntVector.fromArray(species, input1, i);\n+      IntVector bv = IntVector.fromArray(species, input2, i);\n+      IntVector cv = IntVector.fromArray(species, index, i);\n+      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n+      IntVector dv = cv.compress(mask);\n+      dv.intoArray(conflict_array, conflict_cnt, mask.compress());\n+      conflict_cnt += mask.trueCount();\n@@ -91,3 +103,2 @@\n-  @Threads(8)\n-  public void selectiveStore_scalar(ThreadLocalData tld) {\n-    tld.conflict_scalar_cnt = 0;\n+  public void selectiveStore_scalar() {\n+    conflict_cnt = 0;\n@@ -95,2 +106,3 @@\n-      if (tld.input1[i] != tld.input2[i]) {\n-        tld.conflict_scalar[tld.conflict_scalar_cnt++] = tld.index[i];\n+      if (input1[i] != input2[i]) {\n+        conflict_array[conflict_cnt] = index[i];\n+        conflict_cnt++;\n@@ -102,12 +114,2 @@\n-  @Threads(8)\n-  public void selectiveStore_vector_128(ThreadLocalData tld) {\n-    tld.conflict_vector_cnt = 0;\n-    for (int i = 0; i < ARRAY_LENGTH; i += INT_128_SPECIES.length()) {\n-      IntVector av = IntVector.fromArray(INT_128_SPECIES, tld.input1, i);\n-      IntVector bv = IntVector.fromArray(INT_128_SPECIES, tld.input2, i);\n-      IntVector cv = IntVector.fromArray(INT_128_SPECIES, tld.index, i);\n-      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n-      IntVector dv = cv.compress(mask);\n-      dv.intoArray(tld.conflict_vector, tld.conflict_vector_cnt, mask.prefixMask());\n-      tld.conflict_vector_cnt += mask.trueCount();\n-    }\n+  public void selectiveStore_vector_64() {\n+    selectiveStore(INT_64_SPECIES);\n@@ -117,12 +119,2 @@\n-  @Threads(8)\n-  public void selectiveStore_vector_256(ThreadLocalData tld) {\n-    tld.conflict_vector_cnt = 0;\n-    for (int i = 0; i < ARRAY_LENGTH; i += INT_256_SPECIES.length()) {\n-      IntVector av = IntVector.fromArray(INT_256_SPECIES, tld.input1, i);\n-      IntVector bv = IntVector.fromArray(INT_256_SPECIES, tld.input2, i);\n-      IntVector cv = IntVector.fromArray(INT_256_SPECIES, tld.index, i);\n-      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n-      IntVector dv = cv.compress(mask);\n-      dv.intoArray(tld.conflict_vector, tld.conflict_vector_cnt, mask.prefixMask());\n-      tld.conflict_vector_cnt += mask.trueCount();\n-    }\n+  public void selectiveStore_vector_128() {\n+    selectiveStore(INT_128_SPECIES);\n@@ -132,12 +124,2 @@\n-  @Threads(8)\n-  public void selectiveStore_vector_512(ThreadLocalData tld) {\n-    tld.conflict_vector_cnt = 0;\n-    for (int i = 0; i < ARRAY_LENGTH; i += INT_512_SPECIES.length()) {\n-      IntVector av = IntVector.fromArray(INT_512_SPECIES, tld.input1, i);\n-      IntVector bv = IntVector.fromArray(INT_512_SPECIES, tld.input2, i);\n-      IntVector cv = IntVector.fromArray(INT_512_SPECIES, tld.index, i);\n-      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n-      IntVector dv = cv.compress(mask);\n-      dv.intoArray(tld.conflict_vector, tld.conflict_vector_cnt, mask.prefixMask());\n-      tld.conflict_vector_cnt += mask.trueCount();\n-    }\n+  public void selectiveStore_vector_256() {\n+    selectiveStore(INT_256_SPECIES);\n@@ -147,12 +129,2 @@\n-  @Threads(8)\n-  public void selectiveStore_vector_preferred(ThreadLocalData tld) {\n-    tld.conflict_vector_cnt = 0;\n-    for (int i = 0; i < ARRAY_LENGTH; i += INT_PREFERRED_SPECIES.length()) {\n-      IntVector av = IntVector.fromArray(INT_PREFERRED_SPECIES, tld.input1, i);\n-      IntVector bv = IntVector.fromArray(INT_PREFERRED_SPECIES, tld.input2, i);\n-      IntVector cv = IntVector.fromArray(INT_PREFERRED_SPECIES, tld.index, i);\n-      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n-      IntVector dv = cv.compress(mask);\n-      dv.intoArray(tld.conflict_vector, tld.conflict_vector_cnt, mask.prefixMask());\n-      tld.conflict_vector_cnt += mask.trueCount();\n-    }\n+  public void selectiveStore_vector_512() {\n+    selectiveStore(INT_512_SPECIES);\n@@ -162,25 +134,2 @@\n-  @Threads(8)\n-  public void selectiveStore_verify(ThreadLocalData tld) {\n-    \/\/ Initialization\n-    int conflict_id_each_5_elements = ThreadLocalRandom.current().nextInt(5);\n-    for (int i = 0; i < ARRAY_LENGTH; i++) {\n-      tld.index[i] = ThreadLocalRandom.current().nextInt(ARRAY_LENGTH);\n-      tld.input1[i] = ThreadLocalRandom.current().nextInt();\n-      \/\/ Generate 20% conflict data\n-      int remainder = i % 5;\n-      if (remainder == conflict_id_each_5_elements) {\n-        tld.input2[i] = ThreadLocalRandom.current().nextInt();\n-      } else {\n-        tld.input2[i] = tld.input1[i];\n-      }\n-      tld.conflict_scalar[i] = 0;\n-      tld.conflict_vector[i] = 0;\n-    }\n-    \/\/ Test\n-    selectiveStore_scalar(tld);\n-    selectiveStore_vector_preferred(tld);\n-    \/\/ Verify\n-    for (int i = 0; i < ARRAY_LENGTH; i++) {\n-      assert(tld.conflict_scalar[i] == tld.conflict_vector[i]);\n-    }\n-    assert(tld.conflict_scalar_cnt == tld.conflict_vector_cnt);\n+  public void selectiveStore_vector_preferred() {\n+    selectiveStore(INT_PREFERRED_SPECIES);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/SelectiveStore.java","additions":60,"deletions":111,"binary":false,"changes":171,"status":"modified"}]}