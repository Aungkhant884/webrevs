{"files":[{"patch":"@@ -0,0 +1,589 @@\n+\/*\n+ * Copyright (c) 2020 Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package benchmark.utf8;\n+\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.nio.Buffer;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CoderResult;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import jdk.incubator.vector.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 5, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+public class DecodeBench {\n+\n+    @Param({\"32768\", \"8388608\"})\n+    private int dataSize;\n+\n+    @Param({\"1\", \"2\", \"3\", \"4\"})\n+    private int maxBytes;\n+\n+    private ByteBuffer src;\n+    private CharBuffer dst;\n+    private String in;\n+    private String out;\n+\n+    private static final VectorSpecies<Byte>  B128 = ByteVector.SPECIES_128;\n+    private static final VectorSpecies<Short> S128 = ShortVector.SPECIES_128;\n+    private static final VectorSpecies<Short> S256 = ShortVector.SPECIES_256;\n+\n+    private static final HashMap<Long, DecoderLutEntry> lutTable = new HashMap<Long, DecoderLutEntry>();\n+\n+    private static class DecoderLutEntry {\n+        public final VectorShuffle<Byte> shufAB;   \/\/ shuffling mask to get lower two bytes of symbols\n+        public final VectorShuffle<Byte> shufC;    \/\/ shuffling mask to get third bytes of symbols\n+        public final byte srcStep;                 \/\/ number of bytes processed in input buffer\n+        public final byte dstStep;                 \/\/ number of symbols produced in output buffer (doubled)\n+        public final Vector<Byte> headerMask;      \/\/ mask of \"111..10\" bits required in each byte\n+        public final Vector<Short> zeroBits;\n+\n+        public DecoderLutEntry(VectorShuffle<Byte> _shufAB, VectorShuffle<Byte> _shufC,\n+                               byte _srcStep, byte _dstStep,\n+                               Vector<Byte> _headerMask, Vector<Short> _zeroBits) {\n+            shufAB = _shufAB;\n+            shufC = _shufC;\n+            srcStep = _srcStep;\n+            dstStep = _dstStep;\n+            headerMask = _headerMask;\n+            zeroBits = _zeroBits;\n+        }\n+\n+        \/\/ @Override\n+        \/\/ public String toString() {\n+        \/\/     return String.format(\"shufAB = %s, shufC = %s, srcStep = %d, dstStep = %d, headerMask = %s, zeroBits = %s\",\n+        \/\/         arrayToString(shufAB), arrayToString(shufC), srcStep, dstStep, arrayToString(headerMask), arrayToString(zeroBits));\n+        \/\/ }\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setupLutTable() {\n+        int[] sizes = new int[32];\n+        computeLutRecursive(sizes, 0, 0); \/\/10609 entries total\n+\n+        \/\/ for (var entry : lutTable.entrySet()) {\n+        \/\/     System.out.println(\"\" + entry.getKey() + \" -> \" + entry.getValue());\n+        \/\/ }\n+    }\n+\n+    static void computeLutRecursive(int[] sizes, int num, int total) {\n+        if (total >= 16) {\n+            computeLutEntry(sizes, num);\n+            return;\n+        }\n+        for (int size = 1; size <= 3; size++) {\n+            sizes[num] = size;\n+            computeLutRecursive(sizes, num + 1, total + size);\n+        }\n+    }\n+\n+    static void computeLutEntry(int[] sizes, int num) {\n+        \/\/find maximal number of chars to decode\n+        int cnt = num - 1;\n+        int preSum = 0;\n+        for (int i = 0; i < cnt; i++)\n+            preSum += sizes[i];\n+        assert preSum < 16;\n+        \/\/ Note: generally, we can process a char only if the next byte is within XMM register\n+        \/\/ However, if the last char takes 3 bytes and fits the register tightly, we can take it too\n+        if (preSum == 13 && preSum + sizes[cnt] == 16)\n+            preSum += sizes[cnt++];\n+        \/\/still cannot process more that 8 chars per register\n+        while (cnt > 8)\n+            preSum -= sizes[--cnt];\n+\n+        \/\/generate bitmask\n+        long mask = 0;\n+        for (int i = 0, pos = 0; i < num; i++) {\n+            for (int j = 0; j < sizes[i]; j++, pos++) {\n+                \/\/ The first byte is not represented in the mask\n+                if (j > 0) {\n+                    mask |= 1 << pos;\n+                }\n+            }\n+        }\n+        assert mask <= 0xFFFF;\n+\n+        \/\/generate shuffle masks\n+        byte[] shufAB = new byte[16];\n+        byte[] shufC  = new byte[16];\n+        for (int i = 0; i < 16; i++)\n+            shufAB[i] = shufC[i] = (byte)0xFF;\n+        for (int i = 0, pos = 0; i < cnt; i++) {\n+            int sz = sizes[i];\n+            for (int j = sz-1; j >= 0; j--, pos++) {\n+                if (j < 2)\n+                    shufAB[2 * i + j] = (byte)pos;\n+                else\n+                    shufC[2 * i] = (byte)pos;\n+            }\n+        }\n+\n+        \/\/generate header masks for validation\n+        byte[] headerMask = new byte[16];\n+        for (int i = 0, pos = 0; i < cnt; i++) {\n+            int sz = sizes[i];\n+            for (int j = 0; j < sz; j++, pos++) {\n+                int bits;\n+                if      (j > 0)    bits = 2;\n+                else if (sz == 1)  bits = 1;\n+                else if (sz == 2)  bits = 3;\n+                else   \/*sz == 3*\/ bits = 4;\n+                headerMask[pos] = (byte)-(1 << (8 - bits));\n+            }\n+        }\n+\n+        \/\/generate min symbols values for validation\n+        short[] zeroBits = new short[8];\n+        for (int i = 0; i < 8; i++) {\n+            int sz = i < cnt ? sizes[i] : 1;\n+            if      (sz == 1)  zeroBits[i] = (short)(0xFF80);\n+            else if (sz == 2)  zeroBits[i] = (short)(0xF800);\n+            else   \/*sz == 3*\/ zeroBits[i] = (short)(0x0000);\n+        }\n+\n+        \/\/store info into the lookup table\n+        lutTable.put(mask, new DecoderLutEntry(ByteVector.fromArray(B128, shufAB, 0).toShuffle(),\n+                                               ByteVector.fromArray(B128, shufC, 0).toShuffle(),\n+                                               (byte)preSum, (byte)cnt,\n+                                               ByteVector.fromArray(B128, headerMask, 0),\n+                                               ShortVector.fromArray(S128, zeroBits, 0)));\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        in = randomString(dataSize, maxBytes);\n+        src = ByteBuffer.wrap(in.getBytes());\n+        dst = CharBuffer.allocate(in.length());\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void setupInvocation() {\n+        src.clear();\n+        dst.clear();\n+    }\n+\n+    @TearDown(Level.Invocation)\n+    public void tearDownInvocation() {\n+        out = new String(dst.array());\n+        if (!in.equals(out)) {\n+            System.out.println(\"in  = (\" + in.length() + \") \\\"\" + arrayToString(in.getBytes()) + \"\\\"\");\n+            System.out.println(\"out = (\" + out.length() + \") \\\"\" + arrayToString(out.getBytes()) + \"\\\"\");\n+            throw new RuntimeException(\"Incorrect result\");\n+        }\n+    }\n+\n+    private static final Random RANDOM = new Random(0);\n+    private static int randomInt(int min \/* inclusive *\/, int max \/* inclusive *\/) {\n+        return RANDOM.nextInt(max - min + 1) + min;\n+    }\n+    private static String randomString(int dataSize, int maxBytes) {\n+        ByteBuffer buf = ByteBuffer.allocate(dataSize);\n+        for (int i = 0, size = randomInt(1, maxBytes); i + size - 1 < dataSize; i += size, size = randomInt(1, maxBytes)) {\n+            int b1, b2, b3, b4;\n+            switch (size) {\n+            case 1: {\n+                b1 = randomInt(0x00, 0x7F);\n+                buf.put(i + 0, (byte)((0b0     << (8 - 1)) | b1));\n+                break;\n+            }\n+            case 2: {\n+                b1 = randomInt(0xC2, 0xDF);\n+                b2 = randomInt(0x80, 0xBF);\n+                buf.put(i + 0, (byte)((0b110   << (8 - 3)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                break;\n+            }\n+            case 3: {\n+                b1 = randomInt(0xE0, 0xEF);\n+                switch (b1) {\n+                case 0xE0:\n+                    b2 = randomInt(0xA0, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    break;\n+                default:\n+                    b2 = randomInt(0x80, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    break;\n+                }\n+                buf.put(i + 0, (byte)((0b1110  << (8 - 4)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                buf.put(i + 2, (byte)((0b10    << (8 - 2)) | b3));\n+                break;\n+            }\n+            case 4: {\n+                b1 = randomInt(0xF0, 0xF4);\n+                switch (b1) {\n+                case 0xF0:\n+                    b2 = randomInt(0x90, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                case 0xF4:\n+                    b2 = randomInt(0x80, 0x8F);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                default:\n+                    b2 = randomInt(0x80, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                }\n+                buf.put(i + 0, (byte)((0b11110 << (8 - 5)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                buf.put(i + 2, (byte)((0b10    << (8 - 2)) | b3));\n+                buf.put(i + 3, (byte)((0b10    << (8 - 2)) | b4));\n+                break;\n+            }\n+            default:\n+                throw new RuntimeException(\"not supported\");\n+            }\n+        }\n+        return new String(buf.array(), Charset.forName(\"UTF-8\"));\n+    }\n+\n+    private static String arrayToString(byte[] array) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[\");\n+        for (int i = 0; i < array.length; ++i) {\n+            if (i != 0) sb.append(\",\");\n+            sb.append(String.format(\"%x\", (byte)array[i]));\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    @Benchmark\n+    public void decodeScalar() {\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    @Benchmark\n+    public void decodeVector() {\n+        decodeArrayVectorized(src, dst);\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    @Benchmark\n+    public void decodeVectorASCII() {\n+        decodeArrayVectorizedASCII(src, dst);\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    private static void decodeArrayVectorized(ByteBuffer src, CharBuffer dst) {\n+        \/\/ Algorithm is largely inspired from https:\/\/dirtyhandscoding.github.io\/posts\/utf8lut-vectorized-utf-8-converter-introduction.html\n+\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+\n+        \/\/ Vectorized loop\n+        while (sp + B128.length() < sl && dp + S128.length() < dl) {\n+            var bytes = ByteVector.fromArray(B128, sa, sp);\n+\n+            \/* Decode *\/\n+\n+            var continuationByteMask = bytes.lanewise(VectorOperators.AND, (byte)0xC0).compare(VectorOperators.EQ, (byte)0x80);\n+            final DecoderLutEntry lookup = lutTable.get(continuationByteMask.toLong());\n+            if (lookup == null) {\n+                break;\n+            }\n+            \/\/ Shuffle the 1st and 2nd bytes\n+            var Rab = bytes.rearrange(lookup.shufAB, lookup.shufAB.toVector().compare(VectorOperators.NE, -1)).reinterpretAsShorts();\n+            \/\/ Shuffle the 3rd byte\n+            var Rc  = bytes.rearrange(lookup.shufC, lookup.shufC.toVector().compare(VectorOperators.NE, -1)).reinterpretAsShorts();\n+            \/\/ Extract the bits from each byte\n+            var sum = Rab.lanewise(VectorOperators.AND, (short)0x007F)\n+                 .add(Rab.lanewise(VectorOperators.AND, (short)0x3F00).lanewise(VectorOperators.LSHR, 2))\n+                 .add(Rc.lanewise(VectorOperators.LSHL, 12));\n+\n+            \/* Validate *\/\n+\n+            var zeroBits = lookup.zeroBits;\n+            if (sum.lanewise(VectorOperators.AND, zeroBits).compare(VectorOperators.NE, 0).anyTrue()) {\n+                break;\n+            }\n+            \/\/ Check for surrogate code point\n+            if (sum.lanewise(VectorOperators.SUB, (short)0x6000).compare(VectorOperators.GT, 0x77FF).anyTrue()) {\n+                break;\n+            }\n+            var headerMask = lookup.headerMask;\n+            if (bytes.lanewise(VectorOperators.AND, headerMask).compare(VectorOperators.NE, headerMask.lanewise(VectorOperators.LSHL, 1)).anyTrue()) {\n+                break;\n+            }\n+\n+            \/* Advance *\/\n+\n+            ((ShortVector)sum).intoCharArray(da, dp);\n+            sp += lookup.srcStep;\n+            dp += lookup.dstStep;\n+        }\n+\n+        updatePositions(src, sp, dst, dp);\n+    }\n+\n+    private static void decodeArrayVectorizedASCII(ByteBuffer src, CharBuffer dst) {\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+\n+        \/\/ Vectorized loop\n+        for (; sp <= sl - B128.length() && dp <= dl - S256.length(); sp += B128.length(), dp += S256.length()) {\n+            var bytes = ByteVector.fromArray(B128, sa, sp);\n+\n+            if (bytes.compare(VectorOperators.LT, (byte) 0x00).anyTrue())\n+                break;\n+\n+            ((ShortVector) bytes.convertShape(VectorOperators.B2S, S256, 0)).intoCharArray(da, dp);\n+        }\n+\n+        updatePositions(src, sp, dst, dp);\n+    }\n+\n+    private static CoderResult decodeArrayLoop(ByteBuffer src, CharBuffer dst) {\n+        \/\/ This method is optimized for ASCII input.\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+        int dlASCII = dp + Math.min(sl - sp, dl - dp);\n+\n+        \/\/ ASCII only loop\n+        while (dp < dlASCII && sa[sp] >= 0)\n+            da[dp++] = (char) sa[sp++];\n+        while (sp < sl) {\n+            int b1 = sa[sp];\n+            if (b1 >= 0) {\n+                \/\/ 1 byte, 7 bits: 0xxxxxxx\n+                if (dp >= dl)\n+                    return xflow(src, sp, sl, dst, dp, 1);\n+                da[dp++] = (char) b1;\n+                sp++;\n+            } else if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0) {\n+                \/\/ 2 bytes, 11 bits: 110xxxxx 10xxxxxx\n+                \/\/                   [C2..DF] [80..BF]\n+                if (sl - sp < 2 || dp >= dl)\n+                    return xflow(src, sp, sl, dst, dp, 2);\n+                int b2 = sa[sp + 1];\n+                \/\/ Now we check the first byte of 2-byte sequence as\n+                \/\/     if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0)\n+                \/\/ no longer need to check b1 against c1 & c0 for\n+                \/\/ malformed as we did in previous version\n+                \/\/   (b1 & 0x1e) == 0x0 || (b2 & 0xc0) != 0x80;\n+                \/\/ only need to check the second byte b2.\n+                if (isNotContinuation(b2))\n+                    return malformedForLength(src, sp, dst, dp, 1);\n+                da[dp++] = (char) (((b1 << 6) ^ b2)\n+                                   ^\n+                                   (((byte) 0xC0 << 6) ^\n+                                    ((byte) 0x80 << 0)));\n+                sp += 2;\n+            } else if ((b1 >> 4) == -2) {\n+                \/\/ 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx\n+                int srcRemaining = sl - sp;\n+                if (srcRemaining < 3 || dp >= dl) {\n+                    if (srcRemaining > 1 && isMalformed3_2(b1, sa[sp + 1]))\n+                        return malformedForLength(src, sp, dst, dp, 1);\n+                    return xflow(src, sp, sl, dst, dp, 3);\n+                }\n+                int b2 = sa[sp + 1];\n+                int b3 = sa[sp + 2];\n+                if (isMalformed3(b1, b2, b3))\n+                    return malformed(src, sp, dst, dp, 3);\n+                char c = (char)\n+                    ((b1 << 12) ^\n+                     (b2 <<  6) ^\n+                     (b3 ^\n+                      (((byte) 0xE0 << 12) ^\n+                       ((byte) 0x80 <<  6) ^\n+                       ((byte) 0x80 <<  0))));\n+                if (Character.isSurrogate(c))\n+                    return malformedForLength(src, sp, dst, dp, 3);\n+                da[dp++] = c;\n+                sp += 3;\n+            } else if ((b1 >> 3) == -2) {\n+                \/\/ 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+                int srcRemaining = sl - sp;\n+                if (srcRemaining < 4 || dl - dp < 2) {\n+                    b1 &= 0xff;\n+                    if (b1 > 0xf4 ||\n+                        srcRemaining > 1 && isMalformed4_2(b1, sa[sp + 1] & 0xff))\n+                        return malformedForLength(src, sp, dst, dp, 1);\n+                    if (srcRemaining > 2 && isMalformed4_3(sa[sp + 2]))\n+                        return malformedForLength(src, sp, dst, dp, 2);\n+                    return xflow(src, sp, sl, dst, dp, 4);\n+                }\n+                int b2 = sa[sp + 1];\n+                int b3 = sa[sp + 2];\n+                int b4 = sa[sp + 3];\n+                int uc = ((b1 << 18) ^\n+                          (b2 << 12) ^\n+                          (b3 <<  6) ^\n+                          (b4 ^\n+                           (((byte) 0xF0 << 18) ^\n+                            ((byte) 0x80 << 12) ^\n+                            ((byte) 0x80 <<  6) ^\n+                            ((byte) 0x80 <<  0))));\n+                if (isMalformed4(b2, b3, b4) ||\n+                    \/\/ shortest form check\n+                    !Character.isSupplementaryCodePoint(uc)) {\n+                    return malformed(src, sp, dst, dp, 4);\n+                }\n+                da[dp++] = Character.highSurrogate(uc);\n+                da[dp++] = Character.lowSurrogate(uc);\n+                sp += 4;\n+            } else\n+                return malformed(src, sp, dst, dp, 1);\n+        }\n+        return xflow(src, sp, sl, dst, dp, 0);\n+    }\n+\n+    private static CoderResult xflow(Buffer src, int sp, int sl,\n+                                     Buffer dst, int dp, int nb) {\n+        updatePositions(src, sp, dst, dp);\n+        return (nb == 0 || sl - sp < nb)\n+               ? CoderResult.UNDERFLOW : CoderResult.OVERFLOW;\n+    }\n+\n+    private static CoderResult malformedForLength(ByteBuffer src,\n+                                                  int sp,\n+                                                  CharBuffer dst,\n+                                                  int dp,\n+                                                  int malformedNB)\n+    {\n+        updatePositions(src, sp, dst, dp);\n+        return CoderResult.malformedForLength(malformedNB);\n+    }\n+\n+    private static CoderResult malformed(ByteBuffer src, int sp,\n+                                         CharBuffer dst, int dp,\n+                                         int nb)\n+    {\n+        src.position(sp - src.arrayOffset());\n+        CoderResult cr = malformedN(src, sp, nb);\n+        updatePositions(src, sp, dst, dp);\n+        return cr;\n+    }\n+\n+    private static CoderResult malformedN(ByteBuffer src, int sp,\n+                                          int nb) {\n+        switch (nb) {\n+        case 1:\n+        case 2:                    \/\/ always 1\n+            return CoderResult.malformedForLength(1);\n+        case 3:\n+            int b1 = src.get();\n+            int b2 = src.get();    \/\/ no need to lookup b3\n+            return CoderResult.malformedForLength(\n+                ((b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                 isNotContinuation(b2)) ? 1 : 2);\n+        case 4:  \/\/ we don't care the speed here\n+            b1 = src.get() & 0xff;\n+            b2 = src.get() & 0xff;\n+            if (b1 > 0xf4 ||\n+                (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n+                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+                isNotContinuation(b2))\n+                return CoderResult.malformedForLength(1);\n+            if (isNotContinuation(src.get()))\n+                return CoderResult.malformedForLength(2);\n+            return CoderResult.malformedForLength(3);\n+        default:\n+            assert false;\n+            return null;\n+        }\n+    }\n+\n+    private static boolean isNotContinuation(int b) {\n+        return (b & 0xc0) != 0x80;\n+    }\n+\n+    \/\/  [E0]     [A0..BF] [80..BF]\n+    \/\/  [E1..EF] [80..BF] [80..BF]\n+    private static boolean isMalformed3(int b1, int b2, int b3) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+               (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ only used when there is only one byte left in src buffer\n+    private static boolean isMalformed3_2(int b1, int b2) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+               (b2 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/  [F0]     [90..BF] [80..BF] [80..BF]\n+    \/\/  [F1..F3] [80..BF] [80..BF] [80..BF]\n+    \/\/  [F4]     [80..8F] [80..BF] [80..BF]\n+    \/\/  only check 80-be range here, the [0xf0,0x80...] and [0xf4,0x90-...]\n+    \/\/  will be checked by Character.isSupplementaryCodePoint(uc)\n+    private static boolean isMalformed4(int b2, int b3, int b4) {\n+        return (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80 ||\n+               (b4 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ only used when there is less than 4 bytes left in src buffer.\n+    \/\/ both b1 and b2 should be \"& 0xff\" before passed in.\n+    private static boolean isMalformed4_2(int b1, int b2) {\n+        return (b1 == 0xf0 && (b2  < 0x90 || b2 > 0xbf)) ||\n+               (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+               (b2 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ tests if b1 and b2 are malformed as the first 2 bytes of a\n+    \/\/ legal`4-byte utf-8 byte sequence.\n+    \/\/ only used when there is less than 4 bytes left in src buffer,\n+    \/\/ after isMalformed4_2 has been invoked.\n+    private static boolean isMalformed4_3(int b3) {\n+        return (b3 & 0xc0) != 0x80;\n+    }\n+\n+    private static void updatePositions(Buffer src, int sp,\n+                                        Buffer dst, int dp) {\n+        src.position(sp - src.arrayOffset());\n+        dst.position(dp - dst.arrayOffset());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/utf8\/DecodeBench.java","additions":589,"deletions":0,"binary":false,"changes":589,"status":"added"}]}