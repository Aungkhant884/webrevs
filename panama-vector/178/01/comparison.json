{"files":[{"patch":"@@ -283,0 +283,2 @@\n+macro(ReverseI)\n+macro(ReverseL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -551,0 +551,20 @@\n+\/\/-------------------------------ReverseINode--------------------------------\n+\/\/ reverse bits of an int\n+class ReverseINode : public Node {\n+public:\n+  ReverseINode(Node *c, Node *in1) : Node(c, in1) {}\n+  virtual int Opcode() const;\n+  const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/-------------------------------ReverseLNode--------------------------------\n+\/\/ reverse bits of a long\n+class ReverseLNode : public Node {\n+public:\n+  ReverseLNode(Node *c, Node *in1) : Node(c, in1) {}\n+  virtual int Opcode() const;\n+  const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -159,0 +159,6 @@\n+  case Op_ReverseI:\n+    \/\/ Not implemented. Returning 0 temporarily\n+    return 0;\n+  case Op_ReverseL:\n+    \/\/ Not implemented. Returning 0 temporarily\n+    return 0;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -512,0 +512,10 @@\n+    case VECTOR_OP_REVERSE: {\n+     switch (bt) {\n+        case T_BYTE:  \/\/ Temporarily returning\n+        case T_SHORT: \/\/ Op_ReverseI for byte and short\n+        case T_INT:   return Op_ReverseI;\n+        case T_LONG:  return Op_ReverseL;\n+        default: fatal(\"REVERSE: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+    VECTOR_OP_REVERSE  = 31,\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -89,0 +89,3 @@\n+    \/\/ Reverse operation\n+    public static final int VECTOR_OP_REVERSE   = 31;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -664,0 +664,2 @@\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> reverse(a));\n@@ -1800,0 +1802,9 @@\n+    static byte reverse(byte a) {\n+        if (a == 0 || a == -1) return a;\n+\n+        byte b = rotateLeft(a, 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -664,0 +664,2 @@\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.reverse(a));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -622,0 +622,2 @@\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.reverse(a));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -664,0 +664,2 @@\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> reverse(a));\n@@ -1800,0 +1802,10 @@\n+    static short reverse(short a) {\n+        if (a == 0 || a == -1) return a;\n+\n+        short b = rotateLeft(a, 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -459,0 +459,2 @@\n+    \/** Produce {@code reverse(a)} *\/\n+    public static final Unary REVERSE = unary(\"REVERSE\", \"reverse\", VectorSupport.VECTOR_OP_REVERSE, VO_NOFP);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -692,0 +692,2 @@\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverse(a));\n@@ -699,0 +701,2 @@\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> reverse(a));\n@@ -2073,0 +2077,16 @@\n+\n+    static $type$ reverse($type$ a) {\n+        if (a == 0 || a == -1) return a;\n+\n+#if[short]\n+        $type$ b = rotateLeft(a, 8);\n+        b = ($type$)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = ($type$)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = ($type$)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+#else[short]\n+        $type$ b = rotateLeft(a, 4);\n+        b = ($type$)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = ($type$)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+#end[short]\n+        return b;\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1221,0 +1221,8 @@\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n+\n@@ -5407,0 +5415,43 @@\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1221,0 +1221,8 @@\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n+\n@@ -5407,0 +5415,43 @@\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1221,0 +1221,8 @@\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n+\n@@ -5407,0 +5415,43 @@\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1221,0 +1221,8 @@\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n+\n@@ -5407,0 +5415,43 @@\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1226,0 +1226,8 @@\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n+\n@@ -5412,0 +5420,43 @@\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -4678,0 +4678,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4678,0 +4678,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4678,0 +4678,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4678,0 +4678,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4683,0 +4683,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4646,0 +4646,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4646,0 +4646,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4646,0 +4646,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4643,0 +4643,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4651,0 +4651,3 @@\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1181,0 +1181,5 @@\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n+\n@@ -5372,0 +5377,43 @@\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1181,0 +1181,5 @@\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n+\n@@ -5372,0 +5377,43 @@\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1181,0 +1181,5 @@\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n+\n@@ -5372,0 +5377,43 @@\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1181,0 +1181,5 @@\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n+\n@@ -5372,0 +5377,43 @@\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1186,0 +1186,5 @@\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n+\n@@ -5377,0 +5382,43 @@\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1203,0 +1203,5 @@\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n+\n@@ -5322,0 +5327,43 @@\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1203,0 +1203,5 @@\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n+\n@@ -5322,0 +5327,43 @@\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1203,0 +1203,5 @@\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n+\n@@ -5322,0 +5327,43 @@\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1203,0 +1203,5 @@\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n+\n@@ -5322,0 +5327,43 @@\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1208,0 +1208,5 @@\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n+\n@@ -5327,0 +5332,43 @@\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1211,0 +1211,9 @@\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n+\n@@ -5397,0 +5406,43 @@\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1211,0 +1211,9 @@\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n+\n@@ -5397,0 +5406,43 @@\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1211,0 +1211,9 @@\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n+\n@@ -5397,0 +5406,43 @@\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1211,0 +1211,9 @@\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n+\n@@ -5397,0 +5406,43 @@\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1216,0 +1216,9 @@\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n+\n@@ -5402,0 +5411,43 @@\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::REVERSE);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -557,0 +557,1 @@\n+gen_unary_alu_op \"REVERSE\" \"REVERSE_scalar(a)\" \"BITWISE\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,0 +175,18 @@\n+    static $type$ REVERSE_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.reverse(a);\n+#else[intOrLong]\n+#if[short]\n+        $type$ b = ROL_scalar(a, ($type$) 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+#else[short]\n+        $type$ b = ROL_scalar(a, ($type$) 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+#end[short]\n+#end[intOrLong]\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-header.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1481,0 +1481,19 @@\n+#end[intOrLong]\n+    }\n+\n+    static $type$ REVERSE_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.reverse(a);\n+#else[intOrLong]\n+#if[short]\n+        $type$ b = ROL_scalar(a, ($type$) 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+#else[short]\n+        $type$ b = ($type$) ROL_scalar(a, ($type$) 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+#end[short]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -140,0 +140,6 @@\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = ROL_scalar(a, (byte) 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n@@ -1782,0 +1788,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(REVERSE_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(REVERSE_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1621,0 +1621,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1621,0 +1621,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1621,0 +1621,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1621,0 +1621,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1621,0 +1621,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1265,0 +1265,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1621,0 +1621,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1621,0 +1621,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1621,0 +1621,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1621,0 +1621,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1621,0 +1621,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1265,0 +1265,2 @@\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -140,0 +140,3 @@\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n@@ -1782,0 +1785,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(REVERSE_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(REVERSE_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -140,0 +140,3 @@\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n@@ -1782,0 +1785,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(REVERSE_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(REVERSE_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2165,0 +2165,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -140,0 +140,7 @@\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n@@ -1782,0 +1789,36 @@\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(REVERSE_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(REVERSE_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"}]}