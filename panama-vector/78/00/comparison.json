{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -273,0 +273,1 @@\n+  if( strcmp(opType,\"LoadVectorMask\")==0 )  return Form::idealV;\n@@ -291,0 +292,1 @@\n+  if( strcmp(opType,\"StoreVectorMask\")==0 )  return Form::idealV;\n","filename":"src\/hotspot\/share\/adlc\/forms.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3512,1 +3512,1 @@\n-    \"StoreVector\", \"LoadVector\", \"LoadVectorGather\", \"StoreVectorScatter\", \"LoadVectorMasked\", \"StoreVectorMasked\",\n+    \"StoreVector\", \"LoadVector\", \"LoadVectorGather\", \"StoreVectorScatter\", \"LoadVectorMasked\", \"StoreVectorMasked\", \"LoadVectorMask\", \"StoreVectorMask\",\n@@ -3816,1 +3816,1 @@\n-\/\/-------------------------- has_commutative_op -------------------------------\n+\/\/-------------------------- count_commutative_op -------------------------------\n@@ -3822,1 +3822,0 @@\n-    \"AddVB\",\"AddVS\",\"AddVI\",\"AddVL\",\"AddVF\",\"AddVD\",\n@@ -3824,1 +3823,0 @@\n-    \"AndV\",\n@@ -3826,1 +3824,0 @@\n-    \"MaxV\", \"MinV\",\n@@ -3828,1 +3825,0 @@\n-    \"MulVB\",\"MulVS\",\"MulVI\",\"MulVL\",\"MulVF\",\"MulVD\",\n@@ -3830,3 +3826,1 @@\n-    \"OrV\",\n-    \"XorI\",\"XorL\",\n-    \"XorV\"\n+    \"XorI\",\"XorL\"\n@@ -3834,1 +3828,0 @@\n-  int cnt = sizeof(commut_op_list)\/sizeof(char*);\n@@ -3836,1 +3829,8 @@\n-  if( _lChild && _rChild && (_lChild->_lChild || _rChild->_lChild) ) {\n+  static const char *commut_vector_op_list[] = {\n+    \"AddVB\", \"AddVS\", \"AddVI\", \"AddVL\", \"AddVF\", \"AddVD\",\n+    \"MulVB\", \"MulVS\", \"MulVI\", \"MulVL\", \"MulVF\", \"MulVD\",\n+    \"AndV\", \"OrV\", \"XorV\",\n+    \"MaxV\", \"MinV\"\n+  };\n+\n+  if (_lChild && _rChild && (_lChild->_lChild || _rChild->_lChild)) {\n@@ -3839,1 +3839,1 @@\n-    if( _rChild->_lChild == NULL && _rChild->_rChild == NULL ) {\n+    if (_rChild->_lChild == NULL && _rChild->_rChild == NULL) {\n@@ -3842,3 +3842,3 @@\n-      if ( form ) {\n-        OperandForm  *oper = form->is_operand();\n-        if( oper && oper->interface_type(globals) == Form::constant_interface )\n+      if (form) {\n+        OperandForm *oper = form->is_operand();\n+        if (oper && oper->interface_type(globals) == Form::constant_interface)\n@@ -3848,5 +3848,19 @@\n-    if( !is_const ) {\n-      for( int i=0; i<cnt; i++ ) {\n-        if( strcmp(_opType, commut_op_list[i]) == 0 ) {\n-          count++;\n-          _commutative_id = count; \/\/ id should be > 0\n+\n+    if (!is_const) {\n+      int scalar_cnt = sizeof(commut_op_list)\/sizeof(char*);\n+      int vector_cnt = sizeof(commut_vector_op_list)\/sizeof(char*);\n+      bool matched = false;\n+\n+      \/\/ Check the commutative vector op first. It's noncommutative if\n+      \/\/ the current node is a masked vector op, since a mask value\n+      \/\/ is added to the original vector node's input list and the original\n+      \/\/ first two inputs are packed into one BinaryNode. So don't swap\n+      \/\/ if one of the operands is a BinaryNode.\n+      for (int i = 0; i < vector_cnt; i++) {\n+        if (strcmp(_opType, commut_vector_op_list[i]) == 0) {\n+          if (strcmp(_lChild->_opType, \"Binary\") != 0 &&\n+              strcmp(_rChild->_opType, \"Binary\") != 0) {\n+            count++;\n+            _commutative_id = count; \/\/ id should be > 0\n+          }\n+          matched = true;\n@@ -3856,0 +3870,12 @@\n+\n+      \/\/ Then check the scalar op if the current op is not in\n+      \/\/ the commut_vector_op_list.\n+      if (!matched) {\n+        for (int i = 0; i < scalar_cnt; i++) {\n+          if (strcmp(_opType, commut_op_list[i]) == 0) {\n+            count++;\n+            _commutative_id = count; \/\/ id should be > 0\n+            break;\n+          }\n+        }\n+      }\n@@ -3858,1 +3884,1 @@\n-  if( _lChild )\n+  if (_lChild)\n@@ -3860,1 +3886,1 @@\n-  if( _rChild )\n+  if (_rChild)\n@@ -4086,0 +4112,2 @@\n+        strcmp(opType,\"MaskToVector\")==0 ||\n+        strcmp(opType,\"MaskAll\")==0 ||\n@@ -4204,0 +4232,3 @@\n+    \"MaskToVector\", \"LoadVectorMask\", \"StoreVectorMask\",\n+    \/\/ Next are vector mask ops.\n+    \"VectorToMask\", \"MaskAll\", \"VectorCmpMaskGen\", \"AndVMask\", \"OrVMask\", \"XorVMask\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":53,"deletions":22,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -414,0 +414,1 @@\n+macro(LoadVectorMask)\n@@ -415,0 +416,1 @@\n+macro(StoreVectorMask)\n@@ -466,0 +468,8 @@\n+macro(VectorMask)\n+macro(VectorToMask)\n+macro(VectorCmpMaskGen)\n+macro(MaskAll)\n+macro(MaskToVector)\n+macro(AndVMask)\n+macro(OrVMask)\n+macro(XorVMask)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3484,0 +3484,2 @@\n+  case Op_LoadVectorMask:\n+  case Op_StoreVectorMask:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -691,0 +691,1 @@\n+        case Op_StoreVectorMask:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2323,0 +2323,10 @@\n+  if (n->is_Vector() && (n->req() == 4) && n->in(3)->is_VectorMask()) {\n+    \/\/ Handle op with mask\n+    Node* pair = new BinaryNode(n->in(1), n->in(2));\n+    Node* mask = n->in(3);\n+    n->set_req(1, pair);\n+    n->set_req(2, mask);\n+    n->del_req(3);\n+    return;\n+  }\n+\n@@ -2462,1 +2472,2 @@\n-    case Op_VectorMaskCmp: {\n+    case Op_VectorMaskCmp:\n+    case Op_VectorCmpMaskGen: {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+class VectorMaskNode;\n@@ -698,0 +699,1 @@\n+        DEFINE_CLASS_ID(VectorMask, Vector, 1)\n@@ -926,0 +928,1 @@\n+  DEFINE_CLASS_QUERY(VectorMask)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2416,1 +2416,5 @@\n-  if (Matcher::has_predicated_vectors()) {\n+  if (Matcher::has_predicated_vectors() &&\n+      \/\/ TODO: remove this condition once the backend is supported.\n+      \/\/ Workround to make tests pass on AVX-512\/SVE when predicate is not supported.\n+      \/\/ Could be removed once the backend is supported.\n+      Matcher::match_rule_supported_vector_masked(Op_StoreVectorMasked, MaxVectorSize, T_BOOLEAN)) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -449,1 +449,1 @@\n-      vec_val_load = gvn.transform(new VectorLoadMaskNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n+      vec_val_load = gvn.transform(VectorNode::make_mask_node(gvn, Op_VectorLoadMask, vec_val_load, num_elem, masktype));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,0 +61,8 @@\n+static bool is_vector_mask(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n+}\n+\n+static bool is_vector_shuffle(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+}\n+\n@@ -75,1 +83,2 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  const TypeVect* vt = is_vector_mask(vbox_type->klass()) ?\n+                       TypeVect::makemask(elem_bt, num_elem) : TypeVect::make(elem_bt, num_elem);\n@@ -90,1 +99,2 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  const TypeVect* vt = is_vector_mask(vbox_type->klass()) ?\n+                       TypeVect::makemask(elem_bt, num_elem) : TypeVect::make(elem_bt, num_elem);\n@@ -189,8 +199,0 @@\n-static bool is_vector_mask(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-}\n-\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n@@ -360,2 +362,1 @@\n-      case 1:\n-      case 2: {\n+      case 1: {\n@@ -365,0 +366,8 @@\n+      case 2: {\n+        if (is_vector_mask(vbox_klass)) {\n+          operation = gvn().transform(VectorNode::make_mask_node(sopc, opd1, opd2, num_elem, elem_bt));\n+        } else {\n+          operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, vt));\n+        }\n+        break;\n+      }\n@@ -602,4 +611,1 @@\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** predicate feature is not supported yet!\");\n-      }\n-      return false;\n+      operation->add_req(mask);\n@@ -699,1 +705,1 @@\n-    Node* mask = gvn().transform(new VectorMaskCmpNode(BoolTest::ge, bcast_lane_cnt, res, pred_node, vt));\n+    Node* mask = gvn().transform(VectorNode::make_mask_node(gvn(), Op_VectorMaskCmp, bcast_lane_cnt, res, pred_node, num_elem, elem_bt));\n@@ -825,25 +831,5 @@\n-\n-  Node* elem = NULL;\n-  switch (elem_bt) {\n-    case T_BOOLEAN: \/\/ fall-through\n-    case T_BYTE:    \/\/ fall-through\n-    case T_SHORT:   \/\/ fall-through\n-    case T_CHAR:    \/\/ fall-through\n-    case T_INT: {\n-      elem = gvn().transform(new ConvL2INode(bits));\n-      break;\n-    }\n-    case T_DOUBLE: {\n-      elem = gvn().transform(new MoveL2DNode(bits));\n-      break;\n-    }\n-    case T_FLOAT: {\n-      bits = gvn().transform(new ConvL2INode(bits));\n-      elem = gvn().transform(new MoveI2FNode(bits));\n-      break;\n-    }\n-    case T_LONG: {\n-      elem = bits; \/\/ no conversion needed\n-      break;\n-    }\n-    default: fatal(\"%s\", type2name(elem_bt));\n+  Node* node = NULL;\n+  if (is_vector_mask(vbox_klass)) {\n+    node = VectorNode::make_mask_node(gvn(), Op_MaskAll, bits, num_elem, elem_bt);\n+  } else {\n+    node = VectorNode::broadcast(gvn(), bits, num_elem, elem_bt);\n@@ -852,4 +838,2 @@\n-  Node* broadcast = VectorNode::scalar2vector(elem, num_elem, Type::get_const_basic_type(elem_bt));\n-  broadcast = gvn().transform(broadcast);\n-\n-  Node* box = box_vector(broadcast, vbox_type, elem_bt, num_elem);\n+  node = gvn().transform(node);\n+  Node* box = box_vector(node, vbox_type, elem_bt, num_elem);\n@@ -1022,2 +1006,1 @@\n-        const TypeVect* to_vect_type = TypeVect::make(elem_bt, num_elem);\n-        vload = gvn().transform(new VectorLoadMaskNode(vload, to_vect_type));\n+        vload = gvn().transform(VectorNode::make_mask_node(gvn(), Op_VectorLoadMask, vload, num_elem, elem_bt));\n@@ -1589,2 +1572,0 @@\n-  BoolTest::mask pred = (BoolTest::mask)cond->get_con();\n-  ConINode* pred_node = (ConINode*)gvn().makecon(cond);\n@@ -1592,2 +1573,2 @@\n-  const TypeVect* vt = TypeVect::make(mask_bt, num_elem);\n-  Node* operation = gvn().transform(new VectorMaskCmpNode(pred, v1, v2, pred_node, vt));\n+  ConINode* pred_node = (ConINode*)gvn().makecon(cond);\n+  Node* operation = gvn().transform(VectorNode::make_mask_node(gvn(), Op_VectorMaskCmp, v1, v2, pred_node, num_elem, mask_bt));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":33,"deletions":52,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"opto\/convertnode.hpp\"\n+#include \"opto\/movenode.hpp\"\n@@ -535,0 +537,30 @@\n+VectorNode* VectorNode::broadcast(PhaseGVN& gvn, Node* bits, uint vlen, BasicType bt) {\n+  Node* elem = NULL;\n+  switch (bt) {\n+    case T_BOOLEAN: \/\/ fall-through\n+    case T_BYTE:    \/\/ fall-through\n+    case T_SHORT:   \/\/ fall-through\n+    case T_CHAR:    \/\/ fall-through\n+    case T_INT: {\n+      elem = gvn.transform(new ConvL2INode(bits));\n+      break;\n+    }\n+    case T_DOUBLE: {\n+      elem = gvn.transform(new MoveL2DNode(bits));\n+      break;\n+    }\n+    case T_FLOAT: {\n+      bits = gvn.transform(new ConvL2INode(bits));\n+      elem = gvn.transform(new MoveI2FNode(bits));\n+      break;\n+    }\n+    case T_LONG: {\n+      elem = bits; \/\/ no conversion needed\n+      break;\n+    }\n+    default:\n+      fatal(\"%s\", type2name(bt) != NULL ? type2name(bt) : \"invalid basic type\");\n+  }\n+  return scalar2vector(elem, vlen, Type::get_const_basic_type(bt));\n+}\n+\n@@ -646,0 +678,76 @@\n+int VectorNode::mask_opcode(int vopc) {\n+  switch (vopc) {\n+    case Op_AndV: return Op_AndVMask;\n+    case Op_OrV: return Op_OrVMask;\n+    case Op_XorV: return Op_XorVMask;\n+    case Op_MaskAll: return Op_MaskAll;\n+    case Op_VectorLoadMask: return Op_VectorToMask;\n+    case Op_VectorMaskCmp: return Op_VectorCmpMaskGen;\n+    default:\n+      fatal(\"Missed mask vector opcode for '%s'\", NodeClassNames[vopc]);\n+      return 0;\n+  }\n+}\n+\n+const TypeVect* VectorNode::mask_type(int vopc, uint vlen, BasicType bt) {\n+  guarantee(vopc > 0, \"vopc must be > 0\");\n+  int vmask_opc = mask_opcode(vopc);\n+  if (vmask_opc != 0 &&\n+      Matcher::has_predicated_vectors() &&\n+      Matcher::match_rule_supported_vector(vmask_opc, vlen, bt)) {\n+    return (const TypeVectMask*) TypeVect::makemask(bt, vlen);\n+  }\n+  return TypeVect::make(bt, vlen);\n+}\n+\n+VectorNode* VectorNode::make_mask_node(PhaseGVN& gvn, int vopc, Node* n1, uint vlen, BasicType bt) {\n+  const TypeVect* type = mask_type(vopc, vlen, bt);\n+  switch (vopc) {\n+    case Op_VectorLoadMask: {\n+      VectorLoadMaskNode* vload_mask = new VectorLoadMaskNode(n1, TypeVect::make(bt, vlen));\n+      if (type->isa_vectmask()) {\n+        return new VectorToMaskNode(gvn.transform(vload_mask), (const TypeVectMask*) type);\n+      }\n+      return vload_mask;\n+    }\n+    case Op_MaskAll: {\n+      const TypeLong* value = gvn.type(n1)->is_long();\n+      if (type->isa_vectmask() &&\n+          value->is_con() && (value->get_con() == -1 || value->get_con() == 0)) {\n+        return new MaskAllNode((ConLNode*) gvn.makecon(value), (const TypeVectMask*) type);\n+      }\n+      return broadcast(gvn, n1, vlen, bt);\n+    }\n+    default:\n+      fatal(\"Missed mask vector creation for '%s'\", NodeClassNames[vopc]);\n+      return NULL;\n+  }\n+}\n+\n+VectorNode* VectorNode::make_mask_node(int vopc, Node* n1, Node* n2, uint vlen, BasicType bt) {\n+  const TypeVect* type = mask_type(vopc, vlen, bt);\n+  if (type->isa_vectmask()) {\n+    const TypeVectMask* vmask_type = (const TypeVectMask*) type;\n+    switch (vopc) {\n+      case Op_AndV: return new AndVMaskNode(n1, n2, vmask_type);\n+      case Op_OrV:  return new OrVMaskNode(n1, n2, vmask_type);\n+      case Op_XorV: return new XorVMaskNode(n1, n2, vmask_type);\n+      default:\n+        fatal(\"Missed mask vector creation for '%s'\", NodeClassNames[vopc]);\n+        return NULL;\n+    }\n+  }\n+  return make(vopc, n1, n2, type);\n+}\n+\n+VectorNode* VectorNode::make_mask_node(PhaseGVN& gvn, int vopc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt) {\n+  assert(vopc == Op_VectorMaskCmp, \"Missed mask vector creation for '%s'\", NodeClassNames[vopc]);\n+  const TypeVect* type = mask_type(vopc, vlen, bt);\n+  ConINode* pred_node = (ConINode*) n3;\n+  if (type->isa_vectmask()) {\n+    return new VectorCmpMaskGenNode(n1, n2, pred_node, (const TypeVectMask*) type);\n+  }\n+  BoolTest::mask pred = (BoolTest::mask) gvn.type(pred_node)->is_int()->get_con();\n+  return new VectorMaskCmpNode(pred, n1, n2, pred_node, type);\n+}\n+\n@@ -723,0 +831,17 @@\n+Node* StoreVectorNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ StoreVector (VectorStoreMask src)  ==>  (StoreVectorMask src).\n+  Node* value = in(MemNode::ValueIn);\n+  if (value->Opcode() == Op_VectorStoreMask) {\n+    assert(vect_type()->element_basic_type() == T_BOOLEAN, \"Invalid basic type to store mask\");\n+    const TypeVect* type = value->in(1)->bottom_type()->is_vect();\n+    if (Matcher::match_rule_supported_vector(Op_StoreVectorMask, type->length(), type->element_basic_type())) {\n+      const TypeVect* mem_type = TypeVect::make(T_BOOLEAN, type->length());\n+      return new StoreVectorMaskNode(in(MemNode::Control),\n+                                     in(MemNode::Memory),\n+                                     in(MemNode::Address),\n+                                     adr_type(), value->in(1), mem_type);\n+    }\n+  }\n+  return StoreNode::Ideal(phase, can_reshape);\n+}\n+\n@@ -758,0 +883,16 @@\n+Node* VectorToMaskNode::Identity(PhaseGVN* phase) {\n+  \/\/ VectorToMask (MaskToVector mask)  ==>  mask\n+  if (in(1)->Opcode() == Op_MaskToVector) {\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+Node* MaskToVectorNode::Identity(PhaseGVN* phase) {\n+  \/\/ MaskToVector (VectorToMask value)  ==>  value\n+  if (in(1)->Opcode() == Op_VectorToMask) {\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n@@ -974,0 +1115,15 @@\n+Node* VectorLoadMaskNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ (VectorLoadMask (LoadVector mem))  ==> (LoadVectorMask mem)\n+  LoadVectorNode* load = this->in(1)->isa_LoadVector();\n+  BasicType out_bt = vect_type()->element_basic_type();\n+  if (load != NULL &&\n+      Matcher::match_rule_supported_vector(Op_LoadVectorMask, length(), out_bt)) {\n+    const TypeVect* mem_type = TypeVect::make(T_BOOLEAN, length());\n+    return new LoadVectorMaskNode(load->in(MemNode::Control),\n+                                  load->in(MemNode::Memory),\n+                                  load->in(MemNode::Address),\n+                                  load->adr_type(), vect_type(), mem_type);\n+  }\n+  return NULL;\n+}\n+\n@@ -993,1 +1149,6 @@\n-  assert(in->bottom_type()->isa_vect(), \"sanity\");\n+  Node* value = in;\n+  if (value->bottom_type()->isa_vectmask() &&\n+      Matcher::match_rule_supported_vector(Op_MaskToVector, num_elem, in_type)) {\n+    value = gvn.transform(new MaskToVectorNode(in, TypeVect::make(in_type, num_elem)));\n+  }\n+  assert(value->bottom_type()->isa_vect(), \"sanity\");\n@@ -996,1 +1157,1 @@\n-  return new VectorStoreMaskNode(in, gvn.intcon(elem_size), vt);\n+  return new VectorStoreMaskNode(value, gvn.intcon(elem_size), vt);\n@@ -1237,1 +1398,1 @@\n-          return new VectorLoadMaskNode(value, out_vt);\n+          return make_mask_node(*phase, Op_VectorLoadMask, value, out_vt->length(), out_vt->element_basic_type());\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":164,"deletions":3,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  static VectorNode* broadcast(PhaseGVN& gvn, Node* bits, uint vlen, BasicType bt);\n@@ -109,0 +110,6 @@\n+\n+  static int mask_opcode(int vopc);\n+  static const TypeVect* mask_type(int vopc, uint vlen, BasicType bt);\n+  static VectorNode* make_mask_node(PhaseGVN& gvn, int vopc, Node* n1, uint vlen, BasicType bt);\n+  static VectorNode* make_mask_node(int vopc, Node* n1, Node* n2, uint vlen, BasicType bt);\n+  static VectorNode* make_mask_node(PhaseGVN& gvn, int vopc, Node* n1, Node* n2, Node* n3, uint vlen, BasicType bt);\n@@ -774,0 +781,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -807,1 +815,1 @@\n-    assert(mask->bottom_type()->is_vectmask(), \"sanity\");\n+    assert(mask->bottom_type()->isa_vectmask(), \"sanity\");\n@@ -825,1 +833,1 @@\n-    assert(mask->bottom_type()->is_vectmask(), \"sanity\");\n+    assert(mask->bottom_type()->isa_vectmask(), \"sanity\");\n@@ -856,0 +864,147 @@\n+\/\/ ==========================Mask feature specific==============================\n+\n+class LoadVectorMaskNode : public LoadVectorNode {\n+ private:\n+  \/**\n+   * The type of the accessed memory, whose basic element type is T_BOOLEAN for mask vector.\n+   * It is different with the basic element type of the node, which can be T_BYTE, T_SHORT,\n+   * T_INT, T_LONG, T_FLOAT or T_DOUBLE.\n+   **\/\n+  const TypeVect* _mem_type;\n+\n+ public:\n+  LoadVectorMaskNode(Node* c, Node* mem, Node* adr, const TypePtr* at, const TypeVect* vt, const TypeVect* mt)\n+   : LoadVectorNode(c, mem, adr, at, vt), _mem_type(mt) {\n+    assert(_mem_type->element_basic_type() == T_BOOLEAN, \"Memory type must be T_BOOLEAN\");\n+    init_class_id(Class_LoadVector);\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual int memory_size() const { return _mem_type->length_in_bytes(); }\n+  virtual int store_Opcode() const { return Op_StoreVectorMask; }\n+  virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(vect_type()->length_in_bytes()); }\n+  virtual uint size_of() const { return sizeof(LoadVectorMaskNode); }\n+};\n+\n+class StoreVectorMaskNode : public StoreVectorNode {\n+ private:\n+  \/**\n+   * The type of the accessed memory, whose basic element type is T_BOOLEAN for mask vector.\n+   * It is different with the basic element type of the src value, which can be T_BYTE, T_SHORT,\n+   * T_INT, T_LONG, T_FLOAT or T_DOUBLE.\n+   **\/\n+  const TypeVect* _mem_type;\n+\n+ public:\n+  StoreVectorMaskNode(Node* c, Node* mem, Node* adr, const TypePtr* at, Node* src, const TypeVect* mt)\n+   : StoreVectorNode(c, mem, adr, at, src), _mem_type(mt) {\n+    assert(_mem_type->element_basic_type() == T_BOOLEAN, \"Memory type must be T_BOOLEAN\");\n+    init_class_id(Class_StoreVector);\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual int memory_size() const { return _mem_type->length_in_bytes(); }\n+  virtual uint ideal_reg() const  { return Matcher::vector_ideal_reg(vect_type()->length_in_bytes()); }\n+  virtual uint size_of() const { return sizeof(StoreVectorMaskNode); }\n+};\n+\n+class VectorMaskNode : public VectorNode {\n+ public:\n+  VectorMaskNode(Node* in1, const TypeVectMask* type) :\n+    VectorNode(in1, type) {\n+    init_class_id(Class_VectorMask);\n+  }\n+\n+  VectorMaskNode(Node* in1, Node* in2, const TypeVectMask* type) :\n+    VectorNode(in1, in2, type) {\n+    init_class_id(Class_VectorMask);\n+  }\n+\n+  VectorMaskNode(Node* in1, Node* in2, Node* in3, const TypeVectMask* type) :\n+    VectorNode(in1, in2, in3, type) {\n+    init_class_id(Class_VectorMask);\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual uint ideal_reg() const { return Op_RegVectMask; }\n+};\n+\n+class VectorToMaskNode : public VectorMaskNode {\n+ public:\n+  VectorToMaskNode(Node* in, const TypeVectMask* type) : VectorMaskNode(in, type) {}\n+\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+};\n+\n+class MaskAllNode : public VectorMaskNode {\n+ public:\n+  MaskAllNode(ConLNode* in, const TypeVectMask* type) : VectorMaskNode(in, type) {\n+    assert(in->get_long() == 0 || in->get_long() == -1, \"Unsupported value to mask all\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+\/\/ Vector compare node with a TypeVectMask bottom_type. It is specially generated for\n+\/\/ platforms that have mask hardware feature. The main difference with \"VectorMaskCmpNode\"\n+\/\/ is that this is a kind of mask node, while \"VectorMaskCmpNode\" is a vector node.\n+class VectorCmpMaskGenNode : public VectorMaskNode {\n+ public:\n+  VectorCmpMaskGenNode(Node* in1, Node* in2, ConINode* predicate_node, const TypeVectMask* type) :\n+    VectorMaskNode(in1, in2, predicate_node, type) {\n+    assert(in1->bottom_type()->is_vect()->element_basic_type() == in2->bottom_type()->is_vect()->element_basic_type(),\n+           \"VectorCmpMaskGen inputs must have the same type for elements\");\n+    assert(in1->bottom_type()->is_vect()->length() == in2->bottom_type()->is_vect()->length(),\n+           \"VectorCmpMaskGen inputs must have the same number of elements\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+\/\/ Vector mask logical and\n+class AndVMaskNode : public VectorMaskNode {\n+ public:\n+  AndVMaskNode(Node* in1, Node* in2, const TypeVectMask* type) :\n+    VectorMaskNode(in1, in2, type) {\n+    assert(in1->bottom_type()->isa_vectmask() &&\n+           in2->bottom_type()->isa_vectmask(), \"Input must be vector mask type\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+\/\/ Vector mask logical or\n+class OrVMaskNode : public VectorMaskNode {\n+ public:\n+  OrVMaskNode(Node* in1, Node* in2, const TypeVectMask* type) :\n+    VectorMaskNode(in1, in2, type) {\n+    assert(in1->bottom_type()->isa_vectmask() &&\n+           in2->bottom_type()->isa_vectmask(), \"Input must be vector mask type\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+\/\/ Vector mask logical xor\n+class XorVMaskNode : public VectorMaskNode {\n+ public:\n+  XorVMaskNode(Node* in1, Node* in2, const TypeVectMask* type) :\n+    VectorMaskNode(in1, in2, type) {\n+    assert(in1->bottom_type()->isa_vectmask() &&\n+           in2->bottom_type()->isa_vectmask(), \"Input must be vector mask type\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n+class MaskToVectorNode : public VectorNode {\n+ public:\n+  MaskToVectorNode(Node* mask, const TypeVect* vt) : VectorNode(mask, vt) {\n+    assert(mask->bottom_type()->isa_vectmask(), \"input must be a VectorMask\");\n+  }\n+\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+};\n+\n@@ -1230,0 +1385,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":158,"deletions":2,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -1865,0 +1865,2 @@\n+  declare_c2_type(LoadVectorMaskNode, LoadVectorNode)                     \\\n+  declare_c2_type(StoreVectorMaskNode, StoreVectorNode)                   \\\n@@ -1882,0 +1884,8 @@\n+  declare_c2_type(MaskToVectorNode, VectorNode)                           \\\n+  declare_c2_type(VectorMaskNode, VectorNode)                             \\\n+  declare_c2_type(VectorCmpMaskGenNode, VectorMaskNode)                   \\\n+  declare_c2_type(VectorToMaskNode, VectorMaskNode)                       \\\n+  declare_c2_type(MaskAllNode, VectorMaskNode)                            \\\n+  declare_c2_type(AndVMaskNode, VectorMaskNode)                           \\\n+  declare_c2_type(OrVMaskNode, VectorMaskNode)                            \\\n+  declare_c2_type(XorVMaskNode, VectorMaskNode)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}