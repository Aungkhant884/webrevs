{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.math.FloatConsts;\n@@ -891,0 +892,192 @@\n+    \/**\n+     * {@return the {@code float} value closest to the numerical value\n+     * of the argument, a floating-point binary16 value encoded in a\n+     * {@code short}} The conversion is exact; all binary16 values can\n+     * be exactly represented in {@code float}.\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * same sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the same sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * <h4><a id=binary16Format>IEEE 754 binary16 format<\/a><\/h4>\n+     * The IEEE 754 standard defines binary16 as a 16-bit format, along\n+     * with the 32-bit binary32 format (corresponding to the {@code\n+     * float} type) and the 64-bit binary64 format (corresponding to\n+     * the {@code double} type). The binary16 format is similar to the\n+     * other IEEE 754 formats, except smaller, having all the usual\n+     * IEEE 754 values such as NaN, signed infinities, signed zeros,\n+     * and subnormals. The parameters (JLS {@jls 4.2.3}) for the\n+     * binary16 format are N = 11 precision bits, K = 5 exponent bits,\n+     * <i>E<\/i><sub><i>max<\/i><\/sub> = 15, and\n+     * <i>E<\/i><sub><i>min<\/i><\/sub> = -14.\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754 from the binary16 format to the binary32 format.\n+     * The operation of this method is analogous to a primitive\n+     * widening conversion (JLS {@jls 5.1.2}).\n+     *\n+     * @param floatBinary16 the binary16 value to convert to {@code float}\n+     * @since 20\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static float float16ToFloat(short floatBinary16) {\n+        \/*\n+         * The binary16 format has 1 sign bit, 5 exponent bits, and 10\n+         * significand bits. The exponent bias is 15.\n+         *\/\n+        int bin16arg = (int)floatBinary16;\n+        int bin16SignBit     = 0x8000 & bin16arg;\n+        int bin16ExpBits     = 0x7c00 & bin16arg;\n+        int bin16SignifBits  = 0x03FF & bin16arg;\n+\n+        \/\/ Shift left difference in the number of significand bits in\n+        \/\/ the float and binary16 formats\n+        final int SIGNIF_SHIFT = (FloatConsts.SIGNIFICAND_WIDTH - 11);\n+\n+        float sign = (bin16SignBit != 0) ? -1.0f : 1.0f;\n+\n+        \/\/ Extract binary16 exponent, remove its bias, add in the bias\n+        \/\/ of a float exponent and shift to correct bit location\n+        \/\/ (significand width includes the implicit bit so shift one\n+        \/\/ less).\n+        int bin16Exp = (bin16ExpBits >> 10) - 15;\n+        if (bin16Exp == -15) {\n+            \/\/ For subnormal binary16 values and 0, the numerical\n+            \/\/ value is 2^24 * the significand as an integer (no\n+            \/\/ implicit bit).\n+            return sign * (0x1p-24f * bin16SignifBits);\n+        } else if (bin16Exp == 16) {\n+            return (bin16SignifBits == 0) ?\n+                sign * Float.POSITIVE_INFINITY :\n+                Float.intBitsToFloat((bin16SignBit << 16) |\n+                                     0x7f80_0000 |\n+                                     \/\/ Preserve NaN signif bits\n+                                     ( bin16SignifBits << SIGNIF_SHIFT ));\n+        }\n+\n+        assert -15 < bin16Exp  && bin16Exp < 16;\n+\n+        int floatExpBits = (bin16Exp + FloatConsts.EXP_BIAS)\n+            << (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+\n+        \/\/ Compute and combine result sign, exponent, and significand bits.\n+        return Float.intBitsToFloat((bin16SignBit << 16) |\n+                                    floatExpBits |\n+                                    (bin16SignifBits << SIGNIF_SHIFT));\n+    }\n+\n+    \/**\n+     * {@return the floating-point binary16 value, encoded in a {@code\n+     * short}, closest in value to the argument}\n+     * The conversion is computed under the {@linkplain\n+     * java.math.RoundingMode#HALF_EVEN round to nearest even rounding\n+     * mode}.\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * same sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the same sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * The <a href=\"#binary16Format\">binary16 format<\/a> is discussed in\n+     * more detail in the {@link #float16ToFloat} method.\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754 from the binary32 format to the binary16 format.\n+     * The operation of this method is analogous to a primitive\n+     * narrowing conversion (JLS {@jls 5.1.3}).\n+     *\n+     * @param f the {@code float} value to convert to binary16\n+     * @since 20\n+     *\/\n+    \/\/ @IntrinsicCandidate\n+    public static short floatToFloat16(float f) {\n+        int doppel = Float.floatToRawIntBits(f);\n+        short sign_bit = (short)((doppel & 0x8000_0000) >> 16);\n+\n+        if (Float.isNaN(f)) {\n+            \/\/ Preserve sign and attempt to preserve significand bits\n+            return (short)(sign_bit\n+                    | 0x7c00 \/\/ max exponent + 1\n+                    \/\/ Preserve high order bit of float NaN in the\n+                    \/\/ binary16 result NaN (tenth bit); OR in remaining\n+                    \/\/ bits into lower 9 bits of binary 16 significand.\n+                    | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+                    | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+                    | (doppel & 0x0000_000f));     \/\/  4 bits\n+        }\n+\n+        float abs_f = Math.abs(f);\n+\n+        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n+        if (abs_f >= (0x1.ffcp15f + 0x0.002p15f) ) {\n+            return (short)(sign_bit | 0x7c00); \/\/ Positive or negative infinity\n+        }\n+\n+        \/\/ Smallest magnitude nonzero representable binary16 value\n+        \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+        if (abs_f <= 0x1.0p-24f * 0.5f) { \/\/ Covers float zeros and subnormals.\n+            return sign_bit; \/\/ Positive or negative zero\n+        }\n+\n+        \/\/ Dealing with finite values in exponent range of binary16\n+        \/\/ (when rounding is done, could still round up)\n+        int exp = Math.getExponent(f);\n+        assert -25 <= exp && exp <= 15;\n+\n+        \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+        \/\/ the difference expdelta = E_min - exp.  This is the excess\n+        \/\/ shift value, in addition to 13, to be used in the\n+        \/\/ computations below.  Further the (hidden) msb with value 1\n+        \/\/ in f must be involved as well.\n+        int expdelta = 0;\n+        int msb = 0x0000_0000;\n+        if (exp < -14) {\n+            expdelta = -14 - exp;\n+            exp = -15;\n+            msb = 0x0080_0000;\n+        }\n+        int f_signif_bits = doppel & 0x007f_ffff | msb;\n+\n+        \/\/ Significand bits as if using rounding to zero (truncation).\n+        short signif_bits = (short)(f_signif_bits >> (13 + expdelta));\n+\n+        \/\/ For round to nearest even, determining whether or not to\n+        \/\/ round up (in magnitude) is a function of the least\n+        \/\/ significant bit (LSB), the next bit position (the round\n+        \/\/ position), and the sticky bit (whether there are any\n+        \/\/ nonzero bits in the exact result to the right of the round\n+        \/\/ digit). An increment occurs in three cases:\n+        \/\/\n+        \/\/ LSB  Round Sticky\n+        \/\/ 0    1     1\n+        \/\/ 1    1     0\n+        \/\/ 1    1     1\n+        \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+        int lsb    = f_signif_bits & (1 << 13 + expdelta);\n+        int round  = f_signif_bits & (1 << 12 + expdelta);\n+        int sticky = f_signif_bits & ((1 << 12 + expdelta) - 1);\n+\n+        if (round != 0 && ((lsb | sticky) != 0 )) {\n+            signif_bits++;\n+        }\n+\n+        \/\/ No bits set in significand beyond the *first* exponent bit,\n+        \/\/ not just the sigificand; quantity is added to the exponent\n+        \/\/ to implement a carry out from rounding the significand.\n+        assert (0xf800 & signif_bits) == 0x0;\n+\n+        return (short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) );\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"modified"}]}