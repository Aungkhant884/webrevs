{"files":[{"patch":"@@ -0,0 +1,502 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.vector;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+class CompressExpand {\n+\n+    \/**\n+     * Returns the value obtained by compressing the bits of the\n+     * specified {@code int} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the bit value of {@code i} at\n+     * the same bit location as {@code mb} is assigned to the compressed\n+     * value contiguously starting from the least significant bit location.\n+     * All the upper remaining bits of the compressed value are set\n+     * to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of compressing the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Compressing drink to food\n+     * compress(0xCAFEBABE, 0xFF00FFF0) == 0xCABAB\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects hexadecimal digits\n+     * at positions 1, 2, 3, 6 and 7 of {@code 0xCAFEBABE}. The selected digits\n+     * occur in the resulting compressed value contiguously from digit position\n+     * 0 in the same order.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code compress}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Returns 1 if the bit at position n is one\n+     * compress(x, 1 << n) == (x >> n & 1)\n+     *\n+     * \/\/ Logical shift right\n+     * compress(x, -1 << n) == x >>> n\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * compress(x, m) == compress(x & m, m)\n+     *\n+     * \/\/ Compressing a value by itself\n+     * compress(m, m) == (m == -1 || m == 0) ? m : (1 << bitCount(m)) - 1\n+     *\n+     * \/\/ Expanding then compressing with the same mask\n+     * compress(expand(x, m), m) == x & compress(m, m)\n+     * }\n+     * <p>\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * int compressLeft(int i, int mask) {\n+     *     \/\/ This implementation follows the description in Hacker's Delight which\n+     *     \/\/ is informative. A more optimal implementation is:\n+     *     \/\/   Integer.compress(i, mask) << -Integer.bitCount(mask)\n+     *     return Integer.reverse(\n+     *         Integer.compress(Integer.reverse(i), Integer.reverse(mask)));\n+     * }\n+     *\n+     * int sag(int i, int mask) {\n+     *     return compressLeft(i, mask) | Integer.compress(i, ~mask);\n+     * }\n+     *\n+     * \/\/ Separate the sheep from the goats\n+     * sag(0xCAFEBABE, 0xFF00FFF0) == 0xCABABFEE\n+     * }\n+     *\n+     * @param i the value whose bits are to be compressed\n+     * @param mask the bit mask\n+     * @return the compressed value\n+     * @see #expand\n+     * @since 19\n+     *\/\n+    static int compress(int i, int mask) {\n+        \/\/ See Hacker's Delight (2nd ed) section 7.4 Compress, or Generalized Extract\n+\n+        i = i & mask; \/\/ Clear irrelevant bits\n+        int maskCount = ~mask << 1; \/\/ Count 0's to right\n+\n+        for (int j = 0; j < 5; j++) {\n+            \/\/ Parallel prefix\n+            \/\/ Mask prefix identifies bits of the mask that have an odd number of 0's to the right\n+            int maskPrefix = parallelSuffix(maskCount);\n+            \/\/ Bits to move\n+            int maskMove = maskPrefix & mask;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Bits of i to be moved\n+            int t = i & maskMove;\n+            \/\/ Compress i\n+            i = (i ^ t) | (t >>> (1 << j));\n+            \/\/ Adjust the mask count by identifying bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+    \/**\n+     * Returns the value obtained by compressing the bits of the\n+     * specified {@code long} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the bit value of {@code i} at\n+     * the same bit location as {@code mb} is assigned to the compressed\n+     * value contiguously starting from the least significant bit location.\n+     * All the upper remaining bits of the compressed value are set\n+     * to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of compressing the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Compressing drink to food\n+     * compress(0xCAFEBABE, 0xFF00FFF0) == 0xCABAB\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects hexadecimal digits\n+     * at positions 1, 2, 3, 6 and 7 of {@code 0xCAFEBABE}. The selected digits\n+     * occur in the resulting compressed value contiguously from digit position\n+     * 0 in the same order.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code compress}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Returns 1 if the bit at position n is one\n+     * compress(x, 1 << n) == (x >> n & 1)\n+     *\n+     * \/\/ Logical shift right\n+     * compress(x, -1 << n) == x >>> n\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * compress(x, m) == compress(x & m, m)\n+     *\n+     * \/\/ Compressing a value by itself\n+     * compress(m, m) == (m == -1 || m == 0) ? m : (1 << bitCount(m)) - 1\n+     *\n+     * \/\/ Expanding then compressing with the same mask\n+     * compress(expand(x, m), m) == x & compress(m, m)\n+     * }\n+     * <p>\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * long compressLeft(long i, long mask) {\n+     *     \/\/ This implementation follows the description in Hacker's Delight which\n+     *     \/\/ is informative. A more optimal implementation is:\n+     *     \/\/   Long.compress(i, mask) << -Long.bitCount(mask)\n+     *     return Long.reverse(\n+     *         Long.compress(Long.reverse(i), Long.reverse(mask)));\n+     * }\n+     *\n+     * long sag(long i, long mask) {\n+     *     return compressLeft(i, mask) | Long.compress(i, ~mask);\n+     * }\n+     *\n+     * \/\/ Separate the sheep from the goats\n+     * sag(0xCAFEBABE, 0xFF00FFF0) == 0xCABABFEE\n+     * }\n+     *\n+     * @param i the value whose bits are to be compressed\n+     * @param mask the bit mask\n+     * @return the compressed value\n+     * @see #expand\n+     * @since 19\n+     *\/\n+    static long compress(long i, long mask) {\n+        \/\/ See Hacker's Delight (2nd ed) section 7.4 Compress, or Generalized Extract\n+\n+        i = i & mask; \/\/ Clear irrelevant bits\n+        long maskCount = ~mask << 1; \/\/ Count 0's to right\n+\n+        for (int j = 0; j < 6; j++) {\n+            \/\/ Parallel prefix\n+            \/\/ Mask prefix identifies bits of the mask that have an odd number of 0's to the right\n+            long maskPrefix = parallelSuffix(maskCount);\n+            \/\/ Bits to move\n+            long maskMove = maskPrefix & mask;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Bits of i to be moved\n+            long t = i & maskMove;\n+            \/\/ Compress i\n+            i = (i ^ t) | (t >>> (1 << j));\n+            \/\/ Adjust the mask count by identifying bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+\n+    \/**\n+     * Returns the value obtained by expanding the bits of the\n+     * specified {@code int} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the next contiguous bit value\n+     * of {@code i} starting at the least significant bit is assigned\n+     * to the expanded value at the same bit location as {@code mb}.\n+     * All other remaining bits of the expanded value are set to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of expanding the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * expand(0x0000CABAB, 0xFF00FFF0) == 0xCA00BAB0\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects the first five\n+     * hexadecimal digits of {@code 0x0000CABAB}. The selected digits occur\n+     * in the resulting expanded value in order at positions 1, 2, 3, 6, and 7.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code expand}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Logically shift right the bit at position 0\n+     * expand(x, 1 << n) == (x & 1) << n\n+     *\n+     * \/\/ Logically shift right\n+     * expand(x, -1 << n) == x << n\n+     *\n+     * \/\/ Expanding all bits returns the mask\n+     * expand(-1, m) == m\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * expand(x, m) == expand(x, m) & m\n+     *\n+     * \/\/ Compressing then expanding with the same mask\n+     * expand(compress(x, m), m) == x & m\n+     * }\n+     * <p>\n+     * The select operation for determining the position of the one-bit with\n+     * index {@code n} in a {@code int} value can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * int select(int i, int n) {\n+     *     \/\/ the one-bit in i (the mask) with index n\n+     *     int nthBit = Integer.expand(1 << n, i);\n+     *     \/\/ the bit position of the one-bit with index n\n+     *     return Integer.numberOfTrailingZeros(nthBit);\n+     * }\n+     *\n+     * \/\/ The one-bit with index 0 is at bit position 1\n+     * select(0b10101010_10101010, 0) == 1\n+     * \/\/ The one-bit with index 3 is at bit position 7\n+     * select(0b10101010_10101010, 3) == 7\n+     * }\n+     *\n+     * @param i the value whose bits are to be expanded\n+     * @param mask the bit mask\n+     * @return the expanded value\n+     * @see #compress\n+     * @since 19\n+     *\/\n+    static int expand(int i, int mask) {\n+        \/\/ Save original mask\n+        int originalMask = mask;\n+        \/\/ Count 0's to right\n+        int maskCount = ~mask << 1;\n+        int maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove1 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove2 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove3 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove4 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove5 = maskPrefix & mask;\n+\n+        int t = i << (1 << 4);\n+        i = (i & ~maskMove5) | (t & maskMove5);\n+        t = i << (1 << 3);\n+        i = (i & ~maskMove4) | (t & maskMove4);\n+        t = i << (1 << 2);\n+        i = (i & ~maskMove3) | (t & maskMove3);\n+        t = i << (1 << 1);\n+        i = (i & ~maskMove2) | (t & maskMove2);\n+        t = i << (1 << 0);\n+        i = (i & ~maskMove1) | (t & maskMove1);\n+\n+        \/\/ Clear irrelevant bits\n+        return i & originalMask;\n+    }\n+\n+    \/**\n+     * Returns the value obtained by expanding the bits of the\n+     * specified {@code long} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the next contiguous bit value\n+     * of {@code i} starting at the least significant bit is assigned\n+     * to the expanded value at the same bit location as {@code mb}.\n+     * All other remaining bits of the expanded value are set to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of expanding the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * expand(0x0000CABAB, 0xFF00FFF0) == 0xCA00BAB0\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects the first five\n+     * hexadecimal digits of {@code 0x0000CABAB}. The selected digits occur\n+     * in the resulting expanded value in order at positions 1, 2, 3, 6, and 7.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code expand}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Logically shift right the bit at position 0\n+     * expand(x, 1 << n) == (x & 1) << n\n+     *\n+     * \/\/ Logically shift right\n+     * expand(x, -1 << n) == x << n\n+     *\n+     * \/\/ Expanding all bits returns the mask\n+     * expand(-1, m) == m\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * expand(x, m) == expand(x, m) & m\n+     *\n+     * \/\/ Compressing then expanding with the same mask\n+     * expand(compress(x, m), m) == x & m\n+     * }\n+     * <p>\n+     * The select operation for determining the position of the one-bit with\n+     * index {@code n} in a {@code long} value can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * long select(long i, long n) {\n+     *     \/\/ the one-bit in i (the mask) with index n\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code expand}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Logically shift right the bit at position 0\n+     * expand(x, 1 << n) == (x & 1) << n\n+     *\n+     * \/\/ Logically shift right\n+     * expand(x, -1 << n) == x << n\n+     *\n+     * \/\/ Expanding all bits returns the mask\n+     * expand(-1, m) == m\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * expand(x, m) == expand(x, m) & m\n+     *\n+     * \/\/ Compressing then expanding with the same mask\n+     * expand(compress(x, m), m) == x & m\n+     * }\n+     * <p>\n+     * The select operation for determining the position of the one-bit with\n+     * index {@code n} in a {@code long} value can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * long select(long i, long n) {\n+     *     \/\/ the one-bit in i (the mask) with index n\n+     *     long nthBit = Long.expand(1 << n, i);\n+     *     \/\/ the bit position of the one-bit with index n\n+     *     return Long.numberOfTrailingZeros(nthBit);\n+     * }\n+     *\n+     * \/\/ The one-bit with index 0 is at bit position 1\n+     * select(0b10101010_10101010, 0) == 1\n+     * \/\/ The one-bit with index 3 is at bit position 7\n+     * select(0b10101010_10101010, 3) == 7\n+     * }\n+     *\n+     * @param i the value whose bits are to be expanded\n+     * @param mask the bit mask\n+     * @return the expanded value\n+     * @see #compress\n+     * @since 19\n+     *\/\n+    static long expand(long i, long mask) {\n+        \/\/ Save original mask\n+        long originalMask = mask;\n+        \/\/ Count 0's to right\n+        long maskCount = ~mask << 1;\n+        long maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove1 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove2 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove3 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove4 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove5 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove5) | (maskMove5 >>> (1 << 4));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove6 = maskPrefix & mask;\n+        long t = i << (1 << 5);\n+        i = (i & ~maskMove6) | (t & maskMove6);\n+        t = i << (1 << 4);\n+        i = (i & ~maskMove5) | (t & maskMove5);\n+        t = i << (1 << 3);\n+        i = (i & ~maskMove4) | (t & maskMove4);\n+        t = i << (1 << 2);\n+        i = (i & ~maskMove3) | (t & maskMove3);\n+        t = i << (1 << 1);\n+        i = (i & ~maskMove2) | (t & maskMove2);\n+        t = i << (1 << 0);\n+        i = (i & ~maskMove1) | (t & maskMove1);\n+\n+        \/\/ Clear irrelevant bits\n+        return i & originalMask;\n+    }\n+\n+    @ForceInline\n+    private static int parallelSuffix(int maskCount) {\n+        int maskPrefix = maskCount ^ (maskCount << 1);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+        return maskPrefix;\n+    }\n+\n+    @ForceInline\n+    private static long parallelSuffix(long maskCount) {\n+        long maskPrefix = maskCount ^ (maskCount << 1);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+        return maskPrefix;\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/CompressExpand.java","additions":502,"deletions":0,"binary":false,"changes":502,"status":"added"},{"patch":"@@ -516,61 +516,0 @@\n-    \/* Implementation note: The implementation is based on Compress or Generalized Extract mentioned in\n-     * Henry S. Warren, Jr's Hackers Delight, Addison Wesley, 2002.\n-     *\/\n-    static int compressBits(int a, int mask) {\n-        a = a & mask; \/\/ Clear irrelevant bits\n-        int maskCount = ~mask << 1; \/\/ Count 0's to right\n-        int iters = 5;\n-\n-        for (int j = 0; j < iters; j++) {\n-            \/\/ Parallel prefix\n-            \/\/ maskPrefix identifies bits of the mask that have odd number of 0's to the right\n-            int maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            \/\/ Bits to move\n-            int maskMove = maskPrefix & mask;\n-            \/\/ Compress mask\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            \/\/ Bits of a to be moved\n-            int t = a & maskMove;\n-            \/\/ Compress a\n-            a = (a ^ t) | (t >>> (1 << j));\n-            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static int expandBits(int a, int mask) {\n-        int originalMask = mask; \/\/ Save original mask\n-        int maskCount = ~mask << 1; \/\/ Count 0's to right\n-        int[] array = new int[5];\n-        int iters = 5;\n-\n-        for (int j = 0; j < iters; j++) {\n-            \/\/ Parallel prefix\n-            int maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            \/\/ Bits to move\n-            int maskMove = maskPrefix & mask;\n-            array[j] = maskMove;\n-            \/\/ Compress mask\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            int maskMove = array[j];\n-            int t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-\n-        \/\/ Clear irrelevant bits\n-        return (a & originalMask);\n-    }\n@@ -939,1 +878,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> compressBits(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n@@ -941,1 +880,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> expandBits(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":2,"deletions":63,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -516,63 +516,0 @@\n-    \/* Implementation note: The implementation is based on Compress or Generalized Extract mentioned in\n-     * Henry S. Warren, Jr's Hackers Delight, Addison Wesley, 2002.\n-     *\/\n-    static long compressBits(long a, long mask) {\n-        a = a & mask; \/\/ Clear irrelevant bits\n-        long maskCount = ~mask << 1; \/\/ Count 0's to right\n-        int iters = 6;\n-\n-        for (int j = 0; j < iters; j++) {\n-            \/\/ Parallel prefix\n-            \/\/ maskPrefix identifies bits of the mask that have odd number of 0's to the right\n-            long maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            \/\/ Bits to move\n-            long maskMove = maskPrefix & mask;\n-            \/\/ Compress mask\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            \/\/ Bits of a to be moved\n-            long t = a & maskMove;\n-            \/\/ Compress a\n-            a = (a ^ t) | (t >>> (1 << j));\n-            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static long expandBits(long a, long mask) {\n-        long originalMask = mask; \/\/ Save original mask\n-        long maskCount = ~mask << 1; \/\/ Count 0's to right\n-        long[] array = new long[6];\n-        int iters = 6;\n-\n-        for (int j = 0; j < iters; j++) {\n-            \/\/ Parallel prefix\n-            long maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            \/\/ Bits to move\n-            long maskMove = maskPrefix & mask;\n-            array[j] = maskMove;\n-            \/\/ Compress mask\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            long maskMove = array[j];\n-            long t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-\n-        \/\/ Clear irrelevant bits\n-        return (a & originalMask);\n-    }\n@@ -899,1 +836,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> compressBits(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n@@ -901,1 +838,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> expandBits(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":2,"deletions":65,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -529,78 +529,0 @@\n-#if[intOrLong]\n-    \/* Implementation note: The implementation is based on Compress or Generalized Extract mentioned in\n-     * Henry S. Warren, Jr's Hackers Delight, Addison Wesley, 2002.\n-     *\/\n-    static $type$ compressBits($type$ a, $type$ mask) {\n-        a = a & mask; \/\/ Clear irrelevant bits\n-        $type$ maskCount = ~mask << 1; \/\/ Count 0's to right\n-#if[int]\n-        int iters = 5;\n-#else[int]\n-        int iters = 6;\n-#end[int]\n-\n-        for (int j = 0; j < iters; j++) {\n-            \/\/ Parallel prefix\n-            \/\/ maskPrefix identifies bits of the mask that have odd number of 0's to the right\n-            $type$ maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-#if[long]\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-#end[long]\n-            \/\/ Bits to move\n-            $type$ maskMove = maskPrefix & mask;\n-            \/\/ Compress mask\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            \/\/ Bits of a to be moved\n-            $type$ t = a & maskMove;\n-            \/\/ Compress a\n-            a = (a ^ t) | (t >>> (1 << j));\n-            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static $type$ expandBits($type$ a, $type$ mask) {\n-        $type$ originalMask = mask; \/\/ Save original mask\n-        $type$ maskCount = ~mask << 1; \/\/ Count 0's to right\n-#if[int]\n-        $type$[] array = new $type$[5];\n-        int iters = 5;\n-#else[int]\n-        $type$[] array = new $type$[6];\n-        int iters = 6;\n-#end[int]\n-\n-        for (int j = 0; j < iters; j++) {\n-            \/\/ Parallel prefix\n-            $type$ maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-#if[long]\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-#end[long]\n-            \/\/ Bits to move\n-            $type$ maskMove = maskPrefix & mask;\n-            array[j] = maskMove;\n-            \/\/ Compress mask\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            $type$ maskMove = array[j];\n-            $type$ t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-\n-        \/\/ Clear irrelevant bits\n-        return (a & originalMask);\n-    }\n-#end[intOrLong]\n@@ -1056,1 +978,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> compressBits(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n@@ -1058,1 +980,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> expandBits(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":2,"deletions":80,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1185,45 +1186,0 @@\n-    static int COMPRESSBITS_scalar(int a, int b) {\n-        a = a & b;\n-        int maskCount = ~b << 1;\n-        int iters = 5;\n-\n-        for (int i = 0; i < iters; i++) {\n-            int maskPrefix = maskCount  ^ (maskCount << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            int maskMove = maskPrefix & b;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n-            int t = a & maskMove;\n-            a = (a ^ t) | (t >>> (1 << i));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static int EXPANDBITS_scalar(int a, int b) {\n-        int originalMask = b;\n-        int maskCount = ~b << 1;\n-        int[] array = new int[5];\n-        int iters = 5;\n-\n-        for (int j = 0; j < iters; j++) {\n-            int maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            int maskMove = maskPrefix & b;\n-            array[j] = maskMove;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            int maskMove = array[j];\n-            int t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-        return (a & originalMask);\n-    }\n@@ -1961,1 +1917,1 @@\n-        return (int)(COMPRESSBITS_scalar(a,b));\n+        return (int)(CompressExpandTest.compress(a,b));\n@@ -2005,1 +1961,1 @@\n-        return (int)(EXPANDBITS_scalar(a,b));\n+        return (int)(CompressExpandTest.expand(a,b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":3,"deletions":47,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1185,45 +1186,0 @@\n-    static int COMPRESSBITS_scalar(int a, int b) {\n-        a = a & b;\n-        int maskCount = ~b << 1;\n-        int iters = 5;\n-\n-        for (int i = 0; i < iters; i++) {\n-            int maskPrefix = maskCount  ^ (maskCount << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            int maskMove = maskPrefix & b;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n-            int t = a & maskMove;\n-            a = (a ^ t) | (t >>> (1 << i));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static int EXPANDBITS_scalar(int a, int b) {\n-        int originalMask = b;\n-        int maskCount = ~b << 1;\n-        int[] array = new int[5];\n-        int iters = 5;\n-\n-        for (int j = 0; j < iters; j++) {\n-            int maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            int maskMove = maskPrefix & b;\n-            array[j] = maskMove;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            int maskMove = array[j];\n-            int t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-        return (a & originalMask);\n-    }\n@@ -1961,1 +1917,1 @@\n-        return (int)(COMPRESSBITS_scalar(a,b));\n+        return (int)(CompressExpandTest.compress(a,b));\n@@ -2005,1 +1961,1 @@\n-        return (int)(EXPANDBITS_scalar(a,b));\n+        return (int)(CompressExpandTest.expand(a,b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":3,"deletions":47,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1185,45 +1186,0 @@\n-    static int COMPRESSBITS_scalar(int a, int b) {\n-        a = a & b;\n-        int maskCount = ~b << 1;\n-        int iters = 5;\n-\n-        for (int i = 0; i < iters; i++) {\n-            int maskPrefix = maskCount  ^ (maskCount << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            int maskMove = maskPrefix & b;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n-            int t = a & maskMove;\n-            a = (a ^ t) | (t >>> (1 << i));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static int EXPANDBITS_scalar(int a, int b) {\n-        int originalMask = b;\n-        int maskCount = ~b << 1;\n-        int[] array = new int[5];\n-        int iters = 5;\n-\n-        for (int j = 0; j < iters; j++) {\n-            int maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            int maskMove = maskPrefix & b;\n-            array[j] = maskMove;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            int maskMove = array[j];\n-            int t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-        return (a & originalMask);\n-    }\n@@ -1961,1 +1917,1 @@\n-        return (int)(COMPRESSBITS_scalar(a,b));\n+        return (int)(CompressExpandTest.compress(a,b));\n@@ -2005,1 +1961,1 @@\n-        return (int)(EXPANDBITS_scalar(a,b));\n+        return (int)(CompressExpandTest.expand(a,b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":3,"deletions":47,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1185,45 +1186,0 @@\n-    static int COMPRESSBITS_scalar(int a, int b) {\n-        a = a & b;\n-        int maskCount = ~b << 1;\n-        int iters = 5;\n-\n-        for (int i = 0; i < iters; i++) {\n-            int maskPrefix = maskCount  ^ (maskCount << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            int maskMove = maskPrefix & b;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n-            int t = a & maskMove;\n-            a = (a ^ t) | (t >>> (1 << i));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static int EXPANDBITS_scalar(int a, int b) {\n-        int originalMask = b;\n-        int maskCount = ~b << 1;\n-        int[] array = new int[5];\n-        int iters = 5;\n-\n-        for (int j = 0; j < iters; j++) {\n-            int maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            int maskMove = maskPrefix & b;\n-            array[j] = maskMove;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            int maskMove = array[j];\n-            int t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-        return (a & originalMask);\n-    }\n@@ -1961,1 +1917,1 @@\n-        return (int)(COMPRESSBITS_scalar(a,b));\n+        return (int)(CompressExpandTest.compress(a,b));\n@@ -2005,1 +1961,1 @@\n-        return (int)(EXPANDBITS_scalar(a,b));\n+        return (int)(CompressExpandTest.expand(a,b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":3,"deletions":47,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1190,45 +1191,0 @@\n-    static int COMPRESSBITS_scalar(int a, int b) {\n-        a = a & b;\n-        int maskCount = ~b << 1;\n-        int iters = 5;\n-\n-        for (int i = 0; i < iters; i++) {\n-            int maskPrefix = maskCount  ^ (maskCount << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            int maskMove = maskPrefix & b;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n-            int t = a & maskMove;\n-            a = (a ^ t) | (t >>> (1 << i));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static int EXPANDBITS_scalar(int a, int b) {\n-        int originalMask = b;\n-        int maskCount = ~b << 1;\n-        int[] array = new int[5];\n-        int iters = 5;\n-\n-        for (int j = 0; j < iters; j++) {\n-            int maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            int maskMove = maskPrefix & b;\n-            array[j] = maskMove;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            int maskMove = array[j];\n-            int t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-        return (a & originalMask);\n-    }\n@@ -1966,1 +1922,1 @@\n-        return (int)(COMPRESSBITS_scalar(a,b));\n+        return (int)(CompressExpandTest.compress(a,b));\n@@ -2010,1 +1966,1 @@\n-        return (int)(EXPANDBITS_scalar(a,b));\n+        return (int)(CompressExpandTest.expand(a,b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":3,"deletions":47,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1207,47 +1208,0 @@\n-    static long COMPRESSBITS_scalar(long a, long b) {\n-        a = a & b;\n-        long maskCount = ~b << 1;\n-        int iters = 6;\n-\n-        for (int i = 0; i < iters; i++) {\n-            long maskPrefix = maskCount  ^ (maskCount << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            long maskMove = maskPrefix & b;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n-            long t = a & maskMove;\n-            a = (a ^ t) | (t >>> (1 << i));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static long EXPANDBITS_scalar(long a, long b) {\n-        long originalMask = b;\n-        long maskCount = ~b << 1;\n-        long[] array = new long[6];\n-        int iters = 6;\n-\n-        for (int j = 0; j < iters; j++) {\n-            long maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            long maskMove = maskPrefix & b;\n-            array[j] = maskMove;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            long maskMove = array[j];\n-            long t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-        return (a & originalMask);\n-    }\n@@ -1985,1 +1939,1 @@\n-        return (long)(COMPRESSBITS_scalar(a,b));\n+        return (long)(CompressExpandTest.compress(a,b));\n@@ -2029,1 +1983,1 @@\n-        return (long)(EXPANDBITS_scalar(a,b));\n+        return (long)(CompressExpandTest.expand(a,b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":3,"deletions":49,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1207,47 +1208,0 @@\n-    static long COMPRESSBITS_scalar(long a, long b) {\n-        a = a & b;\n-        long maskCount = ~b << 1;\n-        int iters = 6;\n-\n-        for (int i = 0; i < iters; i++) {\n-            long maskPrefix = maskCount  ^ (maskCount << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            long maskMove = maskPrefix & b;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n-            long t = a & maskMove;\n-            a = (a ^ t) | (t >>> (1 << i));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static long EXPANDBITS_scalar(long a, long b) {\n-        long originalMask = b;\n-        long maskCount = ~b << 1;\n-        long[] array = new long[6];\n-        int iters = 6;\n-\n-        for (int j = 0; j < iters; j++) {\n-            long maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            long maskMove = maskPrefix & b;\n-            array[j] = maskMove;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            long maskMove = array[j];\n-            long t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-        return (a & originalMask);\n-    }\n@@ -1985,1 +1939,1 @@\n-        return (long)(COMPRESSBITS_scalar(a,b));\n+        return (long)(CompressExpandTest.compress(a,b));\n@@ -2029,1 +1983,1 @@\n-        return (long)(EXPANDBITS_scalar(a,b));\n+        return (long)(CompressExpandTest.expand(a,b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":3,"deletions":49,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1207,47 +1208,0 @@\n-    static long COMPRESSBITS_scalar(long a, long b) {\n-        a = a & b;\n-        long maskCount = ~b << 1;\n-        int iters = 6;\n-\n-        for (int i = 0; i < iters; i++) {\n-            long maskPrefix = maskCount  ^ (maskCount << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            long maskMove = maskPrefix & b;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n-            long t = a & maskMove;\n-            a = (a ^ t) | (t >>> (1 << i));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static long EXPANDBITS_scalar(long a, long b) {\n-        long originalMask = b;\n-        long maskCount = ~b << 1;\n-        long[] array = new long[6];\n-        int iters = 6;\n-\n-        for (int j = 0; j < iters; j++) {\n-            long maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            long maskMove = maskPrefix & b;\n-            array[j] = maskMove;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            long maskMove = array[j];\n-            long t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-        return (a & originalMask);\n-    }\n@@ -1985,1 +1939,1 @@\n-        return (long)(COMPRESSBITS_scalar(a,b));\n+        return (long)(CompressExpandTest.compress(a,b));\n@@ -2029,1 +1983,1 @@\n-        return (long)(EXPANDBITS_scalar(a,b));\n+        return (long)(CompressExpandTest.expand(a,b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":3,"deletions":49,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1207,47 +1208,0 @@\n-    static long COMPRESSBITS_scalar(long a, long b) {\n-        a = a & b;\n-        long maskCount = ~b << 1;\n-        int iters = 6;\n-\n-        for (int i = 0; i < iters; i++) {\n-            long maskPrefix = maskCount  ^ (maskCount << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            long maskMove = maskPrefix & b;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n-            long t = a & maskMove;\n-            a = (a ^ t) | (t >>> (1 << i));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static long EXPANDBITS_scalar(long a, long b) {\n-        long originalMask = b;\n-        long maskCount = ~b << 1;\n-        long[] array = new long[6];\n-        int iters = 6;\n-\n-        for (int j = 0; j < iters; j++) {\n-            long maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            long maskMove = maskPrefix & b;\n-            array[j] = maskMove;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            long maskMove = array[j];\n-            long t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-        return (a & originalMask);\n-    }\n@@ -1985,1 +1939,1 @@\n-        return (long)(COMPRESSBITS_scalar(a,b));\n+        return (long)(CompressExpandTest.compress(a,b));\n@@ -2029,1 +1983,1 @@\n-        return (long)(EXPANDBITS_scalar(a,b));\n+        return (long)(CompressExpandTest.expand(a,b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":3,"deletions":49,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1212,47 +1213,0 @@\n-    static long COMPRESSBITS_scalar(long a, long b) {\n-        a = a & b;\n-        long maskCount = ~b << 1;\n-        int iters = 6;\n-\n-        for (int i = 0; i < iters; i++) {\n-            long maskPrefix = maskCount  ^ (maskCount << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            long maskMove = maskPrefix & b;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n-            long t = a & maskMove;\n-            a = (a ^ t) | (t >>> (1 << i));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static long EXPANDBITS_scalar(long a, long b) {\n-        long originalMask = b;\n-        long maskCount = ~b << 1;\n-        long[] array = new long[6];\n-        int iters = 6;\n-\n-        for (int j = 0; j < iters; j++) {\n-            long maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-            long maskMove = maskPrefix & b;\n-            array[j] = maskMove;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            long maskMove = array[j];\n-            long t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-        return (a & originalMask);\n-    }\n@@ -1990,1 +1944,1 @@\n-        return (long)(COMPRESSBITS_scalar(a,b));\n+        return (long)(CompressExpandTest.compress(a,b));\n@@ -2034,1 +1988,1 @@\n-        return (long)(EXPANDBITS_scalar(a,b));\n+        return (long)(CompressExpandTest.expand(a,b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":3,"deletions":49,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compress;\n+\n+public class CompressExpandTest {\n+    public static int compress(int i, int mask) {\n+        i = i & mask;\n+        int maskCount = ~mask << 1;\n+\n+        for (int j = 0; j < 5; j++) {\n+            int maskPrefix = parallelSuffix(maskCount);\n+            int maskMove = maskPrefix & mask;\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            int t = i & maskMove;\n+            i = (i ^ t) | (t >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+    public static long compress(long i, long mask) {\n+        i = i & mask;\n+        long maskCount = ~mask << 1;\n+\n+        for (int j = 0; j < 6; j++) {\n+            long maskPrefix = parallelSuffix(maskCount);\n+            long maskMove = maskPrefix & mask;\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            long t = i & maskMove;\n+            i = (i ^ t) | (t >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+    public static int expand(int i, int mask) {\n+        int originalMask = mask;\n+        int maskCount = ~mask << 1;\n+        int maskPrefix = parallelSuffix(maskCount);\n+        int maskMove1 = maskPrefix & mask;\n+        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        int maskMove2 = maskPrefix & mask;\n+        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        int maskMove3 = maskPrefix & mask;\n+        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        int maskMove4 = maskPrefix & mask;\n+        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        int maskMove5 = maskPrefix & mask;\n+\n+        int t = i << (1 << 4);\n+        i = (i & ~maskMove5) | (t & maskMove5);\n+        t = i << (1 << 3);\n+        i = (i & ~maskMove4) | (t & maskMove4);\n+        t = i << (1 << 2);\n+        i = (i & ~maskMove3) | (t & maskMove3);\n+        t = i << (1 << 1);\n+        i = (i & ~maskMove2) | (t & maskMove2);\n+        t = i << (1 << 0);\n+        i = (i & ~maskMove1) | (t & maskMove1);\n+\n+        return i & originalMask;\n+    }\n+\n+    public static long expand(long i, long mask) {\n+        long originalMask = mask;\n+        long maskCount = ~mask << 1;\n+        long maskPrefix = parallelSuffix(maskCount);\n+        long maskMove1 = maskPrefix & mask;\n+        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        long maskMove2 = maskPrefix & mask;\n+        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        long maskMove3 = maskPrefix & mask;\n+        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        long maskMove4 = maskPrefix & mask;\n+        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        long maskMove5 = maskPrefix & mask;\n+        mask = (mask ^ maskMove5) | (maskMove5 >>> (1 << 4));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        long maskMove6 = maskPrefix & mask;\n+        long t = i << (1 << 5);\n+        i = (i & ~maskMove6) | (t & maskMove6);\n+        t = i << (1 << 4);\n+        i = (i & ~maskMove5) | (t & maskMove5);\n+        t = i << (1 << 3);\n+        i = (i & ~maskMove4) | (t & maskMove4);\n+        t = i << (1 << 2);\n+        i = (i & ~maskMove3) | (t & maskMove3);\n+        t = i << (1 << 1);\n+        i = (i & ~maskMove2) | (t & maskMove2);\n+        t = i << (1 << 0);\n+        i = (i & ~maskMove1) | (t & maskMove1);\n+\n+        return i & originalMask;\n+    }\n+\n+    private static int parallelSuffix(int maskCount) {\n+        int maskPrefix = maskCount ^ (maskCount << 1);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+        return maskPrefix;\n+    }\n+\n+    private static long parallelSuffix(long maskCount) {\n+        long maskPrefix = maskCount ^ (maskCount << 1);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+        return maskPrefix;\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/compress\/CompressExpandTest.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -406,2 +406,2 @@\n-gen_binary_alu_op \"COMPRESS_BITS\" \"COMPRESSBITS_scalar(a,b)\" \"intOrLong\"\n-gen_binary_alu_op \"EXPAND_BITS\" \"EXPANDBITS_scalar(a,b)\" \"intOrLong\"\n+gen_binary_alu_op \"COMPRESS_BITS\" \"CompressExpandTest.compress(a,b)\" \"intOrLong\"\n+gen_binary_alu_op \"EXPAND_BITS\" \"CompressExpandTest.expand(a,b)\" \"intOrLong\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import compress.CompressExpandTest;\n@@ -56,0 +57,1 @@\n+import compress.CompressExpandTest;\n@@ -1503,62 +1505,0 @@\n-#if[intOrLong]\n-    static $type$ COMPRESSBITS_scalar($type$ a, $type$ b) {\n-        a = a & b;\n-        $type$ maskCount = ~b << 1;\n-#if[int]\n-        int iters = 5;\n-#else[int]\n-        int iters = 6;\n-#end[int]\n-\n-        for (int i = 0; i < iters; i++) {\n-            $type$ maskPrefix = maskCount  ^ (maskCount << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-#if[long]\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-#end[long]\n-            $type$ maskMove = maskPrefix & b;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n-            $type$ t = a & maskMove;\n-            a = (a ^ t) | (t >>> (1 << i));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return a;\n-    }\n-\n-    static $type$ EXPANDBITS_scalar($type$ a, $type$ b) {\n-        $type$ originalMask = b;\n-        $type$ maskCount = ~b << 1;\n-#if[int]\n-        $type$[] array = new $type$[5];\n-        int iters = 5;\n-#else[int]\n-        $type$[] array = new $type$[6];\n-        int iters = 6;\n-#end[int]\n-\n-        for (int j = 0; j < iters; j++) {\n-            $type$ maskPrefix = maskCount  ^ (maskCount  << 1);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-#if[long]\n-            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-#end[long]\n-            $type$ maskMove = maskPrefix & b;\n-            array[j] = maskMove;\n-            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-\n-        for (int j = iters-1; j >= 0; j--) {\n-            $type$ maskMove = array[j];\n-            $type$ t = a << (1 << j);\n-            a = (a & ~maskMove) | (t & maskMove);\n-        }\n-        return (a & originalMask);\n-    }\n-#end[intOrLong]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":2,"deletions":62,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -477,1 +477,1 @@\n-                rs[i] = (int)(COMPRESSBITS_scalar(a,b));\n+                rs[i] = (int)(CompressExpandTest.compress(a,b));\n@@ -498,1 +498,1 @@\n-                    rs[i] = (int)(COMPRESSBITS_scalar(a,b));\n+                    rs[i] = (int)(CompressExpandTest.compress(a,b));\n@@ -519,1 +519,1 @@\n-                rs[i] = (int)(EXPANDBITS_scalar(a,b));\n+                rs[i] = (int)(CompressExpandTest.expand(a,b));\n@@ -540,1 +540,1 @@\n-                    rs[i] = (int)(EXPANDBITS_scalar(a,b));\n+                    rs[i] = (int)(CompressExpandTest.expand(a,b));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -477,1 +477,1 @@\n-                rs[i] = (long)(COMPRESSBITS_scalar(a,b));\n+                rs[i] = (long)(CompressExpandTest.compress(a,b));\n@@ -498,1 +498,1 @@\n-                    rs[i] = (long)(COMPRESSBITS_scalar(a,b));\n+                    rs[i] = (long)(CompressExpandTest.compress(a,b));\n@@ -519,1 +519,1 @@\n-                rs[i] = (long)(EXPANDBITS_scalar(a,b));\n+                rs[i] = (long)(CompressExpandTest.expand(a,b));\n@@ -540,1 +540,1 @@\n-                    rs[i] = (long)(EXPANDBITS_scalar(a,b));\n+                    rs[i] = (long)(CompressExpandTest.expand(a,b));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}