{"files":[{"patch":"@@ -79,0 +79,2 @@\n+macro(CompressBits)\n+macro(ExpandBits)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -392,0 +392,16 @@\n+\/\/------------------------------CompressBitsNode-------------------------------\n+\/\/ CompressBits placeholder node\n+class CompressBitsNode : public Node {\n+public:\n+  CompressBitsNode(Node *in1, Node *in2) : Node(0,in1,in2) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------ExpandBitsNode---------------------------------\n+\/\/ ExpandBits placeholder node\n+class ExpandBitsNode : public Node {\n+public:\n+  ExpandBitsNode(Node *in1, Node *in2) : Node(0,in1,in2) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -164,0 +164,6 @@\n+  case Op_CompressBits:\n+    \/\/ Not implemented. Returning 0 temporarily\n+    return 0;\n+  case Op_ExpandBits:\n+    \/\/ Not implemented. Returning 0 temporarily\n+    return 0;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-     switch (bt) {\n+      switch (bt) {\n@@ -493,1 +493,1 @@\n-     switch (bt) {\n+      switch (bt) {\n@@ -503,1 +503,1 @@\n-     switch (bt) {\n+      switch (bt) {\n@@ -513,1 +513,1 @@\n-     switch (bt) {\n+      switch (bt) {\n@@ -523,1 +523,1 @@\n-     switch (bt) {\n+      switch (bt) {\n@@ -532,0 +532,16 @@\n+    case VECTOR_OP_COMPRESS_BITS: {\n+      switch (bt) {\n+        case T_INT:\n+        case T_LONG: return Op_CompressBits;\n+        default: fatal(\"COMPRESS_BITS: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_EXPAND_BITS: {\n+      switch (bt) {\n+        case T_INT:\n+        case T_LONG: return Op_ExpandBits;\n+        default: fatal(\"EXPAND_BITS: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+    VECTOR_OP_COMPRESS_BITS = 33,\n+    VECTOR_OP_EXPAND_BITS = 34,\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,4 @@\n+    \/\/ Compress and Expand Bits operation\n+    public static final int VECTOR_OP_COMPRESS_BITS = 33;\n+    public static final int VECTOR_OP_EXPAND_BITS = 34;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -516,0 +516,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,502 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.vector;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+class CompressExpand {\n+\n+    \/**\n+     * Returns the value obtained by compressing the bits of the\n+     * specified {@code int} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the bit value of {@code i} at\n+     * the same bit location as {@code mb} is assigned to the compressed\n+     * value contiguously starting from the least significant bit location.\n+     * All the upper remaining bits of the compressed value are set\n+     * to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of compressing the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Compressing drink to food\n+     * compress(0xCAFEBABE, 0xFF00FFF0) == 0xCABAB\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects hexadecimal digits\n+     * at positions 1, 2, 3, 6 and 7 of {@code 0xCAFEBABE}. The selected digits\n+     * occur in the resulting compressed value contiguously from digit position\n+     * 0 in the same order.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code compress}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Returns 1 if the bit at position n is one\n+     * compress(x, 1 << n) == (x >> n & 1)\n+     *\n+     * \/\/ Logical shift right\n+     * compress(x, -1 << n) == x >>> n\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * compress(x, m) == compress(x & m, m)\n+     *\n+     * \/\/ Compressing a value by itself\n+     * compress(m, m) == (m == -1 || m == 0) ? m : (1 << bitCount(m)) - 1\n+     *\n+     * \/\/ Expanding then compressing with the same mask\n+     * compress(expand(x, m), m) == x & compress(m, m)\n+     * }\n+     * <p>\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * int compressLeft(int i, int mask) {\n+     *     \/\/ This implementation follows the description in Hacker's Delight which\n+     *     \/\/ is informative. A more optimal implementation is:\n+     *     \/\/   Integer.compress(i, mask) << -Integer.bitCount(mask)\n+     *     return Integer.reverse(\n+     *         Integer.compress(Integer.reverse(i), Integer.reverse(mask)));\n+     * }\n+     *\n+     * int sag(int i, int mask) {\n+     *     return compressLeft(i, mask) | Integer.compress(i, ~mask);\n+     * }\n+     *\n+     * \/\/ Separate the sheep from the goats\n+     * sag(0xCAFEBABE, 0xFF00FFF0) == 0xCABABFEE\n+     * }\n+     *\n+     * @param i the value whose bits are to be compressed\n+     * @param mask the bit mask\n+     * @return the compressed value\n+     * @see #expand\n+     * @since 19\n+     *\/\n+    static int compress(int i, int mask) {\n+        \/\/ See Hacker's Delight (2nd ed) section 7.4 Compress, or Generalized Extract\n+\n+        i = i & mask; \/\/ Clear irrelevant bits\n+        int maskCount = ~mask << 1; \/\/ Count 0's to right\n+\n+        for (int j = 0; j < 5; j++) {\n+            \/\/ Parallel prefix\n+            \/\/ Mask prefix identifies bits of the mask that have an odd number of 0's to the right\n+            int maskPrefix = parallelSuffix(maskCount);\n+            \/\/ Bits to move\n+            int maskMove = maskPrefix & mask;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Bits of i to be moved\n+            int t = i & maskMove;\n+            \/\/ Compress i\n+            i = (i ^ t) | (t >>> (1 << j));\n+            \/\/ Adjust the mask count by identifying bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+    \/**\n+     * Returns the value obtained by compressing the bits of the\n+     * specified {@code long} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the bit value of {@code i} at\n+     * the same bit location as {@code mb} is assigned to the compressed\n+     * value contiguously starting from the least significant bit location.\n+     * All the upper remaining bits of the compressed value are set\n+     * to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of compressing the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Compressing drink to food\n+     * compress(0xCAFEBABE, 0xFF00FFF0) == 0xCABAB\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects hexadecimal digits\n+     * at positions 1, 2, 3, 6 and 7 of {@code 0xCAFEBABE}. The selected digits\n+     * occur in the resulting compressed value contiguously from digit position\n+     * 0 in the same order.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code compress}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Returns 1 if the bit at position n is one\n+     * compress(x, 1 << n) == (x >> n & 1)\n+     *\n+     * \/\/ Logical shift right\n+     * compress(x, -1 << n) == x >>> n\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * compress(x, m) == compress(x & m, m)\n+     *\n+     * \/\/ Compressing a value by itself\n+     * compress(m, m) == (m == -1 || m == 0) ? m : (1 << bitCount(m)) - 1\n+     *\n+     * \/\/ Expanding then compressing with the same mask\n+     * compress(expand(x, m), m) == x & compress(m, m)\n+     * }\n+     * <p>\n+     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n+     * can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * long compressLeft(long i, long mask) {\n+     *     \/\/ This implementation follows the description in Hacker's Delight which\n+     *     \/\/ is informative. A more optimal implementation is:\n+     *     \/\/   Long.compress(i, mask) << -Long.bitCount(mask)\n+     *     return Long.reverse(\n+     *         Long.compress(Long.reverse(i), Long.reverse(mask)));\n+     * }\n+     *\n+     * long sag(long i, long mask) {\n+     *     return compressLeft(i, mask) | Long.compress(i, ~mask);\n+     * }\n+     *\n+     * \/\/ Separate the sheep from the goats\n+     * sag(0xCAFEBABE, 0xFF00FFF0) == 0xCABABFEE\n+     * }\n+     *\n+     * @param i the value whose bits are to be compressed\n+     * @param mask the bit mask\n+     * @return the compressed value\n+     * @see #expand\n+     * @since 19\n+     *\/\n+    static long compress(long i, long mask) {\n+        \/\/ See Hacker's Delight (2nd ed) section 7.4 Compress, or Generalized Extract\n+\n+        i = i & mask; \/\/ Clear irrelevant bits\n+        long maskCount = ~mask << 1; \/\/ Count 0's to right\n+\n+        for (int j = 0; j < 6; j++) {\n+            \/\/ Parallel prefix\n+            \/\/ Mask prefix identifies bits of the mask that have an odd number of 0's to the right\n+            long maskPrefix = parallelSuffix(maskCount);\n+            \/\/ Bits to move\n+            long maskMove = maskPrefix & mask;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Bits of i to be moved\n+            long t = i & maskMove;\n+            \/\/ Compress i\n+            i = (i ^ t) | (t >>> (1 << j));\n+            \/\/ Adjust the mask count by identifying bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+\n+    \/**\n+     * Returns the value obtained by expanding the bits of the\n+     * specified {@code int} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the next contiguous bit value\n+     * of {@code i} starting at the least significant bit is assigned\n+     * to the expanded value at the same bit location as {@code mb}.\n+     * All other remaining bits of the expanded value are set to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of expanding the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * expand(0x0000CABAB, 0xFF00FFF0) == 0xCA00BAB0\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects the first five\n+     * hexadecimal digits of {@code 0x0000CABAB}. The selected digits occur\n+     * in the resulting expanded value in order at positions 1, 2, 3, 6, and 7.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code expand}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Logically shift right the bit at position 0\n+     * expand(x, 1 << n) == (x & 1) << n\n+     *\n+     * \/\/ Logically shift right\n+     * expand(x, -1 << n) == x << n\n+     *\n+     * \/\/ Expanding all bits returns the mask\n+     * expand(-1, m) == m\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * expand(x, m) == expand(x, m) & m\n+     *\n+     * \/\/ Compressing then expanding with the same mask\n+     * expand(compress(x, m), m) == x & m\n+     * }\n+     * <p>\n+     * The select operation for determining the position of the one-bit with\n+     * index {@code n} in a {@code int} value can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * int select(int i, int n) {\n+     *     \/\/ the one-bit in i (the mask) with index n\n+     *     int nthBit = Integer.expand(1 << n, i);\n+     *     \/\/ the bit position of the one-bit with index n\n+     *     return Integer.numberOfTrailingZeros(nthBit);\n+     * }\n+     *\n+     * \/\/ The one-bit with index 0 is at bit position 1\n+     * select(0b10101010_10101010, 0) == 1\n+     * \/\/ The one-bit with index 3 is at bit position 7\n+     * select(0b10101010_10101010, 3) == 7\n+     * }\n+     *\n+     * @param i the value whose bits are to be expanded\n+     * @param mask the bit mask\n+     * @return the expanded value\n+     * @see #compress\n+     * @since 19\n+     *\/\n+    static int expand(int i, int mask) {\n+        \/\/ Save original mask\n+        int originalMask = mask;\n+        \/\/ Count 0's to right\n+        int maskCount = ~mask << 1;\n+        int maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove1 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove2 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove3 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove4 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        int maskMove5 = maskPrefix & mask;\n+\n+        int t = i << (1 << 4);\n+        i = (i & ~maskMove5) | (t & maskMove5);\n+        t = i << (1 << 3);\n+        i = (i & ~maskMove4) | (t & maskMove4);\n+        t = i << (1 << 2);\n+        i = (i & ~maskMove3) | (t & maskMove3);\n+        t = i << (1 << 1);\n+        i = (i & ~maskMove2) | (t & maskMove2);\n+        t = i << (1 << 0);\n+        i = (i & ~maskMove1) | (t & maskMove1);\n+\n+        \/\/ Clear irrelevant bits\n+        return i & originalMask;\n+    }\n+\n+    \/**\n+     * Returns the value obtained by expanding the bits of the\n+     * specified {@code long} value, {@code i}, in accordance with\n+     * the specified bit mask.\n+     * <p>\n+     * For each one-bit value {@code mb} of the mask, from least\n+     * significant to most significant, the next contiguous bit value\n+     * of {@code i} starting at the least significant bit is assigned\n+     * to the expanded value at the same bit location as {@code mb}.\n+     * All other remaining bits of the expanded value are set to zero.\n+     *\n+     * @apiNote\n+     * Consider the simple case of expanding the digits of a hexadecimal\n+     * value:\n+     * {@snippet lang=\"java\" :\n+     * expand(0x0000CABAB, 0xFF00FFF0) == 0xCA00BAB0\n+     * }\n+     * Starting from the least significant hexadecimal digit at position 0\n+     * from the right, the mask {@code 0xFF00FFF0} selects the first five\n+     * hexadecimal digits of {@code 0x0000CABAB}. The selected digits occur\n+     * in the resulting expanded value in order at positions 1, 2, 3, 6, and 7.\n+     * <p>\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code expand}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Logically shift right the bit at position 0\n+     * expand(x, 1 << n) == (x & 1) << n\n+     *\n+     * \/\/ Logically shift right\n+     * expand(x, -1 << n) == x << n\n+     *\n+     * \/\/ Expanding all bits returns the mask\n+     * expand(-1, m) == m\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * expand(x, m) == expand(x, m) & m\n+     *\n+     * \/\/ Compressing then expanding with the same mask\n+     * expand(compress(x, m), m) == x & m\n+     * }\n+     * <p>\n+     * The select operation for determining the position of the one-bit with\n+     * index {@code n} in a {@code long} value can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * long select(long i, long n) {\n+     *     \/\/ the one-bit in i (the mask) with index n\n+     * The following identities all return {@code true} and are helpful to\n+     * understand the behaviour of {@code expand}:\n+     * {@snippet lang=\"java\" :\n+     * \/\/ Logically shift right the bit at position 0\n+     * expand(x, 1 << n) == (x & 1) << n\n+     *\n+     * \/\/ Logically shift right\n+     * expand(x, -1 << n) == x << n\n+     *\n+     * \/\/ Expanding all bits returns the mask\n+     * expand(-1, m) == m\n+     *\n+     * \/\/ Any bits not covered by the mask are ignored\n+     * expand(x, m) == expand(x, m) & m\n+     *\n+     * \/\/ Compressing then expanding with the same mask\n+     * expand(compress(x, m), m) == x & m\n+     * }\n+     * <p>\n+     * The select operation for determining the position of the one-bit with\n+     * index {@code n} in a {@code long} value can be implemented as follows:\n+     * {@snippet lang=\"java\" :\n+     * long select(long i, long n) {\n+     *     \/\/ the one-bit in i (the mask) with index n\n+     *     long nthBit = Long.expand(1 << n, i);\n+     *     \/\/ the bit position of the one-bit with index n\n+     *     return Long.numberOfTrailingZeros(nthBit);\n+     * }\n+     *\n+     * \/\/ The one-bit with index 0 is at bit position 1\n+     * select(0b10101010_10101010, 0) == 1\n+     * \/\/ The one-bit with index 3 is at bit position 7\n+     * select(0b10101010_10101010, 3) == 7\n+     * }\n+     *\n+     * @param i the value whose bits are to be expanded\n+     * @param mask the bit mask\n+     * @return the expanded value\n+     * @see #compress\n+     * @since 19\n+     *\/\n+    static long expand(long i, long mask) {\n+        \/\/ Save original mask\n+        long originalMask = mask;\n+        \/\/ Count 0's to right\n+        long maskCount = ~mask << 1;\n+        long maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove1 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove2 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove3 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove4 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove5 = maskPrefix & mask;\n+        \/\/ Compress mask\n+        mask = (mask ^ maskMove5) | (maskMove5 >>> (1 << 4));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        \/\/ Bits to move\n+        long maskMove6 = maskPrefix & mask;\n+        long t = i << (1 << 5);\n+        i = (i & ~maskMove6) | (t & maskMove6);\n+        t = i << (1 << 4);\n+        i = (i & ~maskMove5) | (t & maskMove5);\n+        t = i << (1 << 3);\n+        i = (i & ~maskMove4) | (t & maskMove4);\n+        t = i << (1 << 2);\n+        i = (i & ~maskMove3) | (t & maskMove3);\n+        t = i << (1 << 1);\n+        i = (i & ~maskMove2) | (t & maskMove2);\n+        t = i << (1 << 0);\n+        i = (i & ~maskMove1) | (t & maskMove1);\n+\n+        \/\/ Clear irrelevant bits\n+        return i & originalMask;\n+    }\n+\n+    @ForceInline\n+    private static int parallelSuffix(int maskCount) {\n+        int maskPrefix = maskCount ^ (maskCount << 1);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+        return maskPrefix;\n+    }\n+\n+    @ForceInline\n+    private static long parallelSuffix(long maskCount) {\n+        long maskPrefix = maskCount ^ (maskCount << 1);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+        return maskPrefix;\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/CompressExpand.java","additions":502,"deletions":0,"binary":false,"changes":502,"status":"added"},{"patch":"@@ -516,0 +516,1 @@\n+\n@@ -876,0 +877,4 @@\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -516,0 +516,1 @@\n+\n@@ -834,0 +835,4 @@\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -516,0 +516,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -567,0 +567,4 @@\n+    \/** Produce {@code compressBits(a,n)}. Integral only. *\/\n+    public static final \/*bitwise*\/ Binary COMPRESS_BITS = binary(\"COMPRESS_BITS\", \"compressBits\", VectorSupport.VECTOR_OP_COMPRESS_BITS, VO_NOFP);\n+    \/** Produce {@code expandBits(a,n)}. Integral only. *\/\n+    public static final \/*bitwise*\/ Binary EXPAND_BITS = binary(\"EXPAND_BITS\", \"expandBits\", VectorSupport.VECTOR_OP_EXPAND_BITS, VO_NOFP);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+\n@@ -975,0 +976,6 @@\n+#if[intOrLong]\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n+#end[intOrLong]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1228,0 +1228,1 @@\n+\n@@ -1952,0 +1953,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1228,0 +1228,1 @@\n+\n@@ -1952,0 +1953,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1228,0 +1228,1 @@\n+\n@@ -1952,0 +1953,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1228,0 +1228,1 @@\n+\n@@ -1952,0 +1953,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1233,0 +1233,1 @@\n+\n@@ -1957,0 +1958,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1805,0 +1805,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1805,0 +1805,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1805,0 +1805,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1805,0 +1805,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1810,0 +1810,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1815,0 +1815,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1815,0 +1815,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1815,0 +1815,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1815,0 +1815,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1820,0 +1820,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1185,0 +1186,1 @@\n+\n@@ -1914,0 +1916,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.compress(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.expand(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1185,0 +1186,1 @@\n+\n@@ -1914,0 +1916,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.compress(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.expand(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1185,0 +1186,1 @@\n+\n@@ -1914,0 +1916,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.compress(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.expand(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1185,0 +1186,1 @@\n+\n@@ -1914,0 +1916,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.compress(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.expand(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1190,0 +1191,1 @@\n+\n@@ -1919,0 +1921,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.compress(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.expand(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1207,0 +1208,1 @@\n+\n@@ -1936,0 +1938,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.compress(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.expand(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1207,0 +1208,1 @@\n+\n@@ -1936,0 +1938,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.compress(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.expand(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1207,0 +1208,1 @@\n+\n@@ -1936,0 +1938,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.compress(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.expand(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1207,0 +1208,1 @@\n+\n@@ -1936,0 +1938,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.compress(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.expand(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -1212,0 +1213,1 @@\n+\n@@ -1941,0 +1943,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.compress(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.expand(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -1219,0 +1219,1 @@\n+\n@@ -1943,0 +1944,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1219,0 +1219,1 @@\n+\n@@ -1943,0 +1944,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1219,0 +1219,1 @@\n+\n@@ -1943,0 +1944,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1219,0 +1219,1 @@\n+\n@@ -1943,0 +1944,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1224,0 +1224,1 @@\n+\n@@ -1948,0 +1949,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compress;\n+\n+public class CompressExpandTest {\n+    public static int compress(int i, int mask) {\n+        i = i & mask;\n+        int maskCount = ~mask << 1;\n+\n+        for (int j = 0; j < 5; j++) {\n+            int maskPrefix = parallelSuffix(maskCount);\n+            int maskMove = maskPrefix & mask;\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            int t = i & maskMove;\n+            i = (i ^ t) | (t >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+    public static long compress(long i, long mask) {\n+        i = i & mask;\n+        long maskCount = ~mask << 1;\n+\n+        for (int j = 0; j < 6; j++) {\n+            long maskPrefix = parallelSuffix(maskCount);\n+            long maskMove = maskPrefix & mask;\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            long t = i & maskMove;\n+            i = (i ^ t) | (t >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return i;\n+    }\n+\n+    public static int expand(int i, int mask) {\n+        int originalMask = mask;\n+        int maskCount = ~mask << 1;\n+        int maskPrefix = parallelSuffix(maskCount);\n+        int maskMove1 = maskPrefix & mask;\n+        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        int maskMove2 = maskPrefix & mask;\n+        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        int maskMove3 = maskPrefix & mask;\n+        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        int maskMove4 = maskPrefix & mask;\n+        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        int maskMove5 = maskPrefix & mask;\n+\n+        int t = i << (1 << 4);\n+        i = (i & ~maskMove5) | (t & maskMove5);\n+        t = i << (1 << 3);\n+        i = (i & ~maskMove4) | (t & maskMove4);\n+        t = i << (1 << 2);\n+        i = (i & ~maskMove3) | (t & maskMove3);\n+        t = i << (1 << 1);\n+        i = (i & ~maskMove2) | (t & maskMove2);\n+        t = i << (1 << 0);\n+        i = (i & ~maskMove1) | (t & maskMove1);\n+\n+        return i & originalMask;\n+    }\n+\n+    public static long expand(long i, long mask) {\n+        long originalMask = mask;\n+        long maskCount = ~mask << 1;\n+        long maskPrefix = parallelSuffix(maskCount);\n+        long maskMove1 = maskPrefix & mask;\n+        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        long maskMove2 = maskPrefix & mask;\n+        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        long maskMove3 = maskPrefix & mask;\n+        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        long maskMove4 = maskPrefix & mask;\n+        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        long maskMove5 = maskPrefix & mask;\n+        mask = (mask ^ maskMove5) | (maskMove5 >>> (1 << 4));\n+        maskCount = maskCount & ~maskPrefix;\n+\n+        maskPrefix = parallelSuffix(maskCount);\n+        long maskMove6 = maskPrefix & mask;\n+        long t = i << (1 << 5);\n+        i = (i & ~maskMove6) | (t & maskMove6);\n+        t = i << (1 << 4);\n+        i = (i & ~maskMove5) | (t & maskMove5);\n+        t = i << (1 << 3);\n+        i = (i & ~maskMove4) | (t & maskMove4);\n+        t = i << (1 << 2);\n+        i = (i & ~maskMove3) | (t & maskMove3);\n+        t = i << (1 << 1);\n+        i = (i & ~maskMove2) | (t & maskMove2);\n+        t = i << (1 << 0);\n+        i = (i & ~maskMove1) | (t & maskMove1);\n+\n+        return i & originalMask;\n+    }\n+\n+    private static int parallelSuffix(int maskCount) {\n+        int maskPrefix = maskCount ^ (maskCount << 1);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+        return maskPrefix;\n+    }\n+\n+    private static long parallelSuffix(long maskCount) {\n+        long maskPrefix = maskCount ^ (maskCount << 1);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+        maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+        return maskPrefix;\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/compress\/CompressExpandTest.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -406,0 +406,2 @@\n+gen_binary_alu_op \"COMPRESS_BITS\" \"CompressExpandTest.compress(a,b)\" \"intOrLong\"\n+gen_binary_alu_op \"EXPAND_BITS\" \"CompressExpandTest.expand(a,b)\" \"intOrLong\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import compress.CompressExpandTest;\n@@ -56,0 +57,1 @@\n+import compress.CompressExpandTest;\n@@ -1503,0 +1505,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -468,0 +468,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -468,0 +468,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -468,0 +468,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -468,0 +468,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -468,0 +468,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -472,0 +472,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -351,0 +351,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -351,0 +351,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -467,0 +467,84 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(CompressExpandTest.compress(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(CompressExpandTest.compress(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(CompressExpandTest.expand(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(CompressExpandTest.expand(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -467,0 +467,84 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(CompressExpandTest.compress(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(CompressExpandTest.compress(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(CompressExpandTest.expand(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(CompressExpandTest.expand(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -470,0 +470,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,0 +470,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,0 +470,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,0 +470,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,0 +470,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -475,0 +475,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}