{"files":[{"patch":"@@ -78,0 +78,2 @@\n+macro(CompressBits)\n+macro(ExpandBits)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -392,0 +392,16 @@\n+\/\/------------------------------CompressBitsNode-------------------------------\n+\/\/ CompressBits placeholder node\n+class CompressBitsNode : public Node {\n+public:\n+  CompressBitsNode(Node *in1, Node *in2) : Node(0,in1,in2) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------ExpandBitsNode---------------------------------\n+\/\/ ExpandBits placeholder node\n+class ExpandBitsNode : public Node {\n+public:\n+  ExpandBitsNode(Node *in1, Node *in2) : Node(0,in1,in2) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -165,0 +165,6 @@\n+  case Op_CompressBits:\n+    \/\/ Not implemented. Returning 0 temporarily\n+    return 0;\n+  case Op_ExpandBits:\n+    \/\/ Not implemented. Returning 0 temporarily\n+    return 0;\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-     switch (bt) {\n+      switch (bt) {\n@@ -493,1 +493,1 @@\n-     switch (bt) {\n+      switch (bt) {\n@@ -503,1 +503,1 @@\n-     switch (bt) {\n+      switch (bt) {\n@@ -513,1 +513,1 @@\n-     switch (bt) {\n+      switch (bt) {\n@@ -523,1 +523,1 @@\n-     switch (bt) {\n+      switch (bt) {\n@@ -532,0 +532,16 @@\n+    case VECTOR_OP_COMPRESS_BITS: {\n+      switch (bt) {\n+        case T_INT:\n+        case T_LONG: return Op_CompressBits;\n+        default: fatal(\"COMPRESS_BITS: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_EXPAND_BITS: {\n+      switch (bt) {\n+        case T_INT:\n+        case T_LONG: return Op_ExpandBits;\n+        default: fatal(\"EXPAND_BITS: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+    VECTOR_OP_COMPRESS_BITS = 33,\n+    VECTOR_OP_EXPAND_BITS = 34,\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,4 @@\n+    \/\/ Compress and Expand Bits operation\n+    public static final int VECTOR_OP_COMPRESS_BITS = 33;\n+    public static final int VECTOR_OP_EXPAND_BITS = 34;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -448,0 +448,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -448,0 +448,62 @@\n+    \/* Implementation note: The implementation is based on Compress or Generalized Extract mentioned in\n+     * Henry S. Warren, Jr's Hackers Delight, Addison Wesley, 2002.\n+     *\/\n+    static int compressBits(int a, int mask) {\n+        a = a & mask; \/\/ Clear irrelevant bits\n+        int maskCount = ~mask << 1; \/\/ Count 0's to right\n+        int iters = 5;\n+\n+        for (int j = 0; j < iters; j++) {\n+            \/\/ Parallel prefix\n+            \/\/ maskPrefix identifies bits of the mask that have odd number of 0's to the right\n+            int maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            \/\/ Bits to move\n+            int maskMove = maskPrefix & mask;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Bits of a to be moved\n+            int t = a & maskMove;\n+            \/\/ Compress a\n+            a = (a ^ t) | (t >>> (1 << j));\n+            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static int expandBits(int a, int mask) {\n+        int originalMask = mask; \/\/ Save original mask\n+        int maskCount = ~mask << 1; \/\/ Count 0's to right\n+        int[] array = new int[5];\n+        int iters = 5;\n+\n+        for (int j = 0; j < iters; j++) {\n+            \/\/ Parallel prefix\n+            int maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            \/\/ Bits to move\n+            int maskMove = maskPrefix & mask;\n+            array[j] = maskMove;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            int maskMove = array[j];\n+            int t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+\n+        \/\/ Clear irrelevant bits\n+        return (a & originalMask);\n+    }\n+\n@@ -808,0 +870,4 @@\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> compressBits(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> expandBits(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -448,0 +448,64 @@\n+    \/* Implementation note: The implementation is based on Compress or Generalized Extract mentioned in\n+     * Henry S. Warren, Jr's Hackers Delight, Addison Wesley, 2002.\n+     *\/\n+    static long compressBits(long a, long mask) {\n+        a = a & mask; \/\/ Clear irrelevant bits\n+        long maskCount = ~mask << 1; \/\/ Count 0's to right\n+        int iters = 6;\n+\n+        for (int j = 0; j < iters; j++) {\n+            \/\/ Parallel prefix\n+            \/\/ maskPrefix identifies bits of the mask that have odd number of 0's to the right\n+            long maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            \/\/ Bits to move\n+            long maskMove = maskPrefix & mask;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Bits of a to be moved\n+            long t = a & maskMove;\n+            \/\/ Compress a\n+            a = (a ^ t) | (t >>> (1 << j));\n+            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static long expandBits(long a, long mask) {\n+        long originalMask = mask; \/\/ Save original mask\n+        long maskCount = ~mask << 1; \/\/ Count 0's to right\n+        long[] array = new long[6];\n+        int iters = 6;\n+\n+        for (int j = 0; j < iters; j++) {\n+            \/\/ Parallel prefix\n+            long maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            \/\/ Bits to move\n+            long maskMove = maskPrefix & mask;\n+            array[j] = maskMove;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            long maskMove = array[j];\n+            long t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+\n+        \/\/ Clear irrelevant bits\n+        return (a & originalMask);\n+    }\n+\n@@ -766,0 +830,4 @@\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> compressBits(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> expandBits(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -448,0 +448,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -567,0 +567,4 @@\n+    \/** Produce {@code compressBits(a,n)}. Integral only. *\/\n+    public static final \/*bitwise*\/ Binary COMPRESS_BITS = binary(\"COMPRESS_BITS\", \"compressBits\", VectorSupport.VECTOR_OP_COMPRESS_BITS, VO_NOFP);\n+    \/** Produce {@code expandBits(a,n)}. Integral only. *\/\n+    public static final \/*bitwise*\/ Binary EXPAND_BITS = binary(\"EXPAND_BITS\", \"expandBits\", VectorSupport.VECTOR_OP_EXPAND_BITS, VO_NOFP);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -460,0 +460,79 @@\n+\n+#if[intOrLong]\n+    \/* Implementation note: The implementation is based on Compress or Generalized Extract mentioned in\n+     * Henry S. Warren, Jr's Hackers Delight, Addison Wesley, 2002.\n+     *\/\n+    static $type$ compressBits($type$ a, $type$ mask) {\n+        a = a & mask; \/\/ Clear irrelevant bits\n+        $type$ maskCount = ~mask << 1; \/\/ Count 0's to right\n+#if[int]\n+        int iters = 5;\n+#else[int]\n+        int iters = 6;\n+#end[int]\n+\n+        for (int j = 0; j < iters; j++) {\n+            \/\/ Parallel prefix\n+            \/\/ maskPrefix identifies bits of the mask that have odd number of 0's to the right\n+            $type$ maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+#if[long]\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+#end[long]\n+            \/\/ Bits to move\n+            $type$ maskMove = maskPrefix & mask;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Bits of a to be moved\n+            $type$ t = a & maskMove;\n+            \/\/ Compress a\n+            a = (a ^ t) | (t >>> (1 << j));\n+            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static $type$ expandBits($type$ a, $type$ mask) {\n+        $type$ originalMask = mask; \/\/ Save original mask\n+        $type$ maskCount = ~mask << 1; \/\/ Count 0's to right\n+#if[int]\n+        $type$[] array = new $type$[5];\n+        int iters = 5;\n+#else[int]\n+        $type$[] array = new $type$[6];\n+        int iters = 6;\n+#end[int]\n+\n+        for (int j = 0; j < iters; j++) {\n+            \/\/ Parallel prefix\n+            $type$ maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+#if[long]\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+#end[long]\n+            \/\/ Bits to move\n+            $type$ maskMove = maskPrefix & mask;\n+            array[j] = maskMove;\n+            \/\/ Compress mask\n+            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n+            \/\/ Adjust the countMask by identifying the bits that have 0 to the right\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            $type$ maskMove = array[j];\n+            $type$ t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+\n+        \/\/ Clear irrelevant bits\n+        return (a & originalMask);\n+    }\n+#end[intOrLong]\n@@ -907,0 +986,6 @@\n+#if[intOrLong]\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> compressBits(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> expandBits(a, n));\n+#end[intOrLong]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -1228,0 +1228,1 @@\n+\n@@ -1952,0 +1953,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1228,0 +1228,1 @@\n+\n@@ -1952,0 +1953,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1228,0 +1228,1 @@\n+\n@@ -1952,0 +1953,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1228,0 +1228,1 @@\n+\n@@ -1952,0 +1953,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1233,0 +1233,1 @@\n+\n@@ -1957,0 +1958,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1805,0 +1805,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1805,0 +1805,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1805,0 +1805,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1805,0 +1805,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1810,0 +1810,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1815,0 +1815,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1815,0 +1815,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1815,0 +1815,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1815,0 +1815,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1820,0 +1820,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1185,0 +1185,46 @@\n+    static int COMPRESSBITS_scalar(int a, int b) {\n+        a = a & b;\n+        int maskCount = ~b << 1;\n+        int iters = 5;\n+\n+        for (int i = 0; i < iters; i++) {\n+            int maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            int maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            int t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static int EXPANDBITS_scalar(int a, int b) {\n+        int originalMask = b;\n+        int maskCount = ~b << 1;\n+        int[] array = new int[5];\n+        int iters = 5;\n+\n+        for (int j = 0; j < iters; j++) {\n+            int maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            int maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            int maskMove = array[j];\n+            int t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+\n@@ -1914,0 +1960,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(COMPRESSBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(EXPANDBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -1185,0 +1185,46 @@\n+    static int COMPRESSBITS_scalar(int a, int b) {\n+        a = a & b;\n+        int maskCount = ~b << 1;\n+        int iters = 5;\n+\n+        for (int i = 0; i < iters; i++) {\n+            int maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            int maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            int t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static int EXPANDBITS_scalar(int a, int b) {\n+        int originalMask = b;\n+        int maskCount = ~b << 1;\n+        int[] array = new int[5];\n+        int iters = 5;\n+\n+        for (int j = 0; j < iters; j++) {\n+            int maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            int maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            int maskMove = array[j];\n+            int t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+\n@@ -1914,0 +1960,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(COMPRESSBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(EXPANDBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -1185,0 +1185,46 @@\n+    static int COMPRESSBITS_scalar(int a, int b) {\n+        a = a & b;\n+        int maskCount = ~b << 1;\n+        int iters = 5;\n+\n+        for (int i = 0; i < iters; i++) {\n+            int maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            int maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            int t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static int EXPANDBITS_scalar(int a, int b) {\n+        int originalMask = b;\n+        int maskCount = ~b << 1;\n+        int[] array = new int[5];\n+        int iters = 5;\n+\n+        for (int j = 0; j < iters; j++) {\n+            int maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            int maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            int maskMove = array[j];\n+            int t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+\n@@ -1914,0 +1960,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(COMPRESSBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(EXPANDBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -1185,0 +1185,46 @@\n+    static int COMPRESSBITS_scalar(int a, int b) {\n+        a = a & b;\n+        int maskCount = ~b << 1;\n+        int iters = 5;\n+\n+        for (int i = 0; i < iters; i++) {\n+            int maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            int maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            int t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static int EXPANDBITS_scalar(int a, int b) {\n+        int originalMask = b;\n+        int maskCount = ~b << 1;\n+        int[] array = new int[5];\n+        int iters = 5;\n+\n+        for (int j = 0; j < iters; j++) {\n+            int maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            int maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            int maskMove = array[j];\n+            int t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+\n@@ -1914,0 +1960,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(COMPRESSBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(EXPANDBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -1190,0 +1190,46 @@\n+    static int COMPRESSBITS_scalar(int a, int b) {\n+        a = a & b;\n+        int maskCount = ~b << 1;\n+        int iters = 5;\n+\n+        for (int i = 0; i < iters; i++) {\n+            int maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            int maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            int t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static int EXPANDBITS_scalar(int a, int b) {\n+        int originalMask = b;\n+        int maskCount = ~b << 1;\n+        int[] array = new int[5];\n+        int iters = 5;\n+\n+        for (int j = 0; j < iters; j++) {\n+            int maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            int maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            int maskMove = array[j];\n+            int t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+\n@@ -1919,0 +1965,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(COMPRESSBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(EXPANDBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -1207,0 +1207,48 @@\n+    static long COMPRESSBITS_scalar(long a, long b) {\n+        a = a & b;\n+        long maskCount = ~b << 1;\n+        int iters = 6;\n+\n+        for (int i = 0; i < iters; i++) {\n+            long maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            long maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            long t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static long EXPANDBITS_scalar(long a, long b) {\n+        long originalMask = b;\n+        long maskCount = ~b << 1;\n+        long[] array = new long[6];\n+        int iters = 6;\n+\n+        for (int j = 0; j < iters; j++) {\n+            long maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            long maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            long maskMove = array[j];\n+            long t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+\n@@ -1936,0 +1984,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(COMPRESSBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(EXPANDBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -1207,0 +1207,48 @@\n+    static long COMPRESSBITS_scalar(long a, long b) {\n+        a = a & b;\n+        long maskCount = ~b << 1;\n+        int iters = 6;\n+\n+        for (int i = 0; i < iters; i++) {\n+            long maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            long maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            long t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static long EXPANDBITS_scalar(long a, long b) {\n+        long originalMask = b;\n+        long maskCount = ~b << 1;\n+        long[] array = new long[6];\n+        int iters = 6;\n+\n+        for (int j = 0; j < iters; j++) {\n+            long maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            long maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            long maskMove = array[j];\n+            long t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+\n@@ -1936,0 +1984,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(COMPRESSBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(EXPANDBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -1207,0 +1207,48 @@\n+    static long COMPRESSBITS_scalar(long a, long b) {\n+        a = a & b;\n+        long maskCount = ~b << 1;\n+        int iters = 6;\n+\n+        for (int i = 0; i < iters; i++) {\n+            long maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            long maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            long t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static long EXPANDBITS_scalar(long a, long b) {\n+        long originalMask = b;\n+        long maskCount = ~b << 1;\n+        long[] array = new long[6];\n+        int iters = 6;\n+\n+        for (int j = 0; j < iters; j++) {\n+            long maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            long maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            long maskMove = array[j];\n+            long t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+\n@@ -1936,0 +1984,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(COMPRESSBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(EXPANDBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -1207,0 +1207,48 @@\n+    static long COMPRESSBITS_scalar(long a, long b) {\n+        a = a & b;\n+        long maskCount = ~b << 1;\n+        int iters = 6;\n+\n+        for (int i = 0; i < iters; i++) {\n+            long maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            long maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            long t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static long EXPANDBITS_scalar(long a, long b) {\n+        long originalMask = b;\n+        long maskCount = ~b << 1;\n+        long[] array = new long[6];\n+        int iters = 6;\n+\n+        for (int j = 0; j < iters; j++) {\n+            long maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            long maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            long maskMove = array[j];\n+            long t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+\n@@ -1936,0 +1984,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(COMPRESSBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(EXPANDBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -1212,0 +1212,48 @@\n+    static long COMPRESSBITS_scalar(long a, long b) {\n+        a = a & b;\n+        long maskCount = ~b << 1;\n+        int iters = 6;\n+\n+        for (int i = 0; i < iters; i++) {\n+            long maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            long maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            long t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static long EXPANDBITS_scalar(long a, long b) {\n+        long originalMask = b;\n+        long maskCount = ~b << 1;\n+        long[] array = new long[6];\n+        int iters = 6;\n+\n+        for (int j = 0; j < iters; j++) {\n+            long maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+            long maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            long maskMove = array[j];\n+            long t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+\n@@ -1941,0 +1989,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(COMPRESSBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(EXPANDBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -1219,0 +1219,1 @@\n+\n@@ -1943,0 +1944,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1219,0 +1219,1 @@\n+\n@@ -1943,0 +1944,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1219,0 +1219,1 @@\n+\n@@ -1943,0 +1944,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1219,0 +1219,1 @@\n+\n@@ -1943,0 +1944,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1224,0 +1224,1 @@\n+\n@@ -1948,0 +1949,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -406,0 +406,2 @@\n+gen_binary_alu_op \"COMPRESS_BITS\" \"COMPRESSBITS_scalar(a,b)\" \"intOrLong\"\n+gen_binary_alu_op \"EXPAND_BITS\" \"EXPANDBITS_scalar(a,b)\" \"intOrLong\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,3286 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+#warn This file is preprocessed before being compiled\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class $Type$Scalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+        $type$[] array = new $type$[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static $bitstype$ bits($type$ e) {\n+        return {#if[FP]?$Type$.$type$To$Bitstype$Bits(e):e};\n+    }\n+\n+    $type$[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> ($type$)(2*i));\n+        bs = fill(i -> ($type$)(i+1));\n+        cs = fill(i -> ($type$)(i+5));\n+        rs = fill(i -> ($type$)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RANDOM.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<$type$[]> fa = vl -> as;\n+    final IntFunction<$type$[]> fb = vl -> bs;\n+    final IntFunction<$type$[]> fc = vl -> cs;\n+    final IntFunction<$type$[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq($type$ a, $type$ b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq($type$ a, $type$ b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt($type$ a, $type$ b) {\n+        return a < b;\n+    }\n+\n+    static boolean le($type$ a, $type$ b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt($type$ a, $type$ b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge($type$ a, $type$ b) {\n+        return a >= b;\n+    }\n+\n+#if[!FP]\n+    static boolean ult($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) >= 0;\n+    }\n+#end[!FP]\n+\n+#if[BITWISE]\n+    static $type$ ROL_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateLeft(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ ROR_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateRight(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ TRAILING_ZEROS_COUNT_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfTrailingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+#else[short]\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ LEADING_ZEROS_COUNT_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfLeadingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+#else[short]\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ REVERSE_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.reverse(a);\n+#else[intOrLong]\n+#if[short]\n+        $type$ b = ROL_scalar(a, ($type$) 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+#else[short]\n+        $type$ b = ROL_scalar(a, ($type$) 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+#end[short]\n+#end[intOrLong]\n+    }\n+#end[BITWISE]\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(a \/ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(a \/ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)({#if[FP]?Double.doubleToLongBits}(a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)({#if[FP]?Double.doubleToLongBits}(a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(COMPRESSBITS_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(COMPRESSBITS_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(EXPANDBITS_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(EXPANDBITS_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)((a << b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a << (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)((a << (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a << (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)((a << (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)((a >> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a >> (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)((a >> (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a >> (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)((a >> (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)((a >>> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(((a & 0xFF) >>> (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(((a & 0xFF) >>> (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(((a & 0xFFFF) >>> (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(((a & 0xFFFF) >>> (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)((a << b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a << (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)((a << (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a << (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)((a << (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)((a >>> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(((a & 0xFF) >>> (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(((a & 0xFF) >>> (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(((a & 0xFFFF) >>> (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(((a & 0xFFFF) >>> (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)((a >> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a >> (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)((a >> (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)((a >> (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)((a >> (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(ROR_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(ROL_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(ROR_scalar(a,b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(ROL_scalar(a,b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void IS_FINITE(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                r &= ($Boxtype$.isFinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void IS_NAN(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                r &= ($Boxtype$.isNaN(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void IS_INFINITE(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                r &= ($Boxtype$.isInfinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    void rearrangeShared(int window, Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    $type$ a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = new $type$[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = new $type$[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+    void broadcastShared(int window, Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = ($type$)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.sin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.exp((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.log1p((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.log((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.log10((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.expm1((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.cos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.tan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.sinh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.cosh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.tanh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.asin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.acos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.atan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.cbrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(Math.hypot((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(Math.pow((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)(Math.atan2((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] cs = fc.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                $type$ c = cs[i];\n+                rs[i] = ($type$)(Math.fma(a, b, c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] cs = fc.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                $type$ c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)(Math.fma(a, b, c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] cs = fc.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                $type$ c = cs[i];\n+                rs[i] = ($type$)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] cs = fc.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                $type$ c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(-(($type$)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(-(($type$)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.abs(($type$)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(Math.abs(($type$)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#if[BITWISE]\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(~(($type$)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(~(($type$)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[FP]\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Math.sqrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(Math.sqrt((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[FP]\n+\n+#if[intOrLong]\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)($Boxtype$.bitCount(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)($Boxtype$.bitCount(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Integer.bitCount((int)a & 0xFF));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(Integer.bitCount((int)a & 0xFF)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(Integer.bitCount((int)a & 0xFFFF));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(Integer.bitCount((int)a & 0xFFFF)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[BITWISE]\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(TRAILING_ZEROS_COUNT_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(TRAILING_ZEROS_COUNT_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(LEADING_ZEROS_COUNT_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(LEADING_ZEROS_COUNT_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(REVERSE_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(REVERSE_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[BITWISE]\n+\n+#if[intOrLong]\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)($Boxtype$.reverseBytes(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)($Boxtype$.reverseBytes(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[intOrLong]\n+\n+#if[short]\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)($Boxtype$.reverseBytes(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)($Boxtype$.reverseBytes(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[short]\n+\n+#if[byte]\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)(a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)(a) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+#end[byte]\n+\n+}\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/perf_scalar_tests.template","additions":3286,"deletions":0,"binary":false,"changes":3286,"status":"added"},{"patch":"@@ -0,0 +1,3603 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+#warn This file is preprocessed before being compiled\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.$Type$Vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class $vectorbenchtype$ extends AbstractVectorBenchmark {\n+#if[MaxBit]\n+    static final VectorSpecies<$Wideboxtype$> SPECIES = $Type$Vector.SPECIES_MAX;\n+#else[MaxBit]\n+    static final VectorSpecies<$Wideboxtype$> SPECIES = $Type$Vector.SPECIES_$bits$;\n+#end[MaxBit]\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+#if[BITWISE]\n+    static void replaceZero($type$[] a, $type$ v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero($type$[] a, boolean[] mask, $type$ v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+#end[BITWISE]\n+\n+    static $type$ firstNonZero($type$ a, $type$ b) {\n+        return $Boxtype$.compare(a, ($type$) 0) != 0 ? a : b;\n+    }\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+        $type$[] array = new $type$[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    $type$[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> ($type$)(2*i));\n+        b = fill(i -> ($type$)(i+1));\n+        c = fill(i -> ($type$)(i+5));\n+        r = fill(i -> ($type$)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RANDOM.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<$type$[]> fa = vl -> a;\n+    final IntFunction<$type$[]> fb = vl -> b;\n+    final IntFunction<$type$[]> fc = vl -> c;\n+    final IntFunction<$type$[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, ($type$) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, ($type$) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+#end[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = $Wideboxtype$.$MaxValue$;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = $Wideboxtype$.$MaxValue$;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = $Wideboxtype$.$MaxValue$;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = $Wideboxtype$.$MaxValue$;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = $Wideboxtype$.$MinValue$;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = $Wideboxtype$.$MinValue$;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = $Wideboxtype$.$MinValue$;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = $Wideboxtype$.$MinValue$;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = ($type$) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = ($type$) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = ($type$) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = ($type$) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), ($type$)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        $type$[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        $type$[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        $type$[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        $type$[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        $type$[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+#end[FP]\n+\n+    @Benchmark\n+    public Object LT() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+#if[BITWISE]\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+#end[BITWISE]\n+\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[FP]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[BITWISE]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[intOrLong]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[short]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+#end[byte]\n+\n+}\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/perf_tests.template","additions":3603,"deletions":0,"binary":false,"changes":3603,"status":"added"},{"patch":"@@ -1503,0 +1503,63 @@\n+#if[intOrLong]\n+    static $type$ COMPRESSBITS_scalar($type$ a, $type$ b) {\n+        a = a & b;\n+        $type$ maskCount = ~b << 1;\n+#if[int]\n+        int iters = 5;\n+#else[int]\n+        int iters = 6;\n+#end[int]\n+\n+        for (int i = 0; i < iters; i++) {\n+            $type$ maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+#if[long]\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+#end[long]\n+            $type$ maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            $type$ t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static $type$ EXPANDBITS_scalar($type$ a, $type$ b) {\n+        $type$ originalMask = b;\n+        $type$ maskCount = ~b << 1;\n+#if[int]\n+        $type$[] array = new $type$[5];\n+        int iters = 5;\n+#else[int]\n+        $type$[] array = new $type$[6];\n+        int iters = 6;\n+#end[int]\n+\n+        for (int j = 0; j < iters; j++) {\n+            $type$ maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+#if[long]\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+#end[long]\n+            $type$ maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            $type$ maskMove = array[j];\n+            $type$ t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+#end[intOrLong]\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,8647 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.vector\n+ * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation $vectorteststype$\n+ *\/\n+\n+#warn This file is preprocessed before being compiled\n+\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+\n+#if[Byte]\n+import jdk.incubator.vector.ByteVector;\n+#end[Byte]\n+#if[Float]\n+import jdk.incubator.vector.FloatVector;\n+#end[Float]\n+#if[Int]\n+import jdk.incubator.vector.IntVector;\n+#end[Int]\n+#if[Double]\n+import jdk.incubator.vector.DoubleVector;\n+#end[Double]\n+#if[Short]\n+import jdk.incubator.vector.ShortVector;\n+#end[Short]\n+#if[Long]\n+import jdk.incubator.vector.LongVector;\n+#end[Long]\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.Integer;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+@Test\n+public class $vectorteststype$ extends AbstractVectorTest {\n+\n+#if[MaxBit]\n+    static final VectorSpecies<$Wideboxtype$> SPECIES =\n+                $Type$Vector.SPECIES_MAX;\n+#else[MaxBit]\n+    static final VectorSpecies<$Wideboxtype$> SPECIES =\n+                $Type$Vector.SPECIES_$bits$;\n+#end[MaxBit]\n+\n+    static final int INVOC_COUNT = Integer.getInteger(\"jdk.incubator.vector.test.loop-iterations\", 100);\n+\n+#if[MaxBit]\n+    static VectorShape getMaxBit() {\n+        return VectorShape.S_Max_BIT;\n+    }\n+\n+    private static final int Max = 256;  \/\/ juts so we can do N\/$bits$\n+#end[MaxBit]\n+\n+    static final int BUFFER_REPS = Integer.getInteger(\"jdk.incubator.vector.test.buffer-vectors\", 25000 \/ $bits$);\n+\n+    interface FUnOp {\n+        $type$ apply($type$ a);\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i]), \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FUnArrayOp {\n+        $type$[] apply($type$ a);\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, FUnArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a[i]));\n+            }\n+        } catch (AssertionError e) {\n+            $type$[] ref = f.apply(a[i]);\n+            $type$[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, boolean[] mask, FUnOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], mask[i % SPECIES.length()] ? f.apply(a[i]) : a[i], \"at index #\" + i + \", input = \" + a[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    interface FReductionOp {\n+        $type$ apply($type$[] a, int idx);\n+    }\n+\n+    interface FReductionAllOp {\n+        $type$ apply($type$[] a);\n+    }\n+\n+    static void assertReductionArraysEquals($type$[] r, $type$ rc, $type$[] a,\n+                                            FReductionOp f, FReductionAllOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOp {\n+        $type$ apply($type$[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOp {\n+        $type$ apply($type$[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionArraysEqualsMasked($type$[] r, $type$ rc, $type$[] a, boolean[] mask,\n+                                            FReductionMaskedOp f, FReductionAllMaskedOp fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+\n+#if[!Long]\n+    interface FReductionOpLong {\n+        long apply($type$[] a, int idx);\n+    }\n+\n+    interface FReductionAllOpLong {\n+        long apply($type$[] a);\n+    }\n+\n+    static void assertReductionLongArraysEquals(long[] r, long rc, $type$[] a,\n+                                            FReductionOpLong f, FReductionAllOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FReductionMaskedOpLong {\n+        long apply($type$[] a, int idx, boolean[] mask);\n+    }\n+\n+    interface FReductionAllMaskedOpLong {\n+        long apply($type$[] a, boolean[] mask);\n+    }\n+\n+    static void assertReductionLongArraysEqualsMasked(long[] r, long rc, $type$[] a, boolean[] mask,\n+                                            FReductionMaskedOpLong f, FReductionAllMaskedOpLong fa) {\n+        int i = 0;\n+        try {\n+            Assert.assertEquals(rc, fa.apply(a, mask));\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i, mask));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rc, fa.apply(a, mask), \"Final result is incorrect!\");\n+            Assert.assertEquals(r[i], f.apply(a, i, mask), \"at index #\" + i);\n+        }\n+    }\n+#end[!Long]\n+\n+    interface FBoolReductionOp {\n+        boolean apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertReductionBoolArraysEquals(boolean[] r, boolean[] a, FBoolReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FMaskReductionOp {\n+        int apply(boolean[] a, int idx);\n+    }\n+\n+    static void assertMaskReductionArraysEquals(int[] r, boolean[] a, FMaskReductionOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a, i), \"at index #\" + i);\n+        }\n+    }\n+\n+    static void assertInsertArraysEquals($type$[] r, $type$[] a, $type$ element, int index, int start, int end) {\n+        int i = start;\n+        try {\n+            for (; i < end; i += 1) {\n+                if(i%SPECIES.length() == index) {\n+                    Assert.assertEquals(r[i], element);\n+                } else {\n+                    Assert.assertEquals(r[i], a[i]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            if (i%SPECIES.length() == index) {\n+                Assert.assertEquals(r[i], element, \"at index #\" + i);\n+            } else {\n+                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n+            }\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals($type$[] r, $type$[] a, int[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]]);\n+        }\n+    }\n+\n+    static void assertcompressArraysEquals($type$[] r, $type$[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], ($type$)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals($type$[] r, $type$[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], ($type$)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals($type$[] r, $type$[] a, $type$[] order, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]]);\n+        }\n+    }\n+\n+    static void assertRearrangeArraysEquals($type$[] r, $type$[] a, int[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], ($type$)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+order[i+j]], \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], ($type$)0, \"at index #\" + idx + \", input = \" + a[i+order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertSelectFromArraysEquals($type$[] r, $type$[] a, $type$[] order, boolean[] mask, int vector_len) {\n+        int i = 0, j = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                for (j = 0; j < vector_len; j++) {\n+                    if (mask[j % SPECIES.length()])\n+                         Assert.assertEquals(r[i+j], a[i+(int)order[i+j]]);\n+                    else\n+                         Assert.assertEquals(r[i+j], ($type$)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (mask[j % SPECIES.length()])\n+                Assert.assertEquals(r[i+j], a[i+(int)order[i+j]], \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+            else\n+                Assert.assertEquals(r[i+j], ($type$)0, \"at index #\" + idx + \", input = \" + a[i+(int)order[i+j]] + \", mask = \" + mask[j % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals($type$[] r, $type$[] a) {\n+        int i = 0;\n+        for (; i < a.length; i += SPECIES.length()) {\n+            int idx = i;\n+            for (int j = idx; j < (idx + SPECIES.length()); j++)\n+                a[j]=a[idx];\n+        }\n+\n+        try {\n+            for (i = 0; i < a.length; i++) {\n+                Assert.assertEquals(r[i], a[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], a[i], \"at index #\" + i + \", input = \" + a[i]);\n+        }\n+    }\n+\n+    interface FBinOp {\n+        $type$ apply($type$ a, $type$ b);\n+    }\n+\n+    interface FBinMaskOp {\n+        $type$ apply($type$ a, $type$ b, boolean m);\n+\n+        static FBinMaskOp lift(FBinOp f) {\n+            return (a, b, m) -> m ? f.apply(a, b) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i]), \"(\" + a[i] + \", \" + b[i] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals($type$[] r, $type$[] a, $type$[] b, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                                \"(\" + a[i] + \", \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \") at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$[] b, boolean[] mask, FBinOp f) {\n+        assertArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastLongArraysEquals($type$[] r, $type$[] a, $type$[] b, boolean[] mask, FBinOp f) {\n+        assertBroadcastLongArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastLongArraysEquals($type$[] r, $type$[] a, $type$[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]), mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], ($type$)((long)b[(i \/ SPECIES.length()) * SPECIES.length()]),\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals($type$[] r, $type$[] a, $type$[] b, FBinOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]));\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j]), \"at index #\" + i + \", \" + j);\n+        }\n+    }\n+\n+    static void assertShiftArraysEquals($type$[] r, $type$[] a, $type$[] b, boolean[] mask, FBinOp f) {\n+        assertShiftArraysEquals(r, a, b, mask, FBinMaskOp.lift(f));\n+    }\n+\n+    static void assertShiftArraysEquals($type$[] r, $type$[] a, $type$[] b, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        int j = 0;\n+        try {\n+            for (; j < a.length; j += SPECIES.length()) {\n+                for (i = 0; i < SPECIES.length(); i++) {\n+                    Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]));\n+                }\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i+j], f.apply(a[i+j], b[j], mask[i]), \"at index #\" + i + \", input1 = \" + a[i+j] + \", input2 = \" + b[j] + \", mask = \" + mask[i]);\n+        }\n+    }\n+\n+    interface FTernOp {\n+        $type$ apply($type$ a, $type$ b, $type$ c);\n+    }\n+\n+    interface FTernMaskOp {\n+        $type$ apply($type$ a, $type$ b, $type$ c, boolean m);\n+\n+        static FTernMaskOp lift(FTernOp f) {\n+            return (a, b, c, m) -> m ? f.apply(a, b, c) : a;\n+        }\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, boolean[] mask, FTernOp f) {\n+        assertArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, boolean[] mask, FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[i], mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \"\n+              + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i]), \"at index #\" +\n+                                i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[(i \/ SPECIES.length()) * SPECIES.length()] + \",  input3 = \" + c[i]);\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[i], c[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                                b[i] + \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertAltBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, boolean[] mask,\n+                                            FTernOp f) {\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertAltBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, boolean[] mask,\n+                                            FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                    mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()], c[i],\n+                                mask[i % SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i] +\n+                                \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[i] + \", mask = \" + mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, FTernOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]), \"at index #\" + i + \", input1 = \" + a[i]\n+                                + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] + \", input3 = \" +\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()]);\n+        }\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, boolean[] mask,\n+                                                  FTernOp f) {\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, FTernMaskOp.lift(f));\n+    }\n+\n+    static void assertDoubleBroadcastArraysEquals($type$[] r, $type$[] a, $type$[] b, $type$[] c, boolean[] mask,\n+                                                  FTernMaskOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                    c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]));\n+            }\n+        } catch (AssertionError err) {\n+            Assert.assertEquals(r[i], f.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()],\n+                                c[(i \/ SPECIES.length()) * SPECIES.length()], mask[i % SPECIES.length()]), \"at index #\"\n+                                + i + \", input1 = \" + a[i] + \", input2 = \" + b[(i \/ SPECIES.length()) * SPECIES.length()] +\n+                                \", input3 = \" + c[(i \/ SPECIES.length()) * SPECIES.length()] + \", mask = \" +\n+                                mask[i % SPECIES.length()]);\n+        }\n+    }\n+\n+\n+#if[FP]\n+    static boolean isWithin1Ulp($type$ actual, $type$ expected) {\n+        if ($Type$.isNaN(expected) && !$Type$.isNaN(actual)) {\n+            return false;\n+        } else if (!$Type$.isNaN(expected) && $Type$.isNaN(actual)) {\n+            return false;\n+        }\n+\n+        $type$ low = Math.nextDown(expected);\n+        $type$ high = Math.nextUp(expected);\n+\n+        if ($Type$.compare(low, expected) > 0) {\n+            return false;\n+        }\n+\n+        if ($Type$.compare(high, expected) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp($type$[] r, $type$[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp($type$[] r, $type$[] a, $type$[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue($Type$.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp($type$[] r, $type$[] a, $type$[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue($Type$.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue($Type$.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n+#end[FP]\n+\n+    interface FBinArrayOp {\n+        $type$ apply($type$[] a, int b);\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, FBinArrayOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(r[i], f.apply(a, i));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherScatterOp {\n+        $type$[] apply($type$[] a, int ix, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, int[] b, FGatherScatterOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            $type$[] ref = f.apply(a, i, b, i);\n+            $type$[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FGatherMaskedOp {\n+        $type$[] apply($type$[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    interface FScatterMaskedOp {\n+        $type$[] apply($type$[] r, $type$[] a, int ix, boolean[] mask, int[] b, int iy);\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, int[] b, boolean[] mask, FGatherMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            $type$[] ref = f.apply(a, i, mask, b, i);\n+            $type$[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, int[] b, boolean[] mask, FScatterMaskedOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(r, a, i, mask, b, i));\n+            }\n+        } catch (AssertionError e) {\n+            $type$[] ref = f.apply(r, a, i, mask, b, i);\n+            $type$[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref,\n+              \"(ref: \" + Arrays.toString(ref) + \", res: \" + Arrays.toString(res) + \", a: \"\n+              + Arrays.toString(Arrays.copyOfRange(a, i, i+SPECIES.length()))\n+              + \", b: \"\n+              + Arrays.toString(Arrays.copyOfRange(b, i, i+SPECIES.length()))\n+              + \", r: \"\n+              + Arrays.toString(Arrays.copyOfRange(r, i, i+SPECIES.length()))\n+              + \", mask: \"\n+              + Arrays.toString(mask)\n+              + \" at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneOp {\n+        $type$[] apply($type$[] a, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, int origin, FLaneOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            $type$[] ref = f.apply(a, origin, i);\n+            $type$[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i);\n+        }\n+    }\n+\n+    interface FLaneBop {\n+        $type$[] apply($type$[] a, $type$[] b, int origin, int idx);\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$[] b, int origin, FLaneBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, i));\n+            }\n+        } catch (AssertionError e) {\n+            $type$[] ref = f.apply(a, b, origin, i);\n+            $type$[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLaneMaskedBop {\n+        $type$[] apply($type$[] a, $type$[] b, int origin, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$[] b, int origin, boolean[] mask, FLaneMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            $type$[] ref = f.apply(a, b, origin, mask, i);\n+            $type$[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin);\n+        }\n+    }\n+\n+    interface FLanePartBop {\n+        $type$[] apply($type$[] a, $type$[] b, int origin, int part, int idx);\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$[] b, int origin, int part, FLanePartBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, i));\n+            }\n+        } catch (AssertionError e) {\n+            $type$[] ref = f.apply(a, b, origin, part, i);\n+            $type$[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+    interface FLanePartMaskedBop {\n+        $type$[] apply($type$[] a, $type$[] b, int origin, int part, boolean[] mask, int idx);\n+    }\n+\n+    static void assertArraysEquals($type$[] r, $type$[] a, $type$[] b, int origin, int part, boolean[] mask, FLanePartMaskedBop f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i += SPECIES.length()) {\n+                Assert.assertEquals(Arrays.copyOfRange(r, i, i+SPECIES.length()),\n+                  f.apply(a, b, origin, part, mask, i));\n+            }\n+        } catch (AssertionError e) {\n+            $type$[] ref = f.apply(a, b, origin, part, mask, i);\n+            $type$[] res = Arrays.copyOfRange(r, i, i+SPECIES.length());\n+            Assert.assertEquals(res, ref, \"(ref: \" + Arrays.toString(ref)\n+              + \", res: \" + Arrays.toString(res)\n+              + \"), at index #\" + i\n+              + \", at origin #\" + origin\n+              + \", with part #\" + part);\n+        }\n+    }\n+\n+#if[!Int]\n+#if[!byteOrShort]\n+    static int intCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Integer.MAX_VALUE;\n+            case 1:\n+                return Integer.MIN_VALUE;\n+            case 2:\n+                return Integer.MIN_VALUE;\n+            case 3:\n+                return Integer.MAX_VALUE;\n+            default:\n+                return (int)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<$type$[]>> INT_$TYPE$_GENERATORS = List.of(\n+            withToString(\"$type$[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(-i * 5));\n+            }),\n+            withToString(\"$type$[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(i * 5));\n+            }),\n+            withToString(\"$type$[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+            }),\n+            withToString(\"$type$[intCornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)intCornerCaseValue(i));\n+            })\n+    );\n+#end[!byteOrShort]\n+#end[!Int]\n+\n+    static void assertArraysEquals(int[] r, $type$[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (int)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (int)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+#if[!Long]\n+#if[FP]\n+    static long longCornerCaseValue(int i) {\n+        switch(i % 5) {\n+            case 0:\n+                return Long.MAX_VALUE;\n+            case 1:\n+                return Long.MIN_VALUE;\n+            case 2:\n+                return Long.MIN_VALUE;\n+            case 3:\n+                return Long.MAX_VALUE;\n+            default:\n+                return (long)0;\n+        }\n+    }\n+\n+    static final List<IntFunction<$type$[]>> LONG_$TYPE$_GENERATORS = List.of(\n+            withToString(\"$type$[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(-i * 5));\n+            }),\n+            withToString(\"$type$[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(i * 5));\n+            }),\n+            withToString(\"$type$[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+            }),\n+            withToString(\"$type$[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)longCornerCaseValue(i));\n+            })\n+    );\n+#end[FP]\n+#end[!Long]\n+\n+#if[byte]\n+    static void assertArraysEquals($type$[] r, $type$[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+#end[byte]\n+\n+    static void assertArraysEquals(long[] r, $type$[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (long)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (long)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+\n+#if[!Double]\n+    static void assertArraysEquals(double[] r, $type$[] a, int offs) {\n+        int i = 0;\n+        try {\n+            for (; i < r.length; i++) {\n+                Assert.assertEquals(r[i], (double)(a[i+offs]));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(r[i], (double)(a[i+offs]), \"at index #\" + i + \", input = \" + a[i+offs]);\n+        }\n+    }\n+#end[!Double]\n+\n+\n+    static $bitstype$ bits($type$ e) {\n+        return {#if[FP]? $Type$.$type$To$Bitstype$Bits(e): e};\n+    }\n+\n+    static final List<IntFunction<$type$[]>> $TYPE$_GENERATORS = List.of(\n+            withToString(\"$type$[-i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(-i * 5));\n+            }),\n+            withToString(\"$type$[i * 5]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(i * 5));\n+            }),\n+            withToString(\"$type$[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ((($type$)(i + 1) == 0) ? 1 : ($type$)(i + 1)));\n+            }),\n+            withToString(\"$type$[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    \/\/ Create combinations of pairs\n+    \/\/ @@@ Might be sensitive to order e.g. div by 0\n+    static final List<List<IntFunction<$type$[]>>> $TYPE$_GENERATOR_PAIRS =\n+        Stream.of($TYPE$_GENERATORS.get(0)).\n+                flatMap(fa -> $TYPE$_GENERATORS.stream().skip(1).map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] boolUnaryOpProvider() {\n+        return BOOL_ARRAY_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<$type$[]>>> $TYPE$_GENERATOR_TRIPLES =\n+        $TYPE$_GENERATOR_PAIRS.stream().\n+                flatMap(pair -> $TYPE$_GENERATORS.stream().map(f -> List.of(pair.get(0), pair.get(1), f))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] $type$BinaryOpProvider() {\n+        return $TYPE$_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$IndexedOpProvider() {\n+        return $TYPE$_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$BinaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$TernaryOpProvider() {\n+        return $TYPE$_GENERATOR_TRIPLES.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$TernaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_GENERATOR_TRIPLES.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$UnaryOpProvider() {\n+        return $TYPE$_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$UnaryOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+#if[!Int]\n+#if[!byteOrShort]\n+    @DataProvider\n+    public Object[][] $type$toIntUnaryOpProvider() {\n+        return INT_$TYPE$_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+#end[!byteOrShort]\n+#end[!Int]\n+\n+#if[FP]\n+    @DataProvider\n+    public Object[][] $type$toLongUnaryOpProvider() {\n+        return LONG_$TYPE$_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+#end[FP]\n+\n+    @DataProvider\n+    public Object[][] maskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] maskCompareOpProvider() {\n+        return BOOLEAN_MASK_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shuffleCompareOpProvider() {\n+        return INT_SHUFFLE_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$UnaryOpShuffleProvider() {\n+        return INT_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> $TYPE$_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$UnaryOpShuffleMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> $TYPE$_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+#if[!Int]\n+    static final List<BiFunction<Integer,Integer,$type$[]>> $TYPE$_SHUFFLE_GENERATORS = List.of(\n+            withToStringBi(\"shuffle[random]\", (Integer l, Integer m) -> {\n+                $type$[] a = new $type$[l];\n+#if[ByteMax]\n+                int upper = Math.min(Byte.MAX_VALUE + 1, m);\n+#else[ByteMax]\n+                int upper = m;\n+#end[ByteMax]\n+                for (int i = 0; i < 1; i++) {\n+                    a[i] = ($type$)RAND.nextInt(upper);\n+                }\n+                return a;\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] $type$UnaryOpSelectFromProvider() {\n+        return $TYPE$_SHUFFLE_GENERATORS.stream().\n+                flatMap(fs -> $TYPE$_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fs};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$UnaryOpSelectFromMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_SHUFFLE_GENERATORS.stream().\n+                    flatMap(fs -> $TYPE$_GENERATORS.stream().map(fa -> {\n+                        return new Object[] {fa, fs, fm};\n+                }))).\n+                toArray(Object[][]::new);\n+    }\n+\n+#end[!Int]\n+\n+    static final List<IntFunction<$type$[]>> $TYPE$_COMPARE_GENERATORS = List.of(\n+            withToString(\"$type$[i]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)i);\n+            }),\n+            withToString(\"$type$[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n+            withToString(\"$type$[i + 1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(i + 1));\n+            }),\n+            withToString(\"$type$[i - 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(i - 2));\n+            }),\n+            withToString(\"$type$[zigZag(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> i%3 == 0 ? ($type$)i : (i%3 == 1 ? ($type$)(i + 1) : ($type$)(i - 2)));\n+            }),\n+            withToString(\"$type$[cornerCaseValue(i)]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> cornerCaseValue(i));\n+            })\n+    );\n+\n+    static final List<List<IntFunction<$type$[]>>> $TYPE$_TEST_GENERATOR_ARGS =\n+        $TYPE$_COMPARE_GENERATORS.stream().\n+                map(fa -> List.of(fa)).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] $type$TestOpProvider() {\n+        return $TYPE$_TEST_GENERATOR_ARGS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$TestOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_TEST_GENERATOR_ARGS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static final List<List<IntFunction<$type$[]>>> $TYPE$_COMPARE_GENERATOR_PAIRS =\n+        $TYPE$_COMPARE_GENERATORS.stream().\n+                flatMap(fa -> $TYPE$_COMPARE_GENERATORS.stream().map(fb -> List.of(fa, fb))).\n+                collect(Collectors.toList());\n+\n+    @DataProvider\n+    public Object[][] $type$CompareOpProvider() {\n+        return $TYPE$_COMPARE_GENERATOR_PAIRS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$CompareOpMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_COMPARE_GENERATOR_PAIRS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface To$Type$F {\n+        $type$ apply(int i);\n+    }\n+\n+    static $type$[] fill(int s , To$Type$F f) {\n+        return fill(new $type$[s], f);\n+    }\n+\n+    static $type$[] fill($type$[] a, To$Type$F f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static $type$ cornerCaseValue(int i) {\n+#if[FP]\n+        switch(i % 7) {\n+            case 0:\n+                return $Wideboxtype$.MAX_VALUE;\n+            case 1:\n+                return $Wideboxtype$.MIN_VALUE;\n+            case 2:\n+                return $Wideboxtype$.NEGATIVE_INFINITY;\n+            case 3:\n+                return $Wideboxtype$.POSITIVE_INFINITY;\n+            case 4:\n+                return $Wideboxtype$.NaN;\n+            case 5:\n+                return ($type$)0.0;\n+            default:\n+                return ($type$)-0.0;\n+        }\n+#else[FP]\n+        switch(i % 5) {\n+            case 0:\n+                return $Wideboxtype$.MAX_VALUE;\n+            case 1:\n+                return $Wideboxtype$.MIN_VALUE;\n+            case 2:\n+                return $Wideboxtype$.MIN_VALUE;\n+            case 3:\n+                return $Wideboxtype$.MAX_VALUE;\n+            default:\n+                return ($type$)0;\n+        }\n+#end[FP]\n+    }\n+\n+    static $type$ get($type$[] a, int i) {\n+        return ($type$) a[i];\n+    }\n+\n+    static final IntFunction<$type$[]> fr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new $type$[length];\n+    };\n+\n+    static final IntFunction<boolean[]> fmr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new boolean[length];\n+    };\n+\n+#if[!Long]\n+    static final IntFunction<long[]> lfr = (vl) -> {\n+        int length = BUFFER_REPS * vl;\n+        return new long[length];\n+    };\n+#end[!Long]\n+\n+#if[BITWISE]\n+    static void replaceZero($type$[] a, $type$ v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero($type$[] a, boolean[] mask, $type$ v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static $type$ ROL_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateLeft(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ ROR_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateRight(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ TRAILING_ZEROS_COUNT_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfTrailingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+#else[short]\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ LEADING_ZEROS_COUNT_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfLeadingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+#else[short]\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ REVERSE_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.reverse(a);\n+#else[intOrLong]\n+#if[short]\n+        $type$ b = ROL_scalar(a, ($type$) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+#else[short]\n+        $type$ b = ($type$) ROL_scalar(a, ($type$) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+#if[intOrLong]\n+    static $type$ COMPRESSBITS_scalar($type$ a, $type$ b) {\n+        a = a & b;\n+        $type$ maskCount = ~b << 1;\n+#if[int]\n+        int iters = 5;\n+#else[int]\n+        int iters = 6;\n+#end[int]\n+\n+        for (int i = 0; i < iters; i++) {\n+            $type$ maskPrefix = maskCount  ^ (maskCount << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+#if[long]\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+#end[long]\n+            $type$ maskMove = maskPrefix & b;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << i));\n+            $type$ t = a & maskMove;\n+            a = (a ^ t) | (t >>> (1 << i));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+        return a;\n+    }\n+\n+    static $type$ EXPANDBITS_scalar($type$ a, $type$ b) {\n+        $type$ originalMask = b;\n+        $type$ maskCount = ~b << 1;\n+#if[int]\n+        $type$[] array = new $type$[5];\n+        int iters = 5;\n+#else[int]\n+        $type$[] array = new $type$[6];\n+        int iters = 6;\n+#end[int]\n+\n+        for (int j = 0; j < iters; j++) {\n+            $type$ maskPrefix = maskCount  ^ (maskCount  << 1);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 2);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 4);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 8);\n+            maskPrefix = maskPrefix ^ (maskPrefix << 16);\n+#if[long]\n+            maskPrefix = maskPrefix ^ (maskPrefix << 32);\n+#end[long]\n+            $type$ maskMove = maskPrefix & b;\n+            array[j] = maskMove;\n+            b = (b ^ maskMove) | (maskMove >>> (1 << j));\n+            maskCount = maskCount & ~maskPrefix;\n+        }\n+\n+        for (int j = iters-1; j >= 0; j--) {\n+            $type$ maskMove = array[j];\n+            $type$ t = a << (1 << j);\n+            a = (a & ~maskMove) | (t & maskMove);\n+        }\n+        return (a & originalMask);\n+    }\n+#end[intOrLong]\n+\n+#end[BITWISE]\n+    static boolean eq($type$ a, $type$ b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq($type$ a, $type$ b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt($type$ a, $type$ b) {\n+        return a < b;\n+    }\n+\n+    static boolean le($type$ a, $type$ b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt($type$ a, $type$ b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge($type$ a, $type$ b) {\n+        return a >= b;\n+    }\n+\n+#if[!FP]\n+    static boolean ult($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) >= 0;\n+    }\n+#end[!FP]\n+\n+    static $type$ firstNonZero($type$ a, $type$ b) {\n+        return $Boxtype$.compare(a, ($type$) 0) != 0 ? a : b;\n+    }\n+\n+    @Test\n+    static void smokeTest1() {\n+        $abstractvectortype$ three = $abstractvectortype$.broadcast(SPECIES, (byte)-3);\n+        $abstractvectortype$ three2 = ($abstractvectortype$) SPECIES.broadcast(-3);\n+        assert(three.eq(three2).allTrue());\n+        $abstractvectortype$ three3 = three2.broadcast(1).broadcast(-3);\n+        assert(three.eq(three3).allTrue());\n+        int scale = 2;\n+        Class<?> ETYPE = $type$.class;\n+        if (ETYPE == double.class || ETYPE == long.class)\n+            scale = 1000000;\n+        else if (ETYPE == byte.class && SPECIES.length() >= 64)\n+            scale = 1;\n+        $abstractvectortype$ higher = three.addIndex(scale);\n+        VectorMask<$Boxtype$> m = three.compare(VectorOperators.LE, higher);\n+        assert(m.allTrue());\n+        m = higher.min(($type$)-1).test(VectorOperators.IS_NEGATIVE);\n+        assert(m.allTrue());\n+#if[FP]\n+        m = higher.test(VectorOperators.IS_FINITE);\n+        assert(m.allTrue());\n+#end[FP]\n+        $type$ max = higher.reduceLanes(VectorOperators.MAX);\n+        assert(max == -3 + scale * (SPECIES.length()-1));\n+    }\n+\n+    private static $type$[]\n+    bothToArray($abstractvectortype$ a, $abstractvectortype$ b) {\n+        $type$[] r = new $type$[a.length() + b.length()];\n+        a.intoArray(r, 0);\n+        b.intoArray(r, a.length());\n+        return r;\n+    }\n+\n+    @Test\n+    static void smokeTest2() {\n+        \/\/ Do some zipping and shuffling.\n+        $abstractvectortype$ io = ($abstractvectortype$) SPECIES.broadcast(0).addIndex(1);\n+        $abstractvectortype$ io2 = ($abstractvectortype$) VectorShuffle.iota(SPECIES,0,1,false).toVector();\n+        Assert.assertEquals(io, io2);\n+        $abstractvectortype$ a = io.add(($type$)1); \/\/[1,2]\n+        $abstractvectortype$ b = a.neg();  \/\/[-1,-2]\n+        $type$[] abValues = bothToArray(a,b); \/\/[1,2,-1,-2]\n+        VectorShuffle<$Boxtype$> zip0 = VectorShuffle.makeZip(SPECIES, 0);\n+        VectorShuffle<$Boxtype$> zip1 = VectorShuffle.makeZip(SPECIES, 1);\n+        $abstractvectortype$ zab0 = a.rearrange(zip0,b); \/\/[1,-1]\n+        $abstractvectortype$ zab1 = a.rearrange(zip1,b); \/\/[2,-2]\n+        $type$[] zabValues = bothToArray(zab0, zab1); \/\/[1,-1,2,-2]\n+        \/\/ manually zip\n+        $type$[] manual = new $type$[zabValues.length];\n+        for (int i = 0; i < manual.length; i += 2) {\n+            manual[i+0] = abValues[i\/2];\n+            manual[i+1] = abValues[a.length() + i\/2];\n+        }\n+        Assert.assertEquals(Arrays.toString(zabValues), Arrays.toString(manual));\n+        VectorShuffle<$Boxtype$> unz0 = VectorShuffle.makeUnzip(SPECIES, 0);\n+        VectorShuffle<$Boxtype$> unz1 = VectorShuffle.makeUnzip(SPECIES, 1);\n+        $abstractvectortype$ uab0 = zab0.rearrange(unz0,zab1);\n+        $abstractvectortype$ uab1 = zab0.rearrange(unz1,zab1);\n+        $type$[] abValues1 = bothToArray(uab0, uab1);\n+        Assert.assertEquals(Arrays.toString(abValues), Arrays.toString(abValues1));\n+    }\n+\n+    static void iotaShuffle() {\n+        $abstractvectortype$ io = ($abstractvectortype$) SPECIES.broadcast(0).addIndex(1);\n+        $abstractvectortype$ io2 = ($abstractvectortype$) VectorShuffle.iota(SPECIES, 0 , 1, false).toVector();\n+        Assert.assertEquals(io, io2);\n+    }\n+\n+    @Test\n+    \/\/ Test all shuffle related operations.\n+    static void shuffleTest() {\n+        \/\/ To test backend instructions, make sure that C2 is used.\n+        for (int loop = 0; loop < INVOC_COUNT * INVOC_COUNT; loop++) {\n+            iotaShuffle();\n+        }\n+    }\n+\n+    @Test\n+    void viewAsIntegeralLanesTest() {\n+#if[FP]\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        VectorSpecies<?> asIntegralSpecies = asIntegral.species();\n+        Assert.assertNotEquals(asIntegralSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asIntegralSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asIntegralSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asIntegral.viewAsFloatingLanes().species(), SPECIES);\n+#else[FP]\n+        Vector<?> asIntegral = SPECIES.zero().viewAsIntegralLanes();\n+        Assert.assertEquals(asIntegral.species(), SPECIES);\n+#end[FP]\n+    }\n+\n+#if[FP]\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        Assert.assertEquals(asFloating.species(), SPECIES);\n+    }\n+#else[FP]\n+#if[byteOrShort]\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    void viewAsFloatingLanesTest() {\n+        SPECIES.zero().viewAsFloatingLanes();\n+    }\n+#else[byteOrShort]\n+    @Test\n+    void viewAsFloatingLanesTest() {\n+        Vector<?> asFloating = SPECIES.zero().viewAsFloatingLanes();\n+        VectorSpecies<?> asFloatingSpecies = asFloating.species();\n+        Assert.assertNotEquals(asFloatingSpecies.elementType(), SPECIES.elementType());\n+        Assert.assertEquals(asFloatingSpecies.vectorShape(), SPECIES.vectorShape());\n+        Assert.assertEquals(asFloatingSpecies.length(), SPECIES.length());\n+        Assert.assertEquals(asFloating.viewAsIntegralLanes().species(), SPECIES);\n+    }\n+#end[byteOrShort]\n+#end[FP]\n+\n+#if[BITWISE]\n+    @Test\n+    \/\/ Test div by 0.\n+    static void bitwiseDivByZeroSmokeTest() {\n+        try {\n+            $abstractvectortype$ a = ($abstractvectortype$) SPECIES.broadcast(0).addIndex(1);\n+            $abstractvectortype$ b = ($abstractvectortype$) SPECIES.broadcast(0);\n+            a.div(b);\n+            Assert.fail();\n+        } catch (ArithmeticException e) {\n+        }\n+\n+        try {\n+            $abstractvectortype$ a = ($abstractvectortype$) SPECIES.broadcast(0).addIndex(1);\n+            $abstractvectortype$ b = ($abstractvectortype$) SPECIES.broadcast(0);\n+            VectorMask<$Boxtype$> m = a.lt(($type$) 1);\n+            a.div(b, m);\n+            Assert.fail();\n+        } catch (ArithmeticException e) {\n+        }\n+    }\n+#end[BITWISE]\n+    static $type$ ADD($type$ a, $type$ b) {\n+        return ($type$)(a + b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ADD$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::ADD);\n+    }\n+    static $type$ add($type$ a, $type$ b) {\n+        return ($type$)(a + b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void add$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.add(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::add);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ADD$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::ADD);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void add$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.add(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::add);\n+    }\n+    static $type$ SUB($type$ a, $type$ b) {\n+        return ($type$)(a - b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void SUB$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::SUB);\n+    }\n+    static $type$ sub($type$ a, $type$ b) {\n+        return ($type$)(a - b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void sub$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.sub(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::sub);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void SUB$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::SUB);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void sub$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.sub(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::sub);\n+    }\n+    static $type$ MUL($type$ a, $type$ b) {\n+        return ($type$)(a * b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void MUL$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::MUL);\n+    }\n+    static $type$ mul($type$ a, $type$ b) {\n+        return ($type$)(a * b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void mul$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.mul(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::mul);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void MUL$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::MUL);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void mul$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.mul(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::mul);\n+    }\n+#if[FP]\n+\n+    static $type$ DIV($type$ a, $type$ b) {\n+        return ($type$)(a \/ b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void DIV$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::DIV);\n+    }\n+    static $type$ div($type$ a, $type$ b) {\n+        return ($type$)(a \/ b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void div$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.div(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::div);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void DIV$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::DIV);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void div$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.div(bv, vmask).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::div);\n+    }\n+#end[FP]\n+\n+#if[BITWISE]\n+\n+    static $type$ DIV($type$ a, $type$ b) {\n+        return ($type$)(a \/ b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void DIV$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, ($type$) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::DIV);\n+    }\n+    static $type$ div($type$ a, $type$ b) {\n+        return ($type$)(a \/ b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void div$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, ($type$) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.div(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::div);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void DIV$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, ($type$) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::DIV);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void div$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, ($type$) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.div(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::div);\n+    }\n+#end[BITWISE]\n+\n+    static $type$ FIRST_NONZERO($type$ a, $type$ b) {\n+        return ($type$)({#if[FP]?Double.doubleToLongBits}(a)!=0?a:b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void FIRST_NONZERO$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::FIRST_NONZERO);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void FIRST_NONZERO$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::FIRST_NONZERO);\n+    }\n+#if[BITWISE]\n+\n+    static $type$ AND($type$ a, $type$ b) {\n+        return ($type$)(a & b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void AND$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::AND);\n+    }\n+    static $type$ and($type$ a, $type$ b) {\n+        return ($type$)(a & b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void and$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.and(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::and);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void AND$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::AND);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static $type$ AND_NOT($type$ a, $type$ b) {\n+        return ($type$)(a & ~b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void AND_NOT$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::AND_NOT);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void AND_NOT$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::AND_NOT);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static $type$ OR($type$ a, $type$ b) {\n+        return ($type$)(a | b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void OR$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::OR);\n+    }\n+    static $type$ or($type$ a, $type$ b) {\n+        return ($type$)(a | b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void or$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.or(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::or);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void OR$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::OR);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static $type$ XOR($type$ a, $type$ b) {\n+        return ($type$)(a ^ b);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void XOR$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::XOR);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void XOR$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::XOR);\n+    }\n+#end[BITWISE]\n+\n+#if[intOrLong]\n+\n+    static $type$ COMPRESS_BITS($type$ a, $type$ b) {\n+        return ($type$)(COMPRESSBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void COMPRESS_BITS$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::COMPRESS_BITS);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void COMPRESS_BITS$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::COMPRESS_BITS);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+    static $type$ EXPAND_BITS($type$ a, $type$ b) {\n+        return ($type$)(EXPANDBITS_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void EXPAND_BITS$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::EXPAND_BITS);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void EXPAND_BITS$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::EXPAND_BITS);\n+    }\n+#end[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void add$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.add(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::add);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void add$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.add(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, $vectorteststype$::add);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void sub$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.sub(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::sub);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void sub$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.sub(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, $vectorteststype$::sub);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void mul$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.mul(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::mul);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void mul$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.mul(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, $vectorteststype$::mul);\n+    }\n+#if[FP]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void div$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.div(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::div);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void div$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.div(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, $vectorteststype$::div);\n+    }\n+#end[FP]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void div$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, ($type$) 1);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.div(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::div);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void div$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, ($type$) 1);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.div(b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, $vectorteststype$::div);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void OR$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.OR, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::OR);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void or$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.or(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::or);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void OR$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.OR, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, $vectorteststype$::OR);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void AND$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::AND);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void and$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.and(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::and);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void AND$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.AND, b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, mask, $vectorteststype$::AND);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void OR$vectorteststype$BroadcastLongSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.OR, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, $vectorteststype$::OR);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void OR$vectorteststype$BroadcastMaskedLongSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.OR, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, mask, $vectorteststype$::OR);\n+    }\n+#end[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ADD$vectorteststype$BroadcastLongSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, $vectorteststype$::ADD);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ADD$vectorteststype$BroadcastMaskedLongSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.ADD, (long)b[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastLongArraysEquals(r, a, b, mask, $vectorteststype$::ADD);\n+    }\n+#if[intOrLong]\n+\n+    static $type$ LSHL($type$ a, $type$ b) {\n+        return ($type$)((a << b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHL$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::LSHL);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHL$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::LSHL);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+    static $type$ LSHL($type$ a, $type$ b) {\n+        return ($type$)((a << (b & 0x7)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHL$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::LSHL);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHL$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::LSHL);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+    static $type$ LSHL($type$ a, $type$ b) {\n+        return ($type$)((a << (b & 0xF)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHL$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::LSHL);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHL$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::LSHL);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+    static $type$ ASHR($type$ a, $type$ b) {\n+        return ($type$)((a >> b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ASHR$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::ASHR);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ASHR$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::ASHR);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+    static $type$ ASHR($type$ a, $type$ b) {\n+        return ($type$)((a >> (b & 0x7)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ASHR$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::ASHR);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ASHR$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::ASHR);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+    static $type$ ASHR($type$ a, $type$ b) {\n+        return ($type$)((a >> (b & 0xF)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ASHR$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::ASHR);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ASHR$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::ASHR);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+    static $type$ LSHR($type$ a, $type$ b) {\n+        return ($type$)((a >>> b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHR$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::LSHR);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHR$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::LSHR);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+    static $type$ LSHR($type$ a, $type$ b) {\n+        return ($type$)(((a & 0xFF) >>> (b & 0x7)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHR$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::LSHR);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHR$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::LSHR);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+    static $type$ LSHR($type$ a, $type$ b) {\n+        return ($type$)(((a & 0xFFFF) >>> (b & 0xF)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHR$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::LSHR);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHR$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::LSHR);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+    static $type$ LSHL_unary($type$ a, $type$ b) {\n+        return ($type$)((a << b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHL$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::LSHL_unary);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHL$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::LSHL_unary);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+    static $type$ LSHL_unary($type$ a, $type$ b) {\n+        return ($type$)((a << (b & 7)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHL$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::LSHL_unary);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHL$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::LSHL_unary);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+    static $type$ LSHL_unary($type$ a, $type$ b) {\n+        return ($type$)((a << (b & 15)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHL$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::LSHL_unary);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHL$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::LSHL_unary);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+    static $type$ LSHR_unary($type$ a, $type$ b) {\n+        return ($type$)((a >>> b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHR$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::LSHR_unary);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHR$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::LSHR_unary);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+    static $type$ LSHR_unary($type$ a, $type$ b) {\n+        return ($type$)(((a & 0xFF) >>> (b & 7)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHR$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::LSHR_unary);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHR$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::LSHR_unary);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+    static $type$ LSHR_unary($type$ a, $type$ b) {\n+        return ($type$)(((a & 0xFFFF) >>> (b & 15)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void LSHR$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::LSHR_unary);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void LSHR$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::LSHR_unary);\n+    }\n+#end[short]\n+\n+#if[intOrLong]\n+\n+    static $type$ ASHR_unary($type$ a, $type$ b) {\n+        return ($type$)((a >> b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ASHR$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::ASHR_unary);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ASHR$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::ASHR_unary);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+    static $type$ ASHR_unary($type$ a, $type$ b) {\n+        return ($type$)((a >> (b & 7)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ASHR$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::ASHR_unary);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ASHR$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::ASHR_unary);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+    static $type$ ASHR_unary($type$ a, $type$ b) {\n+        return ($type$)((a >> (b & 15)));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ASHR$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::ASHR_unary);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ASHR$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::ASHR_unary);\n+    }\n+#end[short]\n+\n+#if[BITWISE]\n+\n+    static $type$ ROR($type$ a, $type$ b) {\n+        return ($type$)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ROR$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::ROR);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ROR$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::ROR);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static $type$ ROL($type$ a, $type$ b) {\n+        return ($type$)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ROL$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::ROL);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ROL$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::ROL);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static $type$ ROR_unary($type$ a, $type$ b) {\n+        return ($type$)(ROR_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ROR$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::ROR_unary);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ROR$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::ROR_unary);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static $type$ ROL_unary($type$ a, $type$ b) {\n+        return ($type$)(ROL_scalar(a,b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ROL$vectorteststype$ScalarShift(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, $vectorteststype$::ROL_unary);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void ROL$vectorteststype$ScalarShiftMasked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertShiftArraysEquals(r, a, b, mask, $vectorteststype$::ROL_unary);\n+    }\n+#end[BITWISE]\n+\n+    static $type$ MIN($type$ a, $type$ b) {\n+        return ($type$)(Math.min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void MIN$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::MIN);\n+    }\n+    static $type$ min($type$ a, $type$ b) {\n+        return ($type$)(Math.min(a, b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void min$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.min(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::min);\n+    }\n+    static $type$ MAX($type$ a, $type$ b) {\n+        return ($type$)(Math.max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void MAX$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::MAX);\n+    }\n+    static $type$ max($type$ a, $type$ b) {\n+        return ($type$)(Math.max(a, b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void max$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.max(bv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, $vectorteststype$::max);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void MIN$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MIN, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::MIN);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void min$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.min(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::min);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void MAX$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.MAX, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::MAX);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void max$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.max(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, $vectorteststype$::max);\n+    }\n+#if[BITWISE]\n+\n+    static $type$ ANDReduce($type$[] a, int idx) {\n+        $type$ res = -1;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res &= a[i];\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ ANDReduceAll($type$[] a) {\n+        $type$ res = -1;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res &= ANDReduce(a, i);\n+        }\n+\n+        return res;\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void ANDReduce$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        $type$ ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                $vectorteststype$::ANDReduce, $vectorteststype$::ANDReduceAll);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static $type$ ANDReduceMasked($type$[] a, int idx, boolean[] mask) {\n+        $type$ res = -1;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res &= a[i];\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ ANDReduceAllMasked($type$[] a, boolean[] mask) {\n+        $type$ res = -1;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res &= ANDReduceMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void ANDReduce$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                $vectorteststype$::ANDReduceMasked, $vectorteststype$::ANDReduceAllMasked);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static $type$ ORReduce($type$[] a, int idx) {\n+        $type$ res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res |= a[i];\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ ORReduceAll($type$[] a) {\n+        $type$ res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res |= ORReduce(a, i);\n+        }\n+\n+        return res;\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void ORReduce$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                $vectorteststype$::ORReduce, $vectorteststype$::ORReduceAll);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static $type$ ORReduceMasked($type$[] a, int idx, boolean[] mask) {\n+        $type$ res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res |= a[i];\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ ORReduceAllMasked($type$[] a, boolean[] mask) {\n+        $type$ res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res |= ORReduceMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void ORReduce$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                $vectorteststype$::ORReduceMasked, $vectorteststype$::ORReduceAllMasked);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static $type$ XORReduce($type$[] a, int idx) {\n+        $type$ res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res ^= a[i];\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ XORReduceAll($type$[] a) {\n+        $type$ res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res ^= XORReduce(a, i);\n+        }\n+\n+        return res;\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void XORReduce$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                $vectorteststype$::XORReduce, $vectorteststype$::XORReduceAll);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static $type$ XORReduceMasked($type$[] a, int idx, boolean[] mask) {\n+        $type$ res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res ^= a[i];\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ XORReduceAllMasked($type$[] a, boolean[] mask) {\n+        $type$ res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res ^= XORReduceMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void XORReduce$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                $vectorteststype$::XORReduceMasked, $vectorteststype$::XORReduceAllMasked);\n+    }\n+#end[BITWISE]\n+\n+    static $type$ ADDReduce($type$[] a, int idx) {\n+        $type$ res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res += a[i];\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ ADDReduceAll($type$[] a) {\n+        $type$ res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduce(a, i);\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void ADDReduce$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                $vectorteststype$::ADDReduce, $vectorteststype$::ADDReduceAll);\n+    }\n+    static $type$ ADDReduceMasked($type$[] a, int idx, boolean[] mask) {\n+        $type$ res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res += a[i];\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ ADDReduceAllMasked($type$[] a, boolean[] mask) {\n+        $type$ res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void ADDReduce$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                $vectorteststype$::ADDReduceMasked, $vectorteststype$::ADDReduceAllMasked);\n+    }\n+    static $type$ MULReduce($type$[] a, int idx) {\n+        $type$ res = 1;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res *= a[i];\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ MULReduceAll($type$[] a) {\n+        $type$ res = 1;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res *= MULReduce(a, i);\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void MULReduce$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        $type$ ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                $vectorteststype$::MULReduce, $vectorteststype$::MULReduceAll);\n+    }\n+    static $type$ MULReduceMasked($type$[] a, int idx, boolean[] mask) {\n+        $type$ res = 1;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res *= a[i];\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ MULReduceAllMasked($type$[] a, boolean[] mask) {\n+        $type$ res = 1;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res *= MULReduceMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void MULReduce$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                $vectorteststype$::MULReduceMasked, $vectorteststype$::MULReduceAllMasked);\n+    }\n+    static $type$ MINReduce($type$[] a, int idx) {\n+        $type$ res = $Wideboxtype$.$MaxValue$;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = ($type$) Math.min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ MINReduceAll($type$[] a) {\n+        $type$ res = $Wideboxtype$.$MaxValue$;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = ($type$) Math.min(res, MINReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void MINReduce$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        $type$ ra = $Wideboxtype$.$MaxValue$;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = $Wideboxtype$.$MaxValue$;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                $vectorteststype$::MINReduce, $vectorteststype$::MINReduceAll);\n+    }\n+    static $type$ MINReduceMasked($type$[] a, int idx, boolean[] mask) {\n+        $type$ res = $Wideboxtype$.$MaxValue$;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = ($type$) Math.min(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ MINReduceAllMasked($type$[] a, boolean[] mask) {\n+        $type$ res = $Wideboxtype$.$MaxValue$;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = ($type$) Math.min(res, MINReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void MINReduce$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = $Wideboxtype$.$MaxValue$;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MIN, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = $Wideboxtype$.$MaxValue$;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                $vectorteststype$::MINReduceMasked, $vectorteststype$::MINReduceAllMasked);\n+    }\n+    static $type$ MAXReduce($type$[] a, int idx) {\n+        $type$ res = $Wideboxtype$.$MinValue$;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = ($type$) Math.max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ MAXReduceAll($type$[] a) {\n+        $type$ res = $Wideboxtype$.$MinValue$;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = ($type$) Math.max(res, MAXReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void MAXReduce$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        $type$ ra = $Wideboxtype$.$MinValue$;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = $Wideboxtype$.$MinValue$;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                $vectorteststype$::MAXReduce, $vectorteststype$::MAXReduceAll);\n+    }\n+    static $type$ MAXReduceMasked($type$[] a, int idx, boolean[] mask) {\n+        $type$ res = $Wideboxtype$.$MinValue$;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = ($type$) Math.max(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ MAXReduceAllMasked($type$[] a, boolean[] mask) {\n+        $type$ res = $Wideboxtype$.$MinValue$;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = ($type$) Math.max(res, MAXReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void MAXReduce$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = $Wideboxtype$.$MinValue$;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.MAX, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = $Wideboxtype$.$MinValue$;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = ($type$) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                $vectorteststype$::MAXReduceMasked, $vectorteststype$::MAXReduceAllMasked);\n+    }\n+    static $type$ FIRST_NONZEROReduce($type$[] a, int idx) {\n+        $type$ res = ($type$) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ FIRST_NONZEROReduceAll($type$[] a) {\n+        $type$ res = ($type$) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduce(a, i));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void FIRST_NONZEROReduce$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        $type$ ra = ($type$) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = ($type$) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                $vectorteststype$::FIRST_NONZEROReduce, $vectorteststype$::FIRST_NONZEROReduceAll);\n+    }\n+    static $type$ FIRST_NONZEROReduceMasked($type$[] a, int idx, boolean[] mask) {\n+        $type$ res = ($type$) 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if (mask[i % SPECIES.length()])\n+                res = firstNonZero(res, a[i]);\n+        }\n+\n+        return res;\n+    }\n+\n+    static $type$ FIRST_NONZEROReduceAllMasked($type$[] a, boolean[] mask) {\n+        $type$ res = ($type$) 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res = firstNonZero(res, FIRST_NONZEROReduceMasked(a, i, mask));\n+        }\n+\n+        return res;\n+    }\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void FIRST_NONZEROReduce$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = ($type$) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                r[i] = av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask);\n+            }\n+        }\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = ($type$) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                $vectorteststype$::FIRST_NONZEROReduceMasked, $vectorteststype$::FIRST_NONZEROReduceAllMasked);\n+    }\n+#if[BITWISE]\n+\n+    static boolean anyTrue(boolean[] a, int idx) {\n+        boolean res = false;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res |= a[i];\n+        }\n+\n+        return res;\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    static void anyTrue$vectorteststype$(IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        assertReductionBoolArraysEquals(r, mask, $vectorteststype$::anyTrue);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    static boolean allTrue(boolean[] a, int idx) {\n+        boolean res = true;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res &= a[i];\n+        }\n+\n+        return res;\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"boolUnaryOpProvider\")\n+    static void allTrue$vectorteststype$(IntFunction<boolean[]> fm) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        assertReductionBoolArraysEquals(r, mask, $vectorteststype$::allTrue);\n+    }\n+#end[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void with$vectorteststype$(IntFunction<$type$ []> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), ($type$)(65535+i)).intoArray(r, i);\n+            }\n+        }\n+\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, ($type$)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n+    }\n+    static boolean testIS_DEFAULT($type$ a) {\n+        return bits(a)==0;\n+    }\n+\n+    @Test(dataProvider = \"$type$TestOpProvider\")\n+    static void IS_DEFAULT$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.IS_DEFAULT);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$TestOpMaskProvider\")\n+    static void IS_DEFAULTMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.IS_DEFAULT, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_DEFAULT(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+    static boolean testIS_NEGATIVE($type$ a) {\n+        return bits(a)<0;\n+    }\n+\n+    @Test(dataProvider = \"$type$TestOpProvider\")\n+    static void IS_NEGATIVE$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.IS_NEGATIVE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$TestOpMaskProvider\")\n+    static void IS_NEGATIVEMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.IS_NEGATIVE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NEGATIVE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+#if[FP]\n+\n+    static boolean testIS_FINITE($type$ a) {\n+        return $Boxtype$.isFinite(a);\n+    }\n+\n+    @Test(dataProvider = \"$type$TestOpProvider\")\n+    static void IS_FINITE$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.IS_FINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$TestOpMaskProvider\")\n+    static void IS_FINITEMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.IS_FINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_FINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static boolean testIS_NAN($type$ a) {\n+        return $Boxtype$.isNaN(a);\n+    }\n+\n+    @Test(dataProvider = \"$type$TestOpProvider\")\n+    static void IS_NAN$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.IS_NAN);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$TestOpMaskProvider\")\n+    static void IS_NANMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.IS_NAN, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_NAN(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static boolean testIS_INFINITE($type$ a) {\n+        return $Boxtype$.isInfinite(a);\n+    }\n+\n+    @Test(dataProvider = \"$type$TestOpProvider\")\n+    static void IS_INFINITE$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.IS_INFINITE);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$TestOpMaskProvider\")\n+    static void IS_INFINITEMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                VectorMask<$Wideboxtype$> mv = av.test(VectorOperators.IS_INFINITE, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j),  vmask.laneIsSet(j) && testIS_INFINITE(a[i + j]));\n+                }\n+            }\n+        }\n+    }\n+#end[FP]\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void LT$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void lt$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.lt(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void LT$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void GT$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void GT$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void EQ$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.EQ, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void eq$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.eq(bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void EQ$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.EQ, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void NE$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.NE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void NE$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.NE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void LE$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void LE$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void GE$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void GE$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void UNSIGNED_LT$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void UNSIGNED_LT$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void UNSIGNED_GT$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void UNSIGNED_GT$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void UNSIGNED_LE$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void UNSIGNED_LE$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void UNSIGNED_GE$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void UNSIGNED_GE$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+#end[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void LT$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.LT, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void LT$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa,\n+                                IntFunction<$type$[]> fb, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.LT, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i]));\n+            }\n+        }\n+    }\n+\n+#if[!Long]\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void LT$vectorteststype$BroadcastLongSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.LT, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < ($type$)((long)b[i]));\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void LT$vectorteststype$BroadcastLongMaskedSmokeTest(IntFunction<$type$[]> fa,\n+                                IntFunction<$type$[]> fb, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.LT, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < ($type$)((long)b[i])));\n+            }\n+        }\n+    }\n+#end[!Long]\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void EQ$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.EQ, b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void EQ$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa,\n+                                IntFunction<$type$[]> fb, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.EQ, b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i]));\n+            }\n+        }\n+    }\n+\n+#if[!Long]\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void EQ$vectorteststype$BroadcastLongSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.EQ, (long)b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == ($type$)((long)b[i]));\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpMaskProvider\")\n+    static void EQ$vectorteststype$BroadcastLongMaskedSmokeTest(IntFunction<$type$[]> fa,\n+                                IntFunction<$type$[]> fb, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.compare(VectorOperators.EQ, (long)b[i], vmask);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == ($type$)((long)b[i])));\n+            }\n+        }\n+    }\n+#end[!Long]\n+\n+    static $type$ blend($type$ a, $type$ b, boolean mask) {\n+        return mask ? b : a;\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void blend$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, $vectorteststype$::blend);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpShuffleProvider\")\n+    static void Rearrange$vectorteststype$(IntFunction<$type$[]> fa,\n+                                           BiFunction<Integer,Integer,int[]> fs) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpShuffleMaskProvider\")\n+    static void Rearrange$vectorteststype$MaskedSmokeTest(IntFunction<$type$[]> fa,\n+                                                          BiFunction<Integer,Integer,int[]> fs,\n+                                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.rearrange(VectorShuffle.fromArray(SPECIES, order, i), vmask).intoArray(r, i);\n+        }\n+\n+        assertRearrangeArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void compress$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void expand$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void get$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::get);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void Broadcast$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+\n+\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void Zero$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        Assert.assertEquals(a, r);\n+    }\n+\n+\n+\n+\n+    static $type$[] sliceUnary($type$[] a, int origin, int idx) {\n+        $type$[] res = new $type$[SPECIES.length()];\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else\n+                res[i] = ($type$)0;\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void sliceUnary$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, $vectorteststype$::sliceUnary);\n+    }\n+    static $type$[] sliceBinary($type$[] a, $type$[] b, int origin, int idx) {\n+        $type$[] res = new $type$[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = a[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void sliceBinary$vectorteststype$Binary(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, $vectorteststype$::sliceBinary);\n+    }\n+    static $type$[] slice($type$[] a, $type$[] b, int origin, boolean[] mask, int idx) {\n+        $type$[] res = new $type$[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = mask[i] ? a[idx+i+origin] : ($type$)0;\n+            else {\n+                res[i] = mask[i] ? b[idx+j] : ($type$)0;\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void slice$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, mask, $vectorteststype$::slice);\n+    }\n+    static $type$[] unsliceUnary($type$[] a, int origin, int idx) {\n+        $type$[] res = new $type$[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i < origin)\n+                res[i] = ($type$)0;\n+            else {\n+                res[i] = a[idx+j];\n+                j++;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void unsliceUnary$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, origin, $vectorteststype$::unsliceUnary);\n+    }\n+    static $type$[] unsliceBinary($type$[] a, $type$[] b, int origin, int part, int idx) {\n+        $type$[] res = new $type$[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if (part == 0) {\n+                if (i < origin)\n+                    res[i] = b[idx+i];\n+                else {\n+                    res[i] = a[idx+j];\n+                    j++;\n+                }\n+            } else if (part == 1) {\n+                if (i < origin)\n+                    res[i] = a[idx+SPECIES.length()-origin+i];\n+                else {\n+                    res[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void unsliceBinary$vectorteststype$Binary(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, $vectorteststype$::unsliceBinary);\n+    }\n+    static $type$[] unslice($type$[] a, $type$[] b, int origin, int part, boolean[] mask, int idx) {\n+        $type$[] res = new $type$[SPECIES.length()];\n+        for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+            if(i+origin < SPECIES.length())\n+                res[i] = b[idx+i+origin];\n+            else {\n+                res[i] = b[idx+j];\n+                j++;\n+            }\n+        }\n+        for (int i = 0; i < SPECIES.length(); i++){\n+            res[i] = mask[i] ? a[idx+i] : res[i];\n+        }\n+        $type$[] res1 = new $type$[SPECIES.length()];\n+        if (part == 0) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = b[idx+i];\n+                else {\n+                   res1[i] = res[j];\n+                   j++;\n+                }\n+            }\n+        } else if (part == 1) {\n+            for (int i = 0, j = 0; i < SPECIES.length(); i++){\n+                if (i < origin)\n+                    res1[i] = res[SPECIES.length()-origin+i];\n+                else {\n+                    res1[i] = b[idx+origin+j];\n+                    j++;\n+                }\n+            }\n+        }\n+        return res1;\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void unslice$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+    IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$[] r = new $type$[a.length];\n+        int origin = (new java.util.Random()).nextInt(SPECIES.length());\n+        int part = (new java.util.Random()).nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, origin, part, mask, $vectorteststype$::unslice);\n+    }\n+#if[FP]\n+\n+    static $type$ SIN($type$ a) {\n+        return ($type$)(Math.sin((double)a));\n+    }\n+\n+    static $type$ strictSIN($type$ a) {\n+        return ($type$)(StrictMath.sin((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void SIN$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::SIN, $vectorteststype$::strictSIN);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ EXP($type$ a) {\n+        return ($type$)(Math.exp((double)a));\n+    }\n+\n+    static $type$ strictEXP($type$ a) {\n+        return ($type$)(StrictMath.exp((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void EXP$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::EXP, $vectorteststype$::strictEXP);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ LOG1P($type$ a) {\n+        return ($type$)(Math.log1p((double)a));\n+    }\n+\n+    static $type$ strictLOG1P($type$ a) {\n+        return ($type$)(StrictMath.log1p((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void LOG1P$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::LOG1P, $vectorteststype$::strictLOG1P);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ LOG($type$ a) {\n+        return ($type$)(Math.log((double)a));\n+    }\n+\n+    static $type$ strictLOG($type$ a) {\n+        return ($type$)(StrictMath.log((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void LOG$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::LOG, $vectorteststype$::strictLOG);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ LOG10($type$ a) {\n+        return ($type$)(Math.log10((double)a));\n+    }\n+\n+    static $type$ strictLOG10($type$ a) {\n+        return ($type$)(StrictMath.log10((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void LOG10$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::LOG10, $vectorteststype$::strictLOG10);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ EXPM1($type$ a) {\n+        return ($type$)(Math.expm1((double)a));\n+    }\n+\n+    static $type$ strictEXPM1($type$ a) {\n+        return ($type$)(StrictMath.expm1((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void EXPM1$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::EXPM1, $vectorteststype$::strictEXPM1);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ COS($type$ a) {\n+        return ($type$)(Math.cos((double)a));\n+    }\n+\n+    static $type$ strictCOS($type$ a) {\n+        return ($type$)(StrictMath.cos((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void COS$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::COS, $vectorteststype$::strictCOS);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ TAN($type$ a) {\n+        return ($type$)(Math.tan((double)a));\n+    }\n+\n+    static $type$ strictTAN($type$ a) {\n+        return ($type$)(StrictMath.tan((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void TAN$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::TAN, $vectorteststype$::strictTAN);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ SINH($type$ a) {\n+        return ($type$)(Math.sinh((double)a));\n+    }\n+\n+    static $type$ strictSINH($type$ a) {\n+        return ($type$)(StrictMath.sinh((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void SINH$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::SINH, $vectorteststype$::strictSINH);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ COSH($type$ a) {\n+        return ($type$)(Math.cosh((double)a));\n+    }\n+\n+    static $type$ strictCOSH($type$ a) {\n+        return ($type$)(StrictMath.cosh((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void COSH$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::COSH, $vectorteststype$::strictCOSH);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ TANH($type$ a) {\n+        return ($type$)(Math.tanh((double)a));\n+    }\n+\n+    static $type$ strictTANH($type$ a) {\n+        return ($type$)(StrictMath.tanh((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void TANH$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::TANH, $vectorteststype$::strictTANH);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ ASIN($type$ a) {\n+        return ($type$)(Math.asin((double)a));\n+    }\n+\n+    static $type$ strictASIN($type$ a) {\n+        return ($type$)(StrictMath.asin((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void ASIN$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::ASIN, $vectorteststype$::strictASIN);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ ACOS($type$ a) {\n+        return ($type$)(Math.acos((double)a));\n+    }\n+\n+    static $type$ strictACOS($type$ a) {\n+        return ($type$)(StrictMath.acos((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void ACOS$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::ACOS, $vectorteststype$::strictACOS);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ ATAN($type$ a) {\n+        return ($type$)(Math.atan((double)a));\n+    }\n+\n+    static $type$ strictATAN($type$ a) {\n+        return ($type$)(StrictMath.atan((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void ATAN$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::ATAN, $vectorteststype$::strictATAN);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ CBRT($type$ a) {\n+        return ($type$)(Math.cbrt((double)a));\n+    }\n+\n+    static $type$ strictCBRT($type$ a) {\n+        return ($type$)(StrictMath.cbrt((double)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void CBRT$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::CBRT, $vectorteststype$::strictCBRT);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ HYPOT($type$ a, $type$ b) {\n+        return ($type$)(Math.hypot((double)a, (double)b));\n+    }\n+\n+    static $type$ strictHYPOT($type$ a, $type$ b) {\n+        return ($type$)(StrictMath.hypot((double)a, (double)b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void HYPOT$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, $vectorteststype$::HYPOT, $vectorteststype$::strictHYPOT);\n+    }\n+\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ POW($type$ a, $type$ b) {\n+        return ($type$)(Math.pow((double)a, (double)b));\n+    }\n+\n+    static $type$ strictPOW($type$ a, $type$ b) {\n+        return ($type$)(StrictMath.pow((double)a, (double)b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void POW$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, $vectorteststype$::POW, $vectorteststype$::strictPOW);\n+    }\n+\n+    static $type$ pow($type$ a, $type$ b) {\n+        return ($type$)(Math.pow((double)a, (double)b));\n+    }\n+\n+    static $type$ strictpow($type$ a, $type$ b) {\n+        return ($type$)(StrictMath.pow((double)a, (double)b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void pow$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, $vectorteststype$::pow, $vectorteststype$::strictpow);\n+    }\n+\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ ATAN2($type$ a, $type$ b) {\n+        return ($type$)(Math.atan2((double)a, (double)b));\n+    }\n+\n+    static $type$ strictATAN2($type$ a, $type$ b) {\n+        return ($type$)(StrictMath.atan2((double)a, (double)b));\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void ATAN2$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, $vectorteststype$::ATAN2, $vectorteststype$::strictATAN2);\n+    }\n+\n+#end[FP]\n+\n+#if[FP]\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void POW$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, $vectorteststype$::POW, $vectorteststype$::strictPOW);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void pow$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, $vectorteststype$::pow, $vectorteststype$::strictpow);\n+    }\n+\n+#end[FP]\n+\n+#if[FP]\n+\n+    static $type$ FMA($type$ a, $type$ b, $type$ c) {\n+        return ($type$)(Math.fma(a, b, c));\n+    }\n+    static $type$ fma($type$ a, $type$ b, $type$ c) {\n+        return ($type$)(Math.fma(a, b, c));\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void FMA$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"FMA\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, $vectorteststype$::FMA);\n+    }\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void fma$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"fma\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+            av.fma(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, $vectorteststype$::fma);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    @Test(dataProvider = \"$type$TernaryOpMaskProvider\")\n+    static void FMA$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<$type$[]> fc, IntFunction<boolean[]> fm) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"FMA\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, $vectorteststype$::FMA);\n+    }\n+#end[FP]\n+\n+#if[BITWISE]\n+\n+    static $type$ BITWISE_BLEND($type$ a, $type$ b, $type$ c) {\n+        return ($type$)((a&~(c))|(b&c));\n+    }\n+    static $type$ bitwiseBlend($type$ a, $type$ b, $type$ c) {\n+        return ($type$)((a&~(c))|(b&c));\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void BITWISE_BLEND$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"BITWISE_BLEND\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, $vectorteststype$::BITWISE_BLEND);\n+    }\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void bitwiseBlend$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"bitwiseBlend\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+            av.bitwiseBlend(bv, cv).intoArray(r, i);\n+        }\n+\n+        assertArraysEquals(r, a, b, c, $vectorteststype$::bitwiseBlend);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$TernaryOpMaskProvider\")\n+    static void BITWISE_BLEND$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<$type$[]> fc, IntFunction<boolean[]> fm) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"BITWISE_BLEND\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, c, mask, $vectorteststype$::BITWISE_BLEND);\n+    }\n+#end[BITWISE]\n+\n+#if[FP]\n+\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void FMA$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a, b, c, $vectorteststype$::FMA);\n+    }\n+\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void FMA$vectorteststype$AltBroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv).intoArray(r, i);\n+        }\n+        assertAltBroadcastArraysEquals(r, a, b, c, $vectorteststype$::FMA);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    @Test(dataProvider = \"$type$TernaryOpMaskProvider\")\n+    static void FMA$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<$type$[]> fc, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.FMA, bv, c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, c, mask, $vectorteststype$::FMA);\n+    }\n+\n+    @Test(dataProvider = \"$type$TernaryOpMaskProvider\")\n+    static void FMA$vectorteststype$AltBroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<$type$[]> fc, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.FMA, b[i], cv, vmask).intoArray(r, i);\n+        }\n+\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, $vectorteststype$::FMA);\n+    }\n+#end[FP]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void BITWISE_BLEND$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.BITWISE_BLEND, bv, c[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a, b, c, $vectorteststype$::BITWISE_BLEND);\n+    }\n+\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void BITWISE_BLEND$vectorteststype$AltBroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.BITWISE_BLEND, b[i], cv).intoArray(r, i);\n+        }\n+        assertAltBroadcastArraysEquals(r, a, b, c, $vectorteststype$::BITWISE_BLEND);\n+    }\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void bitwiseBlend$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.bitwiseBlend(bv, c[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a, b, c, $vectorteststype$::bitwiseBlend);\n+    }\n+\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void bitwiseBlend$vectorteststype$AltBroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+            av.bitwiseBlend(b[i], cv).intoArray(r, i);\n+        }\n+        assertAltBroadcastArraysEquals(r, a, b, c, $vectorteststype$::bitwiseBlend);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$TernaryOpMaskProvider\")\n+    static void BITWISE_BLEND$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<$type$[]> fc, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+            av.lanewise(VectorOperators.BITWISE_BLEND, bv, c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEquals(r, a, b, c, mask, $vectorteststype$::BITWISE_BLEND);\n+    }\n+\n+    @Test(dataProvider = \"$type$TernaryOpMaskProvider\")\n+    static void BITWISE_BLEND$vectorteststype$AltBroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<$type$[]> fc, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+            av.lanewise(VectorOperators.BITWISE_BLEND, b[i], cv, vmask).intoArray(r, i);\n+        }\n+\n+        assertAltBroadcastArraysEquals(r, a, b, c, mask, $vectorteststype$::BITWISE_BLEND);\n+    }\n+#end[BITWISE]\n+\n+#if[FP]\n+\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void FMA$vectorteststype$DoubleBroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"FMA\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, $vectorteststype$::FMA);\n+    }\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void fma$vectorteststype$DoubleBroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"fma\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.fma(b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, $vectorteststype$::fma);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+    @Test(dataProvider = \"$type$TernaryOpMaskProvider\")\n+    static void FMA$vectorteststype$DoubleBroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<$type$[]> fc, IntFunction<boolean[]> fm) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"FMA\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.FMA, b[i], c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, $vectorteststype$::FMA);\n+    }\n+#end[FP]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void BITWISE_BLEND$vectorteststype$DoubleBroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"BITWISE_BLEND\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.BITWISE_BLEND, b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, $vectorteststype$::BITWISE_BLEND);\n+    }\n+    @Test(dataProvider = \"$type$TernaryOpProvider\")\n+    static void bitwiseBlend$vectorteststype$DoubleBroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"bitwiseBlend\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.bitwiseBlend(b[i], c[i]).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, $vectorteststype$::bitwiseBlend);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+    @Test(dataProvider = \"$type$TernaryOpMaskProvider\")\n+    static void BITWISE_BLEND$vectorteststype$DoubleBroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<$type$[]> fc, IntFunction<boolean[]> fm) {\n+#if[double]\n+        int count = INVOC_COUNT;\n+        switch (\"BITWISE_BLEND\") {\n+        case \"fma\": case \"lanewise_FMA\":\n+           \/\/ Math.fma uses BigDecimal\n+           count = Math.max(5, count\/20); break;\n+        }\n+        final int INVOC_COUNT = count;\n+#end[double]\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.BITWISE_BLEND, b[i], c[i], vmask).intoArray(r, i);\n+        }\n+\n+        assertDoubleBroadcastArraysEquals(r, a, b, c, mask, $vectorteststype$::BITWISE_BLEND);\n+    }\n+#end[BITWISE]\n+\n+\n+    static $type$ NEG($type$ a) {\n+        return ($type$)(-(($type$)a));\n+    }\n+\n+    static $type$ neg($type$ a) {\n+        return ($type$)(-(($type$)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void NEG$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::NEG);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void neg$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.neg().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::neg);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void NEGMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::NEG);\n+    }\n+\n+    static $type$ ABS($type$ a) {\n+        return ($type$)(Math.abs(($type$)a));\n+    }\n+\n+    static $type$ abs($type$ a) {\n+        return ($type$)(Math.abs(($type$)a));\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void ABS$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::ABS);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void abs$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.abs().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::abs);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void ABSMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::ABS);\n+    }\n+#if[BITWISE]\n+\n+\n+    static $type$ NOT($type$ a) {\n+        return ($type$)(~(($type$)a));\n+    }\n+\n+    static $type$ not($type$ a) {\n+        return ($type$)(~(($type$)a));\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void NOT$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::NOT);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void not$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.not().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::not);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void NOTMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::NOT);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    static $type$ ZOMO($type$ a) {\n+        return ($type$)((a==0?0:-1));\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void ZOMO$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::ZOMO);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void ZOMOMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::ZOMO);\n+    }\n+#end[BITWISE]\n+\n+#if[FP]\n+\n+\n+    static $type$ SQRT($type$ a) {\n+        return ($type$)(Math.sqrt((double)a));\n+    }\n+\n+    static $type$ sqrt($type$ a) {\n+        return ($type$)(Math.sqrt((double)a));\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void SQRT$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void sqrt$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::sqrt);\n+    }\n+#end[FP]\n+\n+#if[FP]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void SQRTMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::SQRT);\n+    }\n+#end[FP]\n+\n+#if[intOrLong]\n+\n+\n+    static $type$ BIT_COUNT($type$ a) {\n+        return ($type$)($Boxtype$.bitCount(a));\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void BIT_COUNT$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::BIT_COUNT);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void BIT_COUNTMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::BIT_COUNT);\n+    }\n+#end[intOrLong]\n+\n+#if[byte]\n+\n+\n+    static $type$ BIT_COUNT($type$ a) {\n+        return ($type$)(Integer.bitCount((int)a & 0xFF));\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void BIT_COUNT$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::BIT_COUNT);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void BIT_COUNTMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::BIT_COUNT);\n+    }\n+#end[byte]\n+\n+#if[short]\n+\n+\n+    static $type$ BIT_COUNT($type$ a) {\n+        return ($type$)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void BIT_COUNT$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::BIT_COUNT);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void BIT_COUNTMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::BIT_COUNT);\n+    }\n+#end[short]\n+\n+#if[BITWISE]\n+\n+\n+    static $type$ TRAILING_ZEROS_COUNT($type$ a) {\n+        return ($type$)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNT$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::TRAILING_ZEROS_COUNT);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::TRAILING_ZEROS_COUNT);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    static $type$ LEADING_ZEROS_COUNT($type$ a) {\n+        return ($type$)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNT$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::LEADING_ZEROS_COUNT);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::LEADING_ZEROS_COUNT);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    static $type$ REVERSE($type$ a) {\n+        return ($type$)(REVERSE_scalar(a));\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void REVERSE$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::REVERSE);\n+    }\n+#end[BITWISE]\n+\n+#if[BITWISE]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void REVERSEMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::REVERSE);\n+    }\n+#end[BITWISE]\n+\n+#if[intOrLong]\n+\n+\n+    static $type$ REVERSE_BYTES($type$ a) {\n+        return ($type$)($Boxtype$.reverseBytes(a));\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void REVERSE_BYTES$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::REVERSE_BYTES);\n+    }\n+#end[intOrLong]\n+\n+#if[intOrLong]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::REVERSE_BYTES);\n+    }\n+#end[intOrLong]\n+\n+#if[short]\n+\n+\n+    static $type$ REVERSE_BYTES($type$ a) {\n+        return ($type$)($Boxtype$.reverseBytes(a));\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void REVERSE_BYTES$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::REVERSE_BYTES);\n+    }\n+#end[short]\n+\n+#if[short]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::REVERSE_BYTES);\n+    }\n+#end[short]\n+\n+#if[byte]\n+\n+\n+    static $type$ REVERSE_BYTES($type$ a) {\n+        return ($type$)(a);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void REVERSE_BYTES$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, $vectorteststype$::REVERSE_BYTES);\n+    }\n+#end[byte]\n+\n+#if[byte]\n+\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMasked$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, $vectorteststype$::REVERSE_BYTES);\n+    }\n+#end[byte]\n+\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void lt$vectorteststype$BroadcastSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.lt(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i]);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$CompareOpProvider\")\n+    static void eq$vectorteststype$BroadcastMaskedSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            VectorMask<$Wideboxtype$> mv = av.eq(b[i]);\n+\n+            \/\/ Check results as part of computation.\n+            for (int j = 0; j < SPECIES.length(); j++) {\n+                Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i]);\n+            }\n+        }\n+    }\n+\n+#if[byteOrShort]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+#else[byteOrShort]\n+#if[Int]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+#else[Int]\n+    @Test(dataProvider = \"$type$toIntUnaryOpProvider\")\n+#end[Int]\n+#end[byteOrShort]\n+    static void toIntArray$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            int[] r = av.toIntArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+#if[FP]\n+    @Test(dataProvider = \"$type$toLongUnaryOpProvider\")\n+#else[FP]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+#end[FP]\n+    static void toLongArray$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            long[] r = av.toLongArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+\n+#if[!Double]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void toDoubleArray$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            double[] r = av.toDoubleArray();\n+            assertArraysEquals(r, a, i);\n+        }\n+    }\n+#end[!Double]\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void toString$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            String str = av.toString();\n+\n+            $type$ subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(Arrays.toString(subarr)), \"at index \" + i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void hashCode$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            int hash = av.hashCode();\n+\n+            $type$ subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+#if[byte]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void reinterpretAsBytes$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            av.reinterpretAsBytes().intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, 0);\n+    }\n+#end[byte]\n+\n+#if[!Long]\n+    static long ADDReduceLong($type$[] a, int idx) {\n+        $type$ res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            res += a[i];\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLong($type$[] a) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLong(a, i);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void ADDReduceLong$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEquals(r, ra, a,\n+                $vectorteststype$::ADDReduceLong, $vectorteststype$::ADDReduceAllLong);\n+    }\n+\n+    static long ADDReduceLongMasked($type$[] a, int idx, boolean[] mask) {\n+        $type$ res = 0;\n+        for (int i = idx; i < (idx + SPECIES.length()); i++) {\n+            if(mask[i % SPECIES.length()])\n+                res += a[i];\n+        }\n+\n+        return (long)res;\n+    }\n+\n+    static long ADDReduceAllLongMasked($type$[] a, boolean[] mask) {\n+        long res = 0;\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            res += ADDReduceLongMasked(a, i, mask);\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void ADDReduceLong$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        long[] r = lfr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionLongArraysEqualsMasked(r, ra, a, mask,\n+                $vectorteststype$::ADDReduceLongMasked, $vectorteststype$::ADDReduceAllLongMasked);\n+    }\n+\n+#if[FP]\n+    @Test(dataProvider = \"$type$toLongUnaryOpProvider\")\n+#else[FP]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+#end[FP]\n+    static void BroadcastLong$vectorteststype$SmokeTest(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = new $type$[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$.broadcast(SPECIES, (long)a[i]).intoArray(r, i);\n+        }\n+        assertBroadcastArraysEquals(r, a);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpMaskProvider\")\n+    static void blend$vectorteststype$BroadcastLongSmokeTest(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.blend((long)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+        assertBroadcastLongArraysEquals(r, a, b, mask, $vectorteststype$::blend);\n+    }\n+#end[!Long]\n+\n+#if[Long]\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void ADDReduceLong$vectorteststype$(IntFunction<$type$[]> fa) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        $type$ ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEquals(r, ra, a,\n+                $vectorteststype$::ADDReduce, $vectorteststype$::ADDReduceAll);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void ADDReduceLong$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = 0;\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            r[i] = av.reduceLanesToLong(VectorOperators.ADD, vmask);\n+        }\n+\n+        ra = 0;\n+        for (int i = 0; i < a.length; i ++) {\n+            ra += r[i];\n+        }\n+\n+        assertReductionArraysEqualsMasked(r, ra, a, mask,\n+                $vectorteststype$::ADDReduceMasked, $vectorteststype$::ADDReduceAllMasked);\n+    }\n+#end[Long]\n+\n+#if[Int]\n+    @Test(dataProvider = \"$type$UnaryOpShuffleProvider\")\n+#else[Int]\n+    @Test(dataProvider = \"$type$UnaryOpSelectFromProvider\")\n+#end[Int]\n+    static void SelectFrom$vectorteststype$(IntFunction<$type$[]> fa,\n+                                           BiFunction<Integer,Integer,$type$[]> fs) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] order = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, SPECIES.length());\n+    }\n+\n+#if[Int]\n+    @Test(dataProvider = \"$type$UnaryOpShuffleMaskProvider\")\n+#else[Int]\n+    @Test(dataProvider = \"$type$UnaryOpSelectFromMaskProvider\")\n+#end[Int]\n+    static void SelectFrom$vectorteststype$MaskedSmokeTest(IntFunction<$type$[]> fa,\n+                                                           BiFunction<Integer,Integer,$type$[]> fs,\n+                                                           IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] order = fs.apply(a.length, SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+            $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, order, i);\n+            bv.selectFrom(av, vmask).intoArray(r, i);\n+        }\n+\n+        assertSelectFromArraysEquals(r, a, order, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleMiscellaneous$vectorteststype$SmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            int hash = shuffle.hashCode();\n+            int length = shuffle.length();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+            Assert.assertEquals(length, SPECIES.length());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleProvider\")\n+    static void shuffleToString$vectorteststype$SmokeTest(BiFunction<Integer,Integer,int[]> fs) {\n+        int[] a = fs.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var shuffle = VectorShuffle.fromArray(SPECIES, a, i);\n+            String str = shuffle.toString();\n+\n+            int subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            Assert.assertTrue(str.equals(\"Shuffle\" + Arrays.toString(subarr)), \"at index \" +\n+                i + \", string should be = \" + Arrays.toString(subarr) + \", but is = \" + str);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shuffleCompareOpProvider\")\n+    static void shuffleEquals$vectorteststype$SmokeTest(BiFunction<Integer,Integer,int[]> fa, BiFunction<Integer,Integer,int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length() * BUFFER_REPS, SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = VectorShuffle.fromArray(SPECIES, a, i);\n+            var bv = VectorShuffle.fromArray(SPECIES, b, i);\n+            boolean eq = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(eq, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEquals$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            boolean equals = av.equals(bv);\n+            int to = i + SPECIES.length();\n+            Assert.assertEquals(equals, Arrays.equals(a, i, to, b, i, to));\n+        }\n+    }\n+\n+    static boolean beq(boolean a, boolean b) {\n+        return (a == b);\n+    }\n+\n+    @Test(dataProvider = \"maskCompareOpProvider\")\n+    static void maskEq$vectorteststype$SmokeTest(IntFunction<boolean[]> fa, IntFunction<boolean[]> fb) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        boolean[] b = fb.apply(SPECIES.length());\n+        boolean[] r = new boolean[a.length];\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var av = SPECIES.loadMask(a, i);\n+            var bv = SPECIES.loadMask(b, i);\n+            var cv = av.eq(bv);\n+            cv.intoArray(r, i);\n+        }\n+        assertArraysEquals(r, a, b, $vectorteststype$::beq);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskHashCode$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            var vmask = SPECIES.loadMask(a, i);\n+            int hash = vmask.hashCode();\n+\n+            boolean subarr[] = Arrays.copyOfRange(a, i, i + SPECIES.length());\n+            int expectedHash = Objects.hash(SPECIES, Arrays.hashCode(subarr));\n+            Assert.assertTrue(hash == expectedHash, \"at index \" + i + \", hash should be = \" + expectedHash + \", but is = \" + hash);\n+        }\n+    }\n+\n+    static int maskTrueCount(boolean[] a, int idx) {\n+        int trueCount = 0;\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            trueCount += a[i] ? 1 : 0;\n+        }\n+        return trueCount;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskTrueCount$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.trueCount();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, $vectorteststype$::maskTrueCount);\n+    }\n+\n+    static int maskLastTrue(boolean[] a, int idx) {\n+        int i = idx + SPECIES.length() - 1;\n+        for (; i >= idx; i--) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskLastTrue$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.lastTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, $vectorteststype$::maskLastTrue);\n+    }\n+\n+    static int maskFirstTrue(boolean[] a, int idx) {\n+        int i = idx;\n+        for (; i < idx + SPECIES.length(); i++) {\n+            if (a[i]) {\n+                break;\n+            }\n+        }\n+        return i - idx;\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskFirstTrue$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        boolean[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                r[i] = vmask.firstTrue();\n+            }\n+        }\n+\n+        assertMaskReductionArraysEquals(r, a, $vectorteststype$::maskFirstTrue);\n+    }\n+\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompress$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n+#if[!MaxBit]\n+    @DataProvider\n+    public static Object[][] longMaskProvider() {\n+        return new Object[][]{\n+                {0xFFFFFFFFFFFFFFFFL},\n+                {0x0000000000000000L},\n+                {0x5555555555555555L},\n+                {0x0123456789abcdefL},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"longMaskProvider\")\n+    static void maskFromToLong$vectorteststype$SmokeTest(long inputLong) {\n+        var vmask = VectorMask.fromLong(SPECIES, inputLong);\n+        long outputLong = vmask.toLong();\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n+    }\n+#end[!MaxBit]\n+\n+    @DataProvider\n+    public static Object[][] offsetProvider() {\n+        return new Object[][]{\n+                {0},\n+                {-1},\n+                {+1},\n+                {+2},\n+                {-2},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRange$vectorteststype$SmokeTest(int offset) {\n+        int limit = SPECIES.length() * BUFFER_REPS;\n+        for (int i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                int index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] lengthProvider() {\n+        return new Object[][]{\n+                {0},\n+                {1},\n+                {32},\n+                {37},\n+                {1024},\n+                {1024+1},\n+                {1024+5},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBound$vectorteststype$SmokeTest(int length) {\n+        int actualLoopBound = SPECIES.loopBound(length);\n+        int expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test\n+    static void ElementSize$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        int elsize = av.elementSize();\n+        Assert.assertEquals(elsize, $Wideboxtype$.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorShape$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        assert(vsh.equals(VectorShape.$Shape$));\n+    }\n+\n+    @Test\n+    static void ShapeWithLanes$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = vsh.withLanes($type$.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void ElementType$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        assert(av.species().elementType() == $type$.class);\n+    }\n+\n+    @Test\n+    static void SpeciesElementSize$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        assert(av.species().elementSize() == $Wideboxtype$.SIZE);\n+    }\n+\n+    @Test\n+    static void VectorType$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        assert(av.species().vectorType() == av.getClass());\n+    }\n+\n+    @Test\n+    static void WithLanes$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        VectorSpecies species = av.species().withLanes($type$.class);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void WithShape$vectorteststype$SmokeTest() {\n+        $abstractvectortype$ av = $abstractvectortype$.zero(SPECIES);\n+        VectorShape vsh = av.shape();\n+        VectorSpecies species = av.species().withShape(vsh);\n+        assert(species.equals(SPECIES));\n+    }\n+\n+    @Test\n+    static void MaskAllTrue$vectorteststype$SmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/unit_tests.template","additions":8647,"deletions":0,"binary":false,"changes":8647,"status":"added"},{"patch":"@@ -468,0 +468,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -468,0 +468,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -468,0 +468,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -468,0 +468,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -468,0 +468,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -472,0 +472,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -351,0 +351,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -351,0 +351,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -467,0 +467,84 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(COMPRESSBITS_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(COMPRESSBITS_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(EXPANDBITS_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(EXPANDBITS_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -466,0 +466,80 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -467,0 +467,84 @@\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(COMPRESSBITS_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(COMPRESSBITS_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(EXPANDBITS_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(EXPANDBITS_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -470,0 +470,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,0 +470,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,0 +470,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,0 +470,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,0 +470,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -475,0 +475,4 @@\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}