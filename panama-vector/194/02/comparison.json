{"files":[{"patch":"@@ -1,502 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.vector;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-class CompressExpand {\n-\n-    \/**\n-     * Returns the value obtained by compressing the bits of the\n-     * specified {@code int} value, {@code i}, in accordance with\n-     * the specified bit mask.\n-     * <p>\n-     * For each one-bit value {@code mb} of the mask, from least\n-     * significant to most significant, the bit value of {@code i} at\n-     * the same bit location as {@code mb} is assigned to the compressed\n-     * value contiguously starting from the least significant bit location.\n-     * All the upper remaining bits of the compressed value are set\n-     * to zero.\n-     *\n-     * @apiNote\n-     * Consider the simple case of compressing the digits of a hexadecimal\n-     * value:\n-     * {@snippet lang=\"java\" :\n-     * \/\/ Compressing drink to food\n-     * compress(0xCAFEBABE, 0xFF00FFF0) == 0xCABAB\n-     * }\n-     * Starting from the least significant hexadecimal digit at position 0\n-     * from the right, the mask {@code 0xFF00FFF0} selects hexadecimal digits\n-     * at positions 1, 2, 3, 6 and 7 of {@code 0xCAFEBABE}. The selected digits\n-     * occur in the resulting compressed value contiguously from digit position\n-     * 0 in the same order.\n-     * <p>\n-     * The following identities all return {@code true} and are helpful to\n-     * understand the behaviour of {@code compress}:\n-     * {@snippet lang=\"java\" :\n-     * \/\/ Returns 1 if the bit at position n is one\n-     * compress(x, 1 << n) == (x >> n & 1)\n-     *\n-     * \/\/ Logical shift right\n-     * compress(x, -1 << n) == x >>> n\n-     *\n-     * \/\/ Any bits not covered by the mask are ignored\n-     * compress(x, m) == compress(x & m, m)\n-     *\n-     * \/\/ Compressing a value by itself\n-     * compress(m, m) == (m == -1 || m == 0) ? m : (1 << bitCount(m)) - 1\n-     *\n-     * \/\/ Expanding then compressing with the same mask\n-     * compress(expand(x, m), m) == x & compress(m, m)\n-     * }\n-     * <p>\n-     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n-     * can be implemented as follows:\n-     * {@snippet lang=\"java\" :\n-     * int compressLeft(int i, int mask) {\n-     *     \/\/ This implementation follows the description in Hacker's Delight which\n-     *     \/\/ is informative. A more optimal implementation is:\n-     *     \/\/   Integer.compress(i, mask) << -Integer.bitCount(mask)\n-     *     return Integer.reverse(\n-     *         Integer.compress(Integer.reverse(i), Integer.reverse(mask)));\n-     * }\n-     *\n-     * int sag(int i, int mask) {\n-     *     return compressLeft(i, mask) | Integer.compress(i, ~mask);\n-     * }\n-     *\n-     * \/\/ Separate the sheep from the goats\n-     * sag(0xCAFEBABE, 0xFF00FFF0) == 0xCABABFEE\n-     * }\n-     *\n-     * @param i the value whose bits are to be compressed\n-     * @param mask the bit mask\n-     * @return the compressed value\n-     * @see #expand\n-     * @since 19\n-     *\/\n-    static int compress(int i, int mask) {\n-        \/\/ See Hacker's Delight (2nd ed) section 7.4 Compress, or Generalized Extract\n-\n-        i = i & mask; \/\/ Clear irrelevant bits\n-        int maskCount = ~mask << 1; \/\/ Count 0's to right\n-\n-        for (int j = 0; j < 5; j++) {\n-            \/\/ Parallel prefix\n-            \/\/ Mask prefix identifies bits of the mask that have an odd number of 0's to the right\n-            int maskPrefix = parallelSuffix(maskCount);\n-            \/\/ Bits to move\n-            int maskMove = maskPrefix & mask;\n-            \/\/ Compress mask\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            \/\/ Bits of i to be moved\n-            int t = i & maskMove;\n-            \/\/ Compress i\n-            i = (i ^ t) | (t >>> (1 << j));\n-            \/\/ Adjust the mask count by identifying bits that have 0 to the right\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return i;\n-    }\n-\n-    \/**\n-     * Returns the value obtained by compressing the bits of the\n-     * specified {@code long} value, {@code i}, in accordance with\n-     * the specified bit mask.\n-     * <p>\n-     * For each one-bit value {@code mb} of the mask, from least\n-     * significant to most significant, the bit value of {@code i} at\n-     * the same bit location as {@code mb} is assigned to the compressed\n-     * value contiguously starting from the least significant bit location.\n-     * All the upper remaining bits of the compressed value are set\n-     * to zero.\n-     *\n-     * @apiNote\n-     * Consider the simple case of compressing the digits of a hexadecimal\n-     * value:\n-     * {@snippet lang=\"java\" :\n-     * \/\/ Compressing drink to food\n-     * compress(0xCAFEBABE, 0xFF00FFF0) == 0xCABAB\n-     * }\n-     * Starting from the least significant hexadecimal digit at position 0\n-     * from the right, the mask {@code 0xFF00FFF0} selects hexadecimal digits\n-     * at positions 1, 2, 3, 6 and 7 of {@code 0xCAFEBABE}. The selected digits\n-     * occur in the resulting compressed value contiguously from digit position\n-     * 0 in the same order.\n-     * <p>\n-     * The following identities all return {@code true} and are helpful to\n-     * understand the behaviour of {@code compress}:\n-     * {@snippet lang=\"java\" :\n-     * \/\/ Returns 1 if the bit at position n is one\n-     * compress(x, 1 << n) == (x >> n & 1)\n-     *\n-     * \/\/ Logical shift right\n-     * compress(x, -1 << n) == x >>> n\n-     *\n-     * \/\/ Any bits not covered by the mask are ignored\n-     * compress(x, m) == compress(x & m, m)\n-     *\n-     * \/\/ Compressing a value by itself\n-     * compress(m, m) == (m == -1 || m == 0) ? m : (1 << bitCount(m)) - 1\n-     *\n-     * \/\/ Expanding then compressing with the same mask\n-     * compress(expand(x, m), m) == x & compress(m, m)\n-     * }\n-     * <p>\n-     * The Sheep And Goats (SAG) operation (see Hacker's Delight, section 7.7)\n-     * can be implemented as follows:\n-     * {@snippet lang=\"java\" :\n-     * long compressLeft(long i, long mask) {\n-     *     \/\/ This implementation follows the description in Hacker's Delight which\n-     *     \/\/ is informative. A more optimal implementation is:\n-     *     \/\/   Long.compress(i, mask) << -Long.bitCount(mask)\n-     *     return Long.reverse(\n-     *         Long.compress(Long.reverse(i), Long.reverse(mask)));\n-     * }\n-     *\n-     * long sag(long i, long mask) {\n-     *     return compressLeft(i, mask) | Long.compress(i, ~mask);\n-     * }\n-     *\n-     * \/\/ Separate the sheep from the goats\n-     * sag(0xCAFEBABE, 0xFF00FFF0) == 0xCABABFEE\n-     * }\n-     *\n-     * @param i the value whose bits are to be compressed\n-     * @param mask the bit mask\n-     * @return the compressed value\n-     * @see #expand\n-     * @since 19\n-     *\/\n-    static long compress(long i, long mask) {\n-        \/\/ See Hacker's Delight (2nd ed) section 7.4 Compress, or Generalized Extract\n-\n-        i = i & mask; \/\/ Clear irrelevant bits\n-        long maskCount = ~mask << 1; \/\/ Count 0's to right\n-\n-        for (int j = 0; j < 6; j++) {\n-            \/\/ Parallel prefix\n-            \/\/ Mask prefix identifies bits of the mask that have an odd number of 0's to the right\n-            long maskPrefix = parallelSuffix(maskCount);\n-            \/\/ Bits to move\n-            long maskMove = maskPrefix & mask;\n-            \/\/ Compress mask\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            \/\/ Bits of i to be moved\n-            long t = i & maskMove;\n-            \/\/ Compress i\n-            i = (i ^ t) | (t >>> (1 << j));\n-            \/\/ Adjust the mask count by identifying bits that have 0 to the right\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return i;\n-    }\n-\n-\n-    \/**\n-     * Returns the value obtained by expanding the bits of the\n-     * specified {@code int} value, {@code i}, in accordance with\n-     * the specified bit mask.\n-     * <p>\n-     * For each one-bit value {@code mb} of the mask, from least\n-     * significant to most significant, the next contiguous bit value\n-     * of {@code i} starting at the least significant bit is assigned\n-     * to the expanded value at the same bit location as {@code mb}.\n-     * All other remaining bits of the expanded value are set to zero.\n-     *\n-     * @apiNote\n-     * Consider the simple case of expanding the digits of a hexadecimal\n-     * value:\n-     * {@snippet lang=\"java\" :\n-     * expand(0x0000CABAB, 0xFF00FFF0) == 0xCA00BAB0\n-     * }\n-     * Starting from the least significant hexadecimal digit at position 0\n-     * from the right, the mask {@code 0xFF00FFF0} selects the first five\n-     * hexadecimal digits of {@code 0x0000CABAB}. The selected digits occur\n-     * in the resulting expanded value in order at positions 1, 2, 3, 6, and 7.\n-     * <p>\n-     * The following identities all return {@code true} and are helpful to\n-     * understand the behaviour of {@code expand}:\n-     * {@snippet lang=\"java\" :\n-     * \/\/ Logically shift right the bit at position 0\n-     * expand(x, 1 << n) == (x & 1) << n\n-     *\n-     * \/\/ Logically shift right\n-     * expand(x, -1 << n) == x << n\n-     *\n-     * \/\/ Expanding all bits returns the mask\n-     * expand(-1, m) == m\n-     *\n-     * \/\/ Any bits not covered by the mask are ignored\n-     * expand(x, m) == expand(x, m) & m\n-     *\n-     * \/\/ Compressing then expanding with the same mask\n-     * expand(compress(x, m), m) == x & m\n-     * }\n-     * <p>\n-     * The select operation for determining the position of the one-bit with\n-     * index {@code n} in a {@code int} value can be implemented as follows:\n-     * {@snippet lang=\"java\" :\n-     * int select(int i, int n) {\n-     *     \/\/ the one-bit in i (the mask) with index n\n-     *     int nthBit = Integer.expand(1 << n, i);\n-     *     \/\/ the bit position of the one-bit with index n\n-     *     return Integer.numberOfTrailingZeros(nthBit);\n-     * }\n-     *\n-     * \/\/ The one-bit with index 0 is at bit position 1\n-     * select(0b10101010_10101010, 0) == 1\n-     * \/\/ The one-bit with index 3 is at bit position 7\n-     * select(0b10101010_10101010, 3) == 7\n-     * }\n-     *\n-     * @param i the value whose bits are to be expanded\n-     * @param mask the bit mask\n-     * @return the expanded value\n-     * @see #compress\n-     * @since 19\n-     *\/\n-    static int expand(int i, int mask) {\n-        \/\/ Save original mask\n-        int originalMask = mask;\n-        \/\/ Count 0's to right\n-        int maskCount = ~mask << 1;\n-        int maskPrefix = parallelSuffix(maskCount);\n-        \/\/ Bits to move\n-        int maskMove1 = maskPrefix & mask;\n-        \/\/ Compress mask\n-        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        \/\/ Bits to move\n-        int maskMove2 = maskPrefix & mask;\n-        \/\/ Compress mask\n-        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        \/\/ Bits to move\n-        int maskMove3 = maskPrefix & mask;\n-        \/\/ Compress mask\n-        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        \/\/ Bits to move\n-        int maskMove4 = maskPrefix & mask;\n-        \/\/ Compress mask\n-        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        \/\/ Bits to move\n-        int maskMove5 = maskPrefix & mask;\n-\n-        int t = i << (1 << 4);\n-        i = (i & ~maskMove5) | (t & maskMove5);\n-        t = i << (1 << 3);\n-        i = (i & ~maskMove4) | (t & maskMove4);\n-        t = i << (1 << 2);\n-        i = (i & ~maskMove3) | (t & maskMove3);\n-        t = i << (1 << 1);\n-        i = (i & ~maskMove2) | (t & maskMove2);\n-        t = i << (1 << 0);\n-        i = (i & ~maskMove1) | (t & maskMove1);\n-\n-        \/\/ Clear irrelevant bits\n-        return i & originalMask;\n-    }\n-\n-    \/**\n-     * Returns the value obtained by expanding the bits of the\n-     * specified {@code long} value, {@code i}, in accordance with\n-     * the specified bit mask.\n-     * <p>\n-     * For each one-bit value {@code mb} of the mask, from least\n-     * significant to most significant, the next contiguous bit value\n-     * of {@code i} starting at the least significant bit is assigned\n-     * to the expanded value at the same bit location as {@code mb}.\n-     * All other remaining bits of the expanded value are set to zero.\n-     *\n-     * @apiNote\n-     * Consider the simple case of expanding the digits of a hexadecimal\n-     * value:\n-     * {@snippet lang=\"java\" :\n-     * expand(0x0000CABAB, 0xFF00FFF0) == 0xCA00BAB0\n-     * }\n-     * Starting from the least significant hexadecimal digit at position 0\n-     * from the right, the mask {@code 0xFF00FFF0} selects the first five\n-     * hexadecimal digits of {@code 0x0000CABAB}. The selected digits occur\n-     * in the resulting expanded value in order at positions 1, 2, 3, 6, and 7.\n-     * <p>\n-     * The following identities all return {@code true} and are helpful to\n-     * understand the behaviour of {@code expand}:\n-     * {@snippet lang=\"java\" :\n-     * \/\/ Logically shift right the bit at position 0\n-     * expand(x, 1 << n) == (x & 1) << n\n-     *\n-     * \/\/ Logically shift right\n-     * expand(x, -1 << n) == x << n\n-     *\n-     * \/\/ Expanding all bits returns the mask\n-     * expand(-1, m) == m\n-     *\n-     * \/\/ Any bits not covered by the mask are ignored\n-     * expand(x, m) == expand(x, m) & m\n-     *\n-     * \/\/ Compressing then expanding with the same mask\n-     * expand(compress(x, m), m) == x & m\n-     * }\n-     * <p>\n-     * The select operation for determining the position of the one-bit with\n-     * index {@code n} in a {@code long} value can be implemented as follows:\n-     * {@snippet lang=\"java\" :\n-     * long select(long i, long n) {\n-     *     \/\/ the one-bit in i (the mask) with index n\n-     * The following identities all return {@code true} and are helpful to\n-     * understand the behaviour of {@code expand}:\n-     * {@snippet lang=\"java\" :\n-     * \/\/ Logically shift right the bit at position 0\n-     * expand(x, 1 << n) == (x & 1) << n\n-     *\n-     * \/\/ Logically shift right\n-     * expand(x, -1 << n) == x << n\n-     *\n-     * \/\/ Expanding all bits returns the mask\n-     * expand(-1, m) == m\n-     *\n-     * \/\/ Any bits not covered by the mask are ignored\n-     * expand(x, m) == expand(x, m) & m\n-     *\n-     * \/\/ Compressing then expanding with the same mask\n-     * expand(compress(x, m), m) == x & m\n-     * }\n-     * <p>\n-     * The select operation for determining the position of the one-bit with\n-     * index {@code n} in a {@code long} value can be implemented as follows:\n-     * {@snippet lang=\"java\" :\n-     * long select(long i, long n) {\n-     *     \/\/ the one-bit in i (the mask) with index n\n-     *     long nthBit = Long.expand(1 << n, i);\n-     *     \/\/ the bit position of the one-bit with index n\n-     *     return Long.numberOfTrailingZeros(nthBit);\n-     * }\n-     *\n-     * \/\/ The one-bit with index 0 is at bit position 1\n-     * select(0b10101010_10101010, 0) == 1\n-     * \/\/ The one-bit with index 3 is at bit position 7\n-     * select(0b10101010_10101010, 3) == 7\n-     * }\n-     *\n-     * @param i the value whose bits are to be expanded\n-     * @param mask the bit mask\n-     * @return the expanded value\n-     * @see #compress\n-     * @since 19\n-     *\/\n-    static long expand(long i, long mask) {\n-        \/\/ Save original mask\n-        long originalMask = mask;\n-        \/\/ Count 0's to right\n-        long maskCount = ~mask << 1;\n-        long maskPrefix = parallelSuffix(maskCount);\n-        \/\/ Bits to move\n-        long maskMove1 = maskPrefix & mask;\n-        \/\/ Compress mask\n-        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        \/\/ Bits to move\n-        long maskMove2 = maskPrefix & mask;\n-        \/\/ Compress mask\n-        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        \/\/ Bits to move\n-        long maskMove3 = maskPrefix & mask;\n-        \/\/ Compress mask\n-        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        \/\/ Bits to move\n-        long maskMove4 = maskPrefix & mask;\n-        \/\/ Compress mask\n-        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        \/\/ Bits to move\n-        long maskMove5 = maskPrefix & mask;\n-        \/\/ Compress mask\n-        mask = (mask ^ maskMove5) | (maskMove5 >>> (1 << 4));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        \/\/ Bits to move\n-        long maskMove6 = maskPrefix & mask;\n-        long t = i << (1 << 5);\n-        i = (i & ~maskMove6) | (t & maskMove6);\n-        t = i << (1 << 4);\n-        i = (i & ~maskMove5) | (t & maskMove5);\n-        t = i << (1 << 3);\n-        i = (i & ~maskMove4) | (t & maskMove4);\n-        t = i << (1 << 2);\n-        i = (i & ~maskMove3) | (t & maskMove3);\n-        t = i << (1 << 1);\n-        i = (i & ~maskMove2) | (t & maskMove2);\n-        t = i << (1 << 0);\n-        i = (i & ~maskMove1) | (t & maskMove1);\n-\n-        \/\/ Clear irrelevant bits\n-        return i & originalMask;\n-    }\n-\n-    @ForceInline\n-    private static int parallelSuffix(int maskCount) {\n-        int maskPrefix = maskCount ^ (maskCount << 1);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-        return maskPrefix;\n-    }\n-\n-    @ForceInline\n-    private static long parallelSuffix(long maskCount) {\n-        long maskPrefix = maskCount ^ (maskCount << 1);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-        return maskPrefix;\n-    }\n-\n-}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/CompressExpand.java","additions":0,"deletions":502,"binary":false,"changes":502,"status":"deleted"},{"patch":"@@ -872,1 +872,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> Integer.compress(a, n));\n@@ -874,1 +874,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> Integer.expand(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -830,1 +830,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> Long.compress(a, n));\n@@ -832,1 +832,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> Long.expand(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -972,1 +972,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> $Boxtype$.compress(a, n));\n@@ -974,1 +974,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> $Boxtype$.expand(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import compress.CompressExpandTest;\n@@ -1962,1 +1961,1 @@\n-        return (int)(CompressExpandTest.compress(a, b));\n+        return (int)(Integer.compress(a, b));\n@@ -2006,1 +2005,1 @@\n-        return (int)(CompressExpandTest.expand(a, b));\n+        return (int)(Integer.expand(a, b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import compress.CompressExpandTest;\n@@ -1962,1 +1961,1 @@\n-        return (int)(CompressExpandTest.compress(a, b));\n+        return (int)(Integer.compress(a, b));\n@@ -2006,1 +2005,1 @@\n-        return (int)(CompressExpandTest.expand(a, b));\n+        return (int)(Integer.expand(a, b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import compress.CompressExpandTest;\n@@ -1962,1 +1961,1 @@\n-        return (int)(CompressExpandTest.compress(a, b));\n+        return (int)(Integer.compress(a, b));\n@@ -2006,1 +2005,1 @@\n-        return (int)(CompressExpandTest.expand(a, b));\n+        return (int)(Integer.expand(a, b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import compress.CompressExpandTest;\n@@ -1962,1 +1961,1 @@\n-        return (int)(CompressExpandTest.compress(a, b));\n+        return (int)(Integer.compress(a, b));\n@@ -2006,1 +2005,1 @@\n-        return (int)(CompressExpandTest.expand(a, b));\n+        return (int)(Integer.expand(a, b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import compress.CompressExpandTest;\n@@ -1967,1 +1966,1 @@\n-        return (int)(CompressExpandTest.compress(a, b));\n+        return (int)(Integer.compress(a, b));\n@@ -2011,1 +2010,1 @@\n-        return (int)(CompressExpandTest.expand(a, b));\n+        return (int)(Integer.expand(a, b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import compress.CompressExpandTest;\n@@ -1984,1 +1983,1 @@\n-        return (long)(CompressExpandTest.compress(a, b));\n+        return (long)(Long.compress(a, b));\n@@ -2028,1 +2027,1 @@\n-        return (long)(CompressExpandTest.expand(a, b));\n+        return (long)(Long.expand(a, b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import compress.CompressExpandTest;\n@@ -1984,1 +1983,1 @@\n-        return (long)(CompressExpandTest.compress(a, b));\n+        return (long)(Long.compress(a, b));\n@@ -2028,1 +2027,1 @@\n-        return (long)(CompressExpandTest.expand(a, b));\n+        return (long)(Long.expand(a, b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import compress.CompressExpandTest;\n@@ -1984,1 +1983,1 @@\n-        return (long)(CompressExpandTest.compress(a, b));\n+        return (long)(Long.compress(a, b));\n@@ -2028,1 +2027,1 @@\n-        return (long)(CompressExpandTest.expand(a, b));\n+        return (long)(Long.expand(a, b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import compress.CompressExpandTest;\n@@ -1984,1 +1983,1 @@\n-        return (long)(CompressExpandTest.compress(a, b));\n+        return (long)(Long.compress(a, b));\n@@ -2028,1 +2027,1 @@\n-        return (long)(CompressExpandTest.expand(a, b));\n+        return (long)(Long.expand(a, b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import compress.CompressExpandTest;\n@@ -1989,1 +1988,1 @@\n-        return (long)(CompressExpandTest.compress(a, b));\n+        return (long)(Long.compress(a, b));\n@@ -2033,1 +2032,1 @@\n-        return (long)(CompressExpandTest.expand(a, b));\n+        return (long)(Long.expand(a, b));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compress;\n-\n-public class CompressExpandTest {\n-    public static int compress(int i, int mask) {\n-        i = i & mask;\n-        int maskCount = ~mask << 1;\n-\n-        for (int j = 0; j < 5; j++) {\n-            int maskPrefix = parallelSuffix(maskCount);\n-            int maskMove = maskPrefix & mask;\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            int t = i & maskMove;\n-            i = (i ^ t) | (t >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return i;\n-    }\n-\n-    public static long compress(long i, long mask) {\n-        i = i & mask;\n-        long maskCount = ~mask << 1;\n-\n-        for (int j = 0; j < 6; j++) {\n-            long maskPrefix = parallelSuffix(maskCount);\n-            long maskMove = maskPrefix & mask;\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            long t = i & maskMove;\n-            i = (i ^ t) | (t >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return i;\n-    }\n-\n-    public static int expand(int i, int mask) {\n-        int originalMask = mask;\n-        int maskCount = ~mask << 1;\n-        int maskPrefix = parallelSuffix(maskCount);\n-        int maskMove1 = maskPrefix & mask;\n-        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        int maskMove2 = maskPrefix & mask;\n-        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        int maskMove3 = maskPrefix & mask;\n-        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        int maskMove4 = maskPrefix & mask;\n-        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        int maskMove5 = maskPrefix & mask;\n-\n-        int t = i << (1 << 4);\n-        i = (i & ~maskMove5) | (t & maskMove5);\n-        t = i << (1 << 3);\n-        i = (i & ~maskMove4) | (t & maskMove4);\n-        t = i << (1 << 2);\n-        i = (i & ~maskMove3) | (t & maskMove3);\n-        t = i << (1 << 1);\n-        i = (i & ~maskMove2) | (t & maskMove2);\n-        t = i << (1 << 0);\n-        i = (i & ~maskMove1) | (t & maskMove1);\n-\n-        return i & originalMask;\n-    }\n-\n-    public static long expand(long i, long mask) {\n-        long originalMask = mask;\n-        long maskCount = ~mask << 1;\n-        long maskPrefix = parallelSuffix(maskCount);\n-        long maskMove1 = maskPrefix & mask;\n-        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        long maskMove2 = maskPrefix & mask;\n-        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        long maskMove3 = maskPrefix & mask;\n-        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        long maskMove4 = maskPrefix & mask;\n-        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        long maskMove5 = maskPrefix & mask;\n-        mask = (mask ^ maskMove5) | (maskMove5 >>> (1 << 4));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        long maskMove6 = maskPrefix & mask;\n-        long t = i << (1 << 5);\n-        i = (i & ~maskMove6) | (t & maskMove6);\n-        t = i << (1 << 4);\n-        i = (i & ~maskMove5) | (t & maskMove5);\n-        t = i << (1 << 3);\n-        i = (i & ~maskMove4) | (t & maskMove4);\n-        t = i << (1 << 2);\n-        i = (i & ~maskMove3) | (t & maskMove3);\n-        t = i << (1 << 1);\n-        i = (i & ~maskMove2) | (t & maskMove2);\n-        t = i << (1 << 0);\n-        i = (i & ~maskMove1) | (t & maskMove1);\n-\n-        return i & originalMask;\n-    }\n-\n-    private static int parallelSuffix(int maskCount) {\n-        int maskPrefix = maskCount ^ (maskCount << 1);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-        return maskPrefix;\n-    }\n-\n-    private static long parallelSuffix(long maskCount) {\n-        long maskPrefix = maskCount ^ (maskCount << 1);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-        return maskPrefix;\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/compress\/CompressExpandTest.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -414,2 +414,2 @@\n-gen_binary_alu_op \"COMPRESS_BITS\" \"CompressExpandTest.compress(a, b)\" \"intOrLong\"\n-gen_binary_alu_op \"EXPAND_BITS\" \"CompressExpandTest.expand(a, b)\" \"intOrLong\"\n+gen_binary_alu_op \"COMPRESS_BITS\" \"\\$Boxtype\\$.compress(a, b)\" \"intOrLong\"\n+gen_binary_alu_op \"EXPAND_BITS\" \"\\$Boxtype\\$.expand(a, b)\" \"intOrLong\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Const(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Shift-Const-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Const(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)([[TEST_OP]]) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Shift-Masked-Const-op.template","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -43,0 +43,4 @@\n+#if[BITWISE]\n+    private static final $type$ CONST_SHIFT = $Boxtype$.SIZE \/ 2;\n+#end[BITWISE]\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-header.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,6 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Const(Blackhole bh) {\n+[[KERNEL]]\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Shift-Const-op.template","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Const(Blackhole bh) {\n+[[KERNEL]]\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Shift-Masked-Const-op.template","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -80,0 +80,4 @@\n+#if[BITWISE]\n+    private static final $type$ CONST_SHIFT = $Boxtype$.SIZE \/ 2;\n+#end[BITWISE]\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-header.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import compress.CompressExpandTest;\n@@ -57,1 +56,0 @@\n-import compress.CompressExpandTest;\n@@ -94,0 +92,1 @@\n+#if[BITWISE]\n@@ -95,0 +94,1 @@\n+#end[BITWISE]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n@@ -883,0 +885,184 @@\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n@@ -883,0 +885,184 @@\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n@@ -883,0 +885,184 @@\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n@@ -883,0 +885,184 @@\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n@@ -883,0 +885,184 @@\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n@@ -838,1 +840,1 @@\n-                rs[i] = (byte)(ROR_scalar(a,b));\n+                rs[i] = (byte)(ROR_scalar(a, b));\n@@ -859,1 +861,1 @@\n-                rs[i] = (m ? (byte)(ROR_scalar(a,b)) : a);\n+                rs[i] = (m ? (byte)(ROR_scalar(a, b)) : a);\n@@ -878,1 +880,1 @@\n-                rs[i] = (byte)(ROL_scalar(a,b));\n+                rs[i] = (byte)(ROL_scalar(a, b));\n@@ -899,1 +901,205 @@\n-                rs[i] = (m ? (byte)(ROL_scalar(a,b)) : a);\n+                rs[i] = (m ? (byte)(ROL_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(((a & 0xFF) >>> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(((a & 0xFF) >>> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a << CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a << CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a >> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a >> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROR_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(ROR_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROL_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(ROL_scalar(a, CONST_SHIFT)) : a);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":210,"deletions":4,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.jdk.incubator.vector.operation;\n-\n-public class CompressExpandTest {\n-    public static int compress(int i, int mask) {\n-        i = i & mask;\n-        int maskCount = ~mask << 1;\n-\n-        for (int j = 0; j < 5; j++) {\n-            int maskPrefix = parallelSuffix(maskCount);\n-            int maskMove = maskPrefix & mask;\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            int t = i & maskMove;\n-            i = (i ^ t) | (t >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return i;\n-    }\n-\n-    public static long compress(long i, long mask) {\n-        i = i & mask;\n-        long maskCount = ~mask << 1;\n-\n-        for (int j = 0; j < 6; j++) {\n-            long maskPrefix = parallelSuffix(maskCount);\n-            long maskMove = maskPrefix & mask;\n-            mask = (mask ^ maskMove) | (maskMove >>> (1 << j));\n-            long t = i & maskMove;\n-            i = (i ^ t) | (t >>> (1 << j));\n-            maskCount = maskCount & ~maskPrefix;\n-        }\n-        return i;\n-    }\n-\n-    public static int expand(int i, int mask) {\n-        int originalMask = mask;\n-        int maskCount = ~mask << 1;\n-        int maskPrefix = parallelSuffix(maskCount);\n-        int maskMove1 = maskPrefix & mask;\n-        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        int maskMove2 = maskPrefix & mask;\n-        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        int maskMove3 = maskPrefix & mask;\n-        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        int maskMove4 = maskPrefix & mask;\n-        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        int maskMove5 = maskPrefix & mask;\n-\n-        int t = i << (1 << 4);\n-        i = (i & ~maskMove5) | (t & maskMove5);\n-        t = i << (1 << 3);\n-        i = (i & ~maskMove4) | (t & maskMove4);\n-        t = i << (1 << 2);\n-        i = (i & ~maskMove3) | (t & maskMove3);\n-        t = i << (1 << 1);\n-        i = (i & ~maskMove2) | (t & maskMove2);\n-        t = i << (1 << 0);\n-        i = (i & ~maskMove1) | (t & maskMove1);\n-\n-        return i & originalMask;\n-    }\n-\n-    public static long expand(long i, long mask) {\n-        long originalMask = mask;\n-        long maskCount = ~mask << 1;\n-        long maskPrefix = parallelSuffix(maskCount);\n-        long maskMove1 = maskPrefix & mask;\n-        mask = (mask ^ maskMove1) | (maskMove1 >>> (1 << 0));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        long maskMove2 = maskPrefix & mask;\n-        mask = (mask ^ maskMove2) | (maskMove2 >>> (1 << 1));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        long maskMove3 = maskPrefix & mask;\n-        mask = (mask ^ maskMove3) | (maskMove3 >>> (1 << 2));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        long maskMove4 = maskPrefix & mask;\n-        mask = (mask ^ maskMove4) | (maskMove4 >>> (1 << 3));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        long maskMove5 = maskPrefix & mask;\n-        mask = (mask ^ maskMove5) | (maskMove5 >>> (1 << 4));\n-        maskCount = maskCount & ~maskPrefix;\n-\n-        maskPrefix = parallelSuffix(maskCount);\n-        long maskMove6 = maskPrefix & mask;\n-        long t = i << (1 << 5);\n-        i = (i & ~maskMove6) | (t & maskMove6);\n-        t = i << (1 << 4);\n-        i = (i & ~maskMove5) | (t & maskMove5);\n-        t = i << (1 << 3);\n-        i = (i & ~maskMove4) | (t & maskMove4);\n-        t = i << (1 << 2);\n-        i = (i & ~maskMove3) | (t & maskMove3);\n-        t = i << (1 << 1);\n-        i = (i & ~maskMove2) | (t & maskMove2);\n-        t = i << (1 << 0);\n-        i = (i & ~maskMove1) | (t & maskMove1);\n-\n-        return i & originalMask;\n-    }\n-\n-    private static int parallelSuffix(int maskCount) {\n-        int maskPrefix = maskCount ^ (maskCount << 1);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-        return maskPrefix;\n-    }\n-\n-    private static long parallelSuffix(long maskCount) {\n-        long maskPrefix = maskCount ^ (maskCount << 1);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 2);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 4);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 8);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 16);\n-        maskPrefix = maskPrefix ^ (maskPrefix << 32);\n-        return maskPrefix;\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/CompressExpandTest.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -327,0 +328,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -327,0 +328,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -327,0 +328,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -327,0 +328,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -327,0 +328,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+\n@@ -345,0 +346,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -327,0 +328,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -327,0 +328,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -327,0 +328,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -327,0 +328,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -327,0 +328,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+\n@@ -345,0 +346,14 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n@@ -959,0 +961,184 @@\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n@@ -959,0 +961,184 @@\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n@@ -959,0 +961,184 @@\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n@@ -959,0 +961,184 @@\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n@@ -959,0 +961,184 @@\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n@@ -477,1 +479,1 @@\n-                rs[i] = (int)(CompressExpandTest.compress(a, b));\n+                rs[i] = (int)(Integer.compress(a, b));\n@@ -498,1 +500,1 @@\n-                    rs[i] = (int)(CompressExpandTest.compress(a, b));\n+                    rs[i] = (int)(Integer.compress(a, b));\n@@ -519,1 +521,1 @@\n-                rs[i] = (int)(CompressExpandTest.expand(a, b));\n+                rs[i] = (int)(Integer.expand(a, b));\n@@ -540,1 +542,1 @@\n-                    rs[i] = (int)(CompressExpandTest.expand(a, b));\n+                    rs[i] = (int)(Integer.expand(a, b));\n@@ -915,1 +917,1 @@\n-                rs[i] = (int)(ROR_scalar(a,b));\n+                rs[i] = (int)(ROR_scalar(a, b));\n@@ -936,1 +938,1 @@\n-                rs[i] = (m ? (int)(ROR_scalar(a,b)) : a);\n+                rs[i] = (m ? (int)(ROR_scalar(a, b)) : a);\n@@ -955,1 +957,1 @@\n-                rs[i] = (int)(ROL_scalar(a,b));\n+                rs[i] = (int)(ROL_scalar(a, b));\n@@ -976,1 +978,205 @@\n-                rs[i] = (m ? (int)(ROL_scalar(a,b)) : a);\n+                rs[i] = (m ? (int)(ROL_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >>> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a >>> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a << CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a << CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a >> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROR_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(ROR_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROL_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(ROL_scalar(a, CONST_SHIFT)) : a);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":214,"deletions":8,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n@@ -959,0 +961,184 @@\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n@@ -959,0 +961,184 @@\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n@@ -959,0 +961,184 @@\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n@@ -959,0 +961,184 @@\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n@@ -959,0 +961,184 @@\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n@@ -477,1 +479,1 @@\n-                rs[i] = (long)(CompressExpandTest.compress(a, b));\n+                rs[i] = (long)(Long.compress(a, b));\n@@ -498,1 +500,1 @@\n-                    rs[i] = (long)(CompressExpandTest.compress(a, b));\n+                    rs[i] = (long)(Long.compress(a, b));\n@@ -519,1 +521,1 @@\n-                rs[i] = (long)(CompressExpandTest.expand(a, b));\n+                rs[i] = (long)(Long.expand(a, b));\n@@ -540,1 +542,1 @@\n-                    rs[i] = (long)(CompressExpandTest.expand(a, b));\n+                    rs[i] = (long)(Long.expand(a, b));\n@@ -915,1 +917,1 @@\n-                rs[i] = (long)(ROR_scalar(a,b));\n+                rs[i] = (long)(ROR_scalar(a, b));\n@@ -936,1 +938,1 @@\n-                rs[i] = (m ? (long)(ROR_scalar(a,b)) : a);\n+                rs[i] = (m ? (long)(ROR_scalar(a, b)) : a);\n@@ -955,1 +957,1 @@\n-                rs[i] = (long)(ROL_scalar(a,b));\n+                rs[i] = (long)(ROL_scalar(a, b));\n@@ -976,1 +978,205 @@\n-                rs[i] = (m ? (long)(ROL_scalar(a,b)) : a);\n+                rs[i] = (m ? (long)(ROL_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >>> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a >>> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a << CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a << CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a >> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROR_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(ROR_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROL_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(ROL_scalar(a, CONST_SHIFT)) : a);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":214,"deletions":8,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n@@ -883,0 +885,184 @@\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n@@ -883,0 +885,184 @@\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n@@ -883,0 +885,184 @@\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n@@ -883,0 +885,184 @@\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n@@ -883,0 +885,184 @@\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n@@ -839,1 +841,1 @@\n-                rs[i] = (short)(ROR_scalar(a,b));\n+                rs[i] = (short)(ROR_scalar(a, b));\n@@ -860,1 +862,1 @@\n-                rs[i] = (m ? (short)(ROR_scalar(a,b)) : a);\n+                rs[i] = (m ? (short)(ROR_scalar(a, b)) : a);\n@@ -879,1 +881,1 @@\n-                rs[i] = (short)(ROL_scalar(a,b));\n+                rs[i] = (short)(ROL_scalar(a, b));\n@@ -900,1 +902,205 @@\n-                rs[i] = (m ? (short)(ROL_scalar(a,b)) : a);\n+                rs[i] = (m ? (short)(ROL_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(((a & 0xFFFF) >>> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(((a & 0xFFFF) >>> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a << CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a << CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a >> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a >> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROR_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(ROR_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROL_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(ROL_scalar(a, CONST_SHIFT)) : a);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":210,"deletions":4,"binary":false,"changes":214,"status":"modified"}]}