{"files":[{"patch":"@@ -130,21 +130,0 @@\n-  static Assembler::SIMD_RegVariant elemBytes_to_regVariant(int esize) {\n-    switch(esize) {\n-      case 1:\n-        return Assembler::B;\n-      case 2:\n-        return Assembler::H;\n-      case 4:\n-        return Assembler::S;\n-      case 8:\n-        return Assembler::D;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-    return Assembler::INVALID;\n-  }\n-\n-  static Assembler::SIMD_RegVariant elemType_to_regVariant(BasicType bt) {\n-    return elemBytes_to_regVariant(type2aelembytes(bt));\n-  }\n-\n@@ -180,1 +159,1 @@\n-      (masm.*insn)(reg, elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n+      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n@@ -187,30 +166,0 @@\n-  static void sve_compare(C2_MacroAssembler masm, PRegister pd, BasicType bt,\n-                          PRegister pg, FloatRegister zn, FloatRegister zm, int cond) {\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n-    if (bt == T_FLOAT || bt == T_DOUBLE) {\n-      switch (cond) {\n-        case BoolTest::eq: masm.sve_fcmeq(pd, size, pg, zn, zm); break;\n-        case BoolTest::ne: masm.sve_fcmne(pd, size, pg, zn, zm); break;\n-        case BoolTest::ge: masm.sve_fcmge(pd, size, pg, zn, zm); break;\n-        case BoolTest::gt: masm.sve_fcmgt(pd, size, pg, zn, zm); break;\n-        case BoolTest::le: masm.sve_fcmge(pd, size, pg, zm, zn); break;\n-        case BoolTest::lt: masm.sve_fcmgt(pd, size, pg, zm, zn); break;\n-        default:\n-          assert(false, \"unsupported\");\n-          ShouldNotReachHere();\n-      }\n-    } else {\n-      switch (cond) {\n-        case BoolTest::eq: masm.sve_cmpeq(pd, size, pg, zn, zm); break;\n-        case BoolTest::ne: masm.sve_cmpne(pd, size, pg, zn, zm); break;\n-        case BoolTest::ge: masm.sve_cmpge(pd, size, pg, zn, zm); break;\n-        case BoolTest::gt: masm.sve_cmpgt(pd, size, pg, zn, zm); break;\n-        case BoolTest::le: masm.sve_cmpge(pd, size, pg, zm, zn); break;\n-        case BoolTest::lt: masm.sve_cmpgt(pd, size, pg, zm, zn); break;\n-        default:\n-          assert(false, \"unsupported\");\n-          ShouldNotReachHere();\n-      }\n-    }\n-  }\n-\n@@ -233,1 +182,1 @@\n-        if (vlen < 4) {\n+        if (vlen < 4 || length_in_bytes > MaxVectorSize) {\n@@ -235,0 +184,2 @@\n+        } else {\n+          return true;\n@@ -236,1 +187,0 @@\n-        break;\n@@ -243,2 +193,2 @@\n-    \/\/ By default, we only support vector operations with larger than 16 bytes.\n-    return 16 <= length_in_bytes && length_in_bytes <= MaxVectorSize && vlen >= 2;\n+    \/\/ By default, we only support vector operations with no less than 8 bytes and 2 elements.\n+    return 8 <= length_in_bytes && length_in_bytes <= MaxVectorSize && vlen >= 2;\n@@ -263,1 +213,1 @@\n-  format %{ \"sve_ldr $dst, $mem\\t # vector (sve)\" %}\n+  format %{ \"sve_ldr $dst, $mem\\t# vector (sve)\" %}\n@@ -279,1 +229,1 @@\n-  format %{ \"sve_str $mem, $src\\t # vector (sve)\" %}\n+  format %{ \"sve_str $mem, $src\\t# vector (sve)\" %}\n@@ -390,1 +340,1 @@\n-            \"sve_ldr $dst, $pTmp, $mem\\t # load vector predicated\" %}\n+            \"sve_ldr $dst, $pTmp, $mem\\t# load vector predicated\" %}\n@@ -394,1 +344,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -412,1 +362,1 @@\n-            \"sve_str $src, $pTmp, $mem\\t # store vector predicated\" %}\n+            \"sve_str $src, $pTmp, $mem\\t# store vector predicated\" %}\n@@ -416,1 +366,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -671,1 +621,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -685,1 +635,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -700,1 +650,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -715,1 +665,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -763,1 +713,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -783,1 +733,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -1155,1 +1105,1 @@\n-            \"sve_cpy $dst, $pTmp, -1\\t # vector mask cmp (sve)\" %}\n+            \"sve_cpy $dst, $pTmp, -1\\t# vector mask cmp (sve)\" %}\n@@ -1158,4 +1108,3 @@\n-    sve_compare(C2_MacroAssembler(&cbuf), as_PRegister($pTmp$$reg), bt,\n-                ptrue, as_FloatRegister($src1$$reg),\n-                as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-    __ sve_cpy(as_FloatRegister($dst$$reg), elemType_to_regVariant(bt),\n+    __ sve_compare(as_PRegister($pTmp$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n+                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n@@ -1175,1 +1124,1 @@\n-            \"sve_sel $dst, $pTmp, $src2, $src1\\t # vector blend (sve)\" %}\n+            \"sve_sel $dst, $pTmp, $src2, $src1\\t# vector blend (sve)\" %}\n@@ -1178,1 +1127,1 @@\n-              elemType_to_regVariant(vector_element_basic_type(this));\n+      __ elemType_to_regVariant(vector_element_basic_type(this));\n@@ -1195,2 +1144,2 @@\n-  format %{ \"sve_cmp $pTmp, $src3, $src4\\t # vector cmp (sve)\\n\\t\"\n-            \"sve_sel $dst, $pTmp, $src2, $src1\\t # vector blend (sve)\" %}\n+  format %{ \"sve_cmp $pTmp, $src3, $src4\\t# vector cmp (sve)\\n\\t\"\n+            \"sve_sel $dst, $pTmp, $src2, $src1\\t# vector blend (sve)\" %}\n@@ -1199,4 +1148,3 @@\n-    sve_compare(C2_MacroAssembler(&cbuf), as_PRegister($pTmp$$reg), bt,\n-                ptrue, as_FloatRegister($src3$$reg),\n-                as_FloatRegister($src4$$reg), (int)$cond$$constant);\n-    __ sve_sel(as_FloatRegister($dst$$reg), elemType_to_regVariant(bt),\n+    __ sve_compare(as_PRegister($pTmp$$reg), bt, ptrue, as_FloatRegister($src3$$reg),\n+                   as_FloatRegister($src4$$reg), (int)$cond$$constant);\n+    __ sve_sel(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n@@ -1216,1 +1164,1 @@\n-  format %{ \"sve_neg $dst, $src\\t # vector load mask (B)\" %}\n+  format %{ \"sve_neg $dst, $src\\t# vector load mask (B)\" %}\n@@ -1229,1 +1177,1 @@\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to H)\" %}\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to H)\" %}\n@@ -1245,1 +1193,1 @@\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to S)\" %}\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to S)\" %}\n@@ -1263,1 +1211,1 @@\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to D)\" %}\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to D)\" %}\n@@ -1279,1 +1227,1 @@\n-  format %{ \"sve_neg $dst, $src\\t # vector store mask (B)\" %}\n+  format %{ \"sve_neg $dst, $src\\t# vector store mask (B)\" %}\n@@ -1294,1 +1242,1 @@\n-            \"sve_neg $dst, B, $dst\\t # vector store mask (sve) (H to B)\" %}\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (H to B)\" %}\n@@ -1314,1 +1262,1 @@\n-            \"sve_neg $dst, B, $dst\\t # vector store mask (sve) (S to B)\" %}\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (S to B)\" %}\n@@ -1336,1 +1284,1 @@\n-            \"sve_neg $dst, B, $dst\\t # vector store mask (sve) (D to B)\" %}\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (D to B)\" %}\n@@ -1359,1 +1307,1 @@\n-            \"sve_neg $dst, $dst\\t # load vector mask (sve)\" %}\n+            \"sve_neg $dst, $dst\\t# load vector mask (sve)\" %}\n@@ -1363,1 +1311,1 @@\n-    Assembler::SIMD_RegVariant to_vect_variant = elemType_to_regVariant(to_vect_bt);\n+    Assembler::SIMD_RegVariant to_vect_variant = __ elemType_to_regVariant(to_vect_bt);\n@@ -1378,1 +1326,1 @@\n-            \"sve_neg $dst, $dst\\t # load vector mask (sve)\" %}\n+            \"sve_neg $dst, $dst\\t# load vector mask (sve)\" %}\n@@ -1382,1 +1330,1 @@\n-    Assembler::SIMD_RegVariant to_vect_variant = elemType_to_regVariant(to_vect_bt);\n+    Assembler::SIMD_RegVariant to_vect_variant = __ elemType_to_regVariant(to_vect_bt);\n@@ -1398,1 +1346,1 @@\n-            \"sve_st1b $tmp, $mem\\t # store vector mask (sve)\" %}\n+            \"sve_st1b $tmp, $mem\\t# store vector mask (sve)\" %}\n@@ -1402,1 +1350,1 @@\n-    Assembler::SIMD_RegVariant from_vect_variant = elemBytes_to_regVariant($esize$$constant);\n+    Assembler::SIMD_RegVariant from_vect_variant = __ elemBytes_to_regVariant($esize$$constant);\n@@ -1419,1 +1367,1 @@\n-            \"sve_st1b $tmp, $mem\\t # store vector mask (sve)\" %}\n+            \"sve_st1b $tmp, $mem\\t# store vector mask (sve)\" %}\n@@ -1423,1 +1371,1 @@\n-    Assembler::SIMD_RegVariant from_vect_variant = elemBytes_to_regVariant($esize$$constant);\n+    Assembler::SIMD_RegVariant from_vect_variant = __ elemBytes_to_regVariant($esize$$constant);\n@@ -1433,1 +1381,0 @@\n-\n@@ -1436,43 +1383,2 @@\n-instruct reduce_addB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (AddReductionVI src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (B)\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"addw  $dst, $dst, $src1\\n\\t\"\n-            \"sxtb  $dst, $dst\\t # add reduction B\" %}\n-  ins_encode %{\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ B,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (AddReductionVI src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (H)\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"addw  $dst, $dst, $src1\\n\\t\"\n-            \"sxth  $dst, $dst\\t # add reduction H\" %}\n-  ins_encode %{\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ H,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n@@ -1480,1 +1386,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1482,3 +1388,1 @@\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (S)\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"addw  $dst, $dst, $src1\\t # add reduction S\" %}\n+  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addB\/S\/I reduction (sve) (may extend)\" %}\n@@ -1486,3 +1390,4 @@\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);\n+    BasicType bt = vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n@@ -1490,41 +1395,7 @@\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (AddReductionVL src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) (D)\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"add  $dst, $dst, $src1\\t # add reduction D\" %}\n-  ins_encode %{\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ add($dst$$Register, $dst$$Register, $src1$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addF(vRegF src1_dst, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set src1_dst (AddReductionVF src1_dst src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (S)\" %}\n-  ins_encode %{\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_addD(vRegD src1_dst, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set src1_dst (AddReductionVD src1_dst src2));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (D)\" %}\n-  ins_encode %{\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1544,1 +1415,1 @@\n-    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n@@ -1555,0 +1426,2 @@\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n@@ -1560,0 +1433,14 @@\n+instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction (sve)\" %}\n+  ins_encode %{\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ add($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1578,2 +1465,3 @@\n-instruct reduce_addF_partial(vRegF src1_dst, vReg src2, pRegGov ptmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+\n+instruct reduce_addF(vRegF src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n@@ -1582,1 +1470,0 @@\n-  effect(TEMP ptmp, KILL cr);\n@@ -1585,2 +1472,0 @@\n-    __ mov(rscratch1, vector_length(this, $src2));\n-    __ sve_whilelo(as_PRegister($ptmp$$reg), __ S, zr, rscratch1);\n@@ -1588,1 +1473,1 @@\n-                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+         ptrue, as_FloatRegister($src2$$reg));\n@@ -1593,1 +1478,1 @@\n-instruct reduce_addD_partial(vRegD src1_dst, vReg src2, pRegGov ptmp, rFlagsReg cr) %{\n+instruct reduce_addF_partial(vRegF src1_dst, vReg src2, pRegGov ptmp, rFlagsReg cr) %{\n@@ -1595,1 +1480,1 @@\n-  match(Set src1_dst (AddReductionVD src1_dst src2));\n+  match(Set src1_dst (AddReductionVF src1_dst src2));\n@@ -1598,1 +1483,1 @@\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (D)\" %}\n+  format %{ \"sve_reduce_addF $src1_dst, $src1_dst, $src2\\t# addF reduction partial (sve) (S)\" %}\n@@ -1601,2 +1486,2 @@\n-    __ sve_whilelo(as_PRegister($ptmp$$reg), __ D, zr, rscratch1);\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n+    __ sve_whilelo(as_PRegister($ptmp$$reg), __ S, zr, rscratch1);\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ S,\n@@ -1608,7 +1493,3 @@\n-\/\/ vector and reduction\n-\n-instruct reduce_andB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (AndReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n+instruct reduce_addD(vRegD src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set src1_dst (AddReductionVD src1_dst src2));\n@@ -1616,4 +1497,1 @@\n-  format %{ \"sve_andv $tmp, $src2\\t# vector (sve) (B)\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"andw  $dst, $dst, $src1\\n\\t\"\n-            \"sxtb  $dst, $dst\\t # and reduction B\" %}\n+  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) (D)\" %}\n@@ -1621,1 +1499,1 @@\n-    __ sve_andv(as_FloatRegister($tmp$$reg), __ B,\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n@@ -1623,3 +1501,0 @@\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ andw($dst$$Register, $dst$$Register, $src1$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n@@ -1630,5 +1505,3 @@\n-instruct reduce_andS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (AndReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n+instruct reduce_addD_partial(vRegD src1_dst, vReg src2, pRegGov ptmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() < MaxVectorSize);\n+  match(Set src1_dst (AddReductionVD src1_dst src2));\n@@ -1636,4 +1509,2 @@\n-  format %{ \"sve_andv $tmp, $src2\\t# vector (sve) (H)\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"andw  $dst, $dst, $src1\\n\\t\"\n-            \"sxth  $dst, $dst\\t # and reduction H\" %}\n+  effect(TEMP ptmp, KILL cr);\n+  format %{ \"sve_reduce_addD $src1_dst, $src1_dst, $src2\\t# addD reduction partial (sve) (D)\" %}\n@@ -1641,5 +1512,4 @@\n-    __ sve_andv(as_FloatRegister($tmp$$reg), __ H,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ andw($dst$$Register, $dst$$Register, $src1$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n+    __ mov(rscratch1, vector_length(this, $src2));\n+    __ sve_whilelo(as_PRegister($ptmp$$reg), __ D, zr, rscratch1);\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ D,\n+                 as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1650,17 +1520,1 @@\n-instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (AndReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_andv $tmp, $src2\\t# vector (sve) (S)\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"andw  $dst, $dst, $src1\\t # and reduction S\" %}\n-  ins_encode %{\n-    __ sve_andv(as_FloatRegister($tmp$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ andw($dst$$Register, $dst$$Register, $src1$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n+\/\/ vector and reduction\n@@ -1668,2 +1522,2 @@\n-instruct reduce_andL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n@@ -1672,1 +1526,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1674,3 +1528,1 @@\n-  format %{ \"sve_andv $tmp, $src2\\t# vector (sve) (D)\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"andr  $dst, $dst, $src1\\t # and reduction D\" %}\n+  format %{ \"sve_reduce_andI $dst, $src1, $src2\\t# andB\/S\/I reduction (sve) (may extend)\" %}\n@@ -1678,4 +1530,12 @@\n-    __ sve_andv(as_FloatRegister($tmp$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ andr($dst$$Register, $dst$$Register, $src1$$Register);\n+    BasicType bt = vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ andw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1696,1 +1556,1 @@\n-    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n@@ -1700,1 +1560,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1707,0 +1567,2 @@\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n@@ -1712,0 +1574,15 @@\n+instruct reduce_andL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_andL $dst, $src1, $src2\\t# andL reduction (sve)\" %}\n+  ins_encode %{\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ andr($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1724,1 +1601,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1731,1 +1608,0 @@\n-\n@@ -1734,42 +1610,2 @@\n-instruct reduce_orB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (OrReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orv $tmp, $src2\\t# vector (sve) (B)\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"orrw  $dst, $dst, $src1\\n\\t\"\n-            \"sxtb  $dst, $dst\\t # or reduction B\" %}\n-  ins_encode %{\n-    __ sve_orv(as_FloatRegister($tmp$$reg), __ B,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ orrw($dst$$Register, $dst$$Register, $src1$$Register);\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (OrReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orv $tmp, $src2\\t# vector (sve) (H)\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"orrw  $dst, $dst, $src1\\n\\t\"\n-            \"sxth  $dst, $dst\\t # or reduction H\" %}\n-  ins_encode %{\n-    __ sve_orv(as_FloatRegister($tmp$$reg), __ H,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ orrw($dst$$Register, $dst$$Register, $src1$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&\n+instruct reduce_orI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n@@ -1778,1 +1614,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1780,3 +1616,1 @@\n-  format %{ \"sve_orv $tmp, $src2\\t# vector (sve) (S)\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"orrw  $dst, $dst, $src1\\t # or reduction S\" %}\n+  format %{ \"sve_reduce_orI $dst, $src1, $src2\\t# orB\/S\/I reduction (sve) (may extend)\" %}\n@@ -1784,3 +1618,4 @@\n-    __ sve_orv(as_FloatRegister($tmp$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);\n+    BasicType bt = vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n@@ -1788,18 +1623,7 @@\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_orL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (OrReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orv $tmp, $src2\\t# vector (sve) (D)\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"orr  $dst, $dst, $src1\\t # or reduction D\" %}\n-  ins_encode %{\n-    __ sve_orv(as_FloatRegister($tmp$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ orr($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1820,1 +1644,1 @@\n-    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n@@ -1824,1 +1648,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1831,0 +1655,2 @@\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n@@ -1836,0 +1662,15 @@\n+instruct reduce_orL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (OrReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_orL $dst, $src1, $src2\\t# orL reduction (sve)\" %}\n+  ins_encode %{\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ orr($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1848,1 +1689,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1855,1 +1696,0 @@\n-\n@@ -1858,3 +1698,2 @@\n-instruct reduce_eorB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&\n+instruct reduce_eorI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n@@ -1863,1 +1702,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1865,4 +1704,1 @@\n-  format %{ \"sve_eorv $tmp, $src2\\t# vector (sve) (B)\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"eorw  $dst, $dst, $src1\\n\\t\"\n-            \"sxtb  $dst, $dst\\t # eor reduction B\" %}\n+  format %{ \"sve_reduce_eorI $dst, $src1, $src2\\t# xorB\/H\/I reduction (sve) (may extend)\" %}\n@@ -1870,3 +1706,4 @@\n-    __ sve_eorv(as_FloatRegister($tmp$$reg), __ B,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n+    BasicType bt = vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n@@ -1874,60 +1711,7 @@\n-    __ sxtb($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eorS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (XorReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eorv $tmp, $src2\\t# vector (sve) (H)\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"eorw  $dst, $dst, $src1\\n\\t\"\n-            \"sxth  $dst, $dst\\t # eor reduction H\" %}\n-  ins_encode %{\n-    __ sve_eorv(as_FloatRegister($tmp$$reg), __ H,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ eorw($dst$$Register, $dst$$Register, $src1$$Register);\n-    __ sxth($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eorI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (XorReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eorv $tmp, $src2\\t# vector (sve) (S)\\n\\t\"\n-            \"umov  $dst, $tmp, S, 0\\n\\t\"\n-            \"eorw  $dst, $dst, $src1\\t # eor reduction S\" %}\n-  ins_encode %{\n-    __ sve_eorv(as_FloatRegister($tmp$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ eorw($dst$$Register, $dst$$Register, $src1$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_eorL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (XorReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eorv $tmp, $src2\\t# vector (sve) (D)\\n\\t\"\n-            \"umov  $dst, $tmp, D, 0\\n\\t\"\n-            \"eor  $dst, $dst, $src1\\t # eor reduction D\" %}\n-  ins_encode %{\n-    __ sve_eorv(as_FloatRegister($tmp$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ eor($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1948,1 +1732,1 @@\n-    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n@@ -1952,1 +1736,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1959,0 +1743,2 @@\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n@@ -1964,0 +1750,15 @@\n+instruct reduce_eorL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (XorReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_eorL $dst, $src1, $src2\\t# xorL reduction (sve)\" %}\n+  ins_encode %{\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ eor($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1976,1 +1777,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1986,43 +1787,5 @@\n-instruct reduce_maxB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (MaxReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_smaxv $tmp, $src2\\t# vector (sve) (B)\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $src1\\n\\t\"\n-            \"cselw $dst, $dst, $src1 GT\\t# max reduction B\" %}\n-  ins_encode %{\n-    __ sve_smaxv(as_FloatRegister($tmp$$reg), __ B,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, $src1$$Register);\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (MaxReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_smaxv $tmp, $src2\\t# vector (sve) (H)\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $src1\\n\\t\"\n-            \"cselw $dst, $dst, $src1 GT\\t# max reduction H\" %}\n-  ins_encode %{\n-    __ sve_smaxv(as_FloatRegister($tmp$$reg), __ H,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw($dst$$Register, $src1$$Register);\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_maxI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+instruct reduce_maxI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -2030,1 +1793,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -2032,4 +1795,1 @@\n-  format %{ \"sve_smaxv $tmp, $src2\\t# vector (sve) (S)\\n\\t\"\n-            \"smov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $src1\\n\\t\"\n-            \"cselw $dst, $dst, $src1 GT\\t# max reduction S\" %}\n+  format %{ \"sve_reduce_maxI $dst, $src1, $src2\\t# reduce maxB\/S\/I (sve)\" %}\n@@ -2037,3 +1797,4 @@\n-    __ sve_smaxv(as_FloatRegister($tmp$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);\n+    BasicType bt = vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_smaxv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n@@ -2046,20 +1807,0 @@\n-instruct reduce_maxL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (MaxReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_smaxv $tmp, $src2\\t# vector (sve) (D)\\n\\t\"\n-            \"smov  $dst, $tmp, D, 0\\n\\t\"\n-            \"cmp  $dst, $src1\\n\\t\"\n-            \"csel $dst, $dst, $src1 GT\\t# max reduction D\" %}\n-  ins_encode %{\n-    __ sve_smaxv(as_FloatRegister($tmp$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ cmp($dst$$Register, $src1$$Register);\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2078,1 +1819,1 @@\n-    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n@@ -2090,0 +1831,16 @@\n+instruct reduce_maxL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (MaxReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_maxL $dst, $src1, $src2\\t# reduce maxL partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_smaxv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ cmp($dst$$Register, $src1$$Register);\n+    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::GT);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2117,1 +1874,1 @@\n-            \"fmaxs $dst, $dst, $src1\\t # max reduction F\" %}\n+            \"fmaxs $dst, $dst, $src1\\t# max reduction F\" %}\n@@ -2126,16 +1883,0 @@\n-instruct reduce_maxD(vRegD dst, vRegD src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (MaxReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_fmaxv $dst, $src2 # vector (sve) (D)\\n\\t\"\n-            \"fmaxs $dst, $dst, $src1\\t # max reduction D\" %}\n-  ins_encode %{\n-    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2160,0 +1901,16 @@\n+instruct reduce_maxD(vRegD dst, vRegD src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (MaxReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fmaxv $dst, $src2 # vector (sve) (D)\\n\\t\"\n+            \"fmaxs $dst, $dst, $src1\\t# max reduction D\" %}\n+  ins_encode %{\n+    __ sve_fmaxv(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2180,43 +1937,5 @@\n-instruct reduce_minB(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (MinReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sminv $tmp, $src2\\t# vector (sve) (B)\\n\\t\"\n-            \"smov  $dst, $tmp, B, 0\\n\\t\"\n-            \"cmpw  $dst, $src1\\n\\t\"\n-            \"cselw $dst, $dst, $src1 LT\\t# min reduction B\" %}\n-  ins_encode %{\n-    __ sve_sminv(as_FloatRegister($tmp$$reg), __ B,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ B, 0);\n-    __ cmpw($dst$$Register, $src1$$Register);\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minS(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (MinReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sminv $tmp, $src2\\t# vector (sve) (H)\\n\\t\"\n-            \"smov  $dst, $tmp, H, 0\\n\\t\"\n-            \"cmpw  $dst, $src1\\n\\t\"\n-            \"cselw $dst, $dst, $src1 LT\\t# min reduction H\" %}\n-  ins_encode %{\n-    __ sve_sminv(as_FloatRegister($tmp$$reg), __ H,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ cmpw($dst$$Register, $src1$$Register);\n-    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_minI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+instruct reduce_minI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -2224,1 +1943,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -2226,4 +1945,1 @@\n-  format %{ \"sve_sminv $tmp, $src2\\t# vector (sve) (S)\\n\\t\"\n-            \"smov  $dst, $tmp, S, 0\\n\\t\"\n-            \"cmpw  $dst, $src1\\n\\t\"\n-            \"cselw $dst, $dst, $src1 LT\\t# min reduction S\" %}\n+  format %{ \"sve_reduce_minI $dst, $src1, $src2\\t# reduce minB\/S\/I (sve)\" %}\n@@ -2231,3 +1947,4 @@\n-    __ sve_sminv(as_FloatRegister($tmp$$reg), __ S,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ S, 0);\n+    BasicType bt = vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_sminv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n@@ -2240,20 +1957,0 @@\n-instruct reduce_minL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (MinReductionV src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sminv $tmp, $src2\\t# vector (sve) (D)\\n\\t\"\n-            \"smov  $dst, $tmp, D, 0\\n\\t\"\n-            \"cmp  $dst, $src1\\n\\t\"\n-            \"csel $dst, $dst, $src1 LT\\t# min reduction D\" %}\n-  ins_encode %{\n-    __ sve_sminv(as_FloatRegister($tmp$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ D, 0);\n-    __ cmp($dst$$Register, $src1$$Register);\n-    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2272,1 +1969,1 @@\n-    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n@@ -2284,0 +1981,16 @@\n+instruct reduce_minL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (MinReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_minL $dst, $src1, $src2\\t# reduce minL partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_sminv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ cmp($dst$$Register, $src1$$Register);\n+    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::LT);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -2311,1 +2024,1 @@\n-            \"fmins $dst, $dst, $src1\\t # min reduction F\" %}\n+            \"fmins $dst, $dst, $src1\\t# min reduction F\" %}\n@@ -2320,16 +2033,0 @@\n-instruct reduce_minD(vRegD dst, vRegD src1, vReg src2) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst (MinReductionV src1 src2));\n-  ins_cost(INSN_COST);\n-  effect(TEMP_DEF dst);\n-  format %{ \"sve_fminv $dst, $src2 # vector (sve) (D)\\n\\t\"\n-            \"fmins $dst, $dst, $src1\\t # min reduction D\" %}\n-  ins_encode %{\n-    __ sve_fminv(as_FloatRegister($dst$$reg), __ D,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2354,0 +2051,16 @@\n+instruct reduce_minD(vRegD dst, vRegD src1, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (MinReductionV src1 src2));\n+  ins_cost(INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"sve_fminv $dst, $src2 # vector (sve) (D)\\n\\t\"\n+            \"fmins $dst, $dst, $src1\\t# min reduction D\" %}\n+  ins_encode %{\n+    __ sve_fminv(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src2$$reg));\n+    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3060,1 +2773,1 @@\n-instruct vcvtStoI(vReg dst, vReg src)\n+instruct vcvtBtoI(vReg dst, vReg src)\n@@ -3064,3 +2777,4 @@\n-  match(Set dst (VectorCastS2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, S, $src\\t# convert S to I vector\" %}\n+  match(Set dst (VectorCastB2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n+            \"sve_sunpklo  $dst, S, $dst\\t# convert B to I vector\" %}\n@@ -3068,1 +2782,2 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n@@ -3073,1 +2788,1 @@\n-instruct vcvtItoL(vReg dst, vReg src)\n+instruct vcvtBtoL(vReg dst, vReg src)\n@@ -3077,3 +2792,5 @@\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, D, $src\\t# convert I to L vector\" %}\n+  match(Set dst (VectorCastB2X src));\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n+            \"sve_sunpklo  $dst, S, $dst\\n\\t\"\n+            \"sve_sunpklo  $dst, D, $dst\\t# convert B to L vector\" %}\n@@ -3081,1 +2798,3 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n@@ -3086,1 +2805,1 @@\n-instruct vcvtBtoI(vReg dst, vReg src)\n+instruct vcvtBtoF(vReg dst, vReg src)\n@@ -3089,1 +2808,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -3091,1 +2810,1 @@\n-  ins_cost(2 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -3093,1 +2812,2 @@\n-            \"sve_sunpklo  $dst, S, $dst\\t# convert B to I vector\" %}\n+            \"sve_sunpklo  $dst, S, $dst\\n\\t\"\n+            \"sve_scvtf  $dst, S, $dst, S\\t# convert B to F vector\" %}\n@@ -3097,0 +2817,1 @@\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg), __ S);\n@@ -3101,17 +2822,1 @@\n-instruct vcvtStoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastS2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n-            \"sve_sunpklo  $dst, D, $dst\\t# convert S to L vector\" %}\n-  ins_encode %{\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\n-instruct vcvtBtoL(vReg dst, vReg src)\n+instruct vcvtBtoD(vReg dst, vReg src)\n@@ -3120,1 +2825,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n@@ -3122,1 +2827,1 @@\n-  ins_cost(3 * SVE_COST);\n+  ins_cost(4 * SVE_COST);\n@@ -3125,1 +2830,2 @@\n-            \"sve_sunpklo  $dst, D, $dst\\t# convert B to L vector\" %}\n+            \"sve_sunpklo  $dst, D, $dst\\n\\t\"\n+            \"sve_scvtf  $dst, D, $dst, D\\t# convert B to D vector\" %}\n@@ -3130,0 +2836,1 @@\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n@@ -3134,1 +2841,0 @@\n-\n@@ -3151,1 +2857,1 @@\n-instruct vcvtItoS(vReg dst, vReg src, vReg tmp)\n+instruct vcvtStoI(vReg dst, vReg src)\n@@ -3154,3 +2860,15 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorCastI2X src));\n-  effect(TEMP tmp);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (VectorCastS2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, S, $src\\t# convert S to I vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcvtStoL(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorCastS2X src));\n@@ -3158,2 +2876,2 @@\n-  format %{ \"sve_dup  $tmp, H, 0\\n\\t\"\n-            \"sve_uzp1  $dst, H, $src, tmp\\t# convert I to S vector\" %}\n+  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n+            \"sve_sunpklo  $dst, D, $dst\\t# convert S to L vector\" %}\n@@ -3161,2 +2879,2 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n@@ -3167,1 +2885,1 @@\n-instruct vcvtLtoI(vReg dst, vReg src, vReg tmp)\n+instruct vcvtStoF(vReg dst, vReg src)\n@@ -3170,3 +2888,2 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP tmp);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorCastS2X src));\n@@ -3174,2 +2891,2 @@\n-  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $src, tmp\\t# convert L to I vector\" %}\n+  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n+            \"sve_scvtf  $dst, S, $dst, S\\t# convert S to F vector\" %}\n@@ -3177,2 +2894,2 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg), __ S);\n@@ -3183,0 +2900,16 @@\n+instruct vcvtStoD(vReg dst, vReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorCastS2X src));\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n+            \"sve_sunpklo  $dst, D, $dst\\n\\t\"\n+            \"sve_scvtf  $dst, D, $dst, D\\t# convert S to D vector\" %}\n+  ins_encode %{\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -3189,1 +2922,1 @@\n-  effect(TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP tmp);\n@@ -3202,1 +2935,1 @@\n-instruct vcvtLtoS(vReg dst, vReg src, vReg tmp)\n+instruct vcvtItoS(vReg dst, vReg src, vReg tmp)\n@@ -3206,1 +2939,1 @@\n-  match(Set dst (VectorCastL2X src));\n+  match(Set dst (VectorCastI2X src));\n@@ -3208,4 +2941,3 @@\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $src, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t# convert L to S vector\" %}\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_dup  $tmp, H, 0\\n\\t\"\n+            \"sve_uzp1  $dst, H, $src, tmp\\t# convert I to S vector\" %}\n@@ -3213,3 +2945,2 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n@@ -3220,1 +2951,1 @@\n-instruct vcvtLtoB(vReg dst, vReg src, vReg tmp)\n+instruct vcvtItoL(vReg dst, vReg src)\n@@ -3223,8 +2954,4 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastL2X src));\n-  effect(TEMP tmp);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $src, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert L to B vector\" %}\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorCastI2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, D, $src\\t# convert I to L vector\" %}\n@@ -3232,4 +2959,1 @@\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n@@ -3240,1 +2964,1 @@\n-instruct vcvtBtoF(vReg dst, vReg src)\n+instruct vcvtItoF(vReg dst, vReg src)\n@@ -3244,5 +2968,3 @@\n-  match(Set dst (VectorCastB2X src));\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n-            \"sve_sunpklo  $dst, S, $dst\\n\\t\"\n-            \"sve_scvtf  $dst, S, $dst, S\\t# convert B to F vector\" %}\n+  match(Set dst (VectorCastI2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_scvtf  $dst, S, $src, S\\t# convert I to F vector\" %}\n@@ -3250,3 +2972,1 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg), __ S);\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n@@ -3257,1 +2977,1 @@\n-instruct vcvtStoD(vReg dst, vReg src)\n+instruct vcvtItoD(vReg dst, vReg src)\n@@ -3261,5 +2981,4 @@\n-  match(Set dst (VectorCastS2X src));\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n-            \"sve_sunpklo  $dst, D, $dst\\n\\t\"\n-            \"sve_scvtf  $dst, D, $dst, D\\t# convert S to D vector\" %}\n+  match(Set dst (VectorCastI2X src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, D, $src\\n\\t\"\n+            \"sve_scvtf  $dst, D, $dst, D\\t# convert I to D vector\" %}\n@@ -3267,2 +2986,1 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n@@ -3274,1 +2992,1 @@\n-instruct vcvtBtoD(vReg dst, vReg src)\n+instruct vcvtLtoB(vReg dst, vReg src, vReg tmp)\n@@ -3277,2 +2995,3 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastB2X src));\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n@@ -3280,4 +2999,4 @@\n-  format %{ \"sve_sunpklo  $dst, H, $src\\n\\t\"\n-            \"sve_sunpklo  $dst, S, $dst\\n\\t\"\n-            \"sve_sunpklo  $dst, D, $dst\\n\\t\"\n-            \"sve_scvtf  $dst, D, $dst, D\\t# convert B to D vector\" %}\n+  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $src, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert L to B vector\" %}\n@@ -3285,4 +3004,4 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($src$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg));\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n@@ -3293,1 +3012,1 @@\n-instruct vcvtLtoF(vReg dst, vReg src, vReg tmp)\n+instruct vcvtLtoS(vReg dst, vReg src, vReg tmp)\n@@ -3296,1 +3015,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n@@ -3298,1 +3017,1 @@\n-  effect(TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP tmp);\n@@ -3300,3 +3019,3 @@\n-  format %{ \"sve_scvtf  $dst, S, $src, D\\n\\t\"\n-            \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $dst, $tmp\\t# convert L to F vector\" %}\n+  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $src, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t# convert L to S vector\" %}\n@@ -3304,1 +3023,0 @@\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n@@ -3306,1 +3024,2 @@\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n@@ -3311,1 +3030,1 @@\n-instruct vcvtDtoF(vReg dst, vReg src, vReg tmp)\n+instruct vcvtLtoI(vReg dst, vReg src, vReg tmp)\n@@ -3314,2 +3033,2 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastD2X src));\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (VectorCastL2X src));\n@@ -3317,4 +3036,3 @@\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_fcvt  $dst, S, $src, D\\n\\t\"\n-            \"sve_dup  $tmp, S, 0\\n\\t\"\n-            \"sve_uzp1  $dst, S, $dst, $tmp\\t# convert D to F vector\" %}\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $src, tmp\\t# convert L to I vector\" %}\n@@ -3322,1 +3040,0 @@\n-    __ sve_fcvt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n@@ -3324,1 +3041,1 @@\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), as_FloatRegister($tmp$$reg));\n@@ -3329,1 +3046,1 @@\n-instruct vcvtItoF(vReg dst, vReg src)\n+instruct vcvtLtoF(vReg dst, vReg src, vReg tmp)\n@@ -3333,3 +3050,6 @@\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_scvtf  $dst, S, $src, S\\t# convert I to F vector\" %}\n+  match(Set dst (VectorCastL2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_scvtf  $dst, S, $src, D\\n\\t\"\n+            \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $dst, $tmp\\t# convert L to F vector\" %}\n@@ -3337,1 +3057,3 @@\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n+    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n@@ -3355,1 +3077,1 @@\n-instruct vcvtFtoI(vReg dst, vReg src)\n+instruct vcvtFtoB(vReg dst, vReg src, vReg tmp)\n@@ -3358,1 +3080,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n@@ -3360,2 +3082,6 @@\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fcvtzs  $dst, S, $src, S\\t# convert F to I vector\" %}\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n+            \"sve_dup  $tmp, H, 0\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert F to B vector\" %}\n@@ -3364,0 +3090,3 @@\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n@@ -3368,14 +3097,1 @@\n-instruct vcvtDtoL(vReg dst, vReg src)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n-  match(Set dst (VectorCastD2X src));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_fcvtzs  $dst, D, $src, D\\t# convert D to L vector\" %}\n-  ins_encode %{\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vcvtItoD(vReg dst, vReg src)\n+instruct vcvtFtoS(vReg dst, vReg src, vReg tmp)\n@@ -3384,5 +3100,7 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n-  match(Set dst (VectorCastI2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, D, $src\\n\\t\"\n-            \"sve_scvtf  $dst, D, $dst, D\\t# convert I to D vector\" %}\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n+            \"sve_dup  $tmp, H, 0\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\t# convert F to S vector\" %}\n@@ -3390,2 +3108,3 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ D);\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n@@ -3396,1 +3115,1 @@\n-instruct vcvtStoF(vReg dst, vReg src)\n+instruct vcvtFtoI(vReg dst, vReg src)\n@@ -3399,5 +3118,4 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n-  match(Set dst (VectorCastS2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_sunpklo  $dst, S, $src\\n\\t\"\n-            \"sve_scvtf  $dst, S, $dst, S\\t# convert S to F vector\" %}\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (VectorCastF2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, S, $src, S\\t# convert F to I vector\" %}\n@@ -3405,2 +3123,1 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg));\n-    __ sve_scvtf(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($dst$$reg), __ S);\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n@@ -3411,1 +3128,1 @@\n-instruct vcvtFtoD(vReg dst, vReg src)\n+instruct vcvtFtoL(vReg dst, vReg src)\n@@ -3414,1 +3131,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n@@ -3417,2 +3134,2 @@\n-  format %{ \"sve_sunpklo  $dst, D, $src\\n\\t\"\n-            \"sve_fcvt  $dst, D, $dst, S\\t# convert F to D vector\" %}\n+  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n+            \"sve_sunpklo  $dst, D, $dst\\t# convert F to L vector\" %}\n@@ -3420,2 +3137,2 @@\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n-    __ sve_fcvt(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n@@ -3426,1 +3143,1 @@\n-instruct vcvtFtoS(vReg dst, vReg src, vReg tmp)\n+instruct vcvtFtoD(vReg dst, vReg src)\n@@ -3429,1 +3146,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n@@ -3431,5 +3148,3 @@\n-  effect(TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n-  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n-            \"sve_dup  $tmp, H, 0\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\t# convert F to S vector\" %}\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_sunpklo  $dst, D, $src\\n\\t\"\n+            \"sve_fcvt  $dst, D, $dst, S\\t# convert F to D vector\" %}\n@@ -3437,3 +3152,2 @@\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg));\n+    __ sve_fcvt(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($dst$$reg), __ S);\n@@ -3444,1 +3158,1 @@\n-instruct vcvtDtoI(vReg dst, vReg src, vReg tmp)\n+instruct vcvtDtoB(vReg dst, vReg src, vReg tmp)\n@@ -3447,1 +3161,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n@@ -3449,2 +3163,2 @@\n-  effect(TEMP tmp);\n-  ins_cost(3 * SVE_COST);\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(5 * SVE_COST);\n@@ -3453,1 +3167,3 @@\n-            \"sve_uzp1  $dst, S, $dst, tmp\\t# convert D to I vector\" %}\n+            \"sve_uzp1  $dst, S, $dst, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert D to B vector\" %}\n@@ -3458,0 +3174,2 @@\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n@@ -3462,1 +3180,1 @@\n-instruct vcvtFtoB(vReg dst, vReg src, vReg tmp)\n+instruct vcvtDtoS(vReg dst, vReg src, vReg tmp)\n@@ -3465,3 +3183,3 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorCastF2X src));\n-  effect(TEMP tmp);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n@@ -3469,4 +3187,4 @@\n-  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n-            \"sve_dup  $tmp, H, 0\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert F to B vector\" %}\n+  format %{ \"sve_fcvtzs  $dst, D, $src, D\\n\\t\"\n+            \"sve_dup  $tmp, S, 0\\n\\t\"\n+            \"sve_uzp1  $dst, S, $dst, tmp\\n\\t\"\n+            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t# convert D to S vector\" %}\n@@ -3474,2 +3192,3 @@\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-    __ sve_dup(as_FloatRegister($tmp$$reg), __ H, 0);\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n+    __ sve_dup(as_FloatRegister($tmp$$reg), __ S, 0);\n+    __ sve_uzp1(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n@@ -3477,1 +3196,0 @@\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n@@ -3482,1 +3200,1 @@\n-instruct vcvtDtoS(vReg dst, vReg src, vReg tmp)\n+instruct vcvtDtoI(vReg dst, vReg src, vReg tmp)\n@@ -3485,1 +3203,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n@@ -3487,2 +3205,2 @@\n-  effect(TEMP tmp);\n-  ins_cost(4 * SVE_COST);\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n@@ -3491,2 +3209,1 @@\n-            \"sve_uzp1  $dst, S, $dst, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t# convert D to S vector\" %}\n+            \"sve_uzp1  $dst, S, $dst, tmp\\t# convert D to I vector\" %}\n@@ -3497,1 +3214,0 @@\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n@@ -3502,1 +3218,1 @@\n-instruct vcvtFtoL(vReg dst, vReg src)\n+instruct vcvtDtoL(vReg dst, vReg src)\n@@ -3506,4 +3222,3 @@\n-  match(Set dst (VectorCastF2X src));\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_fcvtzs  $dst, S, $src, S\\n\\t\"\n-            \"sve_sunpklo  $dst, D, $dst\\t# convert F to L vector\" %}\n+  match(Set dst (VectorCastD2X src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fcvtzs  $dst, D, $src, D\\t# convert D to L vector\" %}\n@@ -3511,2 +3226,1 @@\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ S);\n-    __ sve_sunpklo(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($dst$$reg));\n+    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n@@ -3517,1 +3231,1 @@\n-instruct vcvtDtoB(vReg dst, vReg src, vReg tmp)\n+instruct vcvtDtoF(vReg dst, vReg src, vReg tmp)\n@@ -3520,1 +3234,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -3522,3 +3236,3 @@\n-  effect(TEMP tmp);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_fcvtzs  $dst, D, $src, D\\n\\t\"\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_fcvt  $dst, S, $src, D\\n\\t\"\n@@ -3526,3 +3240,1 @@\n-            \"sve_uzp1  $dst, S, $dst, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, H, $dst, tmp\\n\\t\"\n-            \"sve_uzp1  $dst, B, $dst, tmp\\n\\t# convert D to B vector\" %}\n+            \"sve_uzp1  $dst, S, $dst, $tmp\\t# convert D to F vector\" %}\n@@ -3530,1 +3242,1 @@\n-    __ sve_fcvtzs(as_FloatRegister($dst$$reg), __ D, ptrue, as_FloatRegister($src$$reg), __ D);\n+    __ sve_fcvt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg), __ D);\n@@ -3533,2 +3245,0 @@\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ H, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n-    __ sve_uzp1(as_FloatRegister($dst$$reg), __ B, as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));\n@@ -3538,1 +3248,0 @@\n-\n@@ -3662,1 +3371,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -3682,1 +3391,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -3701,1 +3410,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -3722,1 +3431,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -3734,25 +3443,1 @@\n-instruct insertB_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, B, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B)\" %}\n-  ins_encode %{\n-    __ sve_index(as_FloatRegister($dst$$reg), __ B, -16, 1);\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ B, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n-               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertS_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)\n@@ -3761,1 +3446,3 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -3765,1 +3452,1 @@\n-  format %{ \"sve_index $dst, H, -16, 1\\n\\t\"\n+  format %{ \"sve_index $dst, -16, 1\\t# (B\/S\/I)\\n\\t\"\n@@ -3768,1 +3455,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (S)\" %}\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n@@ -3770,2 +3457,4 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ H, -16, 1);\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ H, ptrue,\n+    BasicType bt = vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index(as_FloatRegister($dst$$reg), size, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n@@ -3773,5 +3462,2 @@\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ H,\n-               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n@@ -3782,1 +3468,1 @@\n-instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pTmp, rFlagsReg cr)\n@@ -3785,1 +3471,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -3792,1 +3478,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (I)\" %}\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n@@ -3797,5 +3483,2 @@\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n@@ -3806,1 +3489,1 @@\n-instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n@@ -3808,2 +3491,4 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -3811,4 +3496,5 @@\n-  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/S\/I)\\n\\t\"\n+            \"sve_dup $dst, $idx\\t# (B\/S\/I)\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n@@ -3816,1 +3502,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n@@ -3818,8 +3504,8 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+    BasicType bt = vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index(as_FloatRegister($tmp1$$reg), size, 0, 1);\n+    __ sve_dup(as_FloatRegister($dst$$reg), size, (int)($idx$$constant));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n@@ -3830,1 +3516,0 @@\n-\n@@ -3846,5 +3531,2 @@\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n@@ -3870,84 +3552,2 @@\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-\n-instruct insertB(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_index $tmp1, B, 0, 1\\n\\t\"\n-            \"sve_dup $dst, B, $idx\\n\\t\"\n-            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B)\" %}\n-  ins_encode %{\n-    __ sve_index(as_FloatRegister($tmp1$$reg), __ B, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ B, (int)($idx$$constant));\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ B, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n-               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertS(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_index $tmp1, H, 0, 1\\n\\t\"\n-            \"sve_dup $dst, H, $idx\\n\\t\"\n-            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (S)\" %}\n-  ins_encode %{\n-    __ sve_index(as_FloatRegister($tmp1$$reg), __ H, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ H, (int)($idx$$constant));\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ H, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ H,\n-               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n-  ins_cost(5 * SVE_COST);\n-  format %{ \"sve_index $tmp1, S, 0, 1\\n\\t\"\n-            \"sve_dup $dst, S, $idx\\n\\t\"\n-            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (I)\" %}\n-  ins_encode %{\n-    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n-                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n@@ -4050,43 +3650,1 @@\n-instruct rearrangeB(vReg dst, vReg src, vReg shuffle)\n-%{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) == 1);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_tbl $dst, B, $src, $shuffle\\t# vector rearrange (B)\" %}\n-  ins_encode %{\n-    __ sve_tbl(as_FloatRegister($dst$$reg), __ B,\n-               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rearrangeS(vReg dst, vReg src, vReg shuffle)\n-%{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) == 2);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_tbl $dst, H, $src, $shuffle\\t# vector rearrange (H)\" %}\n-  ins_encode %{\n-    __ sve_tbl(as_FloatRegister($dst$$reg), __ H,\n-               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rearrangeI(vReg dst, vReg src, vReg shuffle)\n-%{\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) == 4);\n-  match(Set dst (VectorRearrange src shuffle));\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_tbl $dst, S, $src, $shuffle\\t# vector rearrange (S)\" %}\n-  ins_encode %{\n-    __ sve_tbl(as_FloatRegister($dst$$reg), __ S,\n-               as_FloatRegister($src$$reg), as_FloatRegister($shuffle$$reg));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct rearrangeL(vReg dst, vReg src, vReg shuffle)\n+instruct rearrange(vReg dst, vReg src, vReg shuffle)\n@@ -4094,2 +3652,1 @@\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) == 8);\n+  predicate(UseSVE > 0);\n@@ -4098,1 +3655,1 @@\n-  format %{ \"sve_tbl $dst, D, $src, $shuffle\\t# vector rearrange (D)\" %}\n+  format %{ \"sve_tbl $dst, $src, $shuffle\\t# vector rearrange\" %}\n@@ -4100,1 +3657,3 @@\n-    __ sve_tbl(as_FloatRegister($dst$$reg), __ D,\n+    BasicType bt = vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_tbl(as_FloatRegister($dst$$reg), size,\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":558,"deletions":999,"binary":false,"changes":1557,"status":"modified"},{"patch":"@@ -125,21 +125,0 @@\n-  static Assembler::SIMD_RegVariant elemBytes_to_regVariant(int esize) {\n-    switch(esize) {\n-      case 1:\n-        return Assembler::B;\n-      case 2:\n-        return Assembler::H;\n-      case 4:\n-        return Assembler::S;\n-      case 8:\n-        return Assembler::D;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-    return Assembler::INVALID;\n-  }\n-\n-  static Assembler::SIMD_RegVariant elemType_to_regVariant(BasicType bt) {\n-    return elemBytes_to_regVariant(type2aelembytes(bt));\n-  }\n-\n@@ -175,1 +154,1 @@\n-      (masm.*insn)(reg, elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n+      (masm.*insn)(reg, Assembler::elemType_to_regVariant(vector_elem_bt), pg, Address(base, imm4));\n@@ -182,30 +161,0 @@\n-  static void sve_compare(C2_MacroAssembler masm, PRegister pd, BasicType bt,\n-                          PRegister pg, FloatRegister zn, FloatRegister zm, int cond) {\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n-    if (bt == T_FLOAT || bt == T_DOUBLE) {\n-      switch (cond) {\n-        case BoolTest::eq: masm.sve_fcmeq(pd, size, pg, zn, zm); break;\n-        case BoolTest::ne: masm.sve_fcmne(pd, size, pg, zn, zm); break;\n-        case BoolTest::ge: masm.sve_fcmge(pd, size, pg, zn, zm); break;\n-        case BoolTest::gt: masm.sve_fcmgt(pd, size, pg, zn, zm); break;\n-        case BoolTest::le: masm.sve_fcmge(pd, size, pg, zm, zn); break;\n-        case BoolTest::lt: masm.sve_fcmgt(pd, size, pg, zm, zn); break;\n-        default:\n-          assert(false, \"unsupported\");\n-          ShouldNotReachHere();\n-      }\n-    } else {\n-      switch (cond) {\n-        case BoolTest::eq: masm.sve_cmpeq(pd, size, pg, zn, zm); break;\n-        case BoolTest::ne: masm.sve_cmpne(pd, size, pg, zn, zm); break;\n-        case BoolTest::ge: masm.sve_cmpge(pd, size, pg, zn, zm); break;\n-        case BoolTest::gt: masm.sve_cmpgt(pd, size, pg, zn, zm); break;\n-        case BoolTest::le: masm.sve_cmpge(pd, size, pg, zm, zn); break;\n-        case BoolTest::lt: masm.sve_cmpgt(pd, size, pg, zm, zn); break;\n-        default:\n-          assert(false, \"unsupported\");\n-          ShouldNotReachHere();\n-      }\n-    }\n-  }\n-\n@@ -228,1 +177,1 @@\n-        if (vlen < 4) {\n+        if (vlen < 4 || length_in_bytes > MaxVectorSize) {\n@@ -230,0 +179,2 @@\n+        } else {\n+          return true;\n@@ -231,1 +182,0 @@\n-        break;\n@@ -238,2 +188,2 @@\n-    \/\/ By default, we only support vector operations with larger than 16 bytes.\n-    return 16 <= length_in_bytes && length_in_bytes <= MaxVectorSize && vlen >= 2;\n+    \/\/ By default, we only support vector operations with no less than 8 bytes and 2 elements.\n+    return 8 <= length_in_bytes && length_in_bytes <= MaxVectorSize && vlen >= 2;\n@@ -266,1 +216,1 @@\n-  format %{ \"sve_ldr $dst, $mem\\t # vector (sve)\" %}\n+  format %{ \"sve_ldr $dst, $mem\\t# vector (sve)\" %}\n@@ -282,1 +232,1 @@\n-  format %{ \"sve_str $mem, $src\\t # vector (sve)\" %}\n+  format %{ \"sve_str $mem, $src\\t# vector (sve)\" %}\n@@ -327,1 +277,1 @@\n-            \"sve_ldr $dst, $pTmp, $mem\\t # load vector predicated\" %}\n+            \"sve_ldr $dst, $pTmp, $mem\\t# load vector predicated\" %}\n@@ -331,1 +281,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -349,1 +299,1 @@\n-            \"sve_str $src, $pTmp, $mem\\t # store vector predicated\" %}\n+            \"sve_str $src, $pTmp, $mem\\t# store vector predicated\" %}\n@@ -353,1 +303,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -485,1 +435,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -510,1 +460,1 @@\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16);\n+  predicate(UseSVE > 0);\n@@ -554,1 +504,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -574,1 +524,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -787,1 +737,1 @@\n-            \"sve_cpy $dst, $pTmp, -1\\t # vector mask cmp (sve)\" %}\n+            \"sve_cpy $dst, $pTmp, -1\\t# vector mask cmp (sve)\" %}\n@@ -790,4 +740,3 @@\n-    sve_compare(C2_MacroAssembler(&cbuf), as_PRegister($pTmp$$reg), bt,\n-                ptrue, as_FloatRegister($src1$$reg),\n-                as_FloatRegister($src2$$reg), (int)$cond$$constant);\n-    __ sve_cpy(as_FloatRegister($dst$$reg), elemType_to_regVariant(bt),\n+    __ sve_compare(as_PRegister($pTmp$$reg), bt, ptrue, as_FloatRegister($src1$$reg),\n+                   as_FloatRegister($src2$$reg), (int)$cond$$constant);\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n@@ -807,1 +756,1 @@\n-            \"sve_sel $dst, $pTmp, $src2, $src1\\t # vector blend (sve)\" %}\n+            \"sve_sel $dst, $pTmp, $src2, $src1\\t# vector blend (sve)\" %}\n@@ -810,1 +759,1 @@\n-              elemType_to_regVariant(vector_element_basic_type(this));\n+      __ elemType_to_regVariant(vector_element_basic_type(this));\n@@ -827,2 +776,2 @@\n-  format %{ \"sve_cmp $pTmp, $src3, $src4\\t # vector cmp (sve)\\n\\t\"\n-            \"sve_sel $dst, $pTmp, $src2, $src1\\t # vector blend (sve)\" %}\n+  format %{ \"sve_cmp $pTmp, $src3, $src4\\t# vector cmp (sve)\\n\\t\"\n+            \"sve_sel $dst, $pTmp, $src2, $src1\\t# vector blend (sve)\" %}\n@@ -831,4 +780,3 @@\n-    sve_compare(C2_MacroAssembler(&cbuf), as_PRegister($pTmp$$reg), bt,\n-                ptrue, as_FloatRegister($src3$$reg),\n-                as_FloatRegister($src4$$reg), (int)$cond$$constant);\n-    __ sve_sel(as_FloatRegister($dst$$reg), elemType_to_regVariant(bt),\n+    __ sve_compare(as_PRegister($pTmp$$reg), bt, ptrue, as_FloatRegister($src3$$reg),\n+                   as_FloatRegister($src4$$reg), (int)$cond$$constant);\n+    __ sve_sel(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n@@ -848,1 +796,1 @@\n-  format %{ \"sve_neg $dst, $src\\t # vector load mask (B)\" %}\n+  format %{ \"sve_neg $dst, $src\\t# vector load mask (B)\" %}\n@@ -861,1 +809,1 @@\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to H)\" %}\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to H)\" %}\n@@ -877,1 +825,1 @@\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to S)\" %}\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to S)\" %}\n@@ -895,1 +843,1 @@\n-            \"sve_neg $dst, $dst\\t # vector load mask (B to D)\" %}\n+            \"sve_neg $dst, $dst\\t# vector load mask (B to D)\" %}\n@@ -911,1 +859,1 @@\n-  format %{ \"sve_neg $dst, $src\\t # vector store mask (B)\" %}\n+  format %{ \"sve_neg $dst, $src\\t# vector store mask (B)\" %}\n@@ -926,1 +874,1 @@\n-            \"sve_neg $dst, B, $dst\\t # vector store mask (sve) (H to B)\" %}\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (H to B)\" %}\n@@ -946,1 +894,1 @@\n-            \"sve_neg $dst, B, $dst\\t # vector store mask (sve) (S to B)\" %}\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (S to B)\" %}\n@@ -968,1 +916,1 @@\n-            \"sve_neg $dst, B, $dst\\t # vector store mask (sve) (D to B)\" %}\n+            \"sve_neg $dst, B, $dst\\t# vector store mask (sve) (D to B)\" %}\n@@ -993,1 +941,1 @@\n-            \"sve_neg $dst, $dst\\t # load vector mask (sve)\" %}\n+            \"sve_neg $dst, $dst\\t# load vector mask (sve)\" %}\n@@ -997,1 +945,1 @@\n-    Assembler::SIMD_RegVariant to_vect_variant = elemType_to_regVariant(to_vect_bt);\n+    Assembler::SIMD_RegVariant to_vect_variant = __ elemType_to_regVariant(to_vect_bt);\n@@ -1019,1 +967,1 @@\n-            \"sve_st1b $tmp, $mem\\t # store vector mask (sve)\" %}\n+            \"sve_st1b $tmp, $mem\\t# store vector mask (sve)\" %}\n@@ -1023,1 +971,1 @@\n-    Assembler::SIMD_RegVariant from_vect_variant = elemBytes_to_regVariant($esize$$constant);\n+    Assembler::SIMD_RegVariant from_vect_variant = __ elemBytes_to_regVariant($esize$$constant);\n@@ -1040,54 +988,3 @@\n-dnl\n-dnl REDUCE_ADD_EXT($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n-dnl REDUCE_ADD_EXT(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n-define(`REDUCE_ADD_EXT', `\n-instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == $6 &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n-            \"smov  $dst, $tmp, $5, 0\\n\\t\"\n-            \"addw  $dst, $dst, $src1\\n\\t\"\n-            \"$7  $dst, $dst\\t # add reduction $5\" %}\n-  ins_encode %{\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ $5,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n-    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n-    __ $7($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-define(`PREDICATE', `ifelse($1, AddReductionVL,\n-       `predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);',\n-       `predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);')')dnl\n-dnl\n-dnl REDUCE_ADD($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n-dnl REDUCE_ADD(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n-define(`REDUCE_ADD', `\n-instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n-  PREDICATE($2)\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_uaddv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n-            \"umov  $dst, $tmp, $5, 0\\n\\t\"\n-            \"$7  $dst, $dst, $src1\\t # add reduction $5\" %}\n-  ins_encode %{\n-    __ sve_uaddv(as_FloatRegister($tmp$$reg), __ $5,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n-    __ $7($dst$$Register, $dst$$Register, $src1$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-undefine(PREDICATE)dnl\n-dnl\n-dnl REDUCE_ADDF($1,        $2,      $3,      $4  )\n-dnl REDUCE_ADDF(insn_name, op_name, reg_dst, size)\n-define(`REDUCE_ADDF', `\n-instruct $1($3 src1_dst, vReg src2) %{\n+\/\/ vector add reduction\n+\n+instruct reduce_addI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n@@ -1095,1 +992,2 @@\n-  match(Set src1_dst ($2 src1_dst src2));\n+  match(Set dst (AddReductionVI src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1097,1 +995,1 @@\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) ($4)\" %}\n+  format %{ \"sve_reduce_addI $dst, $src1, $src2\\t# addB\/S\/I reduction (sve) (may extend)\" %}\n@@ -1099,2 +997,12 @@\n-    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n-         ptrue, as_FloatRegister($src2$$reg));\n+    BasicType bt = vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ addw($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1103,9 +1011,1 @@\n-%}')dnl\n-\n-\/\/ vector add reduction\n-REDUCE_ADD_EXT(reduce_addB, AddReductionVI, iRegINoSp, iRegIorL2I, B, T_BYTE, sxtb)\n-REDUCE_ADD_EXT(reduce_addS, AddReductionVI, iRegINoSp, iRegIorL2I, H, T_SHORT, sxth)\n-REDUCE_ADD(reduce_addI, AddReductionVI, iRegINoSp, iRegIorL2I, S, T_INT, addw)\n-REDUCE_ADD(reduce_addL, AddReductionVL, iRegLNoSp, iRegL, D, T_LONG, add)\n-REDUCE_ADDF(reduce_addF, AddReductionVF, vRegF, S)\n-REDUCE_ADDF(reduce_addD, AddReductionVD, vRegD, D)\n+%}\n@@ -1122,1 +1022,1 @@\n-    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n@@ -1133,0 +1033,2 @@\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n@@ -1138,0 +1040,14 @@\n+instruct reduce_addL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AddReductionVL src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_addL $dst, $src1, $src2\\t# addL reduction (sve)\" %}\n+  ins_encode %{\n+    __ sve_uaddv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ add($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1155,0 +1071,16 @@\n+\n+dnl\n+dnl REDUCE_ADDF($1,        $2,      $3,      $4  )\n+dnl REDUCE_ADDF(insn_name, op_name, reg_dst, size)\n+define(`REDUCE_ADDF', `\n+instruct $1($3 src1_dst, vReg src2) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set src1_dst (AddReductionV$2 src1_dst src2));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) ($4)\" %}\n+  ins_encode %{\n+    __ sve_fadda(as_FloatRegister($src1_dst$$reg), __ $4,\n+         ptrue, as_FloatRegister($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n@@ -1157,2 +1089,2 @@\n-dnl REDUCE_ADDF_PARTIAL($1,        $2,      $3,      $4  )\n-dnl REDUCE_ADDF_PARTIAL(insn_name, op_name, reg_dst, size)\n+dnl REDUCE_ADDF_PARTIAL($1,        $2,     $3,      $4  )\n+dnl REDUCE_ADDF_PARTIAL(insn_name, suffix, reg_dst, size)\n@@ -1162,1 +1094,1 @@\n-  match(Set src1_dst ($2 src1_dst src2));\n+  match(Set src1_dst (AddReductionV$2 src1_dst src2));\n@@ -1165,1 +1097,1 @@\n-  format %{ \"sve_fadda $src1_dst, $src1_dst, $src2\\t# vector (sve) ($4)\" %}\n+  format %{ \"sve_reduce_add$2 $src1_dst, $src1_dst, $src2\\t# add$2 reduction partial (sve) ($4)\" %}\n@@ -1175,8 +1107,9 @@\n-REDUCE_ADDF_PARTIAL(reduce_addF_partial, AddReductionVF, vRegF, S)\n-REDUCE_ADDF_PARTIAL(reduce_addD_partial, AddReductionVD, vRegD, D)\n-dnl\n-dnl REDUCE_AND_EXT($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n-dnl REDUCE_AND_EXT(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n-define(`REDUCE_AND_EXT', `\n-instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == $6 &&\n+REDUCE_ADDF(reduce_addF, F, vRegF, S)\n+REDUCE_ADDF_PARTIAL(reduce_addF_partial, F, vRegF, S)\n+REDUCE_ADDF(reduce_addD, D, vRegD, D)\n+REDUCE_ADDF_PARTIAL(reduce_addD_partial, D, vRegD, D)\n+\n+\/\/ vector and reduction\n+\n+instruct reduce_andI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n@@ -1184,2 +1117,2 @@\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1187,4 +1120,1 @@\n-  format %{ \"sve_andv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n-            \"smov  $dst, $tmp, $5, 0\\n\\t\"\n-            \"andw  $dst, $dst, $src1\\n\\t\"\n-            \"$7  $dst, $dst\\t # and reduction $5\" %}\n+  format %{ \"sve_reduce_andI $dst, $src1, $src2\\t# andB\/S\/I reduction (sve) (may extend)\" %}\n@@ -1192,3 +1122,4 @@\n-    __ sve_andv(as_FloatRegister($tmp$$reg), __ $5,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n+    BasicType bt = vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n@@ -1196,22 +1127,7 @@\n-    __ $7($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_AND($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n-dnl REDUCE_AND(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n-define(`REDUCE_AND', `\n-instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == $6 &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_andv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n-            \"umov  $dst, $tmp, $5, 0\\n\\t\"\n-            \"$7  $dst, $dst, $src1\\t # and reduction $5\" %}\n-  ins_encode %{\n-    __ sve_andv(as_FloatRegister($tmp$$reg), __ $5,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n-    __ $7($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1220,7 +1136,1 @@\n-%}')dnl\n-\n-\/\/ vector and reduction\n-REDUCE_AND_EXT(reduce_andB, AndReductionV, iRegINoSp, iRegIorL2I, B, T_BYTE, sxtb)\n-REDUCE_AND_EXT(reduce_andS, AndReductionV, iRegINoSp, iRegIorL2I, H, T_SHORT, sxth)\n-REDUCE_AND(reduce_andI, AndReductionV, iRegINoSp, iRegIorL2I, S, T_INT, andw)\n-REDUCE_AND(reduce_andL, AndReductionV, iRegLNoSp, iRegL, D, T_LONG, andr)\n+%}\n@@ -1238,1 +1148,1 @@\n-    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n@@ -1242,1 +1152,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1249,0 +1159,2 @@\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n@@ -1254,0 +1166,15 @@\n+instruct reduce_andL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (AndReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_andL $dst, $src1, $src2\\t# andL reduction (sve)\" %}\n+  ins_encode %{\n+    __ sve_andv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ andr($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1266,1 +1193,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1273,6 +1200,4 @@\n-dnl\n-dnl REDUCE_OR_EXT($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n-dnl REDUCE_OR_EXT(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n-define(`REDUCE_OR_EXT', `\n-instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == $6 &&\n+\/\/ vector or reduction\n+\n+instruct reduce_orI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n@@ -1280,2 +1205,2 @@\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n+  match(Set dst (OrReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1283,4 +1208,1 @@\n-  format %{ \"sve_orv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n-            \"smov  $dst, $tmp, $5, 0\\n\\t\"\n-            \"orrw  $dst, $dst, $src1\\n\\t\"\n-            \"$7  $dst, $dst\\t # or reduction $5\" %}\n+  format %{ \"sve_reduce_orI $dst, $src1, $src2\\t# orB\/S\/I reduction (sve) (may extend)\" %}\n@@ -1288,3 +1210,4 @@\n-    __ sve_orv(as_FloatRegister($tmp$$reg), __ $5,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n+    BasicType bt = vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n@@ -1292,22 +1215,7 @@\n-    __ $7($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_OR($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n-dnl REDUCE_OR(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n-define(`REDUCE_OR', `\n-instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == $6 &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_orv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n-            \"umov  $dst, $tmp, $5, 0\\n\\t\"\n-            \"$7  $dst, $dst, $src1\\t # or reduction $5\" %}\n-  ins_encode %{\n-    __ sve_orv(as_FloatRegister($tmp$$reg), __ $5,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n-    __ $7($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1316,7 +1224,1 @@\n-%}')dnl\n-\n-\/\/ vector or reduction\n-REDUCE_OR_EXT(reduce_orB, OrReductionV, iRegINoSp, iRegIorL2I, B, T_BYTE, sxtb)\n-REDUCE_OR_EXT(reduce_orS, OrReductionV, iRegINoSp, iRegIorL2I, H, T_SHORT, sxth)\n-REDUCE_OR(reduce_orI, OrReductionV, iRegINoSp, iRegIorL2I, S, T_INT, orrw)\n-REDUCE_OR(reduce_orL, OrReductionV, iRegLNoSp, iRegL, D, T_LONG, orr)\n+%}\n@@ -1334,1 +1236,1 @@\n-    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n@@ -1338,1 +1240,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1345,0 +1247,2 @@\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n@@ -1350,0 +1254,15 @@\n+instruct reduce_orL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (OrReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_orL $dst, $src1, $src2\\t# orL reduction (sve)\" %}\n+  ins_encode %{\n+    __ sve_orv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ orr($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1362,1 +1281,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+               as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1369,7 +1288,4 @@\n-dnl\n-dnl REDUCE_XOR_EXT($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n-dnl REDUCE_XOR_EXT(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n-define(`REDUCE_XOR_EXT', `\n-instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == $6 &&\n+\/\/ vector xor reduction\n+\n+instruct reduce_eorI(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() != T_LONG &&\n@@ -1377,2 +1293,2 @@\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n+  match(Set dst (XorReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1380,4 +1296,1 @@\n-  format %{ \"sve_eorv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n-            \"smov  $dst, $tmp, $5, 0\\n\\t\"\n-            \"eorw  $dst, $dst, $src1\\n\\t\"\n-            \"$7  $dst, $dst\\t # eor reduction $5\" %}\n+  format %{ \"sve_reduce_eorI $dst, $src1, $src2\\t# xorB\/H\/I reduction (sve) (may extend)\" %}\n@@ -1385,3 +1298,4 @@\n-    __ sve_eorv(as_FloatRegister($tmp$$reg), __ $5,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ smov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n+    BasicType bt = vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n@@ -1389,23 +1303,7 @@\n-    __ $7($dst$$Register, $dst$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n-dnl REDUCE_XOR($1,        $2,      $3,      $4,      $5,   $6,        $7   )\n-dnl REDUCE_XOR(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1)\n-define(`REDUCE_XOR', `\n-instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp) %{\n-  predicate(UseSVE > 0 &&\n-            n->in(2)->bottom_type()->is_vect()->element_basic_type() == $6 &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n-  match(Set dst ($2 src1 src2));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  ins_cost(SVE_COST);\n-  format %{ \"sve_eorv $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n-            \"umov  $dst, $tmp, $5, 0\\n\\t\"\n-            \"$7  $dst, $dst, $src1\\t # eor reduction $5\" %}\n-  ins_encode %{\n-    __ sve_eorv(as_FloatRegister($tmp$$reg), __ $5,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ umov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n-    __ $7($dst$$Register, $dst$$Register, $src1$$Register);\n+    if (bt == T_BYTE) {\n+      __ sxtb($dst$$Register, $dst$$Register);\n+    } else if (bt == T_SHORT) {\n+      __ sxth($dst$$Register, $dst$$Register);\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n+    }\n@@ -1414,7 +1312,1 @@\n-%}')dnl\n-\n-\/\/ vector xor reduction\n-REDUCE_XOR_EXT(reduce_eorB, XorReductionV, iRegINoSp, iRegIorL2I, B, T_BYTE, sxtb)\n-REDUCE_XOR_EXT(reduce_eorS, XorReductionV, iRegINoSp, iRegIorL2I, H, T_SHORT, sxth)\n-REDUCE_XOR(reduce_eorI, XorReductionV, iRegINoSp, iRegIorL2I, S, T_INT, eorw)\n-REDUCE_XOR(reduce_eorL, XorReductionV, iRegLNoSp, iRegL, D, T_LONG, eor)\n+%}\n@@ -1432,1 +1324,1 @@\n-    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n@@ -1436,1 +1328,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1443,0 +1335,2 @@\n+    } else {\n+      assert(bt == T_INT, \"unsupported type\");\n@@ -1448,0 +1342,15 @@\n+instruct reduce_eorL(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG &&\n+            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+  match(Set dst (XorReductionV src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_eorL $dst, $src1, $src2\\t# xorL reduction (sve)\" %}\n+  ins_encode %{\n+    __ sve_eorv(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ eor($dst$$Register, $dst$$Register, $src1$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -1460,1 +1369,1 @@\n-         as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n+                as_PRegister($ptmp$$reg), as_FloatRegister($src2$$reg));\n@@ -1468,6 +1377,8 @@\n-dnl REDUCE_MAXMIN($1,        $2,      $3,      $4,      $5,   $6,        $7,    $8,    $9 , $10    )\n-dnl REDUCE_MAXMIN(insn_name, op_name, reg_dst, reg_src, size, elem_type, insn1, insn2, cmp, min_max)\n-define(`REDUCE_MAXMIN', `\n-instruct $1($3 dst, $4 src1, vReg src2, vRegD tmp, rFlagsReg cr) %{\n-  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->element_basic_type() == $6 &&\n-            n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize);\n+dnl REDUCE_MAXMIN_I($1,      $2,      $3 )\n+dnl REDUCE_MAXMIN_I(min_max, op_mame, cmp)\n+define(`REDUCE_MAXMIN_I', `\n+instruct reduce_$1I(iRegINoSp dst, iRegIorL2I src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            (n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -1475,1 +1386,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n+  effect(TEMP_DEF dst, TEMP vtmp);\n@@ -1477,4 +1388,1 @@\n-  format %{ \"sve_s$10v $tmp, $src2\\t# vector (sve) ($5)\\n\\t\"\n-            \"smov  $dst, $tmp, $5, 0\\n\\t\"\n-            \"$7  $dst, $src1\\n\\t\"\n-            \"$8 $dst, $dst, $src1 $9\\t# $10 reduction $5\" %}\n+  format %{ \"sve_reduce_$1I $dst, $src1, $src2\\t# reduce $1B\/S\/I (sve)\" %}\n@@ -1482,5 +1390,25 @@\n-    __ sve_s$10v(as_FloatRegister($tmp$$reg), __ $5,\n-         ptrue, as_FloatRegister($src2$$reg));\n-    __ ifelse($5,D,u,s)mov($dst$$Register, as_FloatRegister($tmp$$reg), __ $5, 0);\n-    __ $7($dst$$Register, $src1$$Register);\n-    __ $8(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::$9);\n+    BasicType bt = vector_element_basic_type(this, $src2);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n+    __ sve_s$1v(as_FloatRegister($vtmp$$reg), variant, ptrue, as_FloatRegister($src2$$reg));\n+    __ smov($dst$$Register, as_FloatRegister($vtmp$$reg), variant, 0);\n+    __ cmpw($dst$$Register, $src1$$Register);\n+    __ cselw(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::$3);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl REDUCE_MAXMIN_L($1,      $2,      $3 )\n+dnl REDUCE_MAXMIN_L(min_max, op_name, cmp)\n+define(`REDUCE_MAXMIN_L', `\n+instruct reduce_$1L(iRegLNoSp dst, iRegL src1, vReg src2, vRegD vtmp) %{\n+  predicate(UseSVE > 0 && n->in(2)->bottom_type()->is_vect()->length_in_bytes() == MaxVectorSize &&\n+            n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst ($2 src1 src2));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_reduce_$1L $dst, $src1, $src2\\t# reduce $1L partial (sve)\" %}\n+  ins_encode %{\n+    __ sve_s$1v(as_FloatRegister($vtmp$$reg), __ D, ptrue, as_FloatRegister($src2$$reg));\n+    __ umov($dst$$Register, as_FloatRegister($vtmp$$reg), __ D, 0);\n+    __ cmp($dst$$Register, $src1$$Register);\n+    __ csel(as_Register($dst$$reg), as_Register($dst$$reg), as_Register($src1$$reg), Assembler::$3);\n@@ -1506,1 +1434,1 @@\n-    Assembler::SIMD_RegVariant variant = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant variant = __ elemType_to_regVariant(bt);\n@@ -1551,1 +1479,1 @@\n-            \"f$1s $dst, $dst, $src1\\t # $1 reduction $2\" %}\n+            \"f$1s $dst, $dst, $src1\\t# $1 reduction $2\" %}\n@@ -1583,4 +1511,1 @@\n-REDUCE_MAXMIN(reduce_maxB, MaxReductionV, iRegINoSp, iRegIorL2I, B, T_BYTE,  cmpw, cselw, GT, max)\n-REDUCE_MAXMIN(reduce_maxS, MaxReductionV, iRegINoSp, iRegIorL2I, H, T_SHORT, cmpw, cselw, GT, max)\n-REDUCE_MAXMIN(reduce_maxI, MaxReductionV, iRegINoSp, iRegIorL2I, S, T_INT,   cmpw, cselw, GT, max)\n-REDUCE_MAXMIN(reduce_maxL, MaxReductionV, iRegLNoSp, iRegL,      D, T_LONG,  cmp,  csel,  GT, max)\n+REDUCE_MAXMIN_I(max, MaxReductionV, GT)\n@@ -1588,0 +1513,1 @@\n+REDUCE_MAXMIN_L(max, MaxReductionV, GT)\n@@ -1590,1 +1516,0 @@\n-REDUCE_FMINMAX(max, D, T_DOUBLE, D, vRegD)\n@@ -1592,0 +1517,1 @@\n+REDUCE_FMINMAX(max, D, T_DOUBLE, D, vRegD)\n@@ -1595,4 +1521,1 @@\n-REDUCE_MAXMIN(reduce_minB, MinReductionV, iRegINoSp, iRegIorL2I, B, T_BYTE,  cmpw, cselw, LT, min)\n-REDUCE_MAXMIN(reduce_minS, MinReductionV, iRegINoSp, iRegIorL2I, H, T_SHORT, cmpw, cselw, LT, min)\n-REDUCE_MAXMIN(reduce_minI, MinReductionV, iRegINoSp, iRegIorL2I, S, T_INT,   cmpw, cselw, LT, min)\n-REDUCE_MAXMIN(reduce_minL, MinReductionV, iRegLNoSp, iRegL,      D, T_LONG,  cmp,  csel,  LT, min)\n+REDUCE_MAXMIN_I(min, MinReductionV, LT)\n@@ -1600,0 +1523,1 @@\n+REDUCE_MAXMIN_L(min, MinReductionV, LT)\n@@ -1602,1 +1526,0 @@\n-REDUCE_FMINMAX(min, D, T_DOUBLE, D, vRegD)\n@@ -1604,0 +1527,1 @@\n+REDUCE_FMINMAX(min, D, T_DOUBLE, D, vRegD)\n@@ -1811,0 +1735,1 @@\n+dnl\n@@ -1824,4 +1749,0 @@\n-dnl                 $1 $2 $3       $4\n-VECTOR_CAST_EXTEND1(B, S, sunpklo, H)\n-VECTOR_CAST_EXTEND1(S, I, sunpklo, S)\n-VECTOR_CAST_EXTEND1(I, L, sunpklo, D)\n@@ -1845,4 +1766,1 @@\n-dnl                 $1 $2 $3       $4 $5\n-VECTOR_CAST_EXTEND2(B, I, sunpklo, H, S)\n-VECTOR_CAST_EXTEND2(S, L, sunpklo, S, D)\n-\n+dnl\n@@ -1867,3 +1785,1 @@\n-dnl                 $1 $2 $3       $4 $5 $6\n-VECTOR_CAST_EXTEND3(B, L, sunpklo, H, S, D)\n-\n+dnl\n@@ -1887,5 +1803,1 @@\n-dnl                 $1 $2 $3   $4 $5\n-VECTOR_CAST_NARROW1(S, B, dup, B, uzp1)\n-VECTOR_CAST_NARROW1(I, S, dup, H, uzp1)\n-VECTOR_CAST_NARROW1(L, I, dup, S, uzp1)\n-\n+dnl\n@@ -1899,1 +1811,1 @@\n-  effect(TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP tmp);\n@@ -1911,3 +1823,0 @@\n-dnl                 $1 $2 $3   $4 $5    $6\n-VECTOR_CAST_NARROW2(I, B, dup, H, uzp1, B)\n-VECTOR_CAST_NARROW2(L, S, dup, S, uzp1, H)\n@@ -1922,1 +1831,1 @@\n-  effect(TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP tmp);\n@@ -1936,2 +1845,0 @@\n-dnl                 $1 $2 $3   $4 $5    $6 $7\n-VECTOR_CAST_NARROW3(L, B, dup, S, uzp1, H, B)\n@@ -1957,3 +1864,0 @@\n-dnl                     $1 $2 $3       $4 $5 $6\n-VECTOR_CAST_I2F_EXTEND2(B, F, sunpklo, H, S, scvtf)\n-VECTOR_CAST_I2F_EXTEND2(S, D, sunpklo, S, D, scvtf)\n@@ -1981,2 +1885,0 @@\n-dnl                     $1 $2 $3       $4 $5 $6 $7\n-VECTOR_CAST_I2F_EXTEND3(B, D, sunpklo, H, S, D, scvtf)\n@@ -1991,1 +1893,1 @@\n-  effect(TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP tmp);\n@@ -2003,3 +1905,0 @@\n-dnl                     $1 $2 $3     $4 $5 $6   $7 $8\n-VECTOR_CAST_X2F_NARROW1(L, F, scvtf, S, D, dup, S, uzp1)\n-VECTOR_CAST_X2F_NARROW1(D, F, fcvt,  S, D, dup, S, uzp1)\n@@ -2021,5 +1920,0 @@\n-dnl             $1 $2 $3      $4\n-VECTOR_CAST_X2X(I, F, scvtf,  S)\n-VECTOR_CAST_X2X(L, D, scvtf,  D)\n-VECTOR_CAST_X2X(F, I, fcvtzs, S)\n-VECTOR_CAST_X2X(D, L, fcvtzs, D)\n@@ -2043,4 +1937,0 @@\n-dnl                     $1 $2 $3       $4 $5     $6\n-VECTOR_CAST_X2F_EXTEND1(I, D, sunpklo, D, scvtf, D)\n-VECTOR_CAST_X2F_EXTEND1(S, F, sunpklo, S, scvtf, S)\n-VECTOR_CAST_X2F_EXTEND1(F, D, sunpklo, D, fcvt,  S)\n@@ -2055,1 +1945,1 @@\n-  effect(TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP tmp);\n@@ -2067,3 +1957,0 @@\n-dnl                     $1 $2 $3      $4 $5   $6 $7\n-VECTOR_CAST_F2X_NARROW1(F, S, fcvtzs, S, dup, H, uzp1)\n-VECTOR_CAST_F2X_NARROW1(D, I, fcvtzs, D, dup, S, uzp1)\n@@ -2078,1 +1965,1 @@\n-  effect(TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP tmp);\n@@ -2092,3 +1979,0 @@\n-dnl                     $1 $2 $3      $4 $5   $6 $7    $8\n-VECTOR_CAST_F2X_NARROW2(F, B, fcvtzs, S, dup, H, uzp1, B)\n-VECTOR_CAST_F2X_NARROW2(D, S, fcvtzs, D, dup, S, uzp1, H)\n@@ -2112,2 +1996,0 @@\n-dnl                     $1 $2 $3      $4 $5       $6\n-VECTOR_CAST_F2X_EXTEND1(F, L, fcvtzs, S, sunpklo, D)\n@@ -2122,1 +2004,1 @@\n-  effect(TEMP tmp);\n+  effect(TEMP_DEF dst, TEMP tmp);\n@@ -2138,1 +2020,31 @@\n-dnl                     $1 $2 $3      $4 $5   $6 $7    $8 $9\n+dnl\n+VECTOR_CAST_EXTEND1(B, S, sunpklo, H)\n+VECTOR_CAST_EXTEND2(B, I, sunpklo, H, S)\n+VECTOR_CAST_EXTEND3(B, L, sunpklo, H, S, D)\n+VECTOR_CAST_I2F_EXTEND2(B, F, sunpklo, H, S, scvtf)\n+VECTOR_CAST_I2F_EXTEND3(B, D, sunpklo, H, S, D, scvtf)\n+dnl\n+VECTOR_CAST_NARROW1(S, B, dup, B, uzp1)\n+VECTOR_CAST_EXTEND1(S, I, sunpklo, S)\n+VECTOR_CAST_EXTEND2(S, L, sunpklo, S, D)\n+VECTOR_CAST_X2F_EXTEND1(S, F, sunpklo, S, scvtf, S)\n+VECTOR_CAST_I2F_EXTEND2(S, D, sunpklo, S, D, scvtf)\n+dnl\n+VECTOR_CAST_NARROW2(I, B, dup, H, uzp1, B)\n+VECTOR_CAST_NARROW1(I, S, dup, H, uzp1)\n+VECTOR_CAST_EXTEND1(I, L, sunpklo, D)\n+VECTOR_CAST_X2X(I, F, scvtf, S)\n+VECTOR_CAST_X2F_EXTEND1(I, D, sunpklo, D, scvtf, D)\n+dnl\n+VECTOR_CAST_NARROW3(L, B, dup, S, uzp1, H, B)\n+VECTOR_CAST_NARROW2(L, S, dup, S, uzp1, H)\n+VECTOR_CAST_NARROW1(L, I, dup, S, uzp1)\n+VECTOR_CAST_X2F_NARROW1(L, F, scvtf, S, D, dup, S, uzp1)\n+VECTOR_CAST_X2X(L, D, scvtf, D)\n+dnl\n+VECTOR_CAST_F2X_NARROW2(F, B, fcvtzs, S, dup, H, uzp1, B)\n+VECTOR_CAST_F2X_NARROW1(F, S, fcvtzs, S, dup, H, uzp1)\n+VECTOR_CAST_X2X(F, I, fcvtzs, S)\n+VECTOR_CAST_F2X_EXTEND1(F, L, fcvtzs, S, sunpklo, D)\n+VECTOR_CAST_X2F_EXTEND1(F, D, sunpklo, D, fcvt, S)\n+dnl\n@@ -2140,1 +2052,6 @@\n-\n+VECTOR_CAST_F2X_NARROW2(D, S, fcvtzs, D, dup, S, uzp1, H)\n+VECTOR_CAST_F2X_NARROW1(D, I, fcvtzs, D, dup, S, uzp1)\n+VECTOR_CAST_X2X(D, L, fcvtzs, D)\n+VECTOR_CAST_X2F_NARROW1(D, F, fcvt, S, D, dup, S, uzp1)\n+dnl\n+dnl\n@@ -2206,1 +2123,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -2232,1 +2149,1 @@\n-    Assembler::SIMD_RegVariant size = elemType_to_regVariant(bt);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n@@ -2246,2 +2163,2 @@\n-define(`VECTOR_INSERT_SMALL', `\n-instruct insert$1_small`'(vReg dst, vReg src, $2 val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+\n+instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pTmp, rFlagsReg cr)\n@@ -2250,1 +2167,3 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -2254,1 +2173,1 @@\n-  format %{ \"sve_index $dst, $3, -16, 1\\n\\t\"\n+  format %{ \"sve_index $dst, -16, 1\\t# (B\/S\/I)\\n\\t\"\n@@ -2257,1 +2176,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector ($1)\" %}\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n@@ -2259,2 +2178,4 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ $3, -16, 1);\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ $3, ptrue,\n+    BasicType bt = vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index(as_FloatRegister($dst$$reg), size, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n@@ -2262,5 +2183,2 @@\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3,\n-               as_PRegister($pTmp$$reg), as_$4($val$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n@@ -2269,6 +2187,22 @@\n-%}')dnl\n-dnl                 $1 $2          $3 $4\n-VECTOR_INSERT_SMALL(B, iRegIorL2I, B, Register)\n-VECTOR_INSERT_SMALL(S, iRegIorL2I, H, Register)\n-VECTOR_INSERT_SMALL(I, iRegIorL2I, S, Register)\n-VECTOR_INSERT_SMALL(F, vRegF,      S, FloatRegister)\n+%}\n+\n+instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -2276,0 +2210,28 @@\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP tmp1, TEMP pTmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/S\/I)\\n\\t\"\n+            \"sve_dup $dst, $idx\\t# (B\/S\/I)\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp1, $dst\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (B\/S\/I)\" %}\n+  ins_encode %{\n+    BasicType bt = vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_index(as_FloatRegister($tmp1$$reg), size, 0, 1);\n+    __ sve_dup(as_FloatRegister($dst$$reg), size, (int)($idx$$constant));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+dnl\n@@ -2292,5 +2254,2 @@\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3,\n-               as_PRegister($pTmp$$reg), as_$4($val$$reg));\n+    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3, as_PRegister($pTmp$$reg), as_$4($val$$reg));\n@@ -2304,2 +2263,1 @@\n-define(`VECTOR_INSERT', `\n-instruct insert$1`'(vReg dst, vReg src, $2 val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pTmp, rFlagsReg cr)\n@@ -2308,1 +2266,1 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -2312,2 +2270,2 @@\n-  format %{ \"sve_index $tmp1, $3, 0, 1\\n\\t\"\n-            \"sve_dup $dst, $3, $idx\\n\\t\"\n+  format %{ \"sve_index $tmp1, S, 0, 1\\n\\t\"\n+            \"sve_dup $dst, S, $idx\\n\\t\"\n@@ -2316,1 +2274,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector ($1)\" %}\n+            \"sve_cpy $dst, $pTmp, $val\\t# insert into vector (F)\" %}\n@@ -2318,3 +2276,3 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), __ $3, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ $3, (int)($idx$$constant));\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ $3, ptrue,\n+    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n+    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n@@ -2325,2 +2283,2 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3,\n-               as_PRegister($pTmp$$reg), as_$4($val$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n@@ -2329,6 +2287,1 @@\n-%}')dnl\n-dnl           $1 $2          $3 $4\n-VECTOR_INSERT(B, iRegIorL2I, B, Register)\n-VECTOR_INSERT(S, iRegIorL2I, H, Register)\n-VECTOR_INSERT(I, iRegIorL2I, S, Register)\n-VECTOR_INSERT(F, vRegF,      S, FloatRegister)\n+%}\n@@ -2401,3 +2354,2 @@\n-dnl\n-define(`VECTOR_REARRANGE', `\n-instruct rearrange$1`'(vReg dst, vReg src, vReg shuffle)\n+\n+instruct rearrange(vReg dst, vReg src, vReg shuffle)\n@@ -2405,2 +2357,1 @@\n-  predicate(UseSVE > 0 &&\n-            type2aelembytes(n->bottom_type()->is_vect()->element_basic_type()) == $2);\n+  predicate(UseSVE > 0);\n@@ -2409,1 +2360,1 @@\n-  format %{ \"sve_tbl $dst, $3, $src, $shuffle\\t# vector rearrange ($3)\" %}\n+  format %{ \"sve_tbl $dst, $src, $shuffle\\t# vector rearrange\" %}\n@@ -2411,1 +2362,3 @@\n-    __ sve_tbl(as_FloatRegister($dst$$reg), __ $3,\n+    BasicType bt = vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_tbl(as_FloatRegister($dst$$reg), size,\n@@ -2415,6 +2368,1 @@\n-%}')dnl\n-dnl              $1 $2 $3\n-VECTOR_REARRANGE(B, 1, B)\n-VECTOR_REARRANGE(S, 2, H)\n-VECTOR_REARRANGE(I, 4, S)\n-VECTOR_REARRANGE(L, 8, D)\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":393,"deletions":445,"binary":false,"changes":838,"status":"modified"},{"patch":"@@ -63,0 +63,21 @@\n+Assembler::SIMD_RegVariant Assembler::elemBytes_to_regVariant(int esize) {\n+  switch(esize) {\n+    case 1:\n+      return B;\n+    case 2:\n+      return H;\n+    case 4:\n+      return S;\n+    case 8:\n+      return D;\n+    default:\n+      assert(false, \"unsupported\");\n+      ShouldNotReachHere();\n+  }\n+  return INVALID;\n+}\n+\n+Assembler::SIMD_RegVariant Assembler::elemType_to_regVariant(BasicType bt) {\n+  return elemBytes_to_regVariant(type2aelembytes(bt));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1542,2 +1542,0 @@\n-  static SIMD_Arrangement esize2arrangement(int esize, bool isQ);\n-\n@@ -1548,0 +1546,4 @@\n+  static SIMD_Arrangement esize2arrangement(int esize, bool isQ);\n+  static SIMD_RegVariant elemType_to_regVariant(BasicType bt);\n+  static SIMD_RegVariant elemBytes_to_regVariant(int esize);\n+\n@@ -3454,1 +3456,1 @@\n-\/\/ SVE conditionally extract element to general-purpose register\n+\/\/ SVE extract element to general-purpose register\n@@ -3467,0 +3469,1 @@\n+\/\/ SVE extract element to SIMD&FP scalar register\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"opto\/subnode.hpp\"\n@@ -835,0 +836,30 @@\n+\n+void C2_MacroAssembler::sve_compare(PRegister pd, BasicType bt, PRegister pg,\n+                                    FloatRegister zn, FloatRegister zm, int cond) {\n+  SIMD_RegVariant size = elemType_to_regVariant(bt);\n+  if (bt == T_FLOAT || bt == T_DOUBLE) {\n+    switch (cond) {\n+      case BoolTest::eq: sve_fcmeq(pd, size, pg, zn, zm); break;\n+      case BoolTest::ne: sve_fcmne(pd, size, pg, zn, zm); break;\n+      case BoolTest::ge: sve_fcmge(pd, size, pg, zn, zm); break;\n+      case BoolTest::gt: sve_fcmgt(pd, size, pg, zn, zm); break;\n+      case BoolTest::le: sve_fcmge(pd, size, pg, zm, zn); break;\n+      case BoolTest::lt: sve_fcmgt(pd, size, pg, zm, zn); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  } else {\n+    switch (cond) {\n+      case BoolTest::eq: sve_cmpeq(pd, size, pg, zn, zm); break;\n+      case BoolTest::ne: sve_cmpne(pd, size, pg, zn, zm); break;\n+      case BoolTest::ge: sve_cmpge(pd, size, pg, zn, zm); break;\n+      case BoolTest::gt: sve_cmpgt(pd, size, pg, zn, zm); break;\n+      case BoolTest::le: sve_cmpge(pd, size, pg, zm, zn); break;\n+      case BoolTest::lt: sve_cmpgt(pd, size, pg, zm, zn); break;\n+      default:\n+        assert(false, \"unsupported\");\n+        ShouldNotReachHere();\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,3 @@\n+  void sve_compare(PRegister pd, BasicType bt, PRegister pg,\n+                   FloatRegister zn, FloatRegister zm, int cond);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2111,1 +2111,4 @@\n-  if (C->max_vector_size() > 8)\n+  \/\/ And when the scalable vector register is used, we may spill\/unspill\n+  \/\/ the whole reg regardless of the max vector size.\n+  if (C->max_vector_size() > 8 ||\n+      (C->max_vector_size() > 0 && Matcher::supports_scalable_vector())) {\n@@ -2113,0 +2116,1 @@\n+  }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}