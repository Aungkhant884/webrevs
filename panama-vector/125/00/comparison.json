{"files":[{"patch":"@@ -9683,0 +9683,66 @@\n+void Assembler::evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src3->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x25);\n+  emit_int8((unsigned char)(0xC0 | encode));\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  assert(dst != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src3, src2->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x25);\n+  emit_operand(dst, src3);\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src3->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x25);\n+  emit_int8((unsigned char)(0xC0 | encode));\n+  emit_int8(imm8);\n+}\n+\n+void Assembler::evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"requires EVEX support\");\n+  assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), \"requires VL support\");\n+  assert(dst != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FV, \/* input_size_in_bits *\/ EVEX_64bit);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  vex_prefix(src3, src2->encoding(), dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int8(0x25);\n+  emit_operand(dst, src3);\n+  emit_int8(imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2402,0 +2402,6 @@\n+  void evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len);\n+  void evpternlogd(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len);\n+  void evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, XMMRegister src3, bool merge, int vector_len);\n+  void evpternlogq(XMMRegister dst, int imm8, KRegister mask, XMMRegister src2, Address src3, bool merge, int vector_len);\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1873,0 +1873,6 @@\n+    case Op_MacroLogicV:\n+      if(bt != T_INT && bt != T_LONG) {\n+        return false;\n+      }\n+      return true;\n+\n@@ -9398,0 +9404,49 @@\n+instruct vternlogd_reg_masked(vec dst, vec src2, vec src3, immU8 func, kReg mask) %{\n+  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MacroLogicV dst (Binary src2 (Binary src3 (Binary func mask)))));\n+  format %{ \"vternlog_masked $dst,$src2,$src3,$func,$mask\\t! vternlog masked operation\" %}\n+  ins_encode %{\n+    int vector_len = vector_length_encoding(this);\n+    __ evpternlogd($dst$$XMMRegister, $func$$constant, $mask$$KRegister,\n+                   $src2$$XMMRegister, $src3$$XMMRegister, true, vector_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vternlogd_mem_masked(vec dst, vec src2, memory src3, immU8 func, kReg mask) %{\n+  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (MacroLogicV dst (Binary src2 (Binary src3 (Binary func mask)))));\n+  format %{ \"vternlog_masked $dst,$src2,$src3,$func,$mask\\t! vternlog masked operation\" %}\n+  ins_encode %{\n+    int vector_len = vector_length_encoding(this);\n+    __ evpternlogd($dst$$XMMRegister, $func$$constant, $mask$$KRegister,\n+                   $src2$$XMMRegister, $src3$$Address, true, vector_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vternlogq_reg_masked(vec dst, vec src2, vec src3, immU8 func, kReg mask) %{\n+  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (MacroLogicV dst (Binary src2 (Binary src3 (Binary func mask)))));\n+  format %{ \"vternlog_masked $dst,$src2,$src3,$func,$mask\\t! vternlog masked operation\" %}\n+  ins_encode %{\n+    int vector_len = vector_length_encoding(this);\n+    __ evpternlogq($dst$$XMMRegister, $func$$constant, $mask$$KRegister,\n+                   $src2$$XMMRegister, $src3$$XMMRegister, true, vector_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vternlogq_mem_masked(vec dst, vec src2, memory src3, immU8 func, kReg mask) %{\n+  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (MacroLogicV dst (Binary src2 (Binary src3 (Binary func mask)))));\n+  format %{ \"vternlog_masked $dst,$src2,$src3,$func,$mask\\t! vternlog masked operation\" %}\n+  ins_encode %{\n+    int vector_len = vector_length_encoding(this);\n+    __ evpternlogq($dst$$XMMRegister, $func$$constant, $mask$$KRegister,\n+                   $src2$$XMMRegister, $src3$$Address, true, vector_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2362,1 +2362,0 @@\n-         n->req() == 2 &&\n@@ -2370,1 +2369,1 @@\n-      return n->req() == 2;\n+      return true;\n@@ -2402,1 +2401,1 @@\n-static uint collect_unique_inputs(Node* n, Unique_Node_List& partition, Unique_Node_List& inputs) {\n+static uint collect_unique_inputs(Node* n, Unique_Node_List& inputs) {\n@@ -2405,0 +2404,1 @@\n+    uint inp_cnt = n->is_predicated_vector() ? n->req()-1 : n->req();\n@@ -2406,1 +2406,1 @@\n-      for (uint i = 1; i < n->req(); i++) {\n+      for (uint i = 1; i < inp_cnt; i++) {\n@@ -2416,1 +2416,1 @@\n-      uint last_req = n->req();\n+      uint last_req = inp_cnt;\n@@ -2418,1 +2418,1 @@\n-        last_req = n->req() - 1; \/\/ skip last input\n+        last_req = inp_cnt - 1; \/\/ skip last input\n@@ -2428,1 +2428,0 @@\n-    partition.push(n);\n@@ -2463,1 +2462,4 @@\n-  return igvn.transform(MacroLogicVNode::make(igvn, in3, in2, in1, func, vt));\n+\n+  Node* pn = partition.at(partition.size() - 1);\n+  Node* mask = pn->is_predicated_vector() ? pn->in(pn->req()-1) : NULL;\n+  return igvn.transform(MacroLogicVNode::make(igvn, in1, in2, in3, mask, func, vt));\n@@ -2543,1 +2545,1 @@\n-  uint input_funcs[] = { 0xAA,   \/\/ (_, _, a) -> a\n+  uint input_funcs[] = { 0xAA,   \/\/ (_, _, c) -> c\n@@ -2545,1 +2547,1 @@\n-                         0xF0 }; \/\/ (c, _, _) -> c\n+                         0xF0 }; \/\/ (a, _, _) -> a\n@@ -2547,1 +2549,1 @@\n-    eval_map.put(inputs.at(i), input_funcs[i]);\n+    eval_map.put(inputs.at(i), input_funcs[2-i]);\n@@ -2590,0 +2592,8 @@\n+\/\/ Criteria under which nodes gets packed into a macro logic node:-\n+\/\/  1) Parent and both child nodes are all unmasked or masked with\n+\/\/     same predicates.\n+\/\/  2) Masked parent can be packed with left child if it is predicated\n+\/\/     and both have same predicates.\n+\/\/  3) Masked parent can be packed with right child if its un-predicated\n+\/\/     or has matching predication condition.\n+\/\/  4) An unmasked parent can be packed with an unmasked child.\n@@ -2599,1 +2609,1 @@\n-    assert(collect_unique_inputs(n, partition, inputs) == 1, \"not unary\");\n+    assert(collect_unique_inputs(n, inputs) == 1, \"not unary\");\n@@ -2603,3 +2613,8 @@\n-  assert(is_vector_binary_bitwise_op(n), \"not binary\");\n-  Node* in1 = n->in(1);\n-  Node* in2 = n->in(2);\n+  bool pack_left_child = true;\n+  bool pack_right_child = true;\n+\n+  bool left_child_LOP = is_vector_bitwise_op(n->in(1));\n+  bool right_child_LOP = is_vector_bitwise_op(n->in(2));\n+\n+  int left_child_input_cnt = 0;\n+  int right_child_input_cnt = 0;\n@@ -2607,3 +2622,3 @@\n-  int in1_unique_inputs_cnt = collect_unique_inputs(in1, partition, inputs);\n-  int in2_unique_inputs_cnt = collect_unique_inputs(in2, partition, inputs);\n-  partition.push(n);\n+  bool parent_is_predicated = n->is_predicated_vector();\n+  bool left_child_predicated = n->in(1)->is_predicated_vector();\n+  bool right_child_predicated = n->in(2)->is_predicated_vector();\n@@ -2611,7 +2626,14 @@\n-  \/\/ Too many inputs?\n-  if (inputs.size() > 3) {\n-    partition.clear();\n-    inputs.clear();\n-    { \/\/ Recompute in2 inputs\n-      Unique_Node_List not_used;\n-      in2_unique_inputs_cnt = collect_unique_inputs(in2, not_used, not_used);\n+  Node* parent_pred = parent_is_predicated ? n->in(n->req()-1) : NULL;\n+  Node* left_child_pred = left_child_predicated ? n->in(1)->in(n->in(1)->req()-1) : NULL;\n+  Node* right_child_pred = right_child_predicated ? n->in(1)->in(n->in(1)->req()-1) : NULL;\n+\n+  do {\n+    if (pack_left_child && left_child_LOP &&\n+        ((!parent_is_predicated && !left_child_predicated) ||\n+        ((parent_is_predicated && left_child_predicated &&\n+          parent_pred == left_child_pred)))) {\n+       partition.push(n->in(1));\n+       left_child_input_cnt = collect_unique_inputs(n->in(1), inputs);\n+    } else {\n+       inputs.push(n->in(1));\n+       left_child_input_cnt = 1;\n@@ -2619,3 +2641,10 @@\n-    \/\/ Pick the node with minimum number of inputs.\n-    if (in1_unique_inputs_cnt >= 3 && in2_unique_inputs_cnt >= 3) {\n-      return false; \/\/ still too many inputs\n+\n+    if (pack_right_child && right_child_LOP &&\n+        (!right_child_predicated ||\n+         (right_child_predicated && parent_is_predicated &&\n+          parent_pred == right_child_pred))) {\n+       partition.push(n->in(2));\n+       right_child_input_cnt = collect_unique_inputs(n->in(2), inputs);\n+    } else {\n+       inputs.push(n->in(2));\n+       right_child_input_cnt = 1;\n@@ -2623,3 +2652,0 @@\n-    \/\/ Recompute partition & inputs.\n-    Node* child       = (in1_unique_inputs_cnt < in2_unique_inputs_cnt ? in1 : in2);\n-    collect_unique_inputs(child, partition, inputs);\n@@ -2627,2 +2653,13 @@\n-    Node* other_input = (in1_unique_inputs_cnt < in2_unique_inputs_cnt ? in2 : in1);\n-    inputs.push(other_input);\n+    if (inputs.size() > 3) {\n+      assert(partition.size() > 0, \"\");\n+      inputs.clear();\n+      partition.clear();\n+      if (left_child_input_cnt > right_child_input_cnt) {\n+        pack_left_child = false;\n+      } else {\n+        pack_right_child = false;\n+      }\n+    } else {\n+      break;\n+    }\n+  } while(true);\n@@ -2630,0 +2667,1 @@\n+  if(partition.size()) {\n@@ -2637,1 +2675,0 @@\n-\n@@ -2658,0 +2695,6 @@\n+#ifdef ASSERT\n+      if (TraceNewVectors) {\n+        tty->print(\"new Vector node: \");\n+        macro_logic->dump();\n+      }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":77,"deletions":34,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2320,0 +2320,8 @@\n+    } else if (n->req() == 6) {\n+      Node* b3 = new BinaryNode(n->in(4), n->in(5));\n+      Node* b2 = new BinaryNode(n->in(3), b3);\n+      Node* b1 = new BinaryNode(n->in(2), b2);\n+      n->set_req(2, b1);\n+      n->del_req(5);\n+      n->del_req(4);\n+      n->del_req(3);\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1196,1 +1196,1 @@\n-                                       uint truth_table, const TypeVect* vt) {\n+                                       Node* mask, uint truth_table, const TypeVect* vt) {\n@@ -1201,0 +1201,1 @@\n+  assert(!mask || mask->bottom_type()->isa_vectmask(), \"predicated register type expected\");\n@@ -1202,1 +1203,1 @@\n-  return new MacroLogicVNode(in1, in2, in3, fn, vt);\n+  return new MacroLogicVNode(in1, in2, in3, fn, mask, vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1245,2 +1245,7 @@\n-  MacroLogicVNode(Node* in1, Node* in2, Node* in3, Node* fn, const TypeVect* vt)\n-  : VectorNode(in1, in2, in3, fn, vt) {}\n+  MacroLogicVNode(Node* in1, Node* in2, Node* in3, Node* fn, Node* mask, const TypeVect* vt)\n+  : VectorNode(in1, in2, in3, fn, vt) {\n+     if (mask) {\n+       this->add_req(mask);\n+       this->add_flag(Node::Flag_is_predicated_vector);\n+     }\n+  }\n@@ -1251,1 +1256,2 @@\n-  static MacroLogicVNode* make(PhaseGVN& igvn, Node* in1, Node* in2, Node* in3, uint truth_table, const TypeVect* vt);\n+  static MacroLogicVNode* make(PhaseGVN& igvn, Node* in1, Node* in2, Node* in3,\n+                               Node* mask, uint truth_table, const TypeVect* vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,493 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8273322\n+ * @modules jdk.incubator.vector\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *           -Xbatch -XX:-TieredCompilation -XX:CICompilerCount=1 -XX:UseAVX=3\n+ *           -XX:CompileCommand=quiet -XX:+TraceNewVectors\n+ *           test.jdk.incubator.TestMaskedMacroLogicVector\n+ *\/\n+\n+package test.jdk.incubator;\n+\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import jdk.incubator.vector.*;\n+\n+public class TestMaskedMacroLogicVector {\n+    static boolean booleanFunc1(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    static void testSubWordBoolean(boolean[] r, boolean[] a, boolean[] b) {\n+        for (int i = 0; i < r.length; i++) {\n+            r[i] = booleanFunc1(a[i], b[i]);\n+        }\n+    }\n+    static void verifySubWordBoolean(boolean[] r, boolean[] a, boolean[] b) {\n+        for (int i = 0; i < r.length; i++) {\n+            boolean expected = booleanFunc1(a[i], b[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(\n+                        String.format(\"at #%d: r=%b, expected = %b = booleanFunc1(%b,%b)\",\n+                                      i, r[i], expected, a[i], b[i]));\n+            }\n+        }\n+    }\n+\n+\n+    static short charFunc1(char a, char b) {\n+        return (short)((a & b) & 1);\n+    }\n+\n+    static void testSubWordChar(short[] r, char[] a, char[] b) {\n+        for (int i = 0; i < r.length; i++) {\n+            r[i] = charFunc1(a[i], b[i]);\n+        }\n+    }\n+    static void verifySubWordChar(short[] r, char[] a, char[] b) {\n+        for (int i = 0; i < r.length; i++) {\n+            short expected = charFunc1(a[i], b[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(\n+                        String.format(\"testSubWordChar: at #%d: r=%d, expected = %d = booleanFunc1(%d,%d)\",\n+                                      i, r[i], expected, (int)a[i], (int)b[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 1): Unmasked expression tree.\n+    \/\/        P_LOP\n+    \/\/   L_LOP     R_LOP\n+\n+    static int intFunc1(int a, int b, int c) {\n+        return (a & b) ^ (a & c);\n+    }\n+\n+    static void testInt1(VectorSpecies<Integer> SPECIES, int[] r, int[] a, int[] b, int[] c) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i+=SPECIES.length()) {\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vc)\n+            .lanewise(VectorOperators.XOR, va.lanewise(VectorOperators.AND, vb))\n+            .intoArray(r, i);\n+        }\n+    }\n+\n+    static void verifyInt1(int[] r, int[] a, int[] b, int[] c) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc1(a[i], b[i], c[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt1: at #%d: r=%d, expected = %d = intFunc1(%d,%d,%d)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 2): Only right child is masked.\n+    \/\/        P_LOP\n+    \/\/   L_LOP    R_LOP(mask)\n+\n+    static int intFunc2(int a, int b, int c, boolean mask) {\n+        return (a & b) ^ (mask == true ? a & c : a);\n+    }\n+\n+    static void testInt2(VectorSpecies<Integer> SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i+=SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vb)\n+            .lanewise(VectorOperators.XOR,\n+                      va.lanewise(VectorOperators.AND, vc, vmask))\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    static void verifyInt2(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc2(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt2: at #%d: r=%d, expected = %d = intFunc2(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 3): Only left child is masked.\n+    \/\/             P_LOP\n+    \/\/   L_LOP(mask)    R_LOP\n+\n+    static int intFunc3(int a, int b, int c, boolean mask) {\n+        return (mask == true ? a & b : a) ^ (a & c);\n+    }\n+\n+    static void testInt3(VectorSpecies<Integer> SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i+=SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vb, vmask)\n+            .lanewise(VectorOperators.XOR,\n+                      va.lanewise(VectorOperators.AND, vc))\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    static void verifyInt3(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc3(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt3: at #%d: r=%d, expected = %d = intFunc3(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 4): Both child nodes are masked.\n+    \/\/             P_LOP\n+    \/\/   L_LOP(mask)    R_LOP(mask)\n+\n+    static int intFunc4(int a, int b, int c, boolean mask) {\n+        return (mask == true ? b & a : b) ^ (mask == true ? c & a : c);\n+    }\n+\n+    static void testInt4(VectorSpecies<Integer> SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i+=SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            vb.lanewise(VectorOperators.AND, va, vmask)\n+            .lanewise(VectorOperators.XOR,\n+                      vc.lanewise(VectorOperators.AND, va, vmask))\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    static void verifyInt4(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc4(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt4: at #%d: r=%d, expected = %d = intFunc4(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 5): Parent is masked with unmasked child expressions.\n+    \/\/        P_LOP(mask)\n+    \/\/   L_LOP     R_LOP\n+\n+    static int intFunc5(int a, int b, int c, boolean mask) {\n+        return mask == true ? ((a & b) ^ (a & c)) : (a & b);\n+    }\n+\n+    static void testInt5(VectorSpecies<Integer> SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i+=SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vb)\n+            .lanewise(VectorOperators.XOR,\n+                      va.lanewise(VectorOperators.AND, vc), vmask)\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    static void verifyInt5(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc5(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt5: at #%d: r=%d, expected = %d = intFunc5(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 6): Parent and right child are masked.\n+    \/\/        P_LOP(mask)\n+    \/\/   L_LOP     R_LOP(mask)\n+\n+    static int intFunc6(int a, int b, int c, boolean mask) {\n+        return mask == true ? ((a & b) ^ (mask == true ? a & c : a)) : (a & b);\n+    }\n+\n+    static void testInt6(VectorSpecies<Integer> SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i+=SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vb)\n+            .lanewise(VectorOperators.XOR,\n+                      va.lanewise(VectorOperators.AND, vc, vmask), vmask)\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    static void verifyInt6(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc6(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt6: at #%d: r=%d, expected = %d = intFunc6(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 7): Parent and left child are masked.\n+    \/\/            P_LOP(mask)\n+    \/\/   L_LOP(mask)       R_LOP\n+\n+    static int intFunc7(int a, int b, int c, boolean mask) {\n+        return mask == true ? ((mask == true ? a & b : a) ^ (a & c)) : a;\n+    }\n+\n+    static void testInt7(VectorSpecies<Integer> SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i+=SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            va.lanewise(VectorOperators.AND, vb, vmask)\n+            .lanewise(VectorOperators.XOR,\n+                      va.lanewise(VectorOperators.AND, vc), vmask)\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    static void verifyInt7(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc7(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt7: at #%d: r=%d, expected = %d = intFunc7(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ Case 8): Parent and both child expressions are masked.\n+    \/\/            P_LOP(mask)\n+    \/\/   L_LOP(mask)       R_LOP (mask)\n+\n+    static int intFunc8(int a, int b, int c, boolean mask) {\n+        return mask == true ? ((mask == true ? b & a : b) ^ (mask == true ? c & a  : c)) : b;\n+    }\n+\n+    static void testInt8(VectorSpecies<Integer> SPECIES, int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i+=SPECIES.length()) {\n+            VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask , i);\n+            IntVector va = IntVector.fromArray(SPECIES, a, i);\n+            IntVector vb = IntVector.fromArray(SPECIES, b, i);\n+            IntVector vc = IntVector.fromArray(SPECIES, c, i);\n+            vb.lanewise(VectorOperators.AND, va, vmask)\n+            .lanewise(VectorOperators.XOR,\n+                      vc.lanewise(VectorOperators.AND, va, vmask), vmask)\n+           .intoArray(r, i);\n+        }\n+    }\n+\n+    static void verifyInt8(int[] r, int[] a, int[] b, int[] c, boolean [] mask) {\n+        for (int i = 0; i < r.length; i++) {\n+            int expected = intFunc8(a[i], b[i], c[i], mask[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(String.format(\"testInt8: at #%d: r=%d, expected = %d = intFunc8(%d,%d,%d,%b)\",\n+                                                       i, r[i], expected, a[i], b[i], c[i], mask[i]));\n+            }\n+        }\n+    }\n+\n+\n+    \/\/ ===================================================== \/\/\n+\n+    static long longFunc(long a, long b, long c) {\n+        long v1 = (a & b) ^ (a & c) ^ (b & c);\n+        long v2 = (~a & b) | (~b & c) | (~c & a);\n+        return v1 & v2;\n+    }\n+\n+    static void testLong(VectorSpecies<Long> SPECIES, long[] r, long[] a, long[] b, long[] c) {\n+        for (int i = 0; i < SPECIES.loopBound(r.length); i += SPECIES.length()) {\n+            LongVector va = LongVector.fromArray(SPECIES, a, i);\n+            LongVector vb = LongVector.fromArray(SPECIES, b, i);\n+            LongVector vc = LongVector.fromArray(SPECIES, c, i);\n+\n+            va.lanewise(VectorOperators.AND, vb)\n+            .lanewise(VectorOperators.XOR, va.lanewise(VectorOperators.AND, vc))\n+            .lanewise(VectorOperators.XOR, vb.lanewise(VectorOperators.AND, vc))\n+            .lanewise(VectorOperators.AND,\n+                       va.lanewise(VectorOperators.NOT).lanewise(VectorOperators.AND, vb)\n+                      .lanewise(VectorOperators.OR, vb.lanewise(VectorOperators.NOT).lanewise(VectorOperators.AND, vc))\n+                      .lanewise(VectorOperators.OR, vc.lanewise(VectorOperators.NOT).lanewise(VectorOperators.AND, va)))\n+            .intoArray(r, i);\n+        }\n+    }\n+\n+    static void verifyLong(long[] r, long[] a, long[] b, long[] c) {\n+        for (int i = 0; i < r.length; i++) {\n+            long expected = longFunc(a[i], b[i], c[i]);\n+            if (r[i] != expected) {\n+                throw new AssertionError(\n+                        String.format(\"testLong: at #%d: r=%d, expected = %d = longFunc(%d,%d,%d)\",\n+                                      i, r[i], expected, a[i], b[i], c[i]));\n+            }\n+        }\n+    }\n+\n+    \/\/ ===================================================== \/\/\n+\n+    private static final Random R = new Random(1024);\n+\n+    static boolean[] fillBooleanRandom(Callable<boolean[]> factory) {\n+        try {\n+            boolean[] arr = factory.call();\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = R.nextBoolean();\n+            }\n+            return arr;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+    static char[] fillCharRandom(Callable<char[]> factory) {\n+        try {\n+            char[] arr = factory.call();\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = (char)R.nextInt();\n+            }\n+            return arr;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+    static int[] fillIntRandom(Callable<int[]> factory) {\n+        try {\n+            int[] arr = factory.call();\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = R.nextInt();\n+            }\n+            return arr;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+    static long[] fillLongRandom(Callable<long[]> factory) {\n+        try {\n+            long[] arr = factory.call();\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = R.nextLong();\n+            }\n+            return arr;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/\/ ===================================================== \/\/\n+\n+    static final int SIZE = 512;\n+\n+    public static void main(String[] args) {\n+        boolean[] br = new boolean[SIZE];\n+        boolean[] ba = fillBooleanRandom((()-> new boolean[SIZE]));\n+        boolean[] bb = fillBooleanRandom((()-> new boolean[SIZE]));\n+\n+        short[] sr = new short[SIZE];\n+        char[] ca = fillCharRandom((()-> new char[SIZE]));\n+        char[] cb = fillCharRandom((()-> new char[SIZE]));\n+\n+        int[] r = new int[SIZE];\n+        int[] a = fillIntRandom(()-> new int[SIZE]);\n+        int[] b = fillIntRandom(()-> new int[SIZE]);\n+        int[] c = fillIntRandom(()-> new int[SIZE]);\n+        int[] d = fillIntRandom(()-> new int[SIZE]);\n+        int[] e = fillIntRandom(()-> new int[SIZE]);\n+        int[] f = fillIntRandom(()-> new int[SIZE]);\n+\n+        long[] rl = new long[SIZE];\n+        long[] al = fillLongRandom(() -> new long[SIZE]);\n+        long[] bl = fillLongRandom(() -> new long[SIZE]);\n+        long[] cl = fillLongRandom(() -> new long[SIZE]);\n+\n+        boolean[] mask = fillBooleanRandom((()-> new boolean[SIZE]));\n+\n+        VectorSpecies [] ispecies = {\n+            IntVector.SPECIES_64,\n+            IntVector.SPECIES_128,\n+            IntVector.SPECIES_256,\n+            IntVector.SPECIES_512\n+        };\n+\n+        VectorSpecies [] lspecies = {\n+            LongVector.SPECIES_64,\n+            LongVector.SPECIES_128,\n+            LongVector.SPECIES_256,\n+            LongVector.SPECIES_512\n+        };\n+\n+        for (int i = 0; i < 20_000; i++) {\n+            testSubWordBoolean(br, ba, bb);\n+            verifySubWordBoolean(br, ba, bb);\n+\n+            testSubWordChar(sr, ca, cb);\n+            verifySubWordChar(sr, ca, cb);\n+\n+            testInt1(ispecies[i & 3], r, a, b, c);\n+            verifyInt1(r, a, b, c);\n+\n+            testInt2(ispecies[i & 3], r, a, b, c, mask);\n+            verifyInt2(r, a, b, c, mask);\n+\n+            testInt3(ispecies[i & 3], r, a, b, c, mask);\n+            verifyInt3(r, a, b, c, mask);\n+\n+            testInt4(ispecies[i & 3], r, a, b, c, mask);\n+            verifyInt4(r, a, b, c, mask);\n+\n+            testInt5(ispecies[i & 3], r, a, b, c, mask);\n+            verifyInt5(r, a, b, c, mask);\n+\n+            testInt6(ispecies[i & 3], r, a, b, c, mask);\n+            verifyInt6(r, a, b, c, mask);\n+\n+            testInt7(ispecies[i & 3], r, a, b, c, mask);\n+            verifyInt7(r, a, b, c, mask);\n+\n+            testInt8(ispecies[i & 3], r, a, b, c, mask);\n+            verifyInt8(r, a, b, c, mask);\n+\n+            testLong(lspecies[i & 3], rl, al, bl, cl);\n+            verifyLong(rl, al, bl, cl);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/TestMaskedMacroLogicVector.java","additions":493,"deletions":0,"binary":false,"changes":493,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class MaskedLogicOpts {\n+    @Param({\"256\",\"512\",\"1024\",\"2048\",\"4096\"})\n+    private int VECLEN;\n+\n+    @Param({\"128\", \"256\", \"512\"})\n+    private int SPECIES;\n+\n+    boolean [] mask_arr = {\n+        false, false, false, true, false, false, false, false,\n+        false, false, false, true, false, false, false, false,\n+        false, false, false, true, false, false, false, false,\n+        true, true, true, true, true, true, true, true,\n+        true, true, true, true, true, true, true, true,\n+        false, false, false, true, false, false, false, false,\n+        false, false, false, true, false, false, false, false,\n+        false, false, false, true, false, false, false, false\n+    };\n+\n+    int INVOC_COUNTER = 1024;\n+\n+    int [] i1 = new int[VECLEN];\n+    int [] i2 = new int[VECLEN];\n+    int [] i3 = new int[VECLEN];\n+    int [] i4 = new int[VECLEN];\n+    int [] i5 = new int[VECLEN];\n+\n+    long [] l1 = new long[VECLEN];\n+    long [] l2 = new long[VECLEN];\n+    long [] l3 = new long[VECLEN];\n+    long [] l4 = new long[VECLEN];\n+    long [] l5 = new long[VECLEN];\n+\n+    Vector<Integer> iv1;\n+    Vector<Integer> iv2;\n+    Vector<Integer> iv3;\n+    Vector<Integer> iv4;\n+    Vector<Integer> iv5;\n+\n+    Vector<Long> lv1;\n+    Vector<Long> lv2;\n+    Vector<Long> lv3;\n+    Vector<Long> lv4;\n+    Vector<Long> lv5;\n+\n+    VectorMask<Integer> imask;\n+    VectorMask<Long> lmask;\n+\n+    VectorSpecies<Integer> ispecies;\n+    VectorSpecies<Long> lspecies;\n+\n+    int int_arr_idx;\n+    int long_arr_idx;\n+\n+    private Random r = new Random();\n+\n+    @Setup(Level.Trial)\n+    public void init() {\n+        int_arr_idx = 0;\n+        long_arr_idx = 0;\n+        i1 = new int[VECLEN];\n+        i2 = new int[VECLEN];\n+        i3 = new int[VECLEN];\n+        i4 = new int[VECLEN];\n+        i5 = new int[VECLEN];\n+\n+        l1 = new long[VECLEN];\n+        l2 = new long[VECLEN];\n+        l3 = new long[VECLEN];\n+        l4 = new long[VECLEN];\n+        l5 = new long[VECLEN];\n+\n+        for (int i=0; i<VECLEN; i++) {\n+            i1[i] = r.nextInt();\n+            i2[i] = r.nextInt();\n+            i3[i] = r.nextInt();\n+            i4[i] = r.nextInt();\n+            i5[i] = r.nextInt();\n+\n+            l1[i] = r.nextLong();\n+            l2[i] = r.nextLong();\n+            l3[i] = r.nextLong();\n+            l4[i] = r.nextLong();\n+            l5[i] = r.nextLong();\n+        }\n+\n+        ispecies = VectorSpecies.of(int.class, VectorShape.forBitSize(SPECIES));\n+        lspecies = VectorSpecies.of(long.class, VectorShape.forBitSize(SPECIES));\n+\n+        imask = VectorMask.fromArray(ispecies, mask_arr, 0);\n+        lmask = VectorMask.fromArray(lspecies, mask_arr, 0);\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void init_per_invoc() {\n+        iv1 = IntVector.fromArray(ispecies, i1, int_arr_idx);\n+        iv2 = IntVector.fromArray(ispecies, i2, int_arr_idx);\n+        iv3 = IntVector.fromArray(ispecies, i3, int_arr_idx);\n+        iv4 = IntVector.fromArray(ispecies, i4, int_arr_idx);\n+        iv5 = IntVector.fromArray(ispecies, i5, int_arr_idx);\n+\n+        lv1 = LongVector.fromArray(lspecies, l1, long_arr_idx);\n+        lv2 = LongVector.fromArray(lspecies, l2, long_arr_idx);\n+        lv3 = LongVector.fromArray(lspecies, l3, long_arr_idx);\n+        lv4 = LongVector.fromArray(lspecies, l4, long_arr_idx);\n+        lv5 = LongVector.fromArray(lspecies, l5, long_arr_idx);\n+\n+        int_arr_idx = (int_arr_idx + ispecies.length()) & (VECLEN -1);\n+        long_arr_idx = (long_arr_idx + lspecies.length()) & (VECLEN -1);\n+    }\n+\n+    @Benchmark\n+    public int maskedLogicOperationsInt() {\n+       for(int i = 0; i < INVOC_COUNTER; i++) {\n+           IntVector.fromArray(ispecies, i1, int_arr_idx)\n+               .lanewise(VectorOperators.AND, iv2, imask)\n+               .lanewise(VectorOperators.OR,  iv3, imask)\n+               .lanewise(VectorOperators.AND, iv4, imask)\n+               .lanewise(VectorOperators.XOR, iv5, imask)\n+               .intoArray(i1, int_arr_idx);\n+       }\n+       return i1[int_arr_idx];\n+    }\n+\n+    @Benchmark\n+    public int partiallyMaskedLogicOperationsInt() {\n+       for(int i = 0; i < INVOC_COUNTER; i++) {\n+           IntVector.fromArray(ispecies, i1, int_arr_idx)\n+               .lanewise(VectorOperators.AND, iv2, imask)\n+               .lanewise(VectorOperators.OR,  iv3)\n+               .lanewise(VectorOperators.AND, iv4, imask)\n+               .lanewise(VectorOperators.XOR, iv5)\n+               .intoArray(i1, int_arr_idx);\n+       }\n+       return i1[int_arr_idx];\n+    }\n+\n+    @Benchmark\n+    public int bitwiseBlendOperationInt() {\n+       for(int i = 0; i < INVOC_COUNTER; i++) {\n+           IntVector.fromArray(ispecies, i1, int_arr_idx)\n+               .lanewise(VectorOperators.BITWISE_BLEND, iv2, iv3, imask)\n+               .lanewise(VectorOperators.BITWISE_BLEND, iv3, iv4, imask)\n+               .lanewise(VectorOperators.BITWISE_BLEND, iv4, iv5, imask)\n+               .intoArray(i1, int_arr_idx);\n+       }\n+       return i1[int_arr_idx];\n+    }\n+\n+    @Benchmark\n+    public long maskedLogicOperationsLong() {\n+       for(int i = 0; i < INVOC_COUNTER; i++) {\n+           LongVector.fromArray(lspecies, l1, long_arr_idx)\n+               .lanewise(VectorOperators.AND, lv2, lmask)\n+               .lanewise(VectorOperators.OR,  lv3, lmask)\n+               .lanewise(VectorOperators.AND, lv4, lmask)\n+               .lanewise(VectorOperators.XOR, lv5, lmask)\n+               .intoArray(l1, long_arr_idx);\n+       }\n+       return l1[long_arr_idx];\n+    }\n+\n+    @Benchmark\n+    public long partiallyMaskedLogicOperationsLong() {\n+       for(int i = 0; i < INVOC_COUNTER; i++) {\n+           LongVector.fromArray(lspecies, l1, long_arr_idx)\n+               .lanewise(VectorOperators.AND, lv2, lmask)\n+               .lanewise(VectorOperators.OR,  lv3)\n+               .lanewise(VectorOperators.AND, lv4, lmask)\n+               .lanewise(VectorOperators.XOR, lv5)\n+               .intoArray(l1, long_arr_idx);\n+       }\n+       return l1[long_arr_idx];\n+    }\n+\n+    @Benchmark\n+    public long bitwiseBlendOperationLong() {\n+       for(int i = 0; i < INVOC_COUNTER; i++) {\n+           LongVector.fromArray(lspecies, l1, long_arr_idx)\n+               .lanewise(VectorOperators.BITWISE_BLEND, lv2, lv3, lmask)\n+               .lanewise(VectorOperators.BITWISE_BLEND, lv3, lv4, lmask)\n+               .lanewise(VectorOperators.BITWISE_BLEND, lv4, lv5, lmask)\n+               .intoArray(l1, long_arr_idx);\n+       }\n+       return l1[long_arr_idx];\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskedLogicOpts.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"}]}