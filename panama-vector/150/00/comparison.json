{"files":[{"patch":"@@ -317,0 +317,25 @@\n+    \/\/ Selective operator\n+\n+    \/*package-private*\/\n+    interface FSelOp {\n+        void apply(byte[] d, byte[] s, int cnt, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    ByteVector selOp(VectorMask<Byte> m, FSelOp f) {\n+        \/\/ mask true count\n+        int cnt = 0;\n+        byte[] vec = vec();\n+        byte[] res = new byte[length()];\n+        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(res, vec, cnt, i);\n+                cnt++;\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -2372,10 +2397,8 @@\n-    ByteVector compressTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      ByteVector v = ByteVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(j++, lane(i));\n-        }\n-      }\n-      return v;\n+    ByteVector compressTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            true, getClass(), maskType, byte.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[cnt] = v[i];\n+            }));\n@@ -2395,10 +2418,8 @@\n-    ByteVector expandTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      ByteVector v = ByteVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(i, lane(j++));\n-        }\n-      }\n-      return v;\n+    ByteVector expandTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            false, getClass(), maskType, byte.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[i] = v[cnt];\n+            }));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":41,"deletions":20,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -317,0 +317,25 @@\n+    \/\/ Selective operator\n+\n+    \/*package-private*\/\n+    interface FSelOp {\n+        void apply(double[] d, double[] s, int cnt, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    DoubleVector selOp(VectorMask<Double> m, FSelOp f) {\n+        \/\/ mask true count\n+        int cnt = 0;\n+        double[] vec = vec();\n+        double[] res = new double[length()];\n+        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(res, vec, cnt, i);\n+                cnt++;\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -2218,10 +2243,8 @@\n-    DoubleVector compressTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      DoubleVector v = DoubleVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(j++, lane(i));\n-        }\n-      }\n-      return v;\n+    DoubleVector compressTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            true, getClass(), maskType, double.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[cnt] = v[i];\n+            }));\n@@ -2241,10 +2264,8 @@\n-    DoubleVector expandTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      DoubleVector v = DoubleVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(i, lane(j++));\n-        }\n-      }\n-      return v;\n+    DoubleVector expandTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            false, getClass(), maskType, double.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[i] = v[cnt];\n+            }));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":41,"deletions":20,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -317,0 +317,25 @@\n+    \/\/ Selective operator\n+\n+    \/*package-private*\/\n+    interface FSelOp {\n+        void apply(float[] d, float[] s, int cnt, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    FloatVector selOp(VectorMask<Float> m, FSelOp f) {\n+        \/\/ mask true count\n+        int cnt = 0;\n+        float[] vec = vec();\n+        float[] res = new float[length()];\n+        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(res, vec, cnt, i);\n+                cnt++;\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -2230,10 +2255,8 @@\n-    FloatVector compressTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      FloatVector v = FloatVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(j++, lane(i));\n-        }\n-      }\n-      return v;\n+    FloatVector compressTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            true, getClass(), maskType, float.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[cnt] = v[i];\n+            }));\n@@ -2253,10 +2276,8 @@\n-    FloatVector expandTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      FloatVector v = FloatVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(i, lane(j++));\n-        }\n-      }\n-      return v;\n+    FloatVector expandTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            false, getClass(), maskType, float.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[i] = v[cnt];\n+            }));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":41,"deletions":20,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -317,0 +317,25 @@\n+    \/\/ Selective operator\n+\n+    \/*package-private*\/\n+    interface FSelOp {\n+        void apply(int[] d, int[] s, int cnt, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    IntVector selOp(VectorMask<Integer> m, FSelOp f) {\n+        \/\/ mask true count\n+        int cnt = 0;\n+        int[] vec = vec();\n+        int[] res = new int[length()];\n+        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(res, vec, cnt, i);\n+                cnt++;\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -2371,10 +2396,8 @@\n-    IntVector compressTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      IntVector v = IntVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(j++, lane(i));\n-        }\n-      }\n-      return v;\n+    IntVector compressTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            true, getClass(), maskType, int.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[cnt] = v[i];\n+            }));\n@@ -2394,10 +2417,8 @@\n-    IntVector expandTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      IntVector v = IntVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(i, lane(j++));\n-        }\n-      }\n-      return v;\n+    IntVector expandTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            false, getClass(), maskType, int.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[i] = v[cnt];\n+            }));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":41,"deletions":20,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -317,0 +317,25 @@\n+    \/\/ Selective operator\n+\n+    \/*package-private*\/\n+    interface FSelOp {\n+        void apply(long[] d, long[] s, int cnt, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    LongVector selOp(VectorMask<Long> m, FSelOp f) {\n+        \/\/ mask true count\n+        int cnt = 0;\n+        long[] vec = vec();\n+        long[] res = new long[length()];\n+        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(res, vec, cnt, i);\n+                cnt++;\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -2237,10 +2262,8 @@\n-    LongVector compressTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      LongVector v = LongVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(j++, lane(i));\n-        }\n-      }\n-      return v;\n+    LongVector compressTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            true, getClass(), maskType, long.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[cnt] = v[i];\n+            }));\n@@ -2260,10 +2283,8 @@\n-    LongVector expandTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      LongVector v = LongVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(i, lane(j++));\n-        }\n-      }\n-      return v;\n+    LongVector expandTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            false, getClass(), maskType, long.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[i] = v[cnt];\n+            }));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":41,"deletions":20,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -317,0 +317,25 @@\n+    \/\/ Selective operator\n+\n+    \/*package-private*\/\n+    interface FSelOp {\n+        void apply(short[] d, short[] s, int cnt, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    ShortVector selOp(VectorMask<Short> m, FSelOp f) {\n+        \/\/ mask true count\n+        int cnt = 0;\n+        short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(res, vec, cnt, i);\n+                cnt++;\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -2372,10 +2397,8 @@\n-    ShortVector compressTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      ShortVector v = ShortVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(j++, lane(i));\n-        }\n-      }\n-      return v;\n+    ShortVector compressTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            true, getClass(), maskType, short.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[cnt] = v[i];\n+            }));\n@@ -2395,10 +2418,8 @@\n-    ShortVector expandTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      ShortVector v = ShortVector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(i, lane(j++));\n-        }\n-      }\n-      return v;\n+    ShortVector expandTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            false, getClass(), maskType, short.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[i] = v[cnt];\n+            }));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":41,"deletions":20,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -321,0 +321,25 @@\n+    \/\/ Selective operator\n+\n+    \/*package-private*\/\n+    interface FSelOp {\n+        void apply($type$[] d, $type$[] s, int cnt, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    $abstractvectortype$ selOp(VectorMask<$Boxtype$> m, FSelOp f) {\n+        \/\/ mask true count\n+        int cnt = 0;\n+        $type$[] vec = vec();\n+        $type$[] res = new $type$[length()];\n+        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(res, vec, cnt, i);\n+                cnt++;\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n@@ -2663,1 +2688,1 @@\n-    $Type$Vector compress(VectorMask<$Boxtype$> m);\n+    $abstractvectortype$ compress(VectorMask<$Boxtype$> m);\n@@ -2669,10 +2694,8 @@\n-    $Type$Vector compressTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      $Type$Vector v = $Type$Vector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(j++, lane(i));\n-        }\n-      }\n-      return v;\n+    $abstractvectortype$ compressTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            true, getClass(), maskType, $type$.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[cnt] = v[i];\n+            }));\n@@ -2686,1 +2709,1 @@\n-    $Type$Vector expand(VectorMask<$Boxtype$> m);\n+    $abstractvectortype$ expand(VectorMask<$Boxtype$> m);\n@@ -2692,10 +2715,8 @@\n-    $Type$Vector expandTemplate(Class<M> masktype, M m) {\n-      m.check(masktype, this);\n-      int j = 0;\n-      $Type$Vector v = $Type$Vector.zero(species());\n-      for (int i = 0; i < length(); i++) {\n-        if (m.laneIsSet(i)) {\n-           v = v.withLane(i, lane(j++));\n-        }\n-      }\n-      return v;\n+    $abstractvectortype$ expandTemplate(Class<M> maskType, M m) {\n+        m.check(maskType, this);\n+        return VectorSupport.selectiveOp(\n+            false, getClass(), maskType, $type$.class, length(),\n+            this, m,\n+            (v1, m_) -> v1.selOp(m_, (a, v, cnt, i) -> {\n+                a[i] = v[cnt];\n+            }));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":43,"deletions":22,"binary":false,"changes":65,"status":"modified"}]}