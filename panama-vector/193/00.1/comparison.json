{"files":[{"patch":"@@ -2437,0 +2437,8 @@\n+    case Op_PopCountI:\n+    case Op_PopCountL:\n+    case Op_PopCountVI:\n+    case Op_PopCountVL:\n+      if (!UsePopCountInstruction) {\n+        ret_value = false;\n+      }\n+      break;\n@@ -2477,0 +2485,2 @@\n+    case Op_CompressV:\n+    case Op_CompressM:\n@@ -8640,1 +8650,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8651,0 +8660,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -8662,1 +8672,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8672,0 +8681,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -8685,1 +8695,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8695,0 +8704,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -8705,1 +8715,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8715,0 +8724,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -5680,2 +5680,2 @@\n-instruct vpopcount4I(vecX dst, vecX src) %{\n-  predicate(UsePopCountInstruction && n->as_Vector()->length() == 4);\n+instruct vpopcountID(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() < 16);\n@@ -5683,4 +5683,15 @@\n-  format %{\n-    \"cnt     $dst, $src\\t# vector (16B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (16B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (8H)\"\n+  ins_cost(3 * INSN_COST);\n+  format %{ \"vpopcountI  $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ cnt(as_FloatRegister($dst$$reg), __ T8B,\n+           as_FloatRegister($src$$reg));\n+    if (bt == T_SHORT || bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T8B,\n+                as_FloatRegister($dst$$reg));\n+    }\n+    if (bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T4H,\n+                as_FloatRegister($dst$$reg));\n+    }\n@@ -5688,0 +5699,8 @@\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vpopcountIX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (PopCountVI src));\n+  ins_cost(3 * INSN_COST);\n+  format %{ \"vpopcountI  $dst, $src\\t# vector (16B\/8H\/4S)\" %}\n@@ -5689,0 +5708,28 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src$$reg));\n+    if (bt == T_SHORT || bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n+                as_FloatRegister($dst$$reg));\n+    }\n+    if (bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n+                as_FloatRegister($dst$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountLX\" rule.\n+instruct vpopcountLD(vecD dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() < 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (PopCountVL src));\n+  ins_cost(5 * INSN_COST);\n+  format %{ \"vpopcountL  $dst, $src\\t# vector (2S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -5695,0 +5742,4 @@\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n+              as_FloatRegister($dst$$reg));\n+    __ xtn(as_FloatRegister($dst$$reg), __ T2S,\n+           as_FloatRegister($dst$$reg), __ T2D);\n@@ -5699,8 +5750,6 @@\n-instruct vpopcount2I(vecD dst, vecD src) %{\n-  predicate(UsePopCountInstruction && n->as_Vector()->length() == 2);\n-  match(Set dst (PopCountVI src));\n-  format %{\n-    \"cnt     $dst, $src\\t# vector (8B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (8B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (4H)\"\n-  %}\n+instruct vpopcountLX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (PopCountVL src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vpopcountL  $dst, $src\\t# vector (2D)\" %}\n@@ -5708,1 +5757,2 @@\n-    __ cnt(as_FloatRegister($dst$$reg), __ T8B,\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n@@ -5710,1 +5760,1 @@\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T8B,\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n@@ -5712,1 +5762,3 @@\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T4H,\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n+              as_FloatRegister($dst$$reg));\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n@@ -5918,0 +5970,128 @@\n+\n+\/\/------------------------- CountLeadingZerosV -----------------------------\n+\n+instruct countLeadingZerosVD(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (CountLeadingZerosV src));\n+  ins_cost(INSN_COST);\n+  format %{ \"countLeadingZerosV $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);\n+    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct countLeadingZerosVX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (CountLeadingZerosV src));\n+  ins_cost(INSN_COST);\n+  format %{ \"countLeadingZerosV $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);\n+    if (bt != T_LONG) {\n+      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n+    } else {\n+      __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 0);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n+      __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/------------------------- CountTrailingZerosV ----------------------------\n+\n+instruct countTrailingZerosVD(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (CountTrailingZerosV src));\n+  ins_cost(3 * INSN_COST);\n+  format %{ \"countTrailingZerosV $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n+    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct countTrailingZerosVX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (CountTrailingZerosV src));\n+  ins_cost(3 * INSN_COST);\n+  format %{ \"countTrailingZerosV $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n+    if (bt != T_LONG) {\n+      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($dst$$reg));\n+    } else {\n+      __ umov(rscratch1, as_FloatRegister($dst$$reg), __ D, 0);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n+      __ umov(rscratch1, as_FloatRegister($dst$$reg), __ D, 1);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/------------------------------ ReverseV -----------------------------------\n+\n+instruct vreverseD(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (ReverseV src));\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"ReverseV $dst, $src\\t# vector (D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreverseX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (ReverseV src));\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"ReverseV $dst, $src\\t# vector (X)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/---------------------------- ReverseBytesV --------------------------------\n+\n+instruct vreverseBytesD(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (ReverseBytesV src));\n+  ins_cost(INSN_COST);\n+  format %{ \"ReverseBytesV $dst, $src\\t# vector (D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ neon_reverse_bytes(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreverseBytesX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (ReverseBytesV src));\n+  ins_cost(INSN_COST);\n+  format %{ \"ReverseBytesV $dst, $src\\t# vector (X)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ neon_reverse_bytes(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":197,"deletions":17,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -2420,13 +2420,21 @@\n-define(`VPOPCOUNT', `\n-instruct vpopcount$1$2`'(vec$5 dst, vec$5 src) %{\n-  predicate(UsePopCountInstruction && n->as_Vector()->length() == $1);\n-  match(Set dst (PopCountVI src));\n-  format %{\n-    \"cnt     $dst, $src\\t# vector ($3B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector ($3B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector ($4H)\"\n-  %}\n-  ins_encode %{\n-    __ cnt(as_FloatRegister($dst$$reg), __ T$3B,\n-           as_FloatRegister($src$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T$3B,\n+define(`VPOPCOUNT', `dnl\n+ifelse($1$2, `LD', `\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountLX\" rule.', `')\n+instruct vpopcount$1$2`'(vec$2 dst, vec$3 src) %{\n+  predicate(n->as_Vector()->length_in_bytes() $4 16`'ifelse($1$2, `LD', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT', $1$2, `LX', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n+  match(Set dst (PopCountV$1 src));\n+  ins_cost($5 * INSN_COST);\n+  format %{ \"vpopcount$1  $dst, $src\\t# vector ($6)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");dnl\n+ifelse($1, `I', `\n+    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n+    __ cnt(as_FloatRegister($dst$$reg), __ T`'ifelse($3, D, 8, 16)B,\n+           as_FloatRegister($src$$reg));dnl\n+ifelse($1, `L', `\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n@@ -2434,1 +2442,1 @@\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T$4H,\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n@@ -2436,0 +2444,13 @@\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n+              as_FloatRegister($dst$$reg));', `\n+    if (bt == T_SHORT || bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T`'ifelse($2, D, 8, 16)B,\n+                as_FloatRegister($dst$$reg));\n+    }\n+    if (bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T`'ifelse($2, D, 4, 8)H,\n+                as_FloatRegister($dst$$reg));\n+    }')dnl\n+ifelse($1$2, `LD', `\n+    __ xtn(as_FloatRegister($dst$$reg), __ T2S,\n+           as_FloatRegister($dst$$reg), __ T2D);', `')\n@@ -2439,3 +2460,5 @@\n-dnl       $1 $2 $3  $4 $5\n-VPOPCOUNT(4, I, 16, 8, X)\n-VPOPCOUNT(2, I, 8,  4, D)\n+dnl       $1 $2 $3 $4  $5 $6\n+VPOPCOUNT(I, D, D, <,  3, 8B\/4H\/2S)\n+VPOPCOUNT(I, X, X, ==, 3, 16B\/8H\/4S)\n+VPOPCOUNT(L, D, X, <,  5, 2S)\n+VPOPCOUNT(L, X, X, ==, 4, 2D)\n@@ -2622,0 +2645,78 @@\n+\n+dnl\n+dnl CLTZ_D($1     )\n+dnl CLTZ_D(op_name)\n+define(`CLTZ_D', `\n+instruct count$1D(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (Count$1 src));\n+  ins_cost(ifelse($1, `TrailingZerosV', `3 * ', `')INSN_COST);\n+  format %{ \"count$1 $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);dnl\n+ifelse($1, `TrailingZerosV', `\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);', `')\n+    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl CLTZ_X($1     )\n+dnl CLTZ_X(op_name)\n+define(`CLTZ_X', `\n+instruct count$1X(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (Count$1 src));\n+  ins_cost(ifelse($1, `TrailingZerosV', `3 * ', `')INSN_COST);\n+  format %{ \"count$1 $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);dnl\n+ifelse($1, `TrailingZerosV', `\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);', `')\n+    if (bt != T_LONG) {\n+      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg));\n+    } else {\n+      __ umov(rscratch1, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg), __ D, 0);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n+      __ umov(rscratch1, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg), __ D, 1);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/------------------------- CountLeadingZerosV -----------------------------\n+CLTZ_D(LeadingZerosV)\n+CLTZ_X(LeadingZerosV)\n+\n+\/\/------------------------- CountTrailingZerosV ----------------------------\n+CLTZ_D(TrailingZerosV)\n+CLTZ_X(TrailingZerosV)\n+\n+dnl\n+dnl REVERSE($1,        $2,      $3,   $4  )\n+dnl REVERSE(insn_name, op_name, type, insn)\n+define(`REVERSE', `\n+instruct $1(vec$3 dst, vec$3 src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == ifelse($3, D, 8, 16));\n+  match(Set dst ($2 src));\n+  ins_cost(ifelse($2, `ReverseV', `2 * ', `')INSN_COST);\n+  format %{ \"$2 $dst, $src\\t# vector ($3)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $4(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, ifelse($3, D, false, true));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/------------------------------ ReverseV -----------------------------------\n+REVERSE(vreverseD, ReverseV, D, neon_reverse_bits)\n+REVERSE(vreverseX, ReverseV, X, neon_reverse_bits)\n+\n+\/\/---------------------------- ReverseBytesV --------------------------------\n+REVERSE(vreverseBytesD, ReverseBytesV, D, neon_reverse_bytes)\n+REVERSE(vreverseBytesX, ReverseBytesV, X, neon_reverse_bytes)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":118,"deletions":17,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2201,1 +2201,1 @@\n-\/\/ popcount vector\n+\/\/ vector popcount\n@@ -2204,1 +2204,2 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n@@ -2206,1 +2207,72 @@\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\" %}\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (B\/H\/S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vpopcountL(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector() &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (PopCountVL src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountL\" rule.\n+instruct vpopcountLI(vReg dst, vReg src, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector() &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\n\\t\"\n+            \"sve_dup $vtmp, #0\\n\\t\"\n+            \"sve_uzp1 $dst, $dst, $vtmp\\t# vector (sve) (S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector popcount - predicated\n+\n+instruct vpopcountI_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (PopCountVI dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) (B\/H\/S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_cnt(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n+         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vpopcountL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst_src (PopCountVL dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n@@ -2208,1 +2280,3 @@\n-     __ sve_cnt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg));\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst_src$$reg), __ D,\n+         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n@@ -5456,0 +5530,64 @@\n+\/\/ ---------------------------- Compress\/Expand Operations ---------------------------\n+\n+instruct mcompress(pReg dst, pReg mask, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CompressM mask));\n+  effect(KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cntp rscratch1, $mask\\n\\t\"\n+            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($mask$$reg));\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (CompressV src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_compact(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg), as_PRegister($pg$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressB(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n+                    pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (B)\" %}\n+  ins_encode %{\n+    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n+                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n+                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(38 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (H)\" %}\n+  ins_encode %{\n+    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5469,0 +5607,144 @@\n+\n+\/\/ ------------------------------ CountLeadingZerosV ------------------------------\n+\n+instruct vcountLeadingZeros(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountLeadingZerosV src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_clz $dst, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_clz(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vcountLeadingZeros_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (CountLeadingZerosV dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_clz $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_clz(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ CountTrailingZerosV -----------------------------\n+\n+instruct vcountTrailingZeros(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountTrailingZerosV src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_rbit $dst, $src\\n\\t\"\n+            \"sve_clz  $dst, $dst\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n+    __ sve_clz(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vcountTrailingZeros_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (CountTrailingZerosV dst_src pg));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_rbit $dst_src, $pg, $dst_src\\n\\t\"\n+            \"sve_clz  $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+    __ sve_clz(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ---------------------------------- ReverseV ------------------------------------\n+\n+instruct vreverse(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseV src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_rbit $dst, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vreverse_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (ReverseV dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_rbit $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ -------------------------------- ReverseBytesV ---------------------------------\n+\n+instruct vreverseBytes(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseBytesV src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_revb $dst, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    if (bt == T_BYTE) {\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+    } else {\n+      __ sve_revb(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vreverseBytes_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (ReverseBytesV dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_revb $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    if (bt == T_BYTE) {\n+      \/\/ do nothing\n+    } else {\n+      __ sve_revb(as_FloatRegister($dst_src$$reg), size,\n+          as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":286,"deletions":4,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -1174,1 +1174,24 @@\n-\/\/ popcount vector\n+dnl\n+dnl VPOPCOUNT($1,          $2  )\n+dnl VPOPCOUNT(name_suffix, size)\n+define(`VPOPCOUNT', `\n+instruct vpopcount$1(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector()`'ifelse($1, `L', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n+  match(Set dst (PopCountV$1 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) ($2)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");dnl\n+ifelse($1, `I', `\n+    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n+    __ sve_cnt(as_FloatRegister($dst$$reg), ifelse($1, `I', `__ elemType_to_regVariant(bt)', `__ D'),\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector popcount\n+VPOPCOUNT(I, B\/H\/S)\n+VPOPCOUNT(L, D)\n@@ -1176,4 +1199,14 @@\n-instruct vpopcountI(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (PopCountVI src));\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\" %}\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountL\" rule.\n+instruct vpopcountLI(vReg dst, vReg src, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector() &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\n\\t\"\n+            \"sve_dup $vtmp, #0\\n\\t\"\n+            \"sve_uzp1 $dst, $dst, $vtmp\\t# vector (sve) (S)\" %}\n@@ -1181,1 +1214,5 @@\n-     __ sve_cnt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg));\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($vtmp$$reg));\n@@ -1186,0 +1223,23 @@\n+dnl\n+dnl VPOPCOUNT_PREDICATE($1,          $2  )\n+dnl VPOPCOUNT_PREDICATE(name_suffix, size)\n+define(`VPOPCOUNT_PREDICATE', `\n+instruct vpopcount$1_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0`'ifelse($1, `L', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n+  match(Set dst_src (PopCountV$1 dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) ($2)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");dnl\n+ifelse($1, `I', `\n+    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n+    __ sve_cnt(as_FloatRegister($dst_src$$reg), ifelse($1, `I', `__ elemType_to_regVariant(bt)', `__ D'),\n+         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\/\/ vector popcount - predicated\n+VPOPCOUNT_PREDICATE(I, B\/H\/S)\n+VPOPCOUNT_PREDICATE(L, D)\n+\n@@ -3009,0 +3069,64 @@\n+\/\/ ---------------------------- Compress\/Expand Operations ---------------------------\n+\n+instruct mcompress(pReg dst, pReg mask, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CompressM mask));\n+  effect(KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cntp rscratch1, $mask\\n\\t\"\n+            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($mask$$reg));\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (CompressV src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_compact(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg), as_PRegister($pg$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressB(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n+                    pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (B)\" %}\n+  ins_encode %{\n+    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n+                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n+                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg mask, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src mask));\n+  ins_cost(38 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $mask\\t# vector compress (H)\" %}\n+  ins_encode %{\n+    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($mask$$reg),\n+                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3022,0 +3146,76 @@\n+\n+dnl\n+dnl BITWISE_UNARY($1,        $2,      $3  )\n+dnl BITWISE_UNARY(insn_name, op_name, insn)\n+define(`BITWISE_UNARY', `\n+instruct $1(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst ($2 src));\n+  ins_cost(ifelse($2, `CountTrailingZerosV', `2 * ', `')SVE_COST);\n+  format %{ ifelse($2, `CountTrailingZerosV', `\"sve_rbit $dst, $src\\n\\t\"\n+            \"$3  $dst, $dst', `\"$3 $dst, $src')\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);dnl\n+ifelse($2, `CountTrailingZerosV', `\n+    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));', `')dnl\n+ifelse($2, `ReverseBytesV', `\n+    if (bt == T_BYTE) {\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+    } else {\n+      __ $3(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n+    }', `\n+    __ $3(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($ifelse($2, `CountTrailingZerosV', dst, src)$$reg));')\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl BITWISE_UNARY_PREDICATE($1,        $2,      $3  )\n+dnl BITWISE_UNARY_PREDICATE(insn_name, op_name, insn)\n+define(`BITWISE_UNARY_PREDICATE', `\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct $1_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($2 dst_src pg));\n+  ins_cost(ifelse($2, `CountTrailingZerosV', `2 * ', `')SVE_COST);\n+  format %{ ifelse($2, `CountTrailingZerosV', `\"sve_rbit $dst_src, $pg, $dst_src\\n\\t\"\n+            \"$3  $dst_src, $pg, $dst_src', `\"$3 $dst_src, $pg, $dst_src')\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);dnl\n+ifelse($2, `CountTrailingZerosV', `\n+    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));', `')dnl\n+ifelse($2, `ReverseBytesV', `\n+    if (bt == T_BYTE) {\n+      \/\/ do nothing\n+    } else {\n+      __ $3(as_FloatRegister($dst_src$$reg), size,\n+          as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+    }', `\n+    __ $3(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));')\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ CountLeadingZerosV ------------------------------\n+BITWISE_UNARY(vcountLeadingZeros, CountLeadingZerosV, sve_clz)\n+BITWISE_UNARY_PREDICATE(vcountLeadingZeros, CountLeadingZerosV, sve_clz)\n+\n+\/\/ ------------------------------ CountTrailingZerosV -----------------------------\n+BITWISE_UNARY(vcountTrailingZeros, CountTrailingZerosV, sve_clz)\n+BITWISE_UNARY_PREDICATE(vcountTrailingZeros, CountTrailingZerosV, sve_clz)\n+\n+\/\/ ---------------------------------- ReverseV ------------------------------------\n+BITWISE_UNARY(vreverse, ReverseV, sve_rbit)\n+BITWISE_UNARY_PREDICATE(vreverse, ReverseV, sve_rbit)\n+\n+\/\/ -------------------------------- ReverseBytesV ---------------------------------\n+BITWISE_UNARY(vreverseBytes, ReverseBytesV, sve_revb)\n+BITWISE_UNARY_PREDICATE(vreverseBytes, ReverseBytesV, sve_revb)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":206,"deletions":6,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -3119,0 +3119,1 @@\n+  INSN(sve_clz,  0b00000100, 0b011001101); \/\/ vector count leading zero bits\n@@ -3736,1 +3737,15 @@\n-  \/\/ SVE create index starting from and incremented by immediate\n+\/\/ SVE reverse within elements\n+#define INSN(NAME, opc, cond)                                                        \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg,  FloatRegister Zn) {  \\\n+    starti;                                                                          \\\n+    assert(cond, \"invalid size\");                                                    \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1001, 21, 18), f(opc, 17, 16);          \\\n+    f(0b100, 15, 13), pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);                            \\\n+  }\n+\n+  INSN(sve_revb, 0b00, T == H || T == S || T == D);\n+  INSN(sve_rbit, 0b11, T != Q);\n+#undef INSN\n+\n+  \/\/ SVE Index Generation:\n+  \/\/ Create index starting from and incremented by immediate\n@@ -3739,0 +3754,1 @@\n+    assert(T != Q, \"invalid size\");\n@@ -3744,0 +3760,10 @@\n+  \/\/ SVE Index Generation:\n+  \/\/ Create index starting from general-purpose register and incremented by immediate\n+  void sve_index(FloatRegister Zd, SIMD_RegVariant T, Register Rn, int imm) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000100, 31, 24), f(T, 23, 22), f(0b1, 21);\n+    sf(imm, 20, 16), f(0b010001, 15, 10);\n+    zrf(Rn, 5), rf(Zd, 0);\n+  }\n+\n@@ -3752,0 +3778,8 @@\n+  \/\/ Shuffle active elements of vector to the right and fill with zero\n+  void sve_compact(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, PRegister Pg) {\n+    starti;\n+    assert(T == S || T == D, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b100001100, 21, 13);\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -106,0 +106,16 @@\n+  \/\/ Pack active elements of src, under the control of mask, into the\n+  \/\/ lowest-numbered elements of dst. Any remaining elements of dst will\n+  \/\/ be filled with zero.\n+  void sve_compress_byte(FloatRegister dst, FloatRegister src, PRegister mask,\n+                         FloatRegister vtmp1, FloatRegister vtmp2,\n+                         FloatRegister vtmp3, FloatRegister vtmp4,\n+                         PRegister ptmp, PRegister pgtmp);\n+\n+  void sve_compress_short(FloatRegister dst, FloatRegister src, PRegister mask,\n+                          FloatRegister vtmp1, FloatRegister vtmp2,\n+                          PRegister pgtmp);\n+\n+  void neon_reverse_bits(FloatRegister dst, FloatRegister src, BasicType bt, bool isQ);\n+\n+  void neon_reverse_bytes(FloatRegister dst, FloatRegister src, BasicType bt, bool isQ);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4883,1 +4883,27 @@\n-void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {\n+void Assembler::evpopcntb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_bitalg(), \"must support avx512bitalg feature\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x54, (0xC0 | encode));\n+}\n+\n+void Assembler::evpopcntw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_bitalg(), \"must support avx512bitalg feature\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x54, (0xC0 | encode));\n+}\n+\n+void Assembler::evpopcntd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n@@ -4885,1 +4911,2 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -4887,0 +4914,4 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n@@ -4891,1 +4922,1 @@\n-void Assembler::vpopcntq(XMMRegister dst, XMMRegister src, int vector_len) {\n+void Assembler::evpopcntq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n@@ -4893,1 +4924,2 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -4895,0 +4927,4 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n@@ -7975,0 +8011,78 @@\n+void Assembler::evexpandps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x88, (0xC0 | encode));\n+}\n+\n+void Assembler::evexpandpd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x88, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x62, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x62, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x89, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x89, (0xC0 | encode));\n+}\n+\n@@ -8018,1 +8132,1 @@\n-  assert(VM_Version::supports_avx(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -8077,1 +8191,1 @@\n-  assert(VM_Version::supports_avx2(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -8090,1 +8204,1 @@\n-  assert(VM_Version::supports_avx(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -9907,0 +10021,8 @@\n+void Assembler::vgf2p8affineqb(XMMRegister dst, XMMRegister src2, XMMRegister src3, int imm8, int vector_len) {\n+  assert(VM_Version::supports_gfni(), \"requires GFNI support\");\n+  assert(VM_Version::supports_sse(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src3->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0xCE, (unsigned char)(0xC0 | encode), imm8);\n+}\n+\n@@ -11600,0 +11722,73 @@\n+\n+void Assembler::evpcompressb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x63, (0xC0 | encode));\n+}\n+\n+void Assembler::evpcompressw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x63, (0xC0 | encode));\n+}\n+\n+void Assembler::evpcompressd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8B, (0xC0 | encode));\n+}\n+\n+void Assembler::evpcompressq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8B, (0xC0 | encode));\n+}\n+\n+void Assembler::evcompressps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8A, (0xC0 | encode));\n+}\n+\n+void Assembler::evcompresspd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8A, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":202,"deletions":7,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -1873,2 +1873,4 @@\n-  void vpopcntd(XMMRegister dst, XMMRegister src, int vector_len);\n-  void vpopcntq(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evpopcntb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n@@ -2201,2 +2203,1 @@\n-  void pdep(Register dst, Register src1, Register src2);\n-\n+  void pdep(Register dst, Register src1, Register src2);\n@@ -2576,0 +2577,15 @@\n+  \/\/ Vector compress\/expand instructions.\n+  void evpcompressb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpcompressw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpcompressd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpcompressq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evcompressps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evcompresspd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+\n+  void evpexpandb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpexpandw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpexpandd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpexpandq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evexpandps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evexpandpd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+\n@@ -2732,0 +2748,4 @@\n+\n+  \/\/ Galois field affine transformation instructions.\n+  void vgf2p8affineqb(XMMRegister dst, XMMRegister src2, XMMRegister src3, int imm8, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -4421,0 +4421,65 @@\n+\n+void C2_MacroAssembler::vector_mask_compress(KRegister dst, KRegister src, Register rtmp1,\n+                                             Register rtmp2, int mask_len) {\n+  kmov(rtmp1, src);\n+  andq(rtmp1, (0xFFFFFFFFFFFFFFFFUL >> (64 - mask_len)));\n+  mov64(rtmp2, -1L);\n+  pext(rtmp2, rtmp2, rtmp1);\n+  kmov(dst, rtmp2);\n+}\n+\n+void C2_MacroAssembler::vector_compress_expand(int opcode, XMMRegister dst, XMMRegister src, KRegister mask,\n+                                               bool merge, BasicType bt, int vec_enc) {\n+  if (opcode == Op_CompressV) {\n+    switch(bt) {\n+    case T_BYTE:\n+      evpcompressb(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      evpcompressw(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_INT:\n+      evpcompressd(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_FLOAT:\n+      evcompressps(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_LONG:\n+      evpcompressq(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_DOUBLE:\n+      evcompresspd(dst, mask, src, merge, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type\");\n+      break;\n+    }\n+  } else {\n+    assert(opcode == Op_ExpandV, \"\");\n+    switch(bt) {\n+    case T_BYTE:\n+      evpexpandb(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      evpexpandw(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_INT:\n+      evpexpandd(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_FLOAT:\n+      evexpandps(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_LONG:\n+      evpexpandq(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_DOUBLE:\n+      evexpandpd(dst, mask, src, merge, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type\");\n+      break;\n+    }\n+  }\n+}\n@@ -4442,0 +4507,10 @@\n+void C2_MacroAssembler::vbroadcastd(XMMRegister dst, int imm32, Register rtmp, int vec_enc) {\n+  if (VM_Version::supports_avx512vl()) {\n+    movl(rtmp, imm32);\n+    evpbroadcastd(dst, rtmp, vec_enc);\n+  } else {\n+    movl(rtmp, imm32);\n+    movdl(dst, rtmp);\n+    vpbroadcastd(dst, dst, vec_enc);\n+  }\n+}\n@@ -4472,0 +4547,14 @@\n+\n+void C2_MacroAssembler::vector_popcount_byte(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                             XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  assert((vec_enc == Assembler::AVX_512bit && VM_Version::supports_avx512bw()) || VM_Version::supports_avx2(), \"\");\n+  vbroadcastd(xtmp1, 0x0F0F0F0F, rtmp, vec_enc);\n+  vpsrlw(dst, src, 4, vec_enc);\n+  vpand(dst, dst, xtmp1, vec_enc);\n+  vpand(xtmp1, src, xtmp1, vec_enc);\n+  vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), rtmp, vec_enc);\n+  vpshufb(xtmp1, xtmp2, xtmp1, vec_enc);\n+  vpshufb(dst, xtmp2, dst, vec_enc);\n+  vpaddb(dst, dst, xtmp1, vec_enc);\n+}\n+\n@@ -4473,27 +4562,19 @@\n-                                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n-                                            int vec_enc) {\n-  if (VM_Version::supports_avx512_vpopcntdq()) {\n-    vpopcntd(dst, src, vec_enc);\n-  } else {\n-    assert((vec_enc == Assembler::AVX_512bit && VM_Version::supports_avx512bw()) || VM_Version::supports_avx2(), \"\");\n-    movl(rtmp, 0x0F0F0F0F);\n-    movdl(xtmp1, rtmp);\n-    vpbroadcastd(xtmp1, xtmp1, vec_enc);\n-    if (Assembler::AVX_512bit == vec_enc) {\n-      evmovdqul(xtmp2, k0, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), false, vec_enc, rtmp);\n-    } else {\n-      vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), rtmp);\n-    }\n-    vpand(xtmp3, src, xtmp1, vec_enc);\n-    vpshufb(xtmp3, xtmp2, xtmp3, vec_enc);\n-    vpsrlw(dst, src, 4, vec_enc);\n-    vpand(dst, dst, xtmp1, vec_enc);\n-    vpshufb(dst, xtmp2, dst, vec_enc);\n-    vpaddb(xtmp3, dst, xtmp3, vec_enc);\n-    vpxor(xtmp1, xtmp1, xtmp1, vec_enc);\n-    vpunpckhdq(dst, xtmp3, xtmp1, vec_enc);\n-    vpsadbw(dst, dst, xtmp1, vec_enc);\n-    vpunpckldq(xtmp2, xtmp3, xtmp1, vec_enc);\n-    vpsadbw(xtmp2, xtmp2, xtmp1, vec_enc);\n-    vpackuswb(dst, xtmp2, dst, vec_enc);\n-  }\n+                                            XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n+  \/\/ Following code is as per steps e,f,g and h of above algorithm.\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  vpunpckhdq(dst, xtmp1, xtmp2, vec_enc);\n+  vpsadbw(dst, dst, xtmp2, vec_enc);\n+  vpunpckldq(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpsadbw(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpackuswb(dst, xtmp1, dst, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_popcount_short(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                              XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n+  \/\/ Add the popcount of upper and lower bytes of word.\n+  vbroadcastd(xtmp2, 0x00FF00FF, rtmp, vec_enc);\n+  vpsrlw(dst, xtmp1, 8, vec_enc);\n+  vpand(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpaddw(dst, dst, xtmp1, vec_enc);\n@@ -4503,23 +4584,49 @@\n-                                             XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n-                                             int vec_enc) {\n-  if (VM_Version::supports_avx512_vpopcntdq()) {\n-    vpopcntq(dst, src, vec_enc);\n-  } else if (vec_enc == Assembler::AVX_512bit) {\n-    assert(VM_Version::supports_avx512bw(), \"\");\n-    movl(rtmp, 0x0F0F0F0F);\n-    movdl(xtmp1, rtmp);\n-    vpbroadcastd(xtmp1, xtmp1, vec_enc);\n-    evmovdqul(xtmp2, k0, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), true, vec_enc, rtmp);\n-    vpandq(xtmp3, src, xtmp1, vec_enc);\n-    vpshufb(xtmp3, xtmp2, xtmp3, vec_enc);\n-    vpsrlw(dst, src, 4, vec_enc);\n-    vpandq(dst, dst, xtmp1, vec_enc);\n-    vpshufb(dst, xtmp2, dst, vec_enc);\n-    vpaddb(xtmp3, dst, xtmp3, vec_enc);\n-    vpxorq(xtmp1, xtmp1, xtmp1, vec_enc);\n-    vpsadbw(dst, xtmp3, xtmp1, vec_enc);\n-  } else {\n-    \/\/ We do not see any performance benefit of running\n-    \/\/ above instruction sequence on 256 bit vector which\n-    \/\/ can operate over maximum 4 long elements.\n-    ShouldNotReachHere();\n+                                             XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  vpsadbw(dst, xtmp1, xtmp2, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_popcount_integral(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                 XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  switch(bt) {\n+    case T_INT:\n+      vector_popcount_int(dst, src, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      vector_popcount_short(dst, src, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      vector_popcount_byte(dst, src, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_popcount_integral_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                      KRegister mask, bool merge, int vec_enc) {\n+  assert(VM_Version::supports_avx512vl() || vec_enc == Assembler::AVX_512bit, \"\");\n+  switch(bt) {\n+    case T_LONG:\n+      assert(VM_Version::supports_avx512_vpopcntdq(), \"\");\n+      evpopcntq(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_INT:\n+      assert(VM_Version::supports_avx512_vpopcntdq(), \"\");\n+      evpopcntd(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      assert(VM_Version::supports_avx512_bitalg(), \"\");\n+      evpopcntw(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      assert(VM_Version::supports_avx512_bitalg(), \"\");\n+      evpopcntb(dst, mask, src, merge, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n@@ -4527,1 +4634,0 @@\n-  evpmovqd(dst, dst, vec_enc);\n@@ -4538,0 +4644,154 @@\n+\/\/ Bit reversal algorithm first reverses the bits of each byte followed by\n+\/\/ a byte level reversal for multi-byte primitive types (short\/int\/long).\n+\/\/ Algorithm performs a lookup table access to get reverse bit sequence\n+\/\/ corresponding to a 4 bit value. Thus a reverse bit sequence for a byte\n+\/\/ is obtained by swapping the reverse bit sequences of upper and lower\n+\/\/ nibble of a byte.\n+void C2_MacroAssembler::vector_reverse_bit(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  if (VM_Version::supports_avx512vlbw()) {\n+\n+    \/\/ Get the reverse bit sequence of lower nibble of each byte.\n+    vmovdqu(xtmp1, ExternalAddress(StubRoutines::x86::vector_reverse_bit_lut()), rtmp, vec_enc);\n+    movl(rtmp, 0x0F0F0F0F);\n+    evpbroadcastd(xtmp2, rtmp, vec_enc);\n+    vpandq(dst, xtmp2, src, vec_enc);\n+    vpshufb(dst, xtmp1, dst, vec_enc);\n+    vpsllq(dst, dst, 4, vec_enc);\n+\n+    \/\/ Get the reverse bit sequence of upper nibble of each byte.\n+    vpandn(xtmp2, xtmp2, src, vec_enc);\n+    vpsrlq(xtmp2, xtmp2, 4, vec_enc);\n+    vpshufb(xtmp2, xtmp1, xtmp2, vec_enc);\n+\n+    \/\/ Perform logical OR operation b\/w left shifted reverse bit sequence of lower nibble and\n+    \/\/ right shifted reverse bit sequence of upper nibble to obtain the reverse bit sequence of each byte.\n+    vporq(xtmp2, dst, xtmp2, vec_enc);\n+    vector_reverse_byte(bt, dst, xtmp2, rtmp, vec_enc);\n+\n+  } else if(!VM_Version::supports_avx512vlbw() && vec_enc == Assembler::AVX_512bit) {\n+\n+    \/\/ Shift based bit reversal.\n+    assert(bt == T_LONG || bt == T_INT, \"\");\n+    movl(rtmp, 0x0f0f0f0f);\n+    evpbroadcastd(xtmp1, rtmp, vec_enc);\n+\n+    \/\/ Swap lower and upper nibble of each byte.\n+    vpandq(dst, xtmp1, src, vec_enc);\n+    vpsllq(dst, dst, 4, vec_enc);\n+    vpandn(xtmp2, xtmp1, src, vec_enc);\n+    vpsrlq(xtmp2, xtmp2, 4, vec_enc);\n+    vporq(xtmp1, dst, xtmp2, vec_enc);\n+\n+    \/\/ Swap two least and most significant bits of each nibble.\n+    movl(rtmp, 0x33333333);\n+    evpbroadcastd(xtmp2, rtmp, vec_enc);\n+    vpandq(dst, xtmp2, xtmp1, vec_enc);\n+    vpsllq(dst, dst, 2, vec_enc);\n+    vpandn(xtmp2, xtmp2, xtmp1, vec_enc);\n+    vpsrlq(xtmp2, xtmp2, 2, vec_enc);\n+    vporq(xtmp1, dst, xtmp2, vec_enc);\n+\n+    \/\/ Swap adjacent pair of bits.\n+    movl(rtmp, 0x55555555);\n+    evpbroadcastd(xtmp2, rtmp, vec_enc);\n+    vpandq(dst, xtmp2, xtmp1, vec_enc);\n+    vpsllq(dst, dst, 1, vec_enc);\n+    vpandn(xtmp2, xtmp2, xtmp1, vec_enc);\n+    vpsrlq(xtmp2, xtmp2, 1, vec_enc);\n+    vporq(xtmp1, dst, xtmp2, vec_enc);\n+\n+    vector_reverse_byte64(bt, dst, xtmp1, xtmp1, xtmp2, rtmp, vec_enc);\n+\n+  } else {\n+    vmovdqu(xtmp1, ExternalAddress(StubRoutines::x86::vector_reverse_bit_lut()), rtmp, vec_enc);\n+    movl(rtmp, 0x0F0F0F0F);\n+    movdl(xtmp2, rtmp);\n+    vpbroadcastd(xtmp2, xtmp2, vec_enc);\n+\n+    \/\/ Get the reverse bit sequence of lower nibble of each byte.\n+    vpand(dst, xtmp2, src, vec_enc);\n+    vpshufb(dst, xtmp1, dst, vec_enc);\n+    vpsllq(dst, dst, 4, vec_enc);\n+\n+    \/\/ Get the reverse bit sequence of upper nibble of each byte.\n+    vpandn(xtmp2, xtmp2, src, vec_enc);\n+    vpsrlq(xtmp2, xtmp2, 4, vec_enc);\n+    vpshufb(xtmp2, xtmp1, xtmp2, vec_enc);\n+\n+    \/\/ Perform logical OR operation b\/w left shifted reverse bit sequence of lower nibble and\n+    \/\/ right shifted reverse bit sequence of upper nibble to obtain the reverse bit sequence of each byte.\n+    vpor(xtmp2, dst, xtmp2, vec_enc);\n+    vector_reverse_byte(bt, dst, xtmp2, rtmp, vec_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_reverse_bit_gfni(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                XMMRegister xtmp, AddressLiteral mask, Register rtmp, int vec_enc) {\n+  \/\/ Galois field instruction based bit reversal based on following algorithm.\n+  \/\/ http:\/\/0x80.pl\/articles\/avx512-galois-field-for-bit-shuffling.html\n+  assert(VM_Version::supports_gfni(), \"\");\n+  vpbroadcastq(xtmp, mask, vec_enc, rtmp);\n+  vgf2p8affineqb(xtmp, src, xtmp, 0, vec_enc);\n+  vector_reverse_byte(bt, dst, xtmp, rtmp, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_reverse_byte64(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                              XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  \/\/ Shift based bit reversal.\n+  assert(VM_Version::supports_evex(), \"\");\n+  evmovdqul(xtmp1, k0, src, true, vec_enc);\n+  switch(bt) {\n+    case T_LONG:\n+      \/\/ Swap upper and lower double word of each quad word.\n+      evprorq(xtmp1, k0, xtmp1, 32, true, vec_enc);\n+    case T_INT:\n+      \/\/ Swap upper and lower word of each double word.\n+      evprord(xtmp1, k0, xtmp1, 16, true, vec_enc);\n+    case T_SHORT:\n+      \/\/ Swap upper and lower byte of each word.\n+      movl(rtmp, 0x00FF00FF);\n+      evpbroadcastd(dst, rtmp, vec_enc);\n+      vpandq(xtmp2, dst, xtmp1, vec_enc);\n+      vpsllq(xtmp2, xtmp2, 8, vec_enc);\n+      vpandn(xtmp1, dst, xtmp1, vec_enc);\n+      vpsrlq(dst, xtmp1, 8, vec_enc);\n+      vporq(dst, dst, xtmp2, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evmovdquq(dst, k0, src, true, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type\");\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_reverse_byte(BasicType bt, XMMRegister dst, XMMRegister src, Register rtmp, int vec_enc) {\n+  if (bt == T_BYTE) {\n+    if (VM_Version::supports_avx512vl() || vec_enc == Assembler::AVX_512bit) {\n+      evmovdquq(dst, k0, src, true, vec_enc);\n+    } else {\n+      vmovdqu(dst, src);\n+    }\n+    return;\n+  }\n+  \/\/ Perform byte reversal by shuffling the bytes of a multi-byte primitive type using\n+  \/\/ pre-computed shuffle indices.\n+  switch(bt) {\n+    case T_LONG:\n+      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_long()), rtmp, vec_enc);\n+      break;\n+    case T_INT:\n+      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_int()), rtmp, vec_enc);\n+      break;\n+    case T_SHORT:\n+      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_short()), rtmp, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type\");\n+      break;\n+  }\n+  vpshufb(dst, src, dst, vec_enc);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":311,"deletions":51,"binary":false,"changes":362,"status":"modified"},{"patch":"@@ -91,0 +91,5 @@\n+  void vector_compress_expand(int opcode, XMMRegister dst, XMMRegister src, KRegister mask,\n+                              bool merge, BasicType bt, int vec_enc);\n+\n+  void vector_mask_compress(KRegister dst, KRegister src, Register rtmp1, Register rtmp2, int mask_len);\n+\n@@ -343,0 +348,8 @@\n+  void vector_reverse_bit(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                          XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_reverse_bit_gfni(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp,\n+                               AddressLiteral mask, Register rtmp, int vec_enc);\n+\n+  void vector_reverse_byte(BasicType bt, XMMRegister dst, XMMRegister src, Register rtmp, int vec_enc);\n+\n@@ -347,1 +360,1 @@\n-  #ifdef _LP64\n+#ifdef _LP64\n@@ -351,1 +364,2 @@\n-  #endif\n+#endif\n+\n@@ -353,2 +367,1 @@\n-                           XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n-                           int vec_enc);\n+                           XMMRegister xtmp2, Register rtmp, int vec_enc);\n@@ -357,2 +370,19 @@\n-                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n-                            int vec_enc);\n+                            XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_popcount_short(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                             XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_popcount_byte(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                            XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_popcount_integral(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_popcount_integral_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                     KRegister mask, bool merge, int vec_enc);\n+\n+  void vbroadcastd(XMMRegister dst, int imm32, Register rtmp, int vec_enc);\n+\n+  void vector_reverse_byte64(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                             XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2535,2 +2535,4 @@\n-  assert(vector_len <= AVX_256bit, \"AVX2 vector length\");\n-  if (vector_len == AVX_256bit) {\n+  assert(vector_len <= AVX_512bit, \"unexpected vector length\");\n+  if (vector_len == AVX_512bit) {\n+    evmovdquq(dst, src, AVX_512bit, scratch_reg);\n+  } else if (vector_len == AVX_256bit) {\n@@ -3148,0 +3150,9 @@\n+void MacroAssembler::vpbroadcastq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {\n+  if (reachable(src)) {\n+    Assembler::vpbroadcastq(dst, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vpbroadcastq(dst, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1318,0 +1318,5 @@\n+  void vpbroadcastq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n+  void vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::vpbroadcastq(dst, src, vector_len); }\n+  void vpbroadcastq(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastq(dst, src, vector_len); }\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -638,0 +638,92 @@\n+  address generate_vector_reverse_bit_lut(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x0C040800, relocInfo::none, 0);\n+    __ emit_data(0x0E060A02, relocInfo::none, 0);\n+    __ emit_data(0x0D050901, relocInfo::none, 0);\n+    __ emit_data(0x0F070B03, relocInfo::none, 0);\n+    __ emit_data(0x0C040800, relocInfo::none, 0);\n+    __ emit_data(0x0E060A02, relocInfo::none, 0);\n+    __ emit_data(0x0D050901, relocInfo::none, 0);\n+    __ emit_data(0x0F070B03, relocInfo::none, 0);\n+    __ emit_data(0x0C040800, relocInfo::none, 0);\n+    __ emit_data(0x0E060A02, relocInfo::none, 0);\n+    __ emit_data(0x0D050901, relocInfo::none, 0);\n+    __ emit_data(0x0F070B03, relocInfo::none, 0);\n+    __ emit_data(0x0C040800, relocInfo::none, 0);\n+    __ emit_data(0x0E060A02, relocInfo::none, 0);\n+    __ emit_data(0x0D050901, relocInfo::none, 0);\n+    __ emit_data(0x0F070B03, relocInfo::none, 0);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_long(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_int(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_short(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x02030001, relocInfo::none, 0);\n+    __ emit_data(0x06070405, relocInfo::none, 0);\n+    __ emit_data(0x0A0B0809, relocInfo::none, 0);\n+    __ emit_data(0x0E0F0C0D, relocInfo::none, 0);\n+    __ emit_data(0x02030001, relocInfo::none, 0);\n+    __ emit_data(0x06070405, relocInfo::none, 0);\n+    __ emit_data(0x0A0B0809, relocInfo::none, 0);\n+    __ emit_data(0x0E0F0C0D, relocInfo::none, 0);\n+    __ emit_data(0x02030001, relocInfo::none, 0);\n+    __ emit_data(0x06070405, relocInfo::none, 0);\n+    __ emit_data(0x0A0B0809, relocInfo::none, 0);\n+    __ emit_data(0x0E0F0C0D, relocInfo::none, 0);\n+    __ emit_data(0x02030001, relocInfo::none, 0);\n+    __ emit_data(0x06070405, relocInfo::none, 0);\n+    __ emit_data(0x0A0B0809, relocInfo::none, 0);\n+    __ emit_data(0x0E0F0C0D, relocInfo::none, 0);\n+    return start;\n+  }\n+\n@@ -3988,0 +4080,4 @@\n+    StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut(\"reverse_bit_lut\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long(\"perm_mask_long\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int(\"perm_mask_int\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short(\"perm_mask_short\");\n@@ -3989,1 +4085,1 @@\n-    if (UsePopCountInstruction && VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n+    if (VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":97,"deletions":1,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -828,0 +828,60 @@\n+  address generate_vector_reverse_bit_lut(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0E060A020C040800, relocInfo::none);\n+    __ emit_data64(0x0F070B030D050901, relocInfo::none);\n+    __ emit_data64(0x0E060A020C040800, relocInfo::none);\n+    __ emit_data64(0x0F070B030D050901, relocInfo::none);\n+    __ emit_data64(0x0E060A020C040800, relocInfo::none);\n+    __ emit_data64(0x0F070B030D050901, relocInfo::none);\n+    __ emit_data64(0x0E060A020C040800, relocInfo::none);\n+    __ emit_data64(0x0F070B030D050901, relocInfo::none);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_long(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0001020304050607, relocInfo::none);\n+    __ emit_data64(0x08090A0B0C0D0E0F, relocInfo::none);\n+    __ emit_data64(0x0001020304050607, relocInfo::none);\n+    __ emit_data64(0x08090A0B0C0D0E0F, relocInfo::none);\n+    __ emit_data64(0x0001020304050607, relocInfo::none);\n+    __ emit_data64(0x08090A0B0C0D0E0F, relocInfo::none);\n+    __ emit_data64(0x0001020304050607, relocInfo::none);\n+    __ emit_data64(0x08090A0B0C0D0E0F, relocInfo::none);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_int(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0405060700010203, relocInfo::none);\n+    __ emit_data64(0x0C0D0E0F08090A0B, relocInfo::none);\n+    __ emit_data64(0x0405060700010203, relocInfo::none);\n+    __ emit_data64(0x0C0D0E0F08090A0B, relocInfo::none);\n+    __ emit_data64(0x0405060700010203, relocInfo::none);\n+    __ emit_data64(0x0C0D0E0F08090A0B, relocInfo::none);\n+    __ emit_data64(0x0405060700010203, relocInfo::none);\n+    __ emit_data64(0x0C0D0E0F08090A0B, relocInfo::none);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_short(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0607040502030001, relocInfo::none);\n+    __ emit_data64(0x0E0F0C0D0A0B0809, relocInfo::none);\n+    __ emit_data64(0x0607040502030001, relocInfo::none);\n+    __ emit_data64(0x0E0F0C0D0A0B0809, relocInfo::none);\n+    __ emit_data64(0x0607040502030001, relocInfo::none);\n+    __ emit_data64(0x0E0F0C0D0A0B0809, relocInfo::none);\n+    __ emit_data64(0x0607040502030001, relocInfo::none);\n+    __ emit_data64(0x0E0F0C0D0A0B0809, relocInfo::none);\n+    return start;\n+  }\n+\n@@ -7682,0 +7742,4 @@\n+    StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut(\"reverse_bit_lut\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long(\"perm_mask_long\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int(\"perm_mask_int\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short(\"perm_mask_short\");\n@@ -7683,1 +7747,1 @@\n-    if (UsePopCountInstruction && VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n+    if (VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":65,"deletions":1,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1408,1 +1408,1 @@\n-      if (!UsePopCountInstruction || (UseAVX < 2)) {\n+      if (UseAVX < 2) {\n@@ -1413,1 +1413,1 @@\n-      if (!UsePopCountInstruction || (UseAVX <= 2)) {\n+      if (UseAVX < 2) {\n@@ -1628,0 +1628,11 @@\n+    case Op_CompressM:\n+      if (!VM_Version::supports_avx512vl() || !VM_Version::supports_bmi2()) {\n+        return false;\n+      }\n+      break;\n+    case Op_CompressV:\n+    case Op_ExpandV:\n+      if (!VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -1649,0 +1660,5 @@\n+static inline bool is_pop_count_instr_target(BasicType bt) {\n+  return (is_subword_type(bt) && VM_Version::supports_avx512_bitalg()) ||\n+         (is_non_subword_integral_type(bt) && VM_Version::supports_avx512_vpopcntdq());\n+}\n+\n@@ -1854,1 +1870,1 @@\n-      if(is_subword_type(bt)) {\n+      if (is_subword_type(bt)) {\n@@ -1881,0 +1897,17 @@\n+    case Op_CompressM:\n+      if (UseAVX < 3 || !VM_Version::supports_bmi2()) {\n+        return false;\n+      }\n+      break;\n+    case Op_CompressV:\n+    case Op_ExpandV:\n+      if (is_subword_type(bt) && !VM_Version::supports_avx512_vbmi2()) {\n+        return false;\n+      }\n+      if (size_in_bits < 128 ) {\n+        return false;\n+      }\n+      if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -1890,3 +1923,5 @@\n-      if (!VM_Version::supports_avx512_vpopcntdq() &&\n-          (vlen == 16) && !VM_Version::supports_avx512bw()) {\n-        return false;\n+    case Op_PopCountVL: {\n+        if (!is_pop_count_instr_target(bt) &&\n+            (size_in_bits == 512) && !VM_Version::supports_avx512bw()) {\n+          return false;\n+        }\n@@ -1895,3 +1930,3 @@\n-    case Op_PopCountVL:\n-      if (!VM_Version::supports_avx512_vpopcntdq() &&\n-          ((vlen <= 4) || ((vlen == 8) && !VM_Version::supports_avx512bw()))) {\n+    case Op_ReverseV:\n+    case Op_ReverseBytesV:\n+      if (UseAVX < 2) {\n@@ -1900,1 +1935,0 @@\n-      break;\n@@ -2045,0 +2079,7 @@\n+    case Op_PopCountVI:\n+    case Op_PopCountVL:\n+      if (!is_pop_count_instr_target(bt)) {\n+        return false;\n+      }\n+      return true;\n+\n@@ -8644,3 +8685,5 @@\n-\n-instruct vpopcountI_popcntd(vec dst, vec src) %{\n-  predicate(VM_Version::supports_avx512_vpopcntdq());\n+instruct vpopcount_integral_reg_evex(vec dst, vec src) %{\n+  predicate((is_subword_type(Matcher::vector_element_basic_type(n->in(1))) &&\n+              VM_Version::supports_avx512_bitalg()) ||\n+             (is_non_subword_integral_type(Matcher::vector_element_basic_type(n->in(1))) &&\n+              VM_Version::supports_avx512_vpopcntdq()));\n@@ -8648,1 +8691,3 @@\n-  format %{ \"vector_popcount_int $dst, $src\\t! vector popcount packedI\" %}\n+  match(Set dst (PopCountVL src));\n+  ins_cost(400);\n+  format %{ \"vector_popcount_integral_evex $dst, $src\" %}\n@@ -8650,3 +8695,10 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_popcount_int($dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg, noreg, vlen_enc);\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_popcount_integral_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, k0, true, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n+      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    }\n@@ -8657,5 +8709,8 @@\n-instruct vpopcountI(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n-  predicate(!VM_Version::supports_avx512_vpopcntdq());\n-  match(Set dst (PopCountVI src));\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, KILL cc);\n-  format %{ \"vector_popcount_int  $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+instruct vpopcount_integral_reg_evex_masked(vec dst, vec src, kReg mask) %{\n+  predicate((is_subword_type(Matcher::vector_element_basic_type(n->in(1))) &&\n+              VM_Version::supports_avx512_bitalg()) ||\n+             (is_non_subword_integral_type(Matcher::vector_element_basic_type(n->in(1))) &&\n+              VM_Version::supports_avx512_vpopcntdq()));\n+  match(Set dst (PopCountVI src mask));\n+  match(Set dst (PopCountVL src mask));\n+  format %{ \"vector_popcount_integral_evex_masked $dst, $src, $mask\" %}\n@@ -8663,4 +8718,5 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_popcount_int($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n-                           $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ evmovdquq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vector_popcount_integral_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $mask$$KRegister, true, vlen_enc);\n@@ -8671,4 +8727,6 @@\n-instruct vpopcountL_popcntd(vec dst, vec src) %{\n-  predicate(VM_Version::supports_avx512_vpopcntdq());\n-  match(Set dst (PopCountVL src));\n-  format %{ \"vector_popcount_long  $dst, $src\\t! vector popcount packedL\" %}\n+instruct vpopcountI_avx_reg(vec dst, vec src, vec xtmp1, vec xtmp2, rRegP rtmp) %{\n+  predicate((!VM_Version::supports_avx512_vpopcntdq() && Matcher::vector_element_basic_type(n->in(1)) == T_INT) ||\n+            (!VM_Version::supports_avx512_bitalg() && is_subword_type(Matcher::vector_element_basic_type(n->in(1)))));\n+  match(Set dst (PopCountVI src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp);\n+  format %{ \"vector_popcount_int  $dst, $src\\t! using $xtmp1, $xtmp2 and $rtmp as TEMP\" %}\n@@ -8676,3 +8734,4 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n-    int vlen_enc = vector_length_encoding(this, $src);\n-    __ vector_popcount_long($dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg, noreg, vlen_enc);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_popcount_integral(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                $xtmp2$$XMMRegister, $rtmp$$Register, vlen_enc);\n@@ -8683,1 +8742,1 @@\n-instruct vpopcountL(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n+instruct vpopcountL_avx_reg(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp) %{\n@@ -8686,1 +8745,1 @@\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, KILL cc);\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp);\n@@ -8689,3 +8748,15 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n-    __ vector_popcount_long($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n-                           $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_popcount_long($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                            $xtmp2$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (bt == T_INT) {\n+      if (VM_Version::supports_avx512vl()) {\n+        __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+      } else {\n+        assert(VM_Version::supports_avx2(), \"\");\n+        __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n+        __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n+      }\n+    }\n@@ -8971,0 +9042,28 @@\n+\n+\/\/ --------------------------------- Compress\/Expand Operations ---------------------------\n+\n+instruct vcompress_expand_reg_evex(vec dst, vec src, kReg mask) %{\n+  match(Set dst (CompressV src mask));\n+  match(Set dst (ExpandV src mask));\n+  format %{ \"vector_compress_expand $dst, $src, $mask\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vector_len = vector_length_encoding(this);\n+    BasicType bt  = Matcher::vector_element_basic_type(this);\n+    __ vector_compress_expand(opcode, $dst$$XMMRegister, $src$$XMMRegister, $mask$$KRegister, false, bt, vector_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcompress_mask_reg_evex(kReg dst, kReg mask, rRegL rtmp1, rRegL rtmp2, rFlagsReg cr) %{\n+  match(Set dst (CompressM mask));\n+  effect(TEMP rtmp1, TEMP rtmp2, KILL cr);\n+  format %{ \"mask_compress_evex $dst, $mask\\t! using $rtmp1 and $rtmp2 as TEMP\" %}\n+  ins_encode %{\n+    assert(this->in(1)->bottom_type()->isa_vectmask(), \"\");\n+    int mask_len = Matcher::vector_length(this);\n+    __ vector_mask_compress($dst$$KRegister, $mask$$KRegister, $rtmp1$$Register, $rtmp2$$Register, mask_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8973,0 +9072,58 @@\n+\/\/ -------------------------------- Bit and Byte Reversal Vector Operations ------------------------\n+\n+instruct vreverse_reg(vec dst, vec src, vec xtmp1, vec xtmp2, rRegI rtmp) %{\n+  predicate(!VM_Version::supports_gfni());\n+  match(Set dst (ReverseV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp);\n+  format %{ \"vector_reverse_bit_evex $dst, $src!\\t using $xtmp1, $xtmp2 and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vec_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_reverse_bit(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                          $xtmp2$$XMMRegister, $rtmp$$Register, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vreverse_reg_gfni(vec dst, vec src, vec xtmp, rRegI rtmp) %{\n+  predicate(VM_Version::supports_gfni());\n+  match(Set dst (ReverseV src));\n+  effect(TEMP dst, TEMP xtmp, TEMP rtmp);\n+  format %{ \"vector_reverse_bit_gfni $dst, $src!\\t using $rtmp and $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int vec_enc = vector_length_encoding(this);\n+    BasicType bt  = Matcher::vector_element_basic_type(this);\n+    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, 0x8040201008040201L, 1));\n+    __ vector_reverse_bit_gfni(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister,\n+                               addr, $rtmp$$Register, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vreverse_byte_reg(vec dst, vec src, rRegI rtmp) %{\n+  predicate(VM_Version::supports_avx512bw() || Matcher::vector_length_in_bytes(n) < 64);\n+  match(Set dst (ReverseBytesV src));\n+  effect(TEMP dst, TEMP rtmp);\n+  format %{ \"vector_reverse_byte $dst, $src!\\t using $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vec_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_reverse_byte(bt, $dst$$XMMRegister, $src$$XMMRegister, $rtmp$$Register, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vreverse_byte64_reg(vec dst, vec src, vec xtmp1, vec xtmp2, rRegI rtmp) %{\n+  predicate(!VM_Version::supports_avx512bw() && Matcher::vector_length_in_bytes(n) == 64);\n+  match(Set dst (ReverseBytesV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp);\n+  format %{ \"vector_reverse_byte $dst, $src!\\t using $xtmp1, $xtmp2 and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vec_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_reverse_byte64(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $rtmp$$Register, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":195,"deletions":38,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -4219,0 +4219,1 @@\n+    \"CompressV\", \"ExpandV\", \"CompressM\",\n@@ -4230,1 +4231,1 @@\n-    \"ReplicateB\",\"ReplicateS\",\"ReplicateI\",\"ReplicateL\",\"ReplicateF\",\"ReplicateD\",\n+    \"ReplicateB\",\"ReplicateS\",\"ReplicateI\",\"ReplicateL\",\"ReplicateF\",\"ReplicateD\", \"ReverseV\", \"ReverseBytesV\",\n@@ -4240,0 +4241,1 @@\n+    \"CountLeadingZerosV\", \"CountTrailingZerosV\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -916,1 +916,1 @@\n-                                     \"I\"                                                                                                       \\\n+                                     \"J\"                                                                                                       \\\n@@ -931,1 +931,1 @@\n-                                            \"I\"                                                                                                \\\n+                                            \"J\"                                                                                                \\\n@@ -943,2 +943,4 @@\n-                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                          \\\n-                                      \"Ljava\/lang\/Object;ILjdk\/internal\/vm\/vector\/VectorSupport$StoreVectorOperation;)\"                        \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                                   \\\n+                                      \"Ljava\/lang\/Object;\"                                                                                     \\\n+                                      \"J\"                                                                                                      \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$StoreVectorOperation;)\"                                           \\\n@@ -958,1 +960,1 @@\n-                                             \"I\"                                                                                               \\\n+                                             \"J\"                                                                                               \\\n@@ -1118,0 +1120,11 @@\n+  do_intrinsic(_VectorComExp, jdk_internal_vm_vector_VectorSupport, vector_comexp_op_name, vector_comexp_op_sig, F_S)                           \\\n+   do_signature(vector_comexp_op_sig, \"(I\"                                                                                                     \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"I\"                                                                                                      \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                          \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;\"                                                      \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$ComExpOperation;)\"                                                \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\")                                                  \\\n+   do_name(vector_comexp_op_name,     \"comExpOp\")                                                                                              \\\n@@ -1226,1 +1239,1 @@\n-  LAST_COMPILER_INLINE = _VectorMaskOp,\n+  LAST_COMPILER_INLINE = _VectorComExp,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -521,0 +521,4 @@\n+  case vmIntrinsics::_VectorComExp:\n+    if (!Matcher::match_rule_supported(Op_CompressM)) return false;\n+    if (!Matcher::match_rule_supported(Op_CompressV)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+macro(ReverseBytesV)\n@@ -78,0 +79,2 @@\n+macro(CompressBits)\n+macro(ExpandBits)\n@@ -156,0 +159,1 @@\n+macro(CountLeadingZerosV)\n@@ -158,0 +162,1 @@\n+macro(CountTrailingZerosV)\n@@ -288,0 +293,3 @@\n+macro(ReverseI)\n+macro(ReverseL)\n+macro(ReverseV)\n@@ -425,0 +433,3 @@\n+macro(CompressV)\n+macro(CompressM)\n+macro(ExpandV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3413,0 +3413,15 @@\n+  case Op_ReverseBytesV:\n+  case Op_ReverseV: {\n+    if ((uint)n->in(1)->Opcode() == nop) {\n+      if (n->is_predicated_vector() && n->in(1)->is_predicated_vector() &&\n+          n->in(2) == n->in(1)->in(2)) {\n+        \/\/ Node (Node X , Mask) Mask => X\n+        n->subsume_by(n->in(1)->in(1), this);\n+      } else if (!n->is_predicated_using_blend() && !n->in(1)->is_predicated_using_blend()) {\n+        \/\/ Node (Node X) =>  X\n+        n->subsume_by(n->in(1)->in(1), this);\n+      }\n+    }\n+    break;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -700,0 +700,2 @@\n+  case vmIntrinsics::_VectorComExp:\n+    return inline_vector_compress_expand();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -334,0 +334,2 @@\n+  bool inline_vector_compress_expand();\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -982,0 +982,4 @@\n+      case Op_ReverseV: {\n+        const TypeVect* vt = n->bottom_type()->is_vect();\n+        body_size += Matcher::vector_op_pre_select_sz_estimate(n->Opcode(), vt->element_basic_type(), vt->length());\n+      } break;\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -179,0 +179,3 @@\n+class ExpandVNode;\n+class CompressVNode;\n+class CompressMNode;\n@@ -710,0 +713,3 @@\n+        DEFINE_CLASS_ID(CompressV, Vector, 4)\n+        DEFINE_CLASS_ID(ExpandV, Vector, 5)\n+        DEFINE_CLASS_ID(CompressM, Vector, 6)\n@@ -779,5 +785,7 @@\n-    Flag_is_expensive                = 1 << 13,\n-    Flag_is_predicated_vector        = 1 << 14,\n-    Flag_for_post_loop_opts_igvn     = 1 << 15,\n-    Flag_is_removed_by_peephole      = 1 << 16,\n-    _last_flag                       = Flag_is_removed_by_peephole\n+    Flag_has_vector_mask_set         = 1 << 13,\n+    Flag_is_expensive                = 1 << 14,\n+    Flag_is_predicated_vector        = 1 << 15,\n+    Flag_for_post_loop_opts_igvn     = 1 << 16,\n+    Flag_is_removed_by_peephole      = 1 << 17,\n+    Flag_is_predicated_using_blend   = 1 << 18,\n+    _last_flag                       = Flag_is_predicated_using_blend\n@@ -939,1 +947,4 @@\n-  DEFINE_CLASS_QUERY(VectorReinterpret);\n+  DEFINE_CLASS_QUERY(VectorReinterpret)\n+  DEFINE_CLASS_QUERY(CompressV)\n+  DEFINE_CLASS_QUERY(ExpandV)\n+  DEFINE_CLASS_QUERY(CompressM)\n@@ -997,0 +1008,5 @@\n+  bool is_predicated_using_blend() const { return (_flags & Flag_is_predicated_using_blend) != 0; }\n+\n+  \/\/ The node is a CountedLoopEnd with a mask annotation so as to emit a restore context\n+  bool has_vector_mask_set() const { return (_flags & Flag_has_vector_mask_set) != 0; }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -85,1 +85,2 @@\n-      if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, elem_bt)) {\n+      if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, elem_bt) ||\n+          !Matcher::match_rule_supported_vector(Op_LoadVector, num_elem, T_BOOLEAN)) {\n@@ -265,1 +266,2 @@\n-    if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, type)) {\n+    if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, type) ||\n+        !Matcher::match_rule_supported_vector(Op_LoadVector, num_elem, T_BOOLEAN)) {\n@@ -278,1 +280,2 @@\n-    if (!Matcher::match_rule_supported_vector(Op_VectorStoreMask, num_elem, type)) {\n+    if (!Matcher::match_rule_supported_vector(Op_VectorStoreMask, num_elem, type) ||\n+        !Matcher::match_rule_supported_vector(Op_StoreVector, num_elem, T_BOOLEAN)) {\n@@ -564,0 +567,1 @@\n+      operation->add_flag(Node::Flag_is_predicated_using_blend);\n@@ -698,9 +702,1 @@\n-  if (!arch_supports_vector(Op_LoadVector, num_elem, T_BOOLEAN, VecMaskNotUsed)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n-                    Op_LoadVector, num_elem, type2name(T_BOOLEAN));\n-    }\n-    return false; \/\/ not supported\n-  }\n-\n-  if (!arch_supports_vector(mopc, num_elem, elem_bt, VecMaskNotUsed)) {\n+  if (!arch_supports_vector(mopc, num_elem, elem_bt, VecMaskUseLoad)) {\n@@ -940,1 +936,1 @@\n-\/\/         C container, int index, S s,     \/\/ Arguments for default implementation\n+\/\/         C container, long index, S s,     \/\/ Arguments for default implementation\n@@ -949,1 +945,1 @@\n-\/\/            C container, int index,      \/\/ Arguments for default implementation\n+\/\/            C container, long index,      \/\/ Arguments for default implementation\n@@ -1052,10 +1048,0 @@\n-    if (!arch_supports_vector(Op_LoadVector, num_elem, T_BOOLEAN, VecMaskNotUsed)) {\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s\/mask vlen=%d etype=bit ismask=no\",\n-                      is_store, is_store ? \"store\" : \"load\",\n-                      num_elem);\n-      }\n-      set_map(old_map);\n-      set_sp(old_sp);\n-      return false; \/\/ not supported\n-    }\n@@ -1099,1 +1085,3 @@\n-\n+    if (is_mask) {\n+      val = gvn().transform(VectorStoreMaskNode::make(gvn(), val, elem_bt, num_elem));\n+    }\n@@ -1141,1 +1129,1 @@\n-\/\/              C container, int index, S s,  \/\/ Arguments for default implementation\n+\/\/              C container, long index, S s,  \/\/ Arguments for default implementation\n@@ -1152,1 +1140,1 @@\n-\/\/                  C container, int index,  \/\/ Arguments for default implementation\n+\/\/                  C container, long index,  \/\/ Arguments for default implementation\n@@ -2739,0 +2727,94 @@\n+\/\/ public static\n+\/\/ <V extends Vector<E>,\n+\/\/  M extends VectorMask<E>,\n+\/\/  E>\n+\/\/  V comExpOp(int opr,\n+\/\/             Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+\/\/             int length, V v, M m,\n+\/\/             CmpExpOperation<V, M> defaultImpl)\n+bool LibraryCallKit::inline_vector_compress_expand() {\n+  const TypeInt*     opr          = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+\n+  if (vector_klass == NULL || elem_klass == NULL || mask_klass == NULL || vlen == NULL ||\n+      vector_klass->const_oop() == NULL || mask_klass->const_oop() == NULL ||\n+      elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(3)->Opcode()],\n+                    NodeClassNames[argument(4)->Opcode()]);\n+    }\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(vector_klass) || !is_klass_initialized(mask_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = elem_type->basic_type();\n+  int opc = VectorSupport::vop2ideal(opr->get_con(), elem_bt);\n+\n+  if (!arch_supports_vector(opc, num_elem, elem_bt, VecMaskUseLoad)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: opc=%d vlen=%d etype=%s ismask=useload\",\n+                    opc, num_elem, type2name(elem_bt));\n+    }\n+    return false; \/\/ not supported\n+  }\n+\n+  Node* opd1 = NULL;\n+  const TypeInstPtr* vbox_type = NULL;\n+  if (opc != Op_CompressM) {\n+    ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+    vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+    opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+    if (opd1 == NULL) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** unbox failed vector=%s\",\n+                      NodeClassNames[argument(5)->Opcode()]);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  assert(is_vector_mask(mbox_klass), \"argument(6) should be a mask class\");\n+  const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);\n+\n+  Node* mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);\n+  if (mask == NULL) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** unbox failed mask=%s\",\n+                    NodeClassNames[argument(6)->Opcode()]);\n+    }\n+    return false;\n+  }\n+\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, opc == Op_CompressM);\n+  Node* operation = gvn().transform(VectorNode::make(opc, opd1, mask, vt));\n+\n+  \/\/ Wrap it up in VectorBox to keep object type information.\n+  const TypeInstPtr* box_type = opc == Op_CompressM ? mbox_type : vbox_type;\n+  Node* vbox = box_vector(operation, box_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":109,"deletions":27,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -165,3 +165,1 @@\n-    \/\/ Unimplemented for subword types since bit count changes\n-    \/\/ depending on size of lane (and sign bit).\n-    return (bt == T_INT ? Op_PopCountVI : 0);\n+    return Op_PopCountVI;\n@@ -170,0 +168,13 @@\n+  case Op_ReverseI:\n+  case Op_ReverseL:\n+    return (is_integral_type(bt) ? Op_ReverseV : 0);\n+  case Op_ReverseBytesS:\n+  case Op_ReverseBytesI:\n+  case Op_ReverseBytesL:\n+    return (is_integral_type(bt) ? Op_ReverseBytesV : 0);\n+  case Op_CompressBits:\n+    \/\/ Not implemented. Returning 0 temporarily\n+    return 0;\n+  case Op_ExpandBits:\n+    \/\/ Not implemented. Returning 0 temporarily\n+    return 0;\n@@ -248,0 +259,6 @@\n+  case Op_CountLeadingZerosI:\n+  case Op_CountLeadingZerosL:\n+    return Op_CountLeadingZerosV;\n+  case Op_CountTrailingZerosI:\n+  case Op_CountTrailingZerosL:\n+    return Op_CountTrailingZerosV;\n@@ -589,0 +606,3 @@\n+  case Op_ReverseV: return new ReverseVNode(n1, vt);\n+  case Op_ReverseBytesV: return new ReverseBytesVNode(n1, vt);\n+\n@@ -622,0 +642,6 @@\n+\n+  case Op_ExpandV: return new ExpandVNode(n1, n2, vt);\n+  case Op_CompressV: return new CompressVNode(n1, n2, vt);\n+  case Op_CompressM: assert(n1 == NULL, \"\"); return new CompressMNode(n2, vt);\n+  case Op_CountLeadingZerosV: return new CountLeadingZerosVNode(n1, vt);\n+  case Op_CountTrailingZerosV: return new CountTrailingZerosVNode(n1, vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -771,0 +771,31 @@\n+\/\/------------------------------CompressVNode--------------------------------------\n+\/\/ Vector compress\n+class CompressVNode: public VectorNode {\n+ public:\n+  CompressVNode(Node* vec, Node* mask, const TypeVect* vt) :\n+      VectorNode(vec, mask, vt) {\n+    init_class_id(Class_CompressV);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class CompressMNode: public VectorNode {\n+ public:\n+  CompressMNode(Node* mask, const TypeVect* vt) :\n+      VectorNode(mask, vt) {\n+    init_class_id(Class_CompressM);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------ExpandVNode--------------------------------------\n+\/\/ Vector expand\n+class ExpandVNode: public VectorNode {\n+ public:\n+  ExpandVNode(Node* vec, Node* mask, const TypeVect* vt) :\n+      VectorNode(vec, mask, vt) {\n+    init_class_id(Class_ExpandV);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n@@ -1387,1 +1418,0 @@\n-    \/\/ assert(mask->is_VectorMask(), \"VectorBlendNode requires that third argument be a mask\");\n@@ -1669,0 +1699,32 @@\n+\n+class CountLeadingZerosVNode : public VectorNode {\n+ public:\n+  CountLeadingZerosVNode(Node* in, const TypeVect* vt)\n+  : VectorNode(in, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n+class CountTrailingZerosVNode : public VectorNode {\n+ public:\n+  CountTrailingZerosVNode(Node* in, const TypeVect* vt)\n+  : VectorNode(in, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n+class ReverseVNode : public VectorNode {\n+public:\n+  ReverseVNode(Node* in, const TypeVect* vt)\n+  : VectorNode(in, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n+class ReverseBytesVNode : public VectorNode {\n+public:\n+  ReverseBytesVNode(Node* in, const TypeVect* vt)\n+  : VectorNode(in, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":63,"deletions":1,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1773,0 +1773,2 @@\n+  declare_c2_type(CompressVNode, VectorNode)                              \\\n+  declare_c2_type(ExpandVNode, VectorNode)                                \\\n@@ -1863,0 +1865,2 @@\n+  declare_c2_type(CountLeadingZerosVNode, VectorNode)                     \\\n+  declare_c2_type(CountTrailingZerosVNode, VectorNode)                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -724,0 +724,4 @@\n+inline bool is_non_subword_integral_type(BasicType t) {\n+  return t == T_INT || t == T_LONG;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -354,0 +357,65 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        byte apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> ByteVector ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        byte[] res = new byte[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> ByteVector ldLongOp(M memory, long offset,\n+                                  VectorMask<Byte> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/byte[] vec = vec();\n+        byte[] res = new byte[length()];\n+        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static ByteVector expandHelper(Vector<Byte> v, VectorMask<Byte> m) {\n+        VectorSpecies<Byte> vsp = m.vectorSpecies();\n+        ByteVector r  = (ByteVector) vsp.zero();\n+        ByteVector vi = (ByteVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static ByteVector compressHelper(Vector<Byte> v, VectorMask<Byte> m) {\n+        VectorSpecies<Byte> vsp = m.vectorSpecies();\n+        ByteVector r  = (ByteVector) vsp.zero();\n+        ByteVector vi = (ByteVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -384,0 +452,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, byte a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        byte[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<Byte> m,\n+                  FStLongOp<M> f) {\n+        byte[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -623,0 +721,10 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (byte) bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (byte) numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (byte) numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> reverse(a));\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> a);\n@@ -1749,0 +1857,19 @@\n+    static int bitCount(byte a) {\n+        return Integer.bitCount((int)a & 0xFF);\n+    }\n+    static int numberOfTrailingZeros(byte a) {\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 8;\n+    }\n+    static int numberOfLeadingZeros(byte a) {\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0;\n+    }\n+\n+    static byte reverse(byte a) {\n+        if (a == 0 || a == -1) return a;\n+\n+        byte b = rotateLeft(a, 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -2375,0 +2502,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector compress(VectorMask<Byte> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Byte>>\n+    ByteVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ByteVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   byte.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector expand(VectorMask<Byte> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Byte>>\n+    ByteVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ByteVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   byte.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -3268,0 +3432,99 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*1 < 0}\n+     *         or {@code offset+N*1 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromMemorySegment(VectorSpecies<Byte> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code byte} (zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * byte[] ar = new byte[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_BYTE.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * ByteVector r = ByteVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * The byte order argument is ignored.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*1 < 0}\n+     *         or {@code offset+N*1 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    ByteVector fromMemorySegment(VectorSpecies<Byte> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Byte> m) {\n+        ByteSpecies vsp = (ByteSpecies) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, ms.byteSize());\n+        var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<Byte>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * 1L));\n+    }\n+\n@@ -3295,1 +3558,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3446,1 +3709,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3648,0 +3911,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Byte> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            ByteSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -3678,1 +3978,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3695,1 +3995,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3712,1 +4012,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3729,1 +4029,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3746,1 +4046,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -3765,1 +4065,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -3781,1 +4081,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -3799,1 +4099,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -3804,0 +4104,34 @@\n+    abstract\n+    ByteVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    ByteVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        ByteSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 1L));\n+                });\n+    }\n+\n+    abstract\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    ByteVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        ByteSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 1L));\n+                });\n+    }\n+\n@@ -3819,1 +4153,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3836,1 +4170,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3855,1 +4189,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3871,1 +4205,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -3890,1 +4224,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -3904,1 +4238,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -3922,1 +4256,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -3927,0 +4261,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        ByteSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 1L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Byte> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Byte>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        ByteSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 1L, e));\n+                });\n+    }\n+\n@@ -3940,0 +4308,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                ByteSpecies vsp,\n+                                VectorMask<Byte> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Byte>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -4259,0 +4637,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> ByteVector ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> ByteVector ldLongOp(M memory, long offset,\n+                                      VectorMask<Byte> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -4273,0 +4666,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<Byte> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":424,"deletions":17,"binary":false,"changes":441,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -354,0 +357,65 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        int apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> IntVector ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        int[] res = new int[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> IntVector ldLongOp(M memory, long offset,\n+                                  VectorMask<Integer> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/int[] vec = vec();\n+        int[] res = new int[length()];\n+        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static IntVector expandHelper(Vector<Integer> v, VectorMask<Integer> m) {\n+        VectorSpecies<Integer> vsp = m.vectorSpecies();\n+        IntVector r  = (IntVector) vsp.zero();\n+        IntVector vi = (IntVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static IntVector compressHelper(Vector<Integer> v, VectorMask<Integer> m) {\n+        VectorSpecies<Integer> vsp = m.vectorSpecies();\n+        IntVector r  = (IntVector) vsp.zero();\n+        IntVector vi = (IntVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -384,0 +452,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, int a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        int[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<Integer> m,\n+                  FStLongOp<M> f) {\n+        int[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -623,0 +721,10 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.reverse(a));\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.reverseBytes(a));\n@@ -763,0 +871,4 @@\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n@@ -1748,0 +1860,1 @@\n+\n@@ -2374,0 +2487,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector compress(VectorMask<Integer> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Integer>>\n+    IntVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (IntVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   int.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector expand(VectorMask<Integer> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Integer>>\n+    IntVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (IntVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   int.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -3132,0 +3282,104 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*4 < 0}\n+     *         or {@code offset+N*4 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    IntVector fromMemorySegment(VectorSpecies<Integer> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        IntSpecies vsp = (IntSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code int} (zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * int[] ar = new int[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_INT.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * IntVector r = IntVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*4 < 0}\n+     *         or {@code offset+N*4 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    IntVector fromMemorySegment(VectorSpecies<Integer> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Integer> m) {\n+        IntSpecies vsp = (IntSpecies) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 4, ms.byteSize());\n+        var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<Integer>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * 4L));\n+    }\n+\n@@ -3159,1 +3413,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3364,0 +3618,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Integer> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            IntSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 4, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -3394,1 +3685,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3411,1 +3702,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3464,1 +3755,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -3483,1 +3774,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -3499,1 +3790,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -3517,1 +3808,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -3522,0 +3813,34 @@\n+    abstract\n+    IntVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    IntVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        IntSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 4L));\n+                });\n+    }\n+\n+    abstract\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    IntVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        IntSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 4L));\n+                });\n+    }\n+\n@@ -3537,1 +3862,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3554,1 +3879,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3605,1 +3930,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -3624,1 +3949,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -3638,1 +3963,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -3656,1 +3981,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -3661,0 +3986,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        IntSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 4L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Integer> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Integer>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        IntSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_INT.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 4L, e));\n+                });\n+    }\n+\n@@ -3674,0 +4033,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                IntSpecies vsp,\n+                                VectorMask<Integer> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Integer>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -3984,0 +4353,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> IntVector ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> IntVector ldLongOp(M memory, long offset,\n+                                      VectorMask<Integer> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -3998,0 +4382,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<Integer> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":411,"deletions":13,"binary":false,"changes":424,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -354,0 +357,65 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        long apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> LongVector ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        long[] res = new long[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> LongVector ldLongOp(M memory, long offset,\n+                                  VectorMask<Long> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/long[] vec = vec();\n+        long[] res = new long[length()];\n+        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static LongVector expandHelper(Vector<Long> v, VectorMask<Long> m) {\n+        VectorSpecies<Long> vsp = m.vectorSpecies();\n+        LongVector r  = (LongVector) vsp.zero();\n+        LongVector vi = (LongVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static LongVector compressHelper(Vector<Long> v, VectorMask<Long> m) {\n+        VectorSpecies<Long> vsp = m.vectorSpecies();\n+        LongVector r  = (LongVector) vsp.zero();\n+        LongVector vi = (LongVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -384,0 +452,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, long a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        long[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<Long> m,\n+                  FStLongOp<M> f) {\n+        long[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -581,0 +679,10 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.reverse(a));\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.reverseBytes(a));\n@@ -721,0 +829,4 @@\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n@@ -1661,0 +1773,1 @@\n+\n@@ -2240,0 +2353,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector compress(VectorMask<Long> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Long>>\n+    LongVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (LongVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   long.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector expand(VectorMask<Long> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Long>>\n+    LongVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (LongVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   long.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -3011,0 +3161,104 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*8 < 0}\n+     *         or {@code offset+N*8 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    LongVector fromMemorySegment(VectorSpecies<Long> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        LongSpecies vsp = (LongSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code long} (zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * long[] ar = new long[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_LONG.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * LongVector r = LongVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*8 < 0}\n+     *         or {@code offset+N*8 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    LongVector fromMemorySegment(VectorSpecies<Long> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Long> m) {\n+        LongSpecies vsp = (LongSpecies) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 8, ms.byteSize());\n+        var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<Long>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * 8L));\n+    }\n+\n@@ -3038,1 +3292,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3262,0 +3516,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Long> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            LongSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 8, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -3292,1 +3583,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3309,1 +3600,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3380,1 +3671,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -3399,1 +3690,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -3415,1 +3706,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -3433,1 +3724,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -3438,0 +3729,34 @@\n+    abstract\n+    LongVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    LongVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        LongSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 8L));\n+                });\n+    }\n+\n+    abstract\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    LongVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        LongSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 8L));\n+                });\n+    }\n+\n@@ -3453,1 +3778,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3470,1 +3795,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3540,1 +3865,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -3559,1 +3884,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -3573,1 +3898,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -3591,1 +3916,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -3596,0 +3921,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        LongSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 8L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Long> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Long>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        LongSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 8L, e));\n+                });\n+    }\n+\n@@ -3609,0 +3968,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                LongSpecies vsp,\n+                                VectorMask<Long> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Long>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -3910,0 +4279,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> LongVector ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> LongVector ldLongOp(M memory, long offset,\n+                                      VectorMask<Long> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -3924,0 +4308,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<Long> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":411,"deletions":13,"binary":false,"changes":424,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -354,0 +357,65 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        short apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> ShortVector ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> ShortVector ldLongOp(M memory, long offset,\n+                                  VectorMask<Short> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static ShortVector expandHelper(Vector<Short> v, VectorMask<Short> m) {\n+        VectorSpecies<Short> vsp = m.vectorSpecies();\n+        ShortVector r  = (ShortVector) vsp.zero();\n+        ShortVector vi = (ShortVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static ShortVector compressHelper(Vector<Short> v, VectorMask<Short> m) {\n+        VectorSpecies<Short> vsp = m.vectorSpecies();\n+        ShortVector r  = (ShortVector) vsp.zero();\n+        ShortVector vi = (ShortVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -384,0 +452,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<Short> m,\n+                  FStLongOp<M> f) {\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -623,0 +721,10 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> reverse(a));\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Short.reverseBytes(a));\n@@ -1749,0 +1857,20 @@\n+    static int bitCount(short a) {\n+        return Integer.bitCount((int)a & 0xFFFF);\n+    }\n+    static int numberOfTrailingZeros(short a) {\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 16;\n+    }\n+    static int numberOfLeadingZeros(short a) {\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0;\n+    }\n+\n+    static short reverse(short a) {\n+        if (a == 0 || a == -1) return a;\n+\n+        short b = rotateLeft(a, 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -2375,0 +2503,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector compress(VectorMask<Short> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Short>>\n+    ShortVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ShortVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   short.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector expand(VectorMask<Short> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Short>>\n+    ShortVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ShortVector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   short.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -3267,0 +3432,104 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromMemorySegment(VectorSpecies<Short> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code short} (zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * short[] ar = new short[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * ShortVector r = ShortVector.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*2 < 0}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    ShortVector fromMemorySegment(VectorSpecies<Short> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Short> m) {\n+        ShortSpecies vsp = (ShortSpecies) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());\n+        var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<Short>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * 2L));\n+    }\n+\n@@ -3294,1 +3563,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3440,1 +3709,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3634,0 +3903,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Short> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            ShortSpecies vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -3664,1 +3970,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3681,1 +3987,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3697,1 +4003,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3714,1 +4020,1 @@\n-                (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3732,1 +4038,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -3751,1 +4057,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -3767,1 +4073,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -3785,1 +4091,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -3790,0 +4096,34 @@\n+    abstract\n+    ShortVector fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    ShortVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        ShortSpecies vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 2L));\n+                });\n+    }\n+\n+    abstract\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    ShortVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        ShortSpecies vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * 2L));\n+                });\n+    }\n+\n@@ -3805,1 +4145,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3822,1 +4162,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3840,1 +4180,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -3859,1 +4199,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -3873,1 +4213,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -3891,1 +4231,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -3896,0 +4236,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        ShortSpecies vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 2L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Short> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<Short>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        ShortSpecies vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * 2L, e));\n+                });\n+    }\n+\n@@ -3910,1 +4284,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3926,0 +4300,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                ShortSpecies vsp,\n+                                VectorMask<Short> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Short>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -4253,0 +4637,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> ShortVector ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> ShortVector ldLongOp(M memory, long offset,\n+                                      VectorMask<Short> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -4267,0 +4666,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<Short> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":430,"deletions":17,"binary":false,"changes":447,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -358,0 +361,65 @@\n+    \/*package-private*\/\n+    interface FLdLongOp<M> {\n+        $type$ apply(M memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n+                                  FLdLongOp<M> f) {\n+        \/\/dummy; no vec = vec();\n+        $type$[] res = new $type$[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n+                                  VectorMask<$Boxtype$> m,\n+                                  FLdLongOp<M> f) {\n+        \/\/$type$[] vec = vec();\n+        $type$[] res = new $type$[length()];\n+        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static $abstractvectortype$ expandHelper(Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+        VectorSpecies<$Boxtype$> vsp = m.vectorSpecies();\n+        $abstractvectortype$ r  = ($abstractvectortype$) vsp.zero();\n+        $abstractvectortype$ vi = ($abstractvectortype$) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static $abstractvectortype$ compressHelper(Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+        VectorSpecies<$Boxtype$> vsp = m.vectorSpecies();\n+        $abstractvectortype$ r  = ($abstractvectortype$) vsp.zero();\n+        $abstractvectortype$ vi = ($abstractvectortype$) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -388,0 +456,30 @@\n+    interface FStLongOp<M> {\n+        void apply(M memory, long offset, int i, $type$ a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  FStLongOp<M> f) {\n+        $type$[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M> void stLongOp(M memory, long offset,\n+                  VectorMask<$Boxtype$> m,\n+                  FStLongOp<M> f) {\n+        $type$[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n@@ -649,0 +747,30 @@\n+#if[!FP]\n+#if[intOrLong]\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverse(a));\n+#else[intOrLong]\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> reverse(a));\n+#end[intOrLong]\n+#if[BITWISE]\n+#if[byte]\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> a);\n+#else[byte]\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverseBytes(a));\n+#end[byte]\n+#end[BITWISE]\n+#end[!FP]\n@@ -842,0 +970,6 @@\n+#if[intOrLong]\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n+#end[intOrLong]\n@@ -1990,0 +2124,50 @@\n+#if[!FP]\n+#if[!intOrLong]\n+    static int bitCount($type$ a) {\n+#if[short]\n+        return Integer.bitCount((int)a & 0xFFFF);\n+#else[short]\n+        return Integer.bitCount((int)a & 0xFF);\n+#end[short]\n+    }\n+#end[!intOrLong]\n+#end[!FP]\n+#if[!FP]\n+#if[!intOrLong]\n+    static int numberOfTrailingZeros($type$ a) {\n+#if[short]\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 16;\n+#else[short]\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 8;\n+#end[short]\n+    }\n+#end[!intOrLong]\n+#end[!FP]\n+#if[!FP]\n+#if[!intOrLong]\n+    static int numberOfLeadingZeros($type$ a) {\n+#if[short]\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0;\n+#else[short]\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0;\n+#end[short]\n+    }\n+\n+    static $type$ reverse($type$ a) {\n+        if (a == 0 || a == -1) return a;\n+\n+#if[short]\n+        $type$ b = rotateLeft(a, 8);\n+        b = ($type$) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = ($type$) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = ($type$) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+#else[short]\n+        $type$ b = rotateLeft(a, 4);\n+        b = ($type$) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = ($type$) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+#end[short]\n+        return b;\n+    }\n+#end[!intOrLong]\n+#end[!FP]\n+\n@@ -2698,0 +2882,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    $Type$Vector compress(VectorMask<$Boxtype$> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<$Boxtype$>>\n+    $Type$Vector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return ($Type$Vector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                   $type$.class, length(), this, m,\n+                                                   (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    public abstract\n+    $Type$Vector expand(VectorMask<$Boxtype$> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<$Boxtype$>>\n+    $Type$Vector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return ($Type$Vector) VectorSupport.comExpOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                   $type$.class, length(), this, m,\n+                                                   (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -4023,0 +4244,108 @@\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * This method behaves as if it returns the result of calling\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n+     * <pre>{@code\n+     * var m = species.maskAll(true);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n+     * }<\/pre>\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*$sizeInBytes$ < 0}\n+     *         or {@code offset+N*$sizeInBytes$ >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromMemorySegment(VectorSpecies<$Boxtype$> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n+    }\n+\n+    \/**\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n+     * and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * Bytes are composed into primitive lane elements according\n+     * to the specified byte order.\n+     * The vector is arranged into lanes according to\n+     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n+     * <p>\n+     * The following pseudocode illustrates the behavior:\n+     * <pre>{@code\n+     * var slice = ms.asSlice(offset);\n+     * $type$[] ar = new $type$[species.length()];\n+     * for (int n = 0; n < ar.length; n++) {\n+     *     if (m.laneIsSet(n)) {\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_$TYPE$.withBitAlignment(8), n);\n+     *     }\n+     * }\n+     * $abstractvectortype$ r = $abstractvectortype$.fromArray(species, ar, 0);\n+     * }<\/pre>\n+     * @implNote\n+#if[!byte]\n+     * This operation is likely to be more efficient if\n+     * the specified byte order is the same as\n+     * {@linkplain ByteOrder#nativeOrder()\n+     * the platform native order},\n+     * since this method will not need to reorder\n+     * the bytes of lane values.\n+#else[!byte]\n+     * The byte order argument is ignored.\n+#end[!byte]\n+     *\n+     * @param species species of desired vector\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n+     * @param bo the intended byte order\n+     * @param m the mask controlling lane selection\n+     * @return a vector loaded from the memory segment\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N*$sizeInBytes$ < 0}\n+     *         or {@code offset+N*$sizeInBytes$ >= ms.byteSize()}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromMemorySegment(VectorSpecies<$Boxtype$> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, ms.byteSize());\n+        var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+        return vsp.ldLongOp(ms, offset, (AbstractMask<$Boxtype$>)m,\n+                   (ms_, o, i)  -> ms_.get(layout, o + i * $sizeInBytes$L));\n+    }\n+\n@@ -4050,1 +4379,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -4267,1 +4596,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -4426,1 +4755,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -4629,0 +4958,37 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+        }\n+\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     *\/\n+    @Override\n+    @ForceInline\n+    public final\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoMemorySegment(ms, offset, bo);\n+        } else {\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n+            }\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n+        }\n+    }\n+\n@@ -4659,1 +5025,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -4676,1 +5042,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -4753,1 +5119,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -4770,1 +5136,1 @@\n-                (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -4787,1 +5153,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -4804,1 +5170,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -4822,1 +5188,1 @@\n-                return s.ldOp(wb, off,\n+                return s.ldOp(wb, (int) off,\n@@ -4841,1 +5207,1 @@\n-                return s.ldOp(wb, off, vm,\n+                return s.ldOp(wb, (int) off, vm,\n@@ -4857,1 +5223,1 @@\n-                    return s.ldOp(wb, off,\n+                    return s.ldOp(wb, (int) off,\n@@ -4875,1 +5241,1 @@\n-                    return s.ldOp(wb, off, vm,\n+                    return s.ldOp(wb, (int) off, vm,\n@@ -4880,0 +5246,34 @@\n+    abstract\n+    $abstractvectortype$ fromMemorySegment0(MemorySegment bb, long offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromMemorySegment0Template(MemorySegment ms, long offset) {\n+        $Type$Species vsp = vspecies();\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * $sizeInBytes$L));\n+                });\n+    }\n+\n+    abstract\n+    $abstractvectortype$ fromMemorySegment0(MemorySegment ms, long offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    $abstractvectortype$ fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        $Type$Species vsp = vspecies();\n+        m.check(vsp);\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+                    return s.ldLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i) -> ms_.get(layout, o + i * $sizeInBytes$L));\n+                });\n+    }\n+\n@@ -4895,1 +5295,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -4912,1 +5312,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -4993,1 +5393,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -5010,1 +5410,1 @@\n-                v.stOp(wb, off,\n+                v.stOp(wb, (int) off,\n@@ -5029,1 +5429,1 @@\n-                v.stOp(wb, off, vm,\n+                v.stOp(wb, (int) off, vm,\n@@ -5043,1 +5443,1 @@\n-                    v.stOp(wb, off,\n+                    v.stOp(wb, (int) off,\n@@ -5061,1 +5461,1 @@\n-                    v.stOp(wb, off, vm,\n+                    v.stOp(wb, (int) off, vm,\n@@ -5066,0 +5466,34 @@\n+    @ForceInline\n+    final\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n+        $Type$Species vsp = vspecies();\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * $sizeInBytes$L, e));\n+                });\n+    }\n+\n+    abstract\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<$Boxtype$> m);\n+    @ForceInline\n+    final\n+    <M extends VectorMask<$Boxtype$>>\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n+        $Type$Species vsp = vspecies();\n+        m.check(vsp);\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n+                vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    var layout = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+                    v.stLongOp((MemorySegment) msp, off, vm,\n+                            (ms_, o, i, e) -> ms_.set(layout, o + i * $sizeInBytes$L, e));\n+                });\n+    }\n+\n@@ -5081,1 +5515,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -5098,0 +5532,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                $Type$Species vsp,\n+                                VectorMask<$Boxtype$> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<$Boxtype$>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -5466,0 +5910,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> $abstractvectortype$ ldLongOp(M memory, long offset,\n+                                      VectorMask<$Boxtype$> m,\n+                                      FLdLongOp<M> f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -5479,0 +5938,14 @@\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset, FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        <M> void stLongOp(M memory, long offset,\n+                      AbstractMask<$Boxtype$> m,\n+                      FStLongOp<M> f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":494,"deletions":21,"binary":false,"changes":515,"status":"modified"},{"patch":"@@ -1741,0 +1741,4 @@\n+                        [\"index\",   \"__ sve_index(z6, __ B, r5, 2);\",                     \"index\\tz6.b, w5, #2\"],\n+                        [\"index\",   \"__ sve_index(z6, __ H, r5, 3);\",                     \"index\\tz6.h, w5, #3\"],\n+                        [\"index\",   \"__ sve_index(z6, __ S, r5, 4);\",                     \"index\\tz6.s, w5, #4\"],\n+                        [\"index\",   \"__ sve_index(z7, __ D, r5, 5);\",                     \"index\\tz7.d, x5, #5\"],\n@@ -1783,0 +1787,2 @@\n+                        [\"compact\", \"__ sve_compact(z16, __ S, z16, p1);\",                \"compact\\tz16.s, p1, z16.s\"],\n+                        [\"compact\", \"__ sve_compact(z16, __ D, z16, p1);\",                \"compact\\tz16.d, p1, z16.d\"],\n@@ -1826,0 +1832,1 @@\n+                       [\"clz\", \"ZPZ\", \"m\"],\n@@ -1834,0 +1841,2 @@\n+                       [\"rbit\", \"ZPZ\", \"m\"],\n+                       [\"revb\", \"ZPZ\", \"m\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -900,0 +900,4 @@\n+    __ sve_index(z6, __ B, r5, 2);                     \/\/       index   z6.b, w5, #2\n+    __ sve_index(z6, __ H, r5, 3);                     \/\/       index   z6.h, w5, #3\n+    __ sve_index(z6, __ S, r5, 4);                     \/\/       index   z6.s, w5, #4\n+    __ sve_index(z7, __ D, r5, 5);                     \/\/       index   z7.d, x5, #5\n@@ -942,0 +946,2 @@\n+    __ sve_compact(z16, __ S, z16, p1);                \/\/       compact z16.s, p1, z16.s\n+    __ sve_compact(z16, __ D, z16, p1);                \/\/       compact z16.d, p1, z16.d\n@@ -1130,39 +1136,42 @@\n-    __ sve_cnt(z21, __ B, p1, z30);                    \/\/       cnt     z21.b, p1\/m, z30.b\n-    __ sve_eor(z10, __ B, p5, z12);                    \/\/       eor     z10.b, p5\/m, z10.b, z12.b\n-    __ sve_lsl(z9, __ S, p1, z24);                     \/\/       lsl     z9.s, p1\/m, z9.s, z24.s\n-    __ sve_lsr(z4, __ H, p6, z6);                      \/\/       lsr     z4.h, p6\/m, z4.h, z6.h\n-    __ sve_mul(z27, __ S, p6, z13);                    \/\/       mul     z27.s, p6\/m, z27.s, z13.s\n-    __ sve_neg(z30, __ S, p5, z22);                    \/\/       neg     z30.s, p5\/m, z22.s\n-    __ sve_not(z30, __ H, p7, z9);                     \/\/       not     z30.h, p7\/m, z9.h\n-    __ sve_orr(z19, __ D, p1, z20);                    \/\/       orr     z19.d, p1\/m, z19.d, z20.d\n-    __ sve_smax(z9, __ H, p2, z13);                    \/\/       smax    z9.h, p2\/m, z9.h, z13.h\n-    __ sve_smin(z19, __ H, p0, z24);                   \/\/       smin    z19.h, p0\/m, z19.h, z24.h\n-    __ sve_sub(z19, __ S, p3, z17);                    \/\/       sub     z19.s, p3\/m, z19.s, z17.s\n-    __ sve_fabs(z16, __ S, p1, z0);                    \/\/       fabs    z16.s, p1\/m, z0.s\n-    __ sve_fadd(z11, __ S, p2, z15);                   \/\/       fadd    z11.s, p2\/m, z11.s, z15.s\n-    __ sve_fdiv(z15, __ D, p1, z15);                   \/\/       fdiv    z15.d, p1\/m, z15.d, z15.d\n-    __ sve_fmax(z5, __ D, p0, z10);                    \/\/       fmax    z5.d, p0\/m, z5.d, z10.d\n-    __ sve_fmin(z26, __ S, p0, z0);                    \/\/       fmin    z26.s, p0\/m, z26.s, z0.s\n-    __ sve_fmul(z19, __ D, p7, z10);                   \/\/       fmul    z19.d, p7\/m, z19.d, z10.d\n-    __ sve_fneg(z3, __ D, p5, z7);                     \/\/       fneg    z3.d, p5\/m, z7.d\n-    __ sve_frintm(z28, __ S, p3, z21);                 \/\/       frintm  z28.s, p3\/m, z21.s\n-    __ sve_frintn(z26, __ D, p3, z17);                 \/\/       frintn  z26.d, p3\/m, z17.d\n-    __ sve_frintp(z17, __ D, p3, z2);                  \/\/       frintp  z17.d, p3\/m, z2.d\n-    __ sve_fsqrt(z16, __ S, p5, z20);                  \/\/       fsqrt   z16.s, p5\/m, z20.s\n-    __ sve_fsub(z19, __ D, p0, z1);                    \/\/       fsub    z19.d, p0\/m, z19.d, z1.d\n-    __ sve_fmad(z17, __ D, p2, z16, z17);              \/\/       fmad    z17.d, p2\/m, z16.d, z17.d\n-    __ sve_fmla(z0, __ S, p1, z2, z23);                \/\/       fmla    z0.s, p1\/m, z2.s, z23.s\n-    __ sve_fmls(z6, __ D, p2, z20, z14);               \/\/       fmls    z6.d, p2\/m, z20.d, z14.d\n-    __ sve_fmsb(z29, __ D, p3, z3, z3);                \/\/       fmsb    z29.d, p3\/m, z3.d, z3.d\n-    __ sve_fnmad(z9, __ S, p0, z24, z27);              \/\/       fnmad   z9.s, p0\/m, z24.s, z27.s\n-    __ sve_fnmsb(z19, __ D, p5, z7, z25);              \/\/       fnmsb   z19.d, p5\/m, z7.d, z25.d\n-    __ sve_fnmla(z13, __ S, p1, z7, z25);              \/\/       fnmla   z13.s, p1\/m, z7.s, z25.s\n-    __ sve_fnmls(z21, __ S, p4, z17, z0);              \/\/       fnmls   z21.s, p4\/m, z17.s, z0.s\n-    __ sve_mla(z9, __ H, p5, z11, z7);                 \/\/       mla     z9.h, p5\/m, z11.h, z7.h\n-    __ sve_mls(z14, __ H, p4, z17, z11);               \/\/       mls     z14.h, p4\/m, z17.h, z11.h\n-    __ sve_and(z24, z17, z30);                         \/\/       and     z24.d, z17.d, z30.d\n-    __ sve_eor(z8, z15, z14);                          \/\/       eor     z8.d, z15.d, z14.d\n-    __ sve_orr(z22, z27, z22);                         \/\/       orr     z22.d, z27.d, z22.d\n-    __ sve_bic(z8, z5, z27);                           \/\/       bic     z8.d, z5.d, z27.d\n-    __ sve_uzp1(z10, __ D, z0, z14);                   \/\/       uzp1    z10.d, z0.d, z14.d\n-    __ sve_uzp2(z21, __ B, z20, z0);                   \/\/       uzp2    z21.b, z20.b, z0.b\n+    __ sve_clz(z21, __ B, p1, z30);                    \/\/       clz     z21.b, p1\/m, z30.b\n+    __ sve_cnt(z10, __ B, p5, z12);                    \/\/       cnt     z10.b, p5\/m, z12.b\n+    __ sve_eor(z9, __ S, p1, z24);                     \/\/       eor     z9.s, p1\/m, z9.s, z24.s\n+    __ sve_lsl(z4, __ H, p6, z6);                      \/\/       lsl     z4.h, p6\/m, z4.h, z6.h\n+    __ sve_lsr(z27, __ S, p6, z13);                    \/\/       lsr     z27.s, p6\/m, z27.s, z13.s\n+    __ sve_mul(z30, __ S, p5, z22);                    \/\/       mul     z30.s, p5\/m, z30.s, z22.s\n+    __ sve_neg(z30, __ H, p7, z9);                     \/\/       neg     z30.h, p7\/m, z9.h\n+    __ sve_not(z19, __ D, p1, z20);                    \/\/       not     z19.d, p1\/m, z20.d\n+    __ sve_orr(z9, __ H, p2, z13);                     \/\/       orr     z9.h, p2\/m, z9.h, z13.h\n+    __ sve_rbit(z19, __ H, p0, z24);                   \/\/       rbit    z19.h, p0\/m, z24.h\n+    __ sve_revb(z19, __ S, p3, z17);                   \/\/       revb    z19.s, p3\/m, z17.s\n+    __ sve_smax(z16, __ B, p1, z0);                    \/\/       smax    z16.b, p1\/m, z16.b, z0.b\n+    __ sve_smin(z11, __ H, p2, z15);                   \/\/       smin    z11.h, p2\/m, z11.h, z15.h\n+    __ sve_sub(z15, __ D, p1, z15);                    \/\/       sub     z15.d, p1\/m, z15.d, z15.d\n+    __ sve_fabs(z5, __ D, p0, z10);                    \/\/       fabs    z5.d, p0\/m, z10.d\n+    __ sve_fadd(z26, __ S, p0, z0);                    \/\/       fadd    z26.s, p0\/m, z26.s, z0.s\n+    __ sve_fdiv(z19, __ D, p7, z10);                   \/\/       fdiv    z19.d, p7\/m, z19.d, z10.d\n+    __ sve_fmax(z3, __ D, p5, z7);                     \/\/       fmax    z3.d, p5\/m, z3.d, z7.d\n+    __ sve_fmin(z28, __ S, p3, z21);                   \/\/       fmin    z28.s, p3\/m, z28.s, z21.s\n+    __ sve_fmul(z26, __ D, p3, z17);                   \/\/       fmul    z26.d, p3\/m, z26.d, z17.d\n+    __ sve_fneg(z17, __ D, p3, z2);                    \/\/       fneg    z17.d, p3\/m, z2.d\n+    __ sve_frintm(z16, __ S, p5, z20);                 \/\/       frintm  z16.s, p5\/m, z20.s\n+    __ sve_frintn(z19, __ D, p0, z1);                  \/\/       frintn  z19.d, p0\/m, z1.d\n+    __ sve_frintp(z17, __ D, p2, z16);                 \/\/       frintp  z17.d, p2\/m, z16.d\n+    __ sve_fsqrt(z21, __ S, p0, z4);                   \/\/       fsqrt   z21.s, p0\/m, z4.s\n+    __ sve_fsub(z23, __ S, p3, z6);                    \/\/       fsub    z23.s, p3\/m, z23.s, z6.s\n+    __ sve_fmad(z20, __ S, p3, z16, z29);              \/\/       fmad    z20.s, p3\/m, z16.s, z29.s\n+    __ sve_fmla(z3, __ S, p0, z22, z9);                \/\/       fmla    z3.s, p0\/m, z22.s, z9.s\n+    __ sve_fmls(z24, __ D, p7, z3, z19);               \/\/       fmls    z24.d, p7\/m, z3.d, z19.d\n+    __ sve_fmsb(z7, __ S, p6, z21, z13);               \/\/       fmsb    z7.s, p6\/m, z21.s, z13.s\n+    __ sve_fnmad(z7, __ D, p6, z5, z21);               \/\/       fnmad   z7.d, p6\/m, z5.d, z21.d\n+    __ sve_fnmsb(z17, __ D, p0, z3, z9);               \/\/       fnmsb   z17.d, p0\/m, z3.d, z9.d\n+    __ sve_fnmla(z11, __ D, p2, z11, z14);             \/\/       fnmla   z11.d, p2\/m, z11.d, z14.d\n+    __ sve_fnmls(z17, __ D, p2, z13, z24);             \/\/       fnmls   z17.d, p2\/m, z13.d, z24.d\n+    __ sve_mla(z30, __ H, p4, z8, z15);                \/\/       mla     z30.h, p4\/m, z8.h, z15.h\n+    __ sve_mls(z26, __ H, p5, z27, z22);               \/\/       mls     z26.h, p5\/m, z27.h, z22.h\n+    __ sve_and(z8, z5, z27);                           \/\/       and     z8.d, z5.d, z27.d\n+    __ sve_eor(z10, z0, z14);                          \/\/       eor     z10.d, z0.d, z14.d\n+    __ sve_orr(z21, z20, z0);                          \/\/       orr     z21.d, z20.d, z0.d\n+    __ sve_bic(z22, z25, z5);                          \/\/       bic     z22.d, z25.d, z5.d\n+    __ sve_uzp1(z29, __ B, z17, z17);                  \/\/       uzp1    z29.b, z17.b, z17.b\n+    __ sve_uzp2(z12, __ H, z14, z29);                  \/\/       uzp2    z12.h, z14.h, z29.h\n@@ -1171,9 +1180,9 @@\n-    __ sve_andv(v22, __ D, p6, z5);                    \/\/       andv d22, p6, z5.d\n-    __ sve_orv(v29, __ B, p4, z17);                    \/\/       orv b29, p4, z17.b\n-    __ sve_eorv(v12, __ H, p3, z29);                   \/\/       eorv h12, p3, z29.h\n-    __ sve_smaxv(v0, __ D, p4, z2);                    \/\/       smaxv d0, p4, z2.d\n-    __ sve_sminv(v20, __ D, p5, z21);                  \/\/       sminv d20, p5, z21.d\n-    __ sve_fminv(v12, __ S, p2, z2);                   \/\/       fminv s12, p2, z2.s\n-    __ sve_fmaxv(v14, __ S, p5, z22);                  \/\/       fmaxv s14, p5, z22.s\n-    __ sve_fadda(v19, __ D, p6, z26);                  \/\/       fadda d19, p6, d19, z26.d\n-    __ sve_uaddv(v12, __ B, p5, z21);                  \/\/       uaddv d12, p5, z21.b\n+    __ sve_andv(v0, __ D, p4, z2);                     \/\/       andv d0, p4, z2.d\n+    __ sve_orv(v20, __ D, p5, z21);                    \/\/       orv d20, p5, z21.d\n+    __ sve_eorv(v12, __ B, p2, z2);                    \/\/       eorv b12, p2, z2.b\n+    __ sve_smaxv(v14, __ B, p5, z22);                  \/\/       smaxv b14, p5, z22.b\n+    __ sve_sminv(v19, __ D, p6, z26);                  \/\/       sminv d19, p6, z26.d\n+    __ sve_fminv(v12, __ S, p5, z21);                  \/\/       fminv s12, p5, z21.s\n+    __ sve_fmaxv(v1, __ S, p2, z19);                   \/\/       fmaxv s1, p2, z19.s\n+    __ sve_fadda(v19, __ S, p6, z23);                  \/\/       fadda s19, p6, s19, z23.s\n+    __ sve_uaddv(v30, __ S, p4, z19);                  \/\/       uaddv d30, p4, z19.s\n@@ -1198,7 +1207,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003d5,     0x94000000,\n-    0x97ffffd4,     0x940003d2,     0x3400000a,     0x34fffa2a,\n-    0x340079ea,     0x35000008,     0x35fff9c8,     0x35007988,\n-    0xb400000b,     0xb4fff96b,     0xb400792b,     0xb500001d,\n-    0xb5fff91d,     0xb50078dd,     0x10000013,     0x10fff8b3,\n-    0x10007873,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363077f6,     0x3758000c,     0x375ff7cc,     0x3758778c,\n+    0x14000000,     0x17ffffd7,     0x140003de,     0x94000000,\n+    0x97ffffd4,     0x940003db,     0x3400000a,     0x34fffa2a,\n+    0x34007b0a,     0x35000008,     0x35fff9c8,     0x35007aa8,\n+    0xb400000b,     0xb4fff96b,     0xb4007a4b,     0xb500001d,\n+    0xb5fff91d,     0xb50079fd,     0x10000013,     0x10fff8b3,\n+    0x10007993,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307916,     0x3758000c,     0x375ff7cc,     0x375878ac,\n@@ -1209,13 +1218,13 @@\n-    0x54007560,     0x54000001,     0x54fff541,     0x54007501,\n-    0x54000002,     0x54fff4e2,     0x540074a2,     0x54000002,\n-    0x54fff482,     0x54007442,     0x54000003,     0x54fff423,\n-    0x540073e3,     0x54000003,     0x54fff3c3,     0x54007383,\n-    0x54000004,     0x54fff364,     0x54007324,     0x54000005,\n-    0x54fff305,     0x540072c5,     0x54000006,     0x54fff2a6,\n-    0x54007266,     0x54000007,     0x54fff247,     0x54007207,\n-    0x54000008,     0x54fff1e8,     0x540071a8,     0x54000009,\n-    0x54fff189,     0x54007149,     0x5400000a,     0x54fff12a,\n-    0x540070ea,     0x5400000b,     0x54fff0cb,     0x5400708b,\n-    0x5400000c,     0x54fff06c,     0x5400702c,     0x5400000d,\n-    0x54fff00d,     0x54006fcd,     0x5400000e,     0x54ffefae,\n-    0x54006f6e,     0x5400000f,     0x54ffef4f,     0x54006f0f,\n+    0x54007680,     0x54000001,     0x54fff541,     0x54007621,\n+    0x54000002,     0x54fff4e2,     0x540075c2,     0x54000002,\n+    0x54fff482,     0x54007562,     0x54000003,     0x54fff423,\n+    0x54007503,     0x54000003,     0x54fff3c3,     0x540074a3,\n+    0x54000004,     0x54fff364,     0x54007444,     0x54000005,\n+    0x54fff305,     0x540073e5,     0x54000006,     0x54fff2a6,\n+    0x54007386,     0x54000007,     0x54fff247,     0x54007327,\n+    0x54000008,     0x54fff1e8,     0x540072c8,     0x54000009,\n+    0x54fff189,     0x54007269,     0x5400000a,     0x54fff12a,\n+    0x5400720a,     0x5400000b,     0x54fff0cb,     0x540071ab,\n+    0x5400000c,     0x54fff06c,     0x5400714c,     0x5400000d,\n+    0x54fff00d,     0x540070ed,     0x5400000e,     0x54ffefae,\n+    0x5400708e,     0x5400000f,     0x54ffef4f,     0x5400702f,\n@@ -1383,1 +1392,2 @@\n-    0x04a14026,     0x0568aca7,     0x05b23230,     0x853040af,\n+    0x04a14026,     0x042244a6,     0x046344a6,     0x04a444a6,\n+    0x04e544a7,     0x0568aca7,     0x05b23230,     0x853040af,\n@@ -1393,51 +1403,53 @@\n-    0x05e14c00,     0x05304001,     0x05314001,     0x1e601000,\n-    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n-    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n-    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n-    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n-    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n-    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n-    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n-    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf82a822f,\n-    0xf822018a,     0xf82c11af,     0xf8222287,     0xf83a3090,\n-    0xf8225184,     0xf8304215,     0xf83072ab,     0xf837634c,\n-    0xf8b781dc,     0xf8ab0038,     0xf8ac115f,     0xf8b02047,\n-    0xf8a3326d,     0xf8b15070,     0xf8a143cb,     0xf8a571e8,\n-    0xf8bd601e,     0xf8f48287,     0xf8f702bc,     0xf8fb10b9,\n-    0xf8e12217,     0xf8ff3185,     0xf8e951fc,     0xf8fd43f6,\n-    0xf8f370bf,     0xf8ee63f0,     0xf870829b,     0xf870016c,\n-    0xf86913c6,     0xf871239b,     0xf87e3147,     0xf874508a,\n-    0xf8784231,     0xf87673a3,     0xf86f6276,     0xb8338056,\n-    0xb82f0186,     0xb83011ab,     0xb83723c1,     0xb8333225,\n-    0xb82252d0,     0xb82d42aa,     0xb83d719b,     0xb83b6023,\n-    0xb8bf8278,     0xb8b10389,     0xb8bb10ef,     0xb8b523f7,\n-    0xb8b933e2,     0xb8bb5150,     0xb8b74073,     0xb8b07320,\n-    0xb8ba6057,     0xb8f0808c,     0xb8fc03be,     0xb8f010db,\n-    0xb8e921fd,     0xb8e730e4,     0xb8ef52e9,     0xb8e84382,\n-    0xb8f570bf,     0xb8fb6220,     0xb86f8344,     0xb86802dc,\n-    0xb87b133b,     0xb8772080,     0xb8663010,     0xb864502f,\n-    0xb86a40a7,     0xb86a70fc,     0xb87462b7,     0xce284145,\n-    0xce1108de,     0xce7c8fab,     0xce96eb42,     0xce7b81ae,\n-    0xce6586f0,     0xcec081a2,     0xce6a89ea,     0x25a0cc5a,\n-    0x25a1d143,     0x05800e44,     0x05406531,     0x05002d42,\n-    0x2520c677,     0x25a1cd07,     0x0580687b,     0x0543bb42,\n-    0x050044a6,     0x25a0c86c,     0x25a1d358,     0x05800500,\n-    0x05400ad3,     0x05000e06,     0x25e0c951,     0x25a1d54a,\n-    0x05839276,     0x0540ea6f,     0x0503c8a4,     0x25a0d448,\n-    0x2521d056,     0x058059c9,     0x05406d05,     0x05003cb6,\n-    0x25a0d0c8,     0x2561c4f9,     0x05809904,     0x05400e5d,\n-    0x0500cadd,     0x043c0162,     0x04ba0427,     0x65c801d1,\n-    0x65c50b15,     0x65d60635,     0x0416b67d,     0x040012e4,\n-    0x04da06f3,     0x04508113,     0x04db1a2e,     0x041aa7d5,\n-    0x0419158a,     0x04938709,     0x045198c4,     0x049019bb,\n-    0x0497b6de,     0x045ebd3e,     0x04d80693,     0x044809a9,\n-    0x044a0313,     0x04810e33,     0x049ca410,     0x658089eb,\n-    0x65cd85ef,     0x65c68145,     0x6587801a,     0x65c29d53,\n-    0x04ddb4e3,     0x6582aebc,     0x65c0ae3a,     0x65c1ac51,\n-    0x658db690,     0x65c18033,     0x65f18a11,     0x65b70440,\n-    0x65ee2a86,     0x65e3ac7d,     0x65bbc309,     0x65f9f4f3,\n-    0x65b944ed,     0x65a07235,     0x04475569,     0x044b722e,\n-    0x043e3238,     0x04ae31e8,     0x04763376,     0x04fb30a8,\n-    0x05ee680a,     0x05206e95,     0x04da38b6,     0x0418323d,\n-    0x04592fac,     0x04c83040,     0x04ca36b4,     0x6587284c,\n-    0x658636ce,     0x65d83b53,     0x040136ac,\n+    0x05e14c00,     0x05304001,     0x05314001,     0x05a18610,\n+    0x05e18610,     0x1e601000,     0x1e603000,     0x1e621000,\n+    0x1e623000,     0x1e641000,     0x1e643000,     0x1e661000,\n+    0x1e663000,     0x1e681000,     0x1e683000,     0x1e6a1000,\n+    0x1e6a3000,     0x1e6c1000,     0x1e6c3000,     0x1e6e1000,\n+    0x1e6e3000,     0x1e701000,     0x1e703000,     0x1e721000,\n+    0x1e723000,     0x1e741000,     0x1e743000,     0x1e761000,\n+    0x1e763000,     0x1e781000,     0x1e783000,     0x1e7a1000,\n+    0x1e7a3000,     0x1e7c1000,     0x1e7c3000,     0x1e7e1000,\n+    0x1e7e3000,     0xf82a822f,     0xf822018a,     0xf82c11af,\n+    0xf8222287,     0xf83a3090,     0xf8225184,     0xf8304215,\n+    0xf83072ab,     0xf837634c,     0xf8b781dc,     0xf8ab0038,\n+    0xf8ac115f,     0xf8b02047,     0xf8a3326d,     0xf8b15070,\n+    0xf8a143cb,     0xf8a571e8,     0xf8bd601e,     0xf8f48287,\n+    0xf8f702bc,     0xf8fb10b9,     0xf8e12217,     0xf8ff3185,\n+    0xf8e951fc,     0xf8fd43f6,     0xf8f370bf,     0xf8ee63f0,\n+    0xf870829b,     0xf870016c,     0xf86913c6,     0xf871239b,\n+    0xf87e3147,     0xf874508a,     0xf8784231,     0xf87673a3,\n+    0xf86f6276,     0xb8338056,     0xb82f0186,     0xb83011ab,\n+    0xb83723c1,     0xb8333225,     0xb82252d0,     0xb82d42aa,\n+    0xb83d719b,     0xb83b6023,     0xb8bf8278,     0xb8b10389,\n+    0xb8bb10ef,     0xb8b523f7,     0xb8b933e2,     0xb8bb5150,\n+    0xb8b74073,     0xb8b07320,     0xb8ba6057,     0xb8f0808c,\n+    0xb8fc03be,     0xb8f010db,     0xb8e921fd,     0xb8e730e4,\n+    0xb8ef52e9,     0xb8e84382,     0xb8f570bf,     0xb8fb6220,\n+    0xb86f8344,     0xb86802dc,     0xb87b133b,     0xb8772080,\n+    0xb8663010,     0xb864502f,     0xb86a40a7,     0xb86a70fc,\n+    0xb87462b7,     0xce284145,     0xce1108de,     0xce7c8fab,\n+    0xce96eb42,     0xce7b81ae,     0xce6586f0,     0xcec081a2,\n+    0xce6a89ea,     0x25a0cc5a,     0x25a1d143,     0x05800e44,\n+    0x05406531,     0x05002d42,     0x2520c677,     0x25a1cd07,\n+    0x0580687b,     0x0543bb42,     0x050044a6,     0x25a0c86c,\n+    0x25a1d358,     0x05800500,     0x05400ad3,     0x05000e06,\n+    0x25e0c951,     0x25a1d54a,     0x05839276,     0x0540ea6f,\n+    0x0503c8a4,     0x25a0d448,     0x2521d056,     0x058059c9,\n+    0x05406d05,     0x05003cb6,     0x25a0d0c8,     0x2561c4f9,\n+    0x05809904,     0x05400e5d,     0x0500cadd,     0x043c0162,\n+    0x04ba0427,     0x65c801d1,     0x65c50b15,     0x65d60635,\n+    0x0416b67d,     0x040012e4,     0x04da06f3,     0x04508113,\n+    0x04db1a2e,     0x0419a7d5,     0x041ab58a,     0x04990709,\n+    0x045398c4,     0x049199bb,     0x049016de,     0x0457bd3e,\n+    0x04dea693,     0x045809a9,     0x05678313,     0x05a48e33,\n+    0x04080410,     0x044a09eb,     0x04c105ef,     0x04dca145,\n+    0x6580801a,     0x65cd9d53,     0x65c694e3,     0x65878ebc,\n+    0x65c28e3a,     0x04ddac51,     0x6582b690,     0x65c0a033,\n+    0x65c1aa11,     0x658da095,     0x65818cd7,     0x65bd8e14,\n+    0x65a902c3,     0x65f33c78,     0x65adbaa7,     0x65f5d8a7,\n+    0x65e9e071,     0x65ee496b,     0x65f869b1,     0x044f511e,\n+    0x0456777a,     0x043b30a8,     0x04ae300a,     0x04603295,\n+    0x04e53336,     0x05316a3d,     0x057d6dcc,     0x04da3040,\n+    0x04d836b4,     0x0419284c,     0x040836ce,     0x04ca3b53,\n+    0x658736ac,     0x65862a61,     0x65983af3,     0x0481327e,\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":132,"deletions":120,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1210,0 +1259,15 @@\n+    static byte TRAILING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -1934,0 +1998,4 @@\n+\n+\n+\n+\n@@ -4576,0 +4644,36 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5438,0 +5542,227 @@\n+\n+\n+\n+\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+    static byte TRAILING_ZEROS_COUNT(byte a) {\n+        return (byte)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static byte LEADING_ZEROS_COUNT(byte a) {\n+        return (byte)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n@@ -5850,0 +6181,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5892,0 +6240,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5910,0 +6272,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1210,0 +1259,15 @@\n+    static byte TRAILING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -1934,0 +1998,4 @@\n+\n+\n+\n+\n@@ -4576,0 +4644,36 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5438,0 +5542,227 @@\n+\n+\n+\n+\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+    static byte TRAILING_ZEROS_COUNT(byte a) {\n+        return (byte)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static byte LEADING_ZEROS_COUNT(byte a) {\n+        return (byte)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n@@ -5850,0 +6181,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5892,0 +6240,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5910,0 +6272,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1210,0 +1259,15 @@\n+    static byte TRAILING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -1934,0 +1998,4 @@\n+\n+\n+\n+\n@@ -4576,0 +4644,36 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5438,0 +5542,227 @@\n+\n+\n+\n+\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+    static byte TRAILING_ZEROS_COUNT(byte a) {\n+        return (byte)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static byte LEADING_ZEROS_COUNT(byte a) {\n+        return (byte)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n@@ -5850,0 +6181,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5892,0 +6240,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5910,0 +6272,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1210,0 +1259,15 @@\n+    static byte TRAILING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -1934,0 +1998,4 @@\n+\n+\n+\n+\n@@ -4576,0 +4644,36 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5438,0 +5542,227 @@\n+\n+\n+\n+\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+    static byte TRAILING_ZEROS_COUNT(byte a) {\n+        return (byte)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static byte LEADING_ZEROS_COUNT(byte a) {\n+        return (byte)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n@@ -5850,0 +6181,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5892,0 +6240,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5910,0 +6272,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -269,0 +269,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1215,0 +1264,15 @@\n+    static byte TRAILING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -1939,0 +2003,4 @@\n+\n+\n+\n+\n@@ -4581,0 +4649,36 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5443,0 +5547,227 @@\n+\n+\n+\n+\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+    static byte TRAILING_ZEROS_COUNT(byte a) {\n+        return (byte)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static byte LEADING_ZEROS_COUNT(byte a) {\n+        return (byte)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n@@ -5855,0 +6186,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5881,0 +6229,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByteMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5899,0 +6261,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByteMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1322,1 +1371,0 @@\n-\n@@ -1803,0 +1851,4 @@\n+\n+\n+\n+\n@@ -3337,0 +3389,36 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble128VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble128VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4649,0 +4737,27 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5040,0 +5155,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5082,0 +5214,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5101,0 +5247,8 @@\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":155,"deletions":1,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1322,1 +1371,0 @@\n-\n@@ -1803,0 +1851,4 @@\n+\n+\n+\n+\n@@ -3337,0 +3389,36 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble256VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble256VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4649,0 +4737,27 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5040,0 +5155,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5082,0 +5214,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5101,0 +5247,8 @@\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":155,"deletions":1,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1322,1 +1371,0 @@\n-\n@@ -1803,0 +1851,4 @@\n+\n+\n+\n+\n@@ -3337,0 +3389,36 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble512VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble512VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4649,0 +4737,27 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5040,0 +5155,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5082,0 +5214,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5101,0 +5247,8 @@\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":155,"deletions":1,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1322,1 +1371,0 @@\n-\n@@ -1803,0 +1851,4 @@\n+\n+\n+\n+\n@@ -3337,0 +3389,36 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble64VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble64VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4649,0 +4737,27 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5040,0 +5155,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5082,0 +5214,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5100,0 +5246,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":155,"deletions":1,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -269,0 +269,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1327,1 +1376,0 @@\n-\n@@ -1808,0 +1856,4 @@\n+\n+\n+\n+\n@@ -3342,0 +3394,36 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDoubleMaxVectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDoubleMaxVectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4654,0 +4742,27 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5045,0 +5160,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5071,0 +5203,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDoubleMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5090,0 +5236,8 @@\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDoubleMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":155,"deletions":1,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1332,1 +1381,0 @@\n-\n@@ -1813,0 +1861,4 @@\n+\n+\n+\n+\n@@ -3347,0 +3399,36 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat128VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat128VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4617,0 +4705,27 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5018,0 +5133,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5060,0 +5192,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5078,0 +5224,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":155,"deletions":1,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1332,1 +1381,0 @@\n-\n@@ -1813,0 +1861,4 @@\n+\n+\n+\n+\n@@ -3347,0 +3399,36 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat256VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat256VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4617,0 +4705,27 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5018,0 +5133,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5060,0 +5192,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5078,0 +5224,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":155,"deletions":1,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1332,1 +1381,0 @@\n-\n@@ -1813,0 +1861,4 @@\n+\n+\n+\n+\n@@ -3347,0 +3399,36 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat512VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat512VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4617,0 +4705,27 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5018,0 +5133,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5060,0 +5192,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5078,0 +5224,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":155,"deletions":1,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1332,1 +1381,0 @@\n-\n@@ -1813,0 +1861,4 @@\n+\n+\n+\n+\n@@ -3347,0 +3399,36 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat64VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat64VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4617,0 +4705,27 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5018,0 +5133,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5060,0 +5192,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5078,0 +5224,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":155,"deletions":1,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -269,0 +269,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1337,1 +1386,0 @@\n-\n@@ -1818,0 +1866,4 @@\n+\n+\n+\n+\n@@ -3352,0 +3404,36 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloatMaxVectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloatMaxVectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -4622,0 +4710,27 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5023,0 +5138,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5049,0 +5181,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloatMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5067,0 +5213,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloatMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":155,"deletions":1,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -264,0 +265,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1170,0 +1220,12 @@\n+    static int TRAILING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n@@ -1899,0 +1961,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n@@ -4541,0 +4691,36 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5403,0 +5589,227 @@\n+\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static int TRAILING_ZEROS_COUNT(int a) {\n+        return (int)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static int LEADING_ZEROS_COUNT(int a) {\n+        return (int)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5804,0 +6217,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5846,0 +6276,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5863,0 +6307,8 @@\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -264,0 +265,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1170,0 +1220,12 @@\n+    static int TRAILING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n@@ -1899,0 +1961,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n@@ -4541,0 +4691,36 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5403,0 +5589,227 @@\n+\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static int TRAILING_ZEROS_COUNT(int a) {\n+        return (int)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static int LEADING_ZEROS_COUNT(int a) {\n+        return (int)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5804,0 +6217,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5846,0 +6276,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5863,0 +6307,8 @@\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -264,0 +265,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1170,0 +1220,12 @@\n+    static int TRAILING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n@@ -1899,0 +1961,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n@@ -4541,0 +4691,36 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5403,0 +5589,227 @@\n+\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static int TRAILING_ZEROS_COUNT(int a) {\n+        return (int)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static int LEADING_ZEROS_COUNT(int a) {\n+        return (int)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5804,0 +6217,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5846,0 +6276,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5863,0 +6307,8 @@\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -264,0 +265,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1170,0 +1220,12 @@\n+    static int TRAILING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n@@ -1899,0 +1961,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n@@ -4541,0 +4691,36 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5403,0 +5589,227 @@\n+\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static int TRAILING_ZEROS_COUNT(int a) {\n+        return (int)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static int LEADING_ZEROS_COUNT(int a) {\n+        return (int)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5804,0 +6217,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5846,0 +6276,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5863,0 +6307,8 @@\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -269,0 +270,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1175,0 +1225,12 @@\n+    static int TRAILING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n@@ -1904,0 +1966,88 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(CompressExpandTest.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n@@ -4546,0 +4696,36 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5408,0 +5594,227 @@\n+\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static int TRAILING_ZEROS_COUNT(int a) {\n+        return (int)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static int LEADING_ZEROS_COUNT(int a) {\n+        return (int)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5809,0 +6222,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5835,0 +6265,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongIntMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5852,0 +6296,8 @@\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongIntMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -221,0 +222,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1192,0 +1242,12 @@\n+    static long TRAILING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n@@ -1921,0 +1983,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::EXPAND_BITS);\n+    }\n+\n+\n@@ -4491,0 +4641,36 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5353,0 +5539,227 @@\n+\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static long TRAILING_ZEROS_COUNT(long a) {\n+        return (long)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static long LEADING_ZEROS_COUNT(long a) {\n+        return (long)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5688,0 +6101,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5730,0 +6160,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5748,0 +6192,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -221,0 +222,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1192,0 +1242,12 @@\n+    static long TRAILING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n@@ -1921,0 +1983,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::EXPAND_BITS);\n+    }\n+\n+\n@@ -4491,0 +4641,36 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5353,0 +5539,227 @@\n+\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static long TRAILING_ZEROS_COUNT(long a) {\n+        return (long)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static long LEADING_ZEROS_COUNT(long a) {\n+        return (long)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5688,0 +6101,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5730,0 +6160,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5748,0 +6192,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -221,0 +222,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1192,0 +1242,12 @@\n+    static long TRAILING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n@@ -1921,0 +1983,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::EXPAND_BITS);\n+    }\n+\n+\n@@ -4491,0 +4641,36 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5353,0 +5539,227 @@\n+\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static long TRAILING_ZEROS_COUNT(long a) {\n+        return (long)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static long LEADING_ZEROS_COUNT(long a) {\n+        return (long)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5688,0 +6101,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5730,0 +6160,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5748,0 +6192,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -221,0 +222,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1192,0 +1242,12 @@\n+    static long TRAILING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n@@ -1921,0 +1983,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::EXPAND_BITS);\n+    }\n+\n+\n@@ -4491,0 +4641,36 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5353,0 +5539,227 @@\n+\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static long TRAILING_ZEROS_COUNT(long a) {\n+        return (long)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static long LEADING_ZEROS_COUNT(long a) {\n+        return (long)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5688,0 +6101,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5730,0 +6160,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5748,0 +6192,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import compress.CompressExpandTest;\n@@ -226,0 +227,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1197,0 +1247,12 @@\n+    static long TRAILING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n@@ -1926,0 +1988,88 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(CompressExpandTest.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+\n@@ -4496,0 +4646,36 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5358,0 +5544,227 @@\n+\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    static long TRAILING_ZEROS_COUNT(long a) {\n+        return (long)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static long LEADING_ZEROS_COUNT(long a) {\n+        return (long)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n+\n+\n+\n@@ -5693,0 +6106,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5719,0 +6149,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLongMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5737,0 +6181,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLongMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1200,0 +1249,16 @@\n+    static short TRAILING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -1924,0 +1989,4 @@\n+\n+\n+\n+\n@@ -4566,0 +4635,36 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5428,0 +5533,227 @@\n+\n+\n+\n+\n+\n+\n+\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    static short TRAILING_ZEROS_COUNT(short a) {\n+        return (short)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static short LEADING_ZEROS_COUNT(short a) {\n+        return (short)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::REVERSE);\n+    }\n+\n+\n+\n+\n+\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n@@ -5829,0 +6161,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5871,0 +6220,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5889,0 +6252,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":371,"deletions":0,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1200,0 +1249,16 @@\n+    static short TRAILING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -1924,0 +1989,4 @@\n+\n+\n+\n+\n@@ -4566,0 +4635,36 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5428,0 +5533,227 @@\n+\n+\n+\n+\n+\n+\n+\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    static short TRAILING_ZEROS_COUNT(short a) {\n+        return (short)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static short LEADING_ZEROS_COUNT(short a) {\n+        return (short)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::REVERSE);\n+    }\n+\n+\n+\n+\n+\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n@@ -5829,0 +6161,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5871,0 +6220,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5889,0 +6252,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":371,"deletions":0,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1200,0 +1249,16 @@\n+    static short TRAILING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -1924,0 +1989,4 @@\n+\n+\n+\n+\n@@ -4566,0 +4635,36 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5428,0 +5533,227 @@\n+\n+\n+\n+\n+\n+\n+\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    static short TRAILING_ZEROS_COUNT(short a) {\n+        return (short)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static short LEADING_ZEROS_COUNT(short a) {\n+        return (short)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::REVERSE);\n+    }\n+\n+\n+\n+\n+\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n@@ -5829,0 +6161,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5871,0 +6220,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5889,0 +6252,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":371,"deletions":0,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1200,0 +1249,16 @@\n+    static short TRAILING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -1924,0 +1989,4 @@\n+\n+\n+\n+\n@@ -4566,0 +4635,36 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5428,0 +5533,227 @@\n+\n+\n+\n+\n+\n+\n+\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    static short TRAILING_ZEROS_COUNT(short a) {\n+        return (short)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static short LEADING_ZEROS_COUNT(short a) {\n+        return (short)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::REVERSE);\n+    }\n+\n+\n+\n+\n+\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n@@ -5829,0 +6161,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5871,0 +6220,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5889,0 +6252,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":371,"deletions":0,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -269,0 +269,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1205,0 +1254,16 @@\n+    static short TRAILING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -1929,0 +1994,4 @@\n+\n+\n+\n+\n@@ -4571,0 +4640,36 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n@@ -5433,0 +5538,227 @@\n+\n+\n+\n+\n+\n+\n+\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::BIT_COUNT);\n+    }\n+\n+\n+\n+    static short TRAILING_ZEROS_COUNT(short a) {\n+        return (short)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static short LEADING_ZEROS_COUNT(short a) {\n+        return (short)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::REVERSE);\n+    }\n+\n+\n+\n+\n+\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+\n+\n+\n+\n@@ -5834,0 +6166,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5860,0 +6209,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShortMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5878,0 +6241,8 @@\n+    }\n+\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShortMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":371,"deletions":0,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+compressexpand_template=\"CompressExpand\"\n@@ -413,0 +414,2 @@\n+gen_binary_alu_op \"COMPRESS_BITS\" \"CompressExpandTest.compress(a, b)\" \"intOrLong\"\n+gen_binary_alu_op \"EXPAND_BITS\" \"CompressExpandTest.expand(a, b)\" \"intOrLong\"\n@@ -511,0 +514,3 @@\n+# Compress\/Expand\n+gen_op_tmpl $compressexpand_template \"compress_expand\" \"\"\n+\n@@ -565,0 +571,9 @@\n+gen_unary_alu_op \"BIT_COUNT\" \"\\$Boxtype\\$.bitCount(a)\" \"intOrLong\"\n+gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFF)\" \"byte\"\n+gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFFFF)\" \"short\"\n+gen_unary_alu_op \"TRAILING_ZEROS_COUNT\" \"TRAILING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n+gen_unary_alu_op \"LEADING_ZEROS_COUNT\" \"LEADING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n+gen_unary_alu_op \"REVERSE\" \"REVERSE_scalar(a)\" \"BITWISE\"\n+gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"intOrLong\"\n+gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"short\"\n+gen_unary_alu_op \"REVERSE_BYTES\" \"a\" \"byte\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import compress.CompressExpandTest;\n@@ -56,0 +57,1 @@\n+import compress.CompressExpandTest;\n@@ -295,0 +297,49 @@\n+    static void assertcompressArraysEquals($type$[] r, $type$[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], ($type$)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals($type$[] r, $type$[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], ($type$)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1456,1 +1507,44 @@\n-#end[BITWISE]\n+    static $type$ TRAILING_ZEROS_COUNT_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfTrailingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+#else[short]\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ LEADING_ZEROS_COUNT_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfLeadingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+#else[short]\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ REVERSE_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.reverse(a);\n+#else[intOrLong]\n+#if[short]\n+        $type$ b = ROL_scalar(a, ($type$) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+#else[short]\n+        $type$ b = ($type$) ROL_scalar(a, ($type$) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+#end[BITWISE]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":95,"deletions":1,"binary":false,"changes":96,"status":"modified"}]}