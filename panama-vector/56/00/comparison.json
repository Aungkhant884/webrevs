{"files":[{"patch":"@@ -3308,0 +3308,64 @@\n+\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP tmp2, TEMP pTmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_index $tmp, S, 0, 1\\n\\t\"\n+            \"sve_dup $tmp2, S, $idx\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp, $tmp2\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector (F)\" %}\n+  ins_encode %{\n+    Assembler::SIMD_RegVariant size =\n+              elemType_to_regVariant(vector_element_basic_type(this));\n+    __ sve_index(as_FloatRegister($tmp$$reg), __ S, 0, 1);\n+    __ sve_dup(as_FloatRegister($tmp2$$reg), __ S, (int)($idx$$constant));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($tmp$$reg), as_FloatRegister($tmp2$$reg));\n+    \/\/ If src and dst are the same reg, this move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD(vReg dst, vReg src, vRegD val, immI idx, vReg tmp, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP tmp2, TEMP pTmp, KILL cr);\n+  ins_cost(5 * SVE_COST);\n+  format %{ \"sve_index $tmp, D, 0, 1\\n\\t\"\n+            \"sve_dup $tmp2, D, $idx\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp, $tmp2\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector (D)\" %}\n+  ins_encode %{\n+    Assembler::SIMD_RegVariant size =\n+              elemType_to_regVariant(vector_element_basic_type(this));\n+    __ sve_index(as_FloatRegister($tmp$$reg), __ D, 0, 1);\n+    __ sve_dup(as_FloatRegister($tmp2$$reg), __ D, (int)($idx$$constant));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n+                 as_FloatRegister($tmp$$reg), as_FloatRegister($tmp2$$reg));\n+    \/\/ If src and dst are the same reg, this move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1925,0 +1925,2 @@\n+VECTOR_INSERT(F, vRegF,      S, FloatRegister)\n+VECTOR_INSERT(D, vRegD,      D, FloatRegister)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}