{"files":[{"patch":"@@ -3181,1 +3181,142 @@\n-instruct insertB(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n+instruct insertB_small(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $tmp, B, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp, ($idx-#16) \/\/ shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector (B)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($tmp$$reg), __ B, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ B, ptrue,\n+                 as_FloatRegister($tmp$$reg), (int)($idx$$constant) - 16);\n+    \/\/ If src and dst are the same reg, this move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertS_small(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $tmp, H, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp, ($idx-#16) \/\/ shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector (S)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($tmp$$reg), __ H, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ H, ptrue,\n+                 as_FloatRegister($tmp$$reg), (int)($idx$$constant) - 16);\n+    \/\/ If src and dst are the same reg, this move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ H,\n+               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $tmp, S, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp, ($idx-#16) \/\/ shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector (I)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($tmp$$reg), __ S, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp$$reg), (int)($idx$$constant) - 16);\n+    \/\/ If src and dst are the same reg, this move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, vReg tmp, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $tmp, S, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp, ($idx-#16) \/\/ shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector (F)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($tmp$$reg), __ S, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp$$reg), (int)($idx$$constant) - 16);\n+    \/\/ If src and dst are the same reg, this move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct insertL_d(vReg dst, vReg src, iRegL val, immI idx, vReg tmp, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $tmp, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp, ($idx-#16) \/\/ shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector (L)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($tmp$$reg), __ D, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($tmp$$reg), (int)($idx$$constant) - 16);\n+    \/\/ If src and dst are the same reg, this move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_d(vReg dst, vReg src, vRegD val, immI idx, vReg tmp, pRegGov pTmp, rFlagsReg cr)\n@@ -3184,0 +3325,29 @@\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $tmp, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp, ($idx-#16) \/\/ shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector (D)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($tmp$$reg), __ D, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($tmp$$reg), (int)($idx$$constant) - 16);\n+    \/\/ If src and dst are the same reg, this move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n+instruct insertB(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n@@ -3186,1 +3356,1 @@\n-  effect(TEMP tmp, TEMP tmp2, TEMP pTmp, KILL cr);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n@@ -3188,1 +3358,1 @@\n-  format %{ \"sve_index $tmp, B, 0, 1\\n\\t\"\n+  format %{ \"sve_index $tmp1, B, 0, 1\\n\\t\"\n@@ -3190,1 +3360,1 @@\n-            \"sve_cmpeq $pTmp, $tmp, $tmp2\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp1, $tmp2\\n\\t\"\n@@ -3194,3 +3364,1 @@\n-    Assembler::SIMD_RegVariant size =\n-              elemType_to_regVariant(vector_element_basic_type(this));\n-    __ sve_index(as_FloatRegister($tmp$$reg), __ B, 0, 1);\n+    __ sve_index(as_FloatRegister($tmp1$$reg), __ B, 0, 1);\n@@ -3198,2 +3366,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($tmp$$reg), as_FloatRegister($tmp2$$reg));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ B, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg));\n@@ -3213,1 +3381,1 @@\n-instruct insertS(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n+instruct insertS(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n@@ -3215,1 +3383,1 @@\n-  predicate(UseSVE > 0 &&\n+  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n@@ -3218,1 +3386,1 @@\n-  effect(TEMP tmp, TEMP tmp2, TEMP pTmp, KILL cr);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n@@ -3220,1 +3388,1 @@\n-  format %{ \"sve_index $tmp, H, 0, 1\\n\\t\"\n+  format %{ \"sve_index $tmp1, H, 0, 1\\n\\t\"\n@@ -3222,1 +3390,1 @@\n-            \"sve_cmpeq $pTmp, $tmp, $tmp2\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp1, $tmp2\\n\\t\"\n@@ -3226,3 +3394,1 @@\n-    Assembler::SIMD_RegVariant size =\n-              elemType_to_regVariant(vector_element_basic_type(this));\n-    __ sve_index(as_FloatRegister($tmp$$reg), __ H, 0, 1);\n+    __ sve_index(as_FloatRegister($tmp1$$reg), __ H, 0, 1);\n@@ -3230,2 +3396,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($tmp$$reg), as_FloatRegister($tmp2$$reg));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ H, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg));\n@@ -3245,1 +3411,1 @@\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n@@ -3247,1 +3413,1 @@\n-  predicate(UseSVE > 0 &&\n+  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n@@ -3250,1 +3416,1 @@\n-  effect(TEMP tmp, TEMP tmp2, TEMP pTmp, KILL cr);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n@@ -3252,1 +3418,1 @@\n-  format %{ \"sve_index $tmp, S, 0, 1\\n\\t\"\n+  format %{ \"sve_index $tmp1, S, 0, 1\\n\\t\"\n@@ -3254,1 +3420,1 @@\n-            \"sve_cmpeq $pTmp, $tmp, $tmp2\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp1, $tmp2\\n\\t\"\n@@ -3258,3 +3424,1 @@\n-    Assembler::SIMD_RegVariant size =\n-              elemType_to_regVariant(vector_element_basic_type(this));\n-    __ sve_index(as_FloatRegister($tmp$$reg), __ S, 0, 1);\n+    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n@@ -3262,2 +3426,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($tmp$$reg), as_FloatRegister($tmp2$$reg));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg));\n@@ -3277,1 +3441,1 @@\n-instruct insertL(vReg dst, vReg src, iRegL val, immI idx, vReg tmp, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n@@ -3279,2 +3443,2 @@\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -3282,1 +3446,1 @@\n-  effect(TEMP tmp, TEMP tmp2, TEMP pTmp, KILL cr);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n@@ -3284,3 +3448,3 @@\n-  format %{ \"sve_index $tmp, D, 0, 1\\n\\t\"\n-            \"sve_dup $tmp2, D, $idx\\n\\t\"\n-            \"sve_cmpeq $pTmp, $tmp, $tmp2\\n\\t\"\n+  format %{ \"sve_index $tmp1, S, 0, 1\\n\\t\"\n+            \"sve_dup $tmp2, S, $idx\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp1, $tmp2\\n\\t\"\n@@ -3288,1 +3452,1 @@\n-            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector (L)\" %}\n+            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector (F)\" %}\n@@ -3290,6 +3454,4 @@\n-    Assembler::SIMD_RegVariant size =\n-              elemType_to_regVariant(vector_element_basic_type(this));\n-    __ sve_index(as_FloatRegister($tmp$$reg), __ D, 0, 1);\n-    __ sve_dup(as_FloatRegister($tmp2$$reg), __ D, (int)($idx$$constant));\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($tmp$$reg), as_FloatRegister($tmp2$$reg));\n+    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n+    __ sve_dup(as_FloatRegister($tmp2$$reg), __ S, (int)($idx$$constant));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg));\n@@ -3302,2 +3464,2 @@\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n-               as_PRegister($pTmp$$reg), as_Register($val$$reg));\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+               as_PRegister($pTmp$$reg), as_FloatRegister($val$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":207,"deletions":45,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -1888,2 +1888,36 @@\n-define(`VECTOR_INSERT', `\n-instruct insert$1`'(vReg dst, vReg src, $2 val, immI idx, vReg tmp, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n+define(`VECTOR_INSERT_SMALL', `\n+instruct insert$1_small`'(vReg dst, vReg src, $2 val, immI idx, vReg tmp, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $tmp, $3, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp, ($idx-#16) \/\/ shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector ($1)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($tmp$$reg), __ $3, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ $3, ptrue,\n+                 as_FloatRegister($tmp$$reg), (int)($idx$$constant) - 16);\n+    \/\/ If src and dst are the same reg, this move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3,\n+               as_PRegister($pTmp$$reg), as_$4($val$$reg));\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl                 $1 $2          $3 $4\n+VECTOR_INSERT_SMALL(B, iRegIorL2I, B, Register)\n+VECTOR_INSERT_SMALL(S, iRegIorL2I, H, Register)\n+VECTOR_INSERT_SMALL(I, iRegIorL2I, S, Register)\n+VECTOR_INSERT_SMALL(F, vRegF,      S, FloatRegister)\n+\n+define(`VECTOR_INSERT_D', `\n+instruct insert$1_d`'(vReg dst, vReg src, $2 val, immI idx, vReg tmp, pRegGov pTmp, rFlagsReg cr)\n@@ -1894,1 +1928,33 @@\n-  effect(TEMP tmp, TEMP tmp2, TEMP pTmp, KILL cr);\n+  effect(TEMP tmp, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $tmp, $3, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp, ($idx-#16) \/\/ shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pTmp, $val\\n\\t# insert into vector ($1)\" %}\n+  ins_encode %{\n+    __ sve_index(as_FloatRegister($tmp$$reg), __ $3, -16, 1);\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ $3, ptrue,\n+                 as_FloatRegister($tmp$$reg), (int)($idx$$constant) - 16);\n+    \/\/ If src and dst are the same reg, this move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3,\n+               as_PRegister($pTmp$$reg), as_$4($val$$reg));\n+\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl             $1 $2     $3 $4\n+VECTOR_INSERT_D(L, iRegL, D, Register)\n+VECTOR_INSERT_D(D, vRegD, D, FloatRegister)\n+\n+define(`VECTOR_INSERT', `\n+instruct insert$1`'(vReg dst, vReg src, $2 val, immI idx, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr)\n+%{\n+  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n@@ -1896,1 +1962,1 @@\n-  format %{ \"sve_index $tmp, $3, 0, 1\\n\\t\"\n+  format %{ \"sve_index $tmp1, $3, 0, 1\\n\\t\"\n@@ -1898,1 +1964,1 @@\n-            \"sve_cmpeq $pTmp, $tmp, $tmp2\\n\\t\"\n+            \"sve_cmpeq $pTmp, $tmp1, $tmp2\\n\\t\"\n@@ -1902,3 +1968,1 @@\n-    Assembler::SIMD_RegVariant size =\n-              elemType_to_regVariant(vector_element_basic_type(this));\n-    __ sve_index(as_FloatRegister($tmp$$reg), __ $3, 0, 1);\n+    __ sve_index(as_FloatRegister($tmp1$$reg), __ $3, 0, 1);\n@@ -1906,2 +1970,2 @@\n-    __ sve_cmpeq(as_PRegister($pTmp$$reg), size, ptrue,\n-                 as_FloatRegister($tmp$$reg), as_FloatRegister($tmp2$$reg));\n+    __ sve_cmpeq(as_PRegister($pTmp$$reg), __ $3, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($tmp2$$reg));\n@@ -1924,1 +1988,1 @@\n-VECTOR_INSERT(L, iRegL,      D, Register)\n+VECTOR_INSERT(F, vRegF,      S, FloatRegister)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":75,"deletions":11,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -3543,2 +3543,2 @@\n-    f(imm2, 20, 16), f(0b010000, 15, 10);\n-    f(imm1, 9, 5), rf(Zd, 0);\n+    sf(imm2, 20, 16), f(0b010000, 15, 10);\n+    sf(imm1, 9, 5), rf(Zd, 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}