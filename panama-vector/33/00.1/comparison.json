{"files":[{"patch":"@@ -427,9 +427,16 @@\n-\t  $$(call ExecuteWithLog, $$@, $$(call MakeCommandRelative, \\\n-\t      $$($1_COMPILER) -showIncludes $$($1_COMPILE_OPTIONS))) \\\n-\t      | $(TR) -d '\\r' | $(GREP) -v -e \"^Note: including file:\" \\\n-\t          -e \"^$$($1_FILENAME)$$$$\" || test \"$$$$?\" = \"1\" ; \\\n-\t  $(ECHO) $$@: \\\\ > $$($1_DEPS_FILE) ; \\\n-\t  $(SED) $(WINDOWS_SHOWINCLUDE_SED_PATTERN) $$($1_OBJ).log \\\n-\t      | $(SORT) -u >> $$($1_DEPS_FILE) ; \\\n-\t  $(ECHO) >> $$($1_DEPS_FILE) ; \\\n-\t  $(SED) $(DEPENDENCY_TARGET_SED_PATTERN) $$($1_DEPS_FILE) > $$($1_DEPS_TARGETS_FILE)\n+          ifeq ($$(filter %.s, $$($1_FILENAME)), )\n+\t    $$(call ExecuteWithLog, $$@, $$(call MakeCommandRelative, \\\n+\t        $$($1_COMPILER) -showIncludes $$($1_COMPILE_OPTIONS))) \\\n+\t        | $(TR) -d '\\r' | $(GREP) -v -e \"^Note: including file:\" \\\n+\t            -e \"^$$($1_FILENAME)$$$$\" || test \"$$$$?\" = \"1\" ; \\\n+\t    $(ECHO) $$@: \\\\ > $$($1_DEPS_FILE) ; \\\n+\t    $(SED) $(WINDOWS_SHOWINCLUDE_SED_PATTERN) $$($1_OBJ).log \\\n+\t        | $(SORT) -u >> $$($1_DEPS_FILE) ; \\\n+\t    $(ECHO) >> $$($1_DEPS_FILE) ; \\\n+\t    $(SED) $(DEPENDENCY_TARGET_SED_PATTERN) $$($1_DEPS_FILE) > $$($1_DEPS_TARGETS_FILE)\n+          else\n+            # For assembler calls, no need to build dependency list.\n+\t    $$(call ExecuteWithLog, $$@, $$(call MakeCommandRelative, \\\n+\t        $$($1_COMPILER) $$($1_FLAGS) \\\n+\t          $(CC_OUT_OPTION)$$($1_OBJ) \/Ta $$($1_SRC_FILE)))\n+          endif\n","filename":"make\/common\/NativeCompilation.gmk","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2445,0 +2445,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n@@ -2493,0 +2507,4 @@\n+    if (bt == T_BOOLEAN) {\n+      \/\/ To support vector api load\/store mask.\n+      return MaxVectorSize \/ 8;\n+    }\n@@ -2520,1 +2538,1 @@\n-  if (UseSVE > 0 && 16 <= len && len <= 256) {\n+  if (UseSVE > 0 && 2 <= len && len <= 256) {\n@@ -16604,1 +16622,1 @@\n-  predicate(n->as_LoadVector()->memory_size() == 4);\n+  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 4);\n@@ -16615,1 +16633,1 @@\n-  predicate(n->as_LoadVector()->memory_size() == 8);\n+  predicate(UseSVE == 0 && n->as_LoadVector()->memory_size() == 8);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3207,1 +3207,1 @@\n-  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, int imm8) {\n+  void sve_dup(FloatRegister Zd, SIMD_RegVariant T, int imm16) {\n@@ -3211,1 +3211,2 @@\n-    if (imm8 <= 127 && imm8 >= -128) {\n+    unsigned imm = imm16;\n+    if (imm16 <= 127 && imm16 >= -128) {\n@@ -3213,1 +3214,1 @@\n-    } else if (T != B && imm8 <= 32512 && imm8 >= -32768 && (imm8 & 0xff) == 0) {\n+    } else if (T != B && imm16 <= 32512 && imm16 >= -32768 && (imm16 & 0xff) == 0) {\n@@ -3215,1 +3216,1 @@\n-      imm8 = (imm8 >> 8);\n+      imm = (imm >> 8);\n@@ -3219,0 +3220,2 @@\n+    unsigned mask = (1U << 8) - 1;\n+    imm &= mask;\n@@ -3220,1 +3223,1 @@\n-    f(sh, 13), sf(imm8, 12, 5), rf(Zd, 0);\n+    f(sh, 13), f(imm, 12, 5), rf(Zd, 0);\n@@ -3229,0 +3232,124 @@\n+   \/\/ SVE cpy immediate\n+  void sve_cpy(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg, int imm16, bool isMerge) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    int sh = 0;\n+    unsigned imm = imm16;\n+    if (imm16 <= 127 && imm16 >= -128) {\n+      sh = 0;\n+    } else if (T != B && imm16 <= 32512 && imm16 >= -32768 && (imm16 & 0xff) == 0) {\n+      sh = 1;\n+      imm = (imm >> 8);\n+    } else {\n+      guarantee(false, \"invalid immediate\");\n+    }\n+    unsigned mask = (1U << 8) - 1;\n+    imm &= mask;\n+    int m = isMerge ? 1 : 0;\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b01, 21, 20);\n+    prf(Pg, 16), f(0b0, 15), f(m, 14), f(sh, 13), f(imm, 12, 5), rf(Zd, 0);\n+  }\n+\n+  \/\/ SVE vector sel\n+  void sve_sel(FloatRegister Zd,\n+               SIMD_RegVariant T,\n+               PRegister Pg,\n+               FloatRegister Zn,\n+               FloatRegister Zm) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);\n+    f(0b11, 15, 14), prf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n+\/\/ SVE compare vector\n+#define INSN(NAME, op, cond, fp)  \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, FloatRegister Zm)  { \\\n+    starti;                                                                                       \\\n+    if (fp == 0) {                                                                                \\\n+      assert(T != Q, \"invalid size\");                                                             \\\n+    } else {                                                                                      \\\n+      assert(T != B && T != Q, \"invalid size\");                                                   \\\n+    }                                                                                             \\\n+    f(op, 31, 24), f(T, 23, 22), f(0b0, 21), rf(Zm, 16), f((cond >> 1) & 0x7, 15, 13);            \\\n+    pgrf(Pg, 10), rf(Zn, 5), f(cond & 0x1, 4), prf(Pd, 0);                                        \\\n+  }\n+\n+  INSN(sve_cmpeq, 0b00100100, 0b1010, 0);\n+  INSN(sve_cmpne, 0b00100100, 0b1011, 0);\n+  INSN(sve_cmpge, 0b00100100, 0b1000, 0);\n+  INSN(sve_cmpgt, 0b00100100, 0b1001, 0);\n+  INSN(sve_fcmeq, 0b01100101, 0b0110, 1);\n+  INSN(sve_fcmne, 0b01100101, 0b0111, 1);\n+  INSN(sve_fcmgt, 0b01100101, 0b0101, 1);\n+  INSN(sve_fcmge, 0b01100101, 0b0100, 1);\n+#undef INSN\n+\n+\/\/ SVE compare vector with immediate\n+#define INSN(NAME, cond)  \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pg, FloatRegister Zn, int imm5) { \\\n+    starti;                                                                              \\\n+    assert(T != Q, \"invalid size\");                                                      \\\n+    if (imm5 > 15 || imm5 < -16) {                                                       \\\n+      guarantee(false, \"invalid immediate\");                                             \\\n+    }                                                                                    \\\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b0, 21), sf(imm5, 20, 16),                   \\\n+    f((cond >> 1) & 0x7, 15, 13), pgrf(Pg, 10), rf(Zn, 5), f(cond & 0x1, 4), prf(Pd, 0); \\\n+  }\n+\n+  INSN(sve_cmpeq, 0b1000);\n+  INSN(sve_cmpne, 0b1001);\n+  INSN(sve_cmpgt, 0b0001);\n+  INSN(sve_cmpge, 0b0000);\n+  INSN(sve_cmplt, 0b0010);\n+  INSN(sve_cmple, 0b0011);\n+#undef INSN\n+\n+\/\/ SVE unpack and extend\n+#define INSN(NAME, op) \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn) { \\\n+    starti;                                                          \\\n+    assert(T != B && T != Q, \"invalid size\");                        \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1100, 21, 18);          \\\n+    f(op, 17, 16), f(0b001110, 15, 10), rf(Zn, 5), rf(Zd, 0);        \\\n+  }\n+\n+  INSN(sve_uunpkhi, 0b11);\n+  INSN(sve_uunpklo, 0b10);\n+  INSN(sve_sunpkhi, 0b01);\n+  INSN(sve_sunpklo, 0b00);\n+#undef INSN\n+\n+\/\/ SVE vector uzp1,uzp2\n+#define INSN(NAME, op) \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) { \\\n+    starti;                                                                            \\\n+    assert(T != Q, \"invalid size\");                                                    \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);                       \\\n+    f(0b01101, 15, 11), f(op, 10), rf(Zn, 5), rf(Zd, 0);                               \\\n+  }\n+\n+  INSN(sve_uzp1, 0b0);\n+  INSN(sve_uzp2, 0b1);\n+#undef INSN\n+\n+\/\/ SVE while[cond]\n+#define INSN(NAME, decode, sf)                                            \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, Register Rn, Register Rm) {  \\\n+    starti;                                                               \\\n+    assert(T != Q, \"invalid register variant\");                           \\\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(1, 21),                        \\\n+    zrf(Rm, 16), f(0, 15, 13), f(sf, 12), f(decode >> 1, 11, 10),         \\\n+    zrf(Rn, 5), f(decode & 0b1, 4), prf(Pd, 0);                           \\\n+  }\n+\n+  INSN(sve_whilelt,  0b010, 1);\n+  INSN(sve_whileltw, 0b010, 0);\n+  INSN(sve_whilele,  0b011, 1);\n+  INSN(sve_whilelew, 0b011, 0);\n+  INSN(sve_whilelo,  0b110, 1);\n+  INSN(sve_whilelow, 0b110, 0);\n+  INSN(sve_whilels,  0b111, 1);\n+  INSN(sve_whilelsw, 0b111, 0);\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":132,"deletions":5,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -856,0 +856,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1000,0 +1000,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -366,0 +366,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2158,0 +2158,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -928,0 +928,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1553,0 +1553,14 @@\n+\/\/ Vector calling convention not yet implemented.\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -862,0 +862,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1033,0 +1033,8 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(!Matcher::supports_vector_calling_convention(), \"not implemented\");\n+  Unimplemented();\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1137,0 +1137,25 @@\n+int SharedRuntime::vector_calling_convention(VMRegPair *regs,\n+                                             uint num_bits,\n+                                             uint total_args_passed) {\n+  assert(num_bits == 64 || num_bits == 128 || num_bits == 256 || num_bits == 512,\n+         \"only certain vector sizes are supported for now\");\n+\n+  static const XMMRegister VEC_ArgReg[32] = {\n+     xmm0,  xmm1,  xmm2,  xmm3,  xmm4,  xmm5,  xmm6,  xmm7,\n+     xmm8,  xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15,\n+    xmm16, xmm17, xmm18, xmm19, xmm20, xmm21, xmm22, xmm23,\n+    xmm24, xmm25, xmm26, xmm27, xmm28, xmm29, xmm30, xmm31\n+  };\n+\n+  uint stk_args = 0;\n+  uint fp_args = 0;\n+\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[fp_args++]->as_VMReg();\n+    int next_val = num_bits == 64 ? 1 : (num_bits == 128 ? 3 : (num_bits  == 256 ? 7 : 15));\n+    regs[i].set_pair(vmreg->next(next_val), vmreg);\n+  }\n+\n+  return stk_args;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -57,0 +57,277 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+\/\/ Vector API SVML routines written in assembly\n+extern \"C\"\n+{\n+   float __svml_expf4_ha_ex(float a);\n+   double __svml_exp1_ha_ex(double a);\n+   double __svml_exp2_ha_ex(double a);\n+   float __svml_expf4_ha_l9(float a);\n+   float __svml_expf8_ha_l9(float a);\n+   float __svml_expf4_ha_e9(float a);\n+   float __svml_expf8_ha_e9(float a);\n+   float __svml_expf16_ha_z0(float a);\n+   double __svml_exp1_ha_l9(double a);\n+   double __svml_exp2_ha_l9(double a);\n+   double __svml_exp4_ha_l9(double a);\n+   double __svml_exp1_ha_e9(double a);\n+   double __svml_exp2_ha_e9(double a);\n+   double __svml_exp4_ha_e9(double a);\n+   double __svml_exp8_ha_z0(double a);\n+   float  __svml_expm1f4_ha_ex(float a);\n+   double __svml_expm11_ha_ex(double a);\n+   double __svml_expm12_ha_ex(double a);\n+   float  __svml_expm1f4_ha_l9(float a);\n+   float  __svml_expm1f8_ha_l9(float a);\n+   float  __svml_expm1f4_ha_e9(float a);\n+   float  __svml_expm1f8_ha_e9(float a);\n+   float __svml_expm1f16_ha_z0(float a);\n+   double __svml_expm11_ha_l9(double a);\n+   double __svml_expm12_ha_l9(double a);\n+   double __svml_expm14_ha_l9(double a);\n+   double __svml_expm11_ha_e9(double a);\n+   double __svml_expm12_ha_e9(double a);\n+   double __svml_expm14_ha_e9(double a);\n+   double __svml_expm18_ha_z0(double a);\n+   float __svml_log1pf4_ha_l9(float a);\n+   float __svml_log1pf8_ha_l9(float a);\n+   float __svml_log1pf4_ha_e9(float a);\n+   float __svml_log1pf8_ha_e9(float a);\n+   float __svml_log1pf16_ha_z0(float a);\n+   double __svml_log1p1_ha_l9(double a);\n+   double __svml_log1p2_ha_l9(double a);\n+   double __svml_log1p4_ha_l9(double a);\n+   double __svml_log1p1_ha_e9(double a);\n+   double __svml_log1p2_ha_e9(double a);\n+   double __svml_log1p4_ha_e9(double a);\n+   double __svml_log1p8_ha_z0(double a);\n+   float __svml_logf4_ha_l9(float a);\n+   float __svml_logf8_ha_l9(float a);\n+   float __svml_logf4_ha_e9(float a);\n+   float __svml_logf8_ha_e9(float a);\n+   float __svml_logf16_ha_z0(float a);\n+   double __svml_log1_ha_l9(double a);\n+   double __svml_log2_ha_l9(double a);\n+   double __svml_log4_ha_l9(double a);\n+   double __svml_log1_ha_e9(double a);\n+   double __svml_log2_ha_e9(double a);\n+   double __svml_log4_ha_e9(double a);\n+   double __svml_log8_ha_z0(double a);\n+   float __svml_log10f4_ha_l9(float a);\n+   float __svml_log10f8_ha_l9(float a);\n+   float __svml_log10f4_ha_e9(float a);\n+   float __svml_log10f8_ha_e9(float a);\n+   float __svml_log10f16_ha_z0(float a);\n+   double __svml_log101_ha_l9(double a);\n+   double __svml_log102_ha_l9(double a);\n+   double __svml_log104_ha_l9(double a);\n+   double __svml_log101_ha_e9(double a);\n+   double __svml_log102_ha_e9(double a);\n+   double __svml_log104_ha_e9(double a);\n+   double __svml_log108_ha_z0(double a);\n+   float __svml_sinf4_ha_l9(float a);\n+   float __svml_sinf8_ha_l9(float a);\n+   float __svml_sinf4_ha_e9(float a);\n+   float __svml_sinf8_ha_e9(float a);\n+   float __svml_sinf16_ha_z0(float a);\n+   double __svml_sin1_ha_l9(double a);\n+   double __svml_sin2_ha_l9(double a);\n+   double __svml_sin4_ha_l9(double a);\n+   double __svml_sin1_ha_e9(double a);\n+   double __svml_sin2_ha_e9(double a);\n+   double __svml_sin4_ha_e9(double a);\n+   double __svml_sin8_ha_z0(double a);\n+   float __svml_cosf4_ha_l9(float a);\n+   float __svml_cosf8_ha_l9(float a);\n+   float __svml_cosf4_ha_e9(float a);\n+   float __svml_cosf8_ha_e9(float a);\n+   float __svml_cosf16_ha_z0(float a);\n+   double  __svml_cos1_ha_l9(double a);\n+   double  __svml_cos2_ha_l9(double a);\n+   double __svml_cos4_ha_l9(double a);\n+   double  __svml_cos1_ha_e9(double a);\n+   double  __svml_cos2_ha_e9(double a);\n+   double __svml_cos4_ha_e9(double a);\n+   double  __svml_cos8_ha_z0(double a);\n+   float __svml_tanf4_ha_l9(float a);\n+   float __svml_tanf8_ha_l9(float a);\n+   float __svml_tanf4_ha_e9(float a);\n+   float __svml_tanf8_ha_e9(float a);\n+   float __svml_tanf16_ha_z0(float a);\n+   double __svml_tan1_ha_l9(double a);\n+   double __svml_tan2_ha_l9(double a);\n+   double __svml_tan4_ha_l9(double a);\n+   double __svml_tan1_ha_e9(double a);\n+   double __svml_tan2_ha_e9(double a);\n+   double __svml_tan4_ha_e9(double a);\n+   double __svml_tan8_ha_z0(double a);\n+   double __svml_sinh1_ha_l9(double a);\n+   double __svml_sinh2_ha_l9(double a);\n+   double __svml_sinh4_ha_l9(double a);\n+   double __svml_sinh1_ha_e9(double a);\n+   double __svml_sinh2_ha_e9(double a);\n+   double __svml_sinh4_ha_e9(double a);\n+   double __svml_sinh8_ha_z0(double a);\n+   float __svml_sinhf4_ha_l9(float a);\n+   float __svml_sinhf8_ha_l9(float a);\n+   float __svml_sinhf4_ha_e9(float a);\n+   float __svml_sinhf8_ha_e9(float a);\n+   float __svml_sinhf16_ha_z0(float a);\n+   double __svml_cosh1_ha_l9(double a);\n+   double __svml_cosh2_ha_l9(double a);\n+   double __svml_cosh4_ha_l9(double a);\n+   double __svml_cosh1_ha_e9(double a);\n+   double __svml_cosh2_ha_e9(double a);\n+   double __svml_cosh4_ha_e9(double a);\n+   double __svml_cosh8_ha_z0(double a);\n+   float __svml_coshf4_ha_l9(float a);\n+   float __svml_coshf8_ha_l9(float a);\n+   float __svml_coshf4_ha_e9(float a);\n+   float __svml_coshf8_ha_e9(float a);\n+   float __svml_coshf16_ha_z0(float a);\n+   double __svml_tanh1_ha_l9(double a);\n+   double __svml_tanh2_ha_l9(double a);\n+   double __svml_tanh4_ha_l9(double a);\n+   double __svml_tanh1_ha_e9(double a);\n+   double __svml_tanh2_ha_e9(double a);\n+   double __svml_tanh4_ha_e9(double a);\n+   double __svml_tanh8_ha_z0(double a);\n+   float __svml_tanhf4_ha_l9(float a);\n+   float __svml_tanhf8_ha_l9(float a);\n+   float __svml_tanhf4_ha_e9(float a);\n+   float __svml_tanhf8_ha_e9(float a);\n+   float __svml_tanhf16_ha_z0(float a);\n+   float __svml_acosf4_ha_ex(float a);\n+   float __svml_acosf4_ha_l9(float a);\n+   float __svml_acosf8_ha_l9(float a);\n+   float __svml_acosf4_ha_e9(float a);\n+   float __svml_acosf8_ha_e9(float a);\n+   float __svml_acosf16_ha_z0(float a);\n+   double __svml_acos1_ha_ex(double a);\n+   double __svml_acos2_ha_ex(double a);\n+   double __svml_acos1_ha_l9(double a);\n+   double __svml_acos2_ha_l9(double a);\n+   double __svml_acos4_ha_l9(double a);\n+   double __svml_acos1_ha_e9(double a);\n+   double __svml_acos2_ha_e9(double a);\n+   double __svml_acos4_ha_e9(double a);\n+   double __svml_acos8_ha_z0(double a);\n+   float __svml_asinf4_ha_ex(float a);\n+   double __svml_asin1_ha_ex(double a);\n+   double __svml_asin2_ha_ex(double a);\n+   double __svml_asin1_ha_l9(double a);\n+   double __svml_asin2_ha_l9(double a);\n+   double __svml_asin4_ha_l9(double a);\n+   double __svml_asin1_ha_e9(double a);\n+   double __svml_asin2_ha_e9(double a);\n+   double __svml_asin4_ha_e9(double a);\n+   double __svml_asin8_ha_z0(double a);\n+   float __svml_asinf4_ha_l9(float a);\n+   float __svml_asinf8_ha_l9(float a);\n+   float __svml_asinf4_ha_e9(float a);\n+   float __svml_asinf8_ha_e9(float a);\n+   float __svml_asinf16_ha_z0(float a);\n+   float __svml_atanf4_ha_ex(float a);\n+   double __svml_atan1_ha_ex(double a);\n+   double __svml_atan2_ha_ex(double a);\n+   double __svml_atan1_ha_l9(double a);\n+   double __svml_atan2_ha_l9(double a);\n+   double __svml_atan4_ha_l9(double a);\n+   double __svml_atan1_ha_e9(double a);\n+   double __svml_atan2_ha_e9(double a);\n+   double __svml_atan4_ha_e9(double a);\n+   double __svml_atan8_ha_z0(double a);\n+   float __svml_atanf4_ha_l9(float a);\n+   float __svml_atanf8_ha_l9(float a);\n+   float __svml_atanf4_ha_e9(float a);\n+   float __svml_atanf8_ha_e9(float a);\n+   float __svml_atanf16_ha_z0(float a);\n+   float __svml_powf4_ha_l9(float a, float b);\n+   float __svml_powf8_ha_l9(float a, float b);\n+   float __svml_powf4_ha_e9(float a, float b);\n+   float __svml_powf8_ha_e9(float a, float b);\n+   float __svml_powf16_ha_z0(float a, float b);\n+   double __svml_pow1_ha_l9(double a, double b);\n+   double __svml_pow2_ha_l9(double a, double b);\n+   double __svml_pow4_ha_l9(double a, double b);\n+   double __svml_pow1_ha_e9(double a, double b);\n+   double __svml_pow2_ha_e9(double a, double b);\n+   double __svml_pow4_ha_e9(double a, double b);\n+   double __svml_pow8_ha_z0(double a, double b);\n+   float __svml_hypotf4_ha_l9(float a, float b);\n+   float __svml_hypotf8_ha_l9(float a, float b);\n+   float __svml_hypotf4_ha_e9(float a, float b);\n+   float __svml_hypotf8_ha_e9(float a, float b);\n+   float __svml_hypotf16_ha_z0(float a, float b);\n+   double __svml_hypot1_ha_l9(double a, double b);\n+   double __svml_hypot2_ha_l9(double a, double b);\n+   double __svml_hypot4_ha_l9(double a, double b);\n+   double __svml_hypot1_ha_e9(double a, double b);\n+   double __svml_hypot2_ha_e9(double a, double b);\n+   double __svml_hypot4_ha_e9(double a, double b);\n+   double __svml_hypot8_ha_z0(double a, double b);\n+   float __svml_cbrtf4_ha_l9(float a);\n+   float __svml_cbrtf8_ha_l9(float a);\n+   float __svml_cbrtf4_ha_e9(float a);\n+   float __svml_cbrtf8_ha_e9(float a);\n+   float __svml_cbrtf16_ha_z0(float a);\n+   double __svml_cbrt1_ha_l9(double a);\n+   double __svml_cbrt2_ha_l9(double a);\n+   double __svml_cbrt4_ha_l9(double a);\n+   double __svml_cbrt1_ha_e9(double a);\n+   double __svml_cbrt2_ha_e9(double a);\n+   double __svml_cbrt4_ha_e9(double a);\n+   double __svml_cbrt8_ha_z0(double a);\n+   float __svml_atan2f4_ha_l9(float a, float b);\n+   float __svml_atan2f8_ha_l9(float a, float b);\n+   float __svml_atan2f4_ha_e9(float a, float b);\n+   float __svml_atan2f8_ha_e9(float a, float b);\n+   float __svml_atan2f16_ha_z0(float a, float b);\n+   double __svml_atan21_ha_l9(double a, double b);\n+   double __svml_atan22_ha_l9(double a, double b);\n+   double __svml_atan24_ha_l9(double a, double b);\n+   double __svml_atan28_ha_z0(double a, double b);\n+   double __svml_atan21_ha_e9(double a, double b);\n+   double __svml_atan22_ha_e9(double a, double b);\n+   double __svml_atan24_ha_e9(double a, double b);\n+   float __svml_sinf4_ha_ex(float a);\n+   double __svml_sin1_ha_ex(double a);\n+   double __svml_sin2_ha_ex(double a);\n+   float __svml_cosf4_ha_ex(float a);\n+   double __svml_cos1_ha_ex(double a);\n+   double __svml_cos2_ha_ex(double a);\n+   float __svml_tanf4_ha_ex(float a);\n+   double __svml_tan1_ha_ex(double a);\n+   double __svml_tan2_ha_ex(double a);\n+   float __svml_sinhf4_ha_ex(float a);\n+   double __svml_sinh1_ha_ex(double a);\n+   double __svml_sinh2_ha_ex(double a);\n+   float __svml_coshf4_ha_ex(float a);\n+   double __svml_cosh1_ha_ex(double a);\n+   double __svml_cosh2_ha_ex(double a);\n+   float __svml_tanhf4_ha_ex(float a);\n+   double __svml_tanh1_ha_ex(double a);\n+   double __svml_tanh2_ha_ex(double a);\n+   double __svml_log1_ha_ex(double a);\n+   double __svml_log2_ha_ex(double a);\n+   double __svml_log1p1_ha_ex(double a);\n+   double __svml_log1p2_ha_ex(double a);\n+   double __svml_log101_ha_ex(double a);\n+   double __svml_log102_ha_ex(double a);\n+   float __svml_logf4_ha_ex(float a);\n+   float __svml_log1pf4_ha_ex(float a);\n+   float __svml_log10f4_ha_ex(float a);\n+   double __svml_atan21_ha_ex(double a);\n+   double __svml_atan22_ha_ex(double a);\n+   float __svml_atan2f4_ha_ex(float a);\n+   float __svml_hypotf4_ha_ex(float a);\n+   double __svml_hypot1_ha_ex(double a);\n+   double __svml_hypot2_ha_ex(double a);\n+   double __svml_pow1_ha_ex(double a);\n+   double __svml_pow2_ha_ex(double a);\n+   float __svml_powf4_ha_ex(float a);\n+   double __svml_cbrt1_ha_ex(double a);\n+   double __svml_cbrt2_ha_ex(double a);\n+   float __svml_cbrtf4_ha_ex(float a);\n+}\n+#endif\n+\n@@ -6952,0 +7229,335 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+#ifdef __VECTOR_API_MATH_INTRINSICS_LINUX\n+    if (UseAVX > 2) {\n+      StubRoutines::_vector_exp_float512    = CAST_FROM_FN_PTR(address, __svml_expf16_ha_z0);\n+      StubRoutines::_vector_exp_double512   = CAST_FROM_FN_PTR(address, __svml_exp8_ha_z0);\n+      StubRoutines::_vector_expm1_float512  = CAST_FROM_FN_PTR(address, __svml_expm1f16_ha_z0);\n+      StubRoutines::_vector_expm1_double512 = CAST_FROM_FN_PTR(address, __svml_expm18_ha_z0);\n+      StubRoutines::_vector_log1p_float512  = CAST_FROM_FN_PTR(address, __svml_log1pf16_ha_z0);\n+      StubRoutines::_vector_log1p_double512 = CAST_FROM_FN_PTR(address, __svml_log1p8_ha_z0);\n+      StubRoutines::_vector_log_float512    = CAST_FROM_FN_PTR(address, __svml_logf16_ha_z0);\n+      StubRoutines::_vector_log_double512   = CAST_FROM_FN_PTR(address, __svml_log8_ha_z0);\n+      StubRoutines::_vector_log10_float512  = CAST_FROM_FN_PTR(address, __svml_log10f16_ha_z0);\n+      StubRoutines::_vector_log10_double512 = CAST_FROM_FN_PTR(address, __svml_log108_ha_z0);\n+      StubRoutines::_vector_sin_float512    = CAST_FROM_FN_PTR(address, __svml_sinf16_ha_z0);\n+      StubRoutines::_vector_sin_double512   = CAST_FROM_FN_PTR(address, __svml_sin8_ha_z0);\n+      StubRoutines::_vector_cos_float512    = CAST_FROM_FN_PTR(address, __svml_cosf16_ha_z0);\n+      StubRoutines::_vector_cos_double512   = CAST_FROM_FN_PTR(address, __svml_cos8_ha_z0);\n+      StubRoutines::_vector_tan_float512    = CAST_FROM_FN_PTR(address, __svml_tanf16_ha_z0);\n+      StubRoutines::_vector_tan_double512   = CAST_FROM_FN_PTR(address, __svml_tan8_ha_z0);\n+      StubRoutines::_vector_sinh_float512   = CAST_FROM_FN_PTR(address, __svml_sinhf16_ha_z0);\n+      StubRoutines::_vector_sinh_double512  = CAST_FROM_FN_PTR(address, __svml_sinh8_ha_z0);\n+      StubRoutines::_vector_cosh_float512   = CAST_FROM_FN_PTR(address, __svml_coshf16_ha_z0);\n+      StubRoutines::_vector_cosh_double512  = CAST_FROM_FN_PTR(address, __svml_cosh8_ha_z0);\n+      StubRoutines::_vector_tanh_float512   = CAST_FROM_FN_PTR(address, __svml_tanhf16_ha_z0);\n+      StubRoutines::_vector_tanh_double512  = CAST_FROM_FN_PTR(address, __svml_tanh8_ha_z0);\n+      StubRoutines::_vector_acos_float512   = CAST_FROM_FN_PTR(address, __svml_acosf16_ha_z0);\n+      StubRoutines::_vector_acos_double512  = CAST_FROM_FN_PTR(address, __svml_acos8_ha_z0);\n+      StubRoutines::_vector_asin_float512   = CAST_FROM_FN_PTR(address, __svml_asinf16_ha_z0);\n+      StubRoutines::_vector_asin_double512  = CAST_FROM_FN_PTR(address, __svml_asin8_ha_z0);\n+      StubRoutines::_vector_atan_float512   = CAST_FROM_FN_PTR(address, __svml_atanf16_ha_z0);\n+      StubRoutines::_vector_atan_double512  = CAST_FROM_FN_PTR(address, __svml_atan8_ha_z0);\n+      StubRoutines::_vector_pow_float512    = CAST_FROM_FN_PTR(address, __svml_powf16_ha_z0);\n+      StubRoutines::_vector_pow_double512   = CAST_FROM_FN_PTR(address, __svml_pow8_ha_z0);\n+      StubRoutines::_vector_hypot_float512  = CAST_FROM_FN_PTR(address, __svml_hypotf16_ha_z0);\n+      StubRoutines::_vector_hypot_double512 = CAST_FROM_FN_PTR(address, __svml_hypot8_ha_z0);\n+      StubRoutines::_vector_cbrt_float512   = CAST_FROM_FN_PTR(address, __svml_cbrtf16_ha_z0);\n+      StubRoutines::_vector_cbrt_double512  = CAST_FROM_FN_PTR(address, __svml_cbrt8_ha_z0);\n+      StubRoutines::_vector_atan2_float512  = CAST_FROM_FN_PTR(address, __svml_atan2f16_ha_z0);\n+      StubRoutines::_vector_atan2_double512 = CAST_FROM_FN_PTR(address, __svml_atan28_ha_z0);\n+    }\n+#endif\n+    if (UseAVX > 1) {\n+      StubRoutines::_vector_exp_float64     = CAST_FROM_FN_PTR(address, __svml_expf4_ha_l9);\n+      StubRoutines::_vector_exp_float128    = CAST_FROM_FN_PTR(address, __svml_expf4_ha_l9);\n+      StubRoutines::_vector_exp_float256    = CAST_FROM_FN_PTR(address, __svml_expf8_ha_l9);\n+      StubRoutines::_vector_exp_double64    = CAST_FROM_FN_PTR(address, __svml_exp1_ha_l9);\n+      StubRoutines::_vector_exp_double128   = CAST_FROM_FN_PTR(address, __svml_exp2_ha_l9);\n+      StubRoutines::_vector_exp_double256   = CAST_FROM_FN_PTR(address, __svml_exp4_ha_l9);\n+      StubRoutines::_vector_expm1_float64   = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_l9);\n+      StubRoutines::_vector_expm1_float128  = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_l9);\n+      StubRoutines::_vector_expm1_float256  = CAST_FROM_FN_PTR(address, __svml_expm1f8_ha_l9);\n+      StubRoutines::_vector_expm1_double64  = CAST_FROM_FN_PTR(address, __svml_expm11_ha_l9);\n+      StubRoutines::_vector_expm1_double128 = CAST_FROM_FN_PTR(address, __svml_expm12_ha_l9);\n+      StubRoutines::_vector_expm1_double256 = CAST_FROM_FN_PTR(address, __svml_expm14_ha_l9);\n+      StubRoutines::_vector_log1p_float64   = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_l9);\n+      StubRoutines::_vector_log1p_float128  = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_l9);\n+      StubRoutines::_vector_log1p_float256  = CAST_FROM_FN_PTR(address, __svml_log1pf8_ha_l9);\n+      StubRoutines::_vector_log1p_double64  = CAST_FROM_FN_PTR(address, __svml_log1p1_ha_l9);\n+      StubRoutines::_vector_log1p_double128 = CAST_FROM_FN_PTR(address, __svml_log1p2_ha_l9);\n+      StubRoutines::_vector_log1p_double256 = CAST_FROM_FN_PTR(address, __svml_log1p4_ha_l9);\n+      StubRoutines::_vector_log_float64     = CAST_FROM_FN_PTR(address, __svml_logf4_ha_l9);\n+      StubRoutines::_vector_log_float128    = CAST_FROM_FN_PTR(address, __svml_logf4_ha_l9);\n+      StubRoutines::_vector_log_float256    = CAST_FROM_FN_PTR(address, __svml_logf8_ha_l9);\n+      StubRoutines::_vector_log_double64    = CAST_FROM_FN_PTR(address, __svml_log1_ha_l9);\n+      StubRoutines::_vector_log_double128   = CAST_FROM_FN_PTR(address, __svml_log2_ha_l9);\n+      StubRoutines::_vector_log_double256   = CAST_FROM_FN_PTR(address, __svml_log4_ha_l9);\n+      StubRoutines::_vector_log10_float64   = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_l9);\n+      StubRoutines::_vector_log10_float128  = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_l9);\n+      StubRoutines::_vector_log10_float256  = CAST_FROM_FN_PTR(address, __svml_log10f8_ha_l9);\n+      StubRoutines::_vector_log10_double64  = CAST_FROM_FN_PTR(address, __svml_log101_ha_l9);\n+      StubRoutines::_vector_log10_double128 = CAST_FROM_FN_PTR(address, __svml_log102_ha_l9);\n+      StubRoutines::_vector_log10_double256 = CAST_FROM_FN_PTR(address, __svml_log104_ha_l9);\n+      StubRoutines::_vector_sin_float64     = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_l9);\n+      StubRoutines::_vector_sin_float128    = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_l9);\n+      StubRoutines::_vector_sin_float256    = CAST_FROM_FN_PTR(address, __svml_sinf8_ha_l9);\n+      StubRoutines::_vector_sin_double64    = CAST_FROM_FN_PTR(address, __svml_sin1_ha_l9);\n+      StubRoutines::_vector_sin_double128   = CAST_FROM_FN_PTR(address, __svml_sin2_ha_l9);\n+      StubRoutines::_vector_sin_double256   = CAST_FROM_FN_PTR(address, __svml_sin4_ha_l9);\n+      StubRoutines::_vector_cos_float64     = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_l9);\n+      StubRoutines::_vector_cos_float128    = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_l9);\n+      StubRoutines::_vector_cos_float256    = CAST_FROM_FN_PTR(address, __svml_cosf8_ha_l9);\n+      StubRoutines::_vector_cos_double64    = CAST_FROM_FN_PTR(address, __svml_cos1_ha_l9);\n+      StubRoutines::_vector_cos_double128   = CAST_FROM_FN_PTR(address, __svml_cos2_ha_l9);\n+      StubRoutines::_vector_cos_double256   = CAST_FROM_FN_PTR(address, __svml_cos4_ha_l9);\n+      StubRoutines::_vector_tan_float64     = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_l9);\n+      StubRoutines::_vector_tan_float128    = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_l9);\n+      StubRoutines::_vector_tan_float256    = CAST_FROM_FN_PTR(address, __svml_tanf8_ha_l9);\n+      StubRoutines::_vector_tan_double64    = CAST_FROM_FN_PTR(address, __svml_tan1_ha_l9);\n+      StubRoutines::_vector_tan_double128   = CAST_FROM_FN_PTR(address, __svml_tan2_ha_l9);\n+      StubRoutines::_vector_tan_double256   = CAST_FROM_FN_PTR(address, __svml_tan4_ha_l9);\n+      StubRoutines::_vector_sinh_float64    = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_l9);\n+      StubRoutines::_vector_sinh_float128   = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_l9);\n+      StubRoutines::_vector_sinh_float256   = CAST_FROM_FN_PTR(address, __svml_sinhf8_ha_l9);\n+      StubRoutines::_vector_sinh_double64   = CAST_FROM_FN_PTR(address, __svml_sinh1_ha_l9);\n+      StubRoutines::_vector_sinh_double128  = CAST_FROM_FN_PTR(address, __svml_sinh2_ha_l9);\n+      StubRoutines::_vector_sinh_double256  = CAST_FROM_FN_PTR(address, __svml_sinh4_ha_l9);\n+      StubRoutines::_vector_cosh_float64    = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_l9);\n+      StubRoutines::_vector_cosh_float128   = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_l9);\n+      StubRoutines::_vector_cosh_float256   = CAST_FROM_FN_PTR(address, __svml_coshf8_ha_l9);\n+      StubRoutines::_vector_cosh_double64   = CAST_FROM_FN_PTR(address, __svml_cosh1_ha_l9);\n+      StubRoutines::_vector_cosh_double128  = CAST_FROM_FN_PTR(address, __svml_cosh2_ha_l9);\n+      StubRoutines::_vector_cosh_double256  = CAST_FROM_FN_PTR(address, __svml_cosh4_ha_l9);\n+      StubRoutines::_vector_tanh_float64    = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_l9);\n+      StubRoutines::_vector_tanh_float128   = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_l9);\n+      StubRoutines::_vector_tanh_float256   = CAST_FROM_FN_PTR(address, __svml_tanhf8_ha_l9);\n+      StubRoutines::_vector_tanh_double64   = CAST_FROM_FN_PTR(address, __svml_tanh1_ha_l9);\n+      StubRoutines::_vector_tanh_double128  = CAST_FROM_FN_PTR(address, __svml_tanh2_ha_l9);\n+      StubRoutines::_vector_tanh_double256  = CAST_FROM_FN_PTR(address, __svml_tanh4_ha_l9);\n+      StubRoutines::_vector_acos_float64    = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_l9);\n+      StubRoutines::_vector_acos_float128   = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_l9);\n+      StubRoutines::_vector_acos_float256   = CAST_FROM_FN_PTR(address, __svml_acosf8_ha_l9);\n+      StubRoutines::_vector_acos_double64   = CAST_FROM_FN_PTR(address, __svml_acos1_ha_l9);\n+      StubRoutines::_vector_acos_double128  = CAST_FROM_FN_PTR(address, __svml_acos2_ha_l9);\n+      StubRoutines::_vector_acos_double256  = CAST_FROM_FN_PTR(address, __svml_acos4_ha_l9);\n+      StubRoutines::_vector_asin_float64    = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_l9);\n+      StubRoutines::_vector_asin_float128   = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_l9);\n+      StubRoutines::_vector_asin_float256   = CAST_FROM_FN_PTR(address, __svml_asinf8_ha_l9);\n+      StubRoutines::_vector_asin_double64   = CAST_FROM_FN_PTR(address, __svml_asin1_ha_l9);\n+      StubRoutines::_vector_asin_double128  = CAST_FROM_FN_PTR(address, __svml_asin2_ha_l9);\n+      StubRoutines::_vector_asin_double256  = CAST_FROM_FN_PTR(address, __svml_asin4_ha_l9);\n+      StubRoutines::_vector_atan_float64    = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_l9);\n+      StubRoutines::_vector_atan_float128   = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_l9);\n+      StubRoutines::_vector_atan_float256   = CAST_FROM_FN_PTR(address, __svml_atanf8_ha_l9);\n+      StubRoutines::_vector_atan_double64   = CAST_FROM_FN_PTR(address, __svml_atan1_ha_l9);\n+      StubRoutines::_vector_atan_double128  = CAST_FROM_FN_PTR(address, __svml_atan2_ha_l9);\n+      StubRoutines::_vector_atan_double256  = CAST_FROM_FN_PTR(address, __svml_atan4_ha_l9);\n+      StubRoutines::_vector_pow_float64     = CAST_FROM_FN_PTR(address, __svml_powf4_ha_l9);\n+      StubRoutines::_vector_pow_float128    = CAST_FROM_FN_PTR(address, __svml_powf4_ha_l9);\n+      StubRoutines::_vector_pow_float256    = CAST_FROM_FN_PTR(address, __svml_powf8_ha_l9);\n+      StubRoutines::_vector_pow_double64    = CAST_FROM_FN_PTR(address, __svml_pow1_ha_l9);\n+      StubRoutines::_vector_pow_double128   = CAST_FROM_FN_PTR(address, __svml_pow2_ha_l9);\n+      StubRoutines::_vector_pow_double256   = CAST_FROM_FN_PTR(address, __svml_pow4_ha_l9);\n+      StubRoutines::_vector_hypot_float64   = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_l9);\n+      StubRoutines::_vector_hypot_float128  = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_l9);\n+      StubRoutines::_vector_hypot_float256  = CAST_FROM_FN_PTR(address, __svml_hypotf8_ha_l9);\n+      StubRoutines::_vector_hypot_double64  = CAST_FROM_FN_PTR(address, __svml_hypot1_ha_l9);\n+      StubRoutines::_vector_hypot_double128 = CAST_FROM_FN_PTR(address, __svml_hypot2_ha_l9);\n+      StubRoutines::_vector_hypot_double256 = CAST_FROM_FN_PTR(address, __svml_hypot4_ha_l9);\n+      StubRoutines::_vector_cbrt_float64    = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_l9);\n+      StubRoutines::_vector_cbrt_float128   = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_l9);\n+      StubRoutines::_vector_cbrt_float256   = CAST_FROM_FN_PTR(address, __svml_cbrtf8_ha_l9);\n+      StubRoutines::_vector_cbrt_double64   = CAST_FROM_FN_PTR(address, __svml_cbrt1_ha_l9);\n+      StubRoutines::_vector_cbrt_double128  = CAST_FROM_FN_PTR(address, __svml_cbrt2_ha_l9);\n+      StubRoutines::_vector_cbrt_double256  = CAST_FROM_FN_PTR(address, __svml_cbrt4_ha_l9);\n+      StubRoutines::_vector_atan2_float64   = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_l9);\n+      StubRoutines::_vector_atan2_float128  = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_l9);\n+      StubRoutines::_vector_atan2_float256  = CAST_FROM_FN_PTR(address, __svml_atan2f8_ha_l9);\n+      StubRoutines::_vector_atan2_double64  = CAST_FROM_FN_PTR(address, __svml_atan21_ha_l9);\n+      StubRoutines::_vector_atan2_double128 = CAST_FROM_FN_PTR(address, __svml_atan22_ha_l9);\n+      StubRoutines::_vector_atan2_double256 = CAST_FROM_FN_PTR(address, __svml_atan24_ha_l9);\n+    } else if (UseAVX > 0) {\n+      StubRoutines::_vector_exp_float64     = CAST_FROM_FN_PTR(address, __svml_expf4_ha_e9);\n+      StubRoutines::_vector_exp_float128    = CAST_FROM_FN_PTR(address, __svml_expf4_ha_e9);\n+      StubRoutines::_vector_exp_float256    = CAST_FROM_FN_PTR(address, __svml_expf8_ha_e9);\n+      StubRoutines::_vector_exp_double64    = CAST_FROM_FN_PTR(address, __svml_exp1_ha_e9);\n+      StubRoutines::_vector_exp_double128   = CAST_FROM_FN_PTR(address, __svml_exp2_ha_e9);\n+      StubRoutines::_vector_exp_double256   = CAST_FROM_FN_PTR(address, __svml_exp4_ha_e9);\n+      StubRoutines::_vector_expm1_float64   = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_e9);\n+      StubRoutines::_vector_expm1_float128  = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_e9);\n+      StubRoutines::_vector_expm1_float256  = CAST_FROM_FN_PTR(address, __svml_expm1f8_ha_e9);\n+      StubRoutines::_vector_expm1_double64  = CAST_FROM_FN_PTR(address, __svml_expm11_ha_e9);\n+      StubRoutines::_vector_expm1_double128 = CAST_FROM_FN_PTR(address, __svml_expm12_ha_e9);\n+      StubRoutines::_vector_expm1_double256 = CAST_FROM_FN_PTR(address, __svml_expm14_ha_e9);\n+      StubRoutines::_vector_log1p_float64   = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_e9);\n+      StubRoutines::_vector_log1p_float128  = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_e9);\n+      StubRoutines::_vector_log1p_float256  = CAST_FROM_FN_PTR(address, __svml_log1pf8_ha_e9);\n+      StubRoutines::_vector_log1p_double64  = CAST_FROM_FN_PTR(address, __svml_log1p1_ha_e9);\n+      StubRoutines::_vector_log1p_double128 = CAST_FROM_FN_PTR(address, __svml_log1p2_ha_e9);\n+      StubRoutines::_vector_log1p_double256 = CAST_FROM_FN_PTR(address, __svml_log1p4_ha_e9);\n+      StubRoutines::_vector_log_float64     = CAST_FROM_FN_PTR(address, __svml_logf4_ha_e9);\n+      StubRoutines::_vector_log_float128    = CAST_FROM_FN_PTR(address, __svml_logf4_ha_e9);\n+      StubRoutines::_vector_log_float256    = CAST_FROM_FN_PTR(address, __svml_logf8_ha_e9);\n+      StubRoutines::_vector_log_double64    = CAST_FROM_FN_PTR(address, __svml_log1_ha_e9);\n+      StubRoutines::_vector_log_double128   = CAST_FROM_FN_PTR(address, __svml_log2_ha_e9);\n+      StubRoutines::_vector_log_double256   = CAST_FROM_FN_PTR(address, __svml_log4_ha_e9);\n+      StubRoutines::_vector_log10_float64   = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_e9);\n+      StubRoutines::_vector_log10_float128  = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_e9);\n+      StubRoutines::_vector_log10_float256  = CAST_FROM_FN_PTR(address, __svml_log10f8_ha_e9);\n+      StubRoutines::_vector_log10_double64  = CAST_FROM_FN_PTR(address, __svml_log101_ha_e9);\n+      StubRoutines::_vector_log10_double128 = CAST_FROM_FN_PTR(address, __svml_log102_ha_e9);\n+      StubRoutines::_vector_log10_double256 = CAST_FROM_FN_PTR(address, __svml_log104_ha_e9);\n+      StubRoutines::_vector_sin_float64     = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_e9);\n+      StubRoutines::_vector_sin_float128    = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_e9);\n+      StubRoutines::_vector_sin_float256    = CAST_FROM_FN_PTR(address, __svml_sinf8_ha_e9);\n+      StubRoutines::_vector_sin_double64    = CAST_FROM_FN_PTR(address, __svml_sin1_ha_e9);\n+      StubRoutines::_vector_sin_double128   = CAST_FROM_FN_PTR(address, __svml_sin2_ha_e9);\n+      StubRoutines::_vector_sin_double256   = CAST_FROM_FN_PTR(address, __svml_sin4_ha_e9);\n+      StubRoutines::_vector_cos_float64     = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_e9);\n+      StubRoutines::_vector_cos_float128    = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_e9);\n+      StubRoutines::_vector_cos_float256    = CAST_FROM_FN_PTR(address, __svml_cosf8_ha_e9);\n+      StubRoutines::_vector_cos_double64    = CAST_FROM_FN_PTR(address, __svml_cos1_ha_e9);\n+      StubRoutines::_vector_cos_double128   = CAST_FROM_FN_PTR(address, __svml_cos2_ha_e9);\n+      StubRoutines::_vector_cos_double256   = CAST_FROM_FN_PTR(address, __svml_cos4_ha_e9);\n+      StubRoutines::_vector_tan_float64     = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_e9);\n+      StubRoutines::_vector_tan_float128    = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_e9);\n+      StubRoutines::_vector_tan_float256    = CAST_FROM_FN_PTR(address, __svml_tanf8_ha_e9);\n+      StubRoutines::_vector_tan_double64    = CAST_FROM_FN_PTR(address, __svml_tan1_ha_e9);\n+      StubRoutines::_vector_tan_double128   = CAST_FROM_FN_PTR(address, __svml_tan2_ha_e9);\n+      StubRoutines::_vector_tan_double256   = CAST_FROM_FN_PTR(address, __svml_tan4_ha_e9);\n+      StubRoutines::_vector_sinh_float64    = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_e9);\n+      StubRoutines::_vector_sinh_float128   = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_e9);\n+      StubRoutines::_vector_sinh_float256   = CAST_FROM_FN_PTR(address, __svml_sinhf8_ha_e9);\n+      StubRoutines::_vector_sinh_double64   = CAST_FROM_FN_PTR(address, __svml_sinh1_ha_e9);\n+      StubRoutines::_vector_sinh_double128  = CAST_FROM_FN_PTR(address, __svml_sinh2_ha_e9);\n+      StubRoutines::_vector_sinh_double256  = CAST_FROM_FN_PTR(address, __svml_sinh4_ha_e9);\n+      StubRoutines::_vector_cosh_float64    = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_e9);\n+      StubRoutines::_vector_cosh_float128   = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_e9);\n+      StubRoutines::_vector_cosh_float256   = CAST_FROM_FN_PTR(address, __svml_coshf8_ha_e9);\n+      StubRoutines::_vector_cosh_double64   = CAST_FROM_FN_PTR(address, __svml_cosh1_ha_e9);\n+      StubRoutines::_vector_cosh_double128  = CAST_FROM_FN_PTR(address, __svml_cosh2_ha_e9);\n+      StubRoutines::_vector_cosh_double256  = CAST_FROM_FN_PTR(address, __svml_cosh4_ha_e9);\n+      StubRoutines::_vector_tanh_float64    = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_e9);\n+      StubRoutines::_vector_tanh_float128   = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_e9);\n+      StubRoutines::_vector_tanh_float256   = CAST_FROM_FN_PTR(address, __svml_tanhf8_ha_e9);\n+      StubRoutines::_vector_tanh_double64   = CAST_FROM_FN_PTR(address, __svml_tanh1_ha_e9);\n+      StubRoutines::_vector_tanh_double128  = CAST_FROM_FN_PTR(address, __svml_tanh2_ha_e9);\n+      StubRoutines::_vector_tanh_double256  = CAST_FROM_FN_PTR(address, __svml_tanh4_ha_e9);\n+      StubRoutines::_vector_acos_float64    = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_e9);\n+      StubRoutines::_vector_acos_float128   = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_e9);\n+      StubRoutines::_vector_acos_float256   = CAST_FROM_FN_PTR(address, __svml_acosf8_ha_e9);\n+      StubRoutines::_vector_acos_double64   = CAST_FROM_FN_PTR(address, __svml_acos1_ha_e9);\n+      StubRoutines::_vector_acos_double128  = CAST_FROM_FN_PTR(address, __svml_acos2_ha_e9);\n+      StubRoutines::_vector_acos_double256  = CAST_FROM_FN_PTR(address, __svml_acos4_ha_e9);\n+      StubRoutines::_vector_asin_float64    = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_e9);\n+      StubRoutines::_vector_asin_float128   = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_e9);\n+      StubRoutines::_vector_asin_float256   = CAST_FROM_FN_PTR(address, __svml_asinf8_ha_e9);\n+      StubRoutines::_vector_asin_double64   = CAST_FROM_FN_PTR(address, __svml_asin1_ha_e9);\n+      StubRoutines::_vector_asin_double128  = CAST_FROM_FN_PTR(address, __svml_asin2_ha_e9);\n+      StubRoutines::_vector_asin_double256  = CAST_FROM_FN_PTR(address, __svml_asin4_ha_e9);\n+      StubRoutines::_vector_atan_float64    = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_e9);\n+      StubRoutines::_vector_atan_float128   = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_e9);\n+      StubRoutines::_vector_atan_float256   = CAST_FROM_FN_PTR(address, __svml_atanf8_ha_e9);\n+      StubRoutines::_vector_atan_double64   = CAST_FROM_FN_PTR(address, __svml_atan1_ha_e9);\n+      StubRoutines::_vector_atan_double128  = CAST_FROM_FN_PTR(address, __svml_atan2_ha_e9);\n+      StubRoutines::_vector_atan_double256  = CAST_FROM_FN_PTR(address, __svml_atan4_ha_e9);\n+      StubRoutines::_vector_pow_float64     = CAST_FROM_FN_PTR(address, __svml_powf4_ha_e9);\n+      StubRoutines::_vector_pow_float128    = CAST_FROM_FN_PTR(address, __svml_powf4_ha_e9);\n+      StubRoutines::_vector_pow_float256    = CAST_FROM_FN_PTR(address, __svml_powf8_ha_e9);\n+      StubRoutines::_vector_pow_double64    = CAST_FROM_FN_PTR(address, __svml_pow1_ha_e9);\n+      StubRoutines::_vector_pow_double128   = CAST_FROM_FN_PTR(address, __svml_pow2_ha_e9);\n+      StubRoutines::_vector_pow_double256   = CAST_FROM_FN_PTR(address, __svml_pow4_ha_e9);\n+      StubRoutines::_vector_hypot_float64   = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_e9);\n+      StubRoutines::_vector_hypot_float128  = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_e9);\n+      StubRoutines::_vector_hypot_float256  = CAST_FROM_FN_PTR(address, __svml_hypotf8_ha_e9);\n+      StubRoutines::_vector_hypot_double64  = CAST_FROM_FN_PTR(address, __svml_hypot1_ha_e9);\n+      StubRoutines::_vector_hypot_double128 = CAST_FROM_FN_PTR(address, __svml_hypot2_ha_e9);\n+      StubRoutines::_vector_hypot_double256 = CAST_FROM_FN_PTR(address, __svml_hypot4_ha_e9);\n+      StubRoutines::_vector_cbrt_float64    = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_e9);\n+      StubRoutines::_vector_cbrt_float128   = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_e9);\n+      StubRoutines::_vector_cbrt_float256   = CAST_FROM_FN_PTR(address, __svml_cbrtf8_ha_e9);\n+      StubRoutines::_vector_cbrt_double64   = CAST_FROM_FN_PTR(address, __svml_cbrt1_ha_e9);\n+      StubRoutines::_vector_cbrt_double128  = CAST_FROM_FN_PTR(address, __svml_cbrt2_ha_e9);\n+      StubRoutines::_vector_cbrt_double256  = CAST_FROM_FN_PTR(address, __svml_cbrt4_ha_e9);\n+      StubRoutines::_vector_atan2_float64   = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_e9);\n+      StubRoutines::_vector_atan2_float128  = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_e9);\n+      StubRoutines::_vector_atan2_float256  = CAST_FROM_FN_PTR(address, __svml_atan2f8_ha_e9);\n+      StubRoutines::_vector_atan2_double64  = CAST_FROM_FN_PTR(address, __svml_atan21_ha_e9);\n+      StubRoutines::_vector_atan2_double128 = CAST_FROM_FN_PTR(address, __svml_atan22_ha_e9);\n+      StubRoutines::_vector_atan2_double256 = CAST_FROM_FN_PTR(address, __svml_atan24_ha_e9);\n+    } else {\n+      assert(UseAVX == 0 && UseSSE >= 2, \"\");\n+      StubRoutines::_vector_exp_float64     = CAST_FROM_FN_PTR(address, __svml_expf4_ha_ex);\n+      StubRoutines::_vector_exp_float128    = CAST_FROM_FN_PTR(address, __svml_expf4_ha_ex);\n+      StubRoutines::_vector_exp_double64    = CAST_FROM_FN_PTR(address, __svml_exp1_ha_ex);\n+      StubRoutines::_vector_exp_double128   = CAST_FROM_FN_PTR(address, __svml_exp2_ha_ex);\n+      StubRoutines::_vector_expm1_float64   = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_ex);\n+      StubRoutines::_vector_expm1_float128  = CAST_FROM_FN_PTR(address, __svml_expm1f4_ha_ex);\n+      StubRoutines::_vector_expm1_double64  = CAST_FROM_FN_PTR(address, __svml_expm11_ha_ex);\n+      StubRoutines::_vector_expm1_double128 = CAST_FROM_FN_PTR(address, __svml_expm12_ha_ex);\n+      StubRoutines::_vector_acos_float64    = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_ex);\n+      StubRoutines::_vector_acos_float128   = CAST_FROM_FN_PTR(address, __svml_acosf4_ha_ex);\n+      StubRoutines::_vector_acos_double64   = CAST_FROM_FN_PTR(address, __svml_acos1_ha_ex);\n+      StubRoutines::_vector_acos_double128  = CAST_FROM_FN_PTR(address, __svml_acos2_ha_ex);\n+      StubRoutines::_vector_asin_float64    = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_ex);\n+      StubRoutines::_vector_asin_float128   = CAST_FROM_FN_PTR(address, __svml_asinf4_ha_ex);\n+      StubRoutines::_vector_asin_double64   = CAST_FROM_FN_PTR(address, __svml_asin1_ha_ex);\n+      StubRoutines::_vector_asin_double128  = CAST_FROM_FN_PTR(address, __svml_asin2_ha_ex);\n+      StubRoutines::_vector_atan_float64    = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_ex);\n+      StubRoutines::_vector_atan_float128   = CAST_FROM_FN_PTR(address, __svml_atanf4_ha_ex);\n+      StubRoutines::_vector_atan_double64   = CAST_FROM_FN_PTR(address, __svml_atan1_ha_ex);\n+      StubRoutines::_vector_atan_double128  = CAST_FROM_FN_PTR(address, __svml_atan2_ha_ex);\n+      StubRoutines::_vector_sin_float64     = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_ex);\n+      StubRoutines::_vector_sin_float128    = CAST_FROM_FN_PTR(address, __svml_sinf4_ha_ex);\n+      StubRoutines::_vector_sin_double64    = CAST_FROM_FN_PTR(address, __svml_sin1_ha_ex);\n+      StubRoutines::_vector_sin_double128   = CAST_FROM_FN_PTR(address, __svml_sin2_ha_ex);\n+      StubRoutines::_vector_cos_float64     = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_ex);\n+      StubRoutines::_vector_cos_float128    = CAST_FROM_FN_PTR(address, __svml_cosf4_ha_ex);\n+      StubRoutines::_vector_cos_double64    = CAST_FROM_FN_PTR(address, __svml_cos1_ha_ex);\n+      StubRoutines::_vector_cos_double128   = CAST_FROM_FN_PTR(address, __svml_cos2_ha_ex);\n+      StubRoutines::_vector_tan_float64     = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_ex);\n+      StubRoutines::_vector_tan_float128    = CAST_FROM_FN_PTR(address, __svml_tanf4_ha_ex);\n+      StubRoutines::_vector_tan_double64    = CAST_FROM_FN_PTR(address, __svml_tan1_ha_ex);\n+      StubRoutines::_vector_tan_double128   = CAST_FROM_FN_PTR(address, __svml_tan2_ha_ex);\n+      StubRoutines::_vector_sinh_float64    = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_ex);\n+      StubRoutines::_vector_sinh_float128   = CAST_FROM_FN_PTR(address, __svml_sinhf4_ha_ex);\n+      StubRoutines::_vector_sinh_double64   = CAST_FROM_FN_PTR(address, __svml_sinh1_ha_ex);\n+      StubRoutines::_vector_sinh_double128  = CAST_FROM_FN_PTR(address, __svml_sinh2_ha_ex);\n+      StubRoutines::_vector_cosh_float64    = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_ex);\n+      StubRoutines::_vector_cosh_float128   = CAST_FROM_FN_PTR(address, __svml_coshf4_ha_ex);\n+      StubRoutines::_vector_cosh_double64   = CAST_FROM_FN_PTR(address, __svml_cosh1_ha_ex);\n+      StubRoutines::_vector_cosh_double128  = CAST_FROM_FN_PTR(address, __svml_cosh2_ha_ex);\n+      StubRoutines::_vector_tanh_float64    = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_ex);\n+      StubRoutines::_vector_tanh_float128   = CAST_FROM_FN_PTR(address, __svml_tanhf4_ha_ex);\n+      StubRoutines::_vector_tanh_double64   = CAST_FROM_FN_PTR(address, __svml_tanh1_ha_ex);\n+      StubRoutines::_vector_tanh_double128  = CAST_FROM_FN_PTR(address, __svml_tanh2_ha_ex);\n+      StubRoutines::_vector_log_float64     = CAST_FROM_FN_PTR(address, __svml_logf4_ha_ex);\n+      StubRoutines::_vector_log_float128    = CAST_FROM_FN_PTR(address, __svml_logf4_ha_ex);\n+      StubRoutines::_vector_log_double64    = CAST_FROM_FN_PTR(address, __svml_log1_ha_ex);\n+      StubRoutines::_vector_log_double128   = CAST_FROM_FN_PTR(address, __svml_log2_ha_ex);\n+      StubRoutines::_vector_log10_float64   = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_ex);\n+      StubRoutines::_vector_log10_float128  = CAST_FROM_FN_PTR(address, __svml_log10f4_ha_ex);\n+      StubRoutines::_vector_log10_double64  = CAST_FROM_FN_PTR(address, __svml_log101_ha_ex);\n+      StubRoutines::_vector_log10_double128 = CAST_FROM_FN_PTR(address, __svml_log102_ha_ex);\n+      StubRoutines::_vector_log1p_float64   = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_ex);\n+      StubRoutines::_vector_log1p_float128  = CAST_FROM_FN_PTR(address, __svml_log1pf4_ha_ex);\n+      StubRoutines::_vector_log1p_double64  = CAST_FROM_FN_PTR(address, __svml_log1p1_ha_ex);\n+      StubRoutines::_vector_log1p_double128 = CAST_FROM_FN_PTR(address, __svml_log1p2_ha_ex);\n+      StubRoutines::_vector_atan2_float64   = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_ex);\n+      StubRoutines::_vector_atan2_float128  = CAST_FROM_FN_PTR(address, __svml_atan2f4_ha_ex);\n+      StubRoutines::_vector_atan2_double64  = CAST_FROM_FN_PTR(address, __svml_atan21_ha_ex);\n+      StubRoutines::_vector_atan2_double128 = CAST_FROM_FN_PTR(address, __svml_atan22_ha_ex);\n+      StubRoutines::_vector_hypot_float64   = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_ex);\n+      StubRoutines::_vector_hypot_float128  = CAST_FROM_FN_PTR(address, __svml_hypotf4_ha_ex);\n+      StubRoutines::_vector_hypot_double64  = CAST_FROM_FN_PTR(address, __svml_hypot1_ha_ex);\n+      StubRoutines::_vector_hypot_double128 = CAST_FROM_FN_PTR(address, __svml_hypot2_ha_ex);\n+      StubRoutines::_vector_pow_float64     = CAST_FROM_FN_PTR(address, __svml_powf4_ha_ex);\n+      StubRoutines::_vector_pow_float128    = CAST_FROM_FN_PTR(address, __svml_powf4_ha_ex);\n+      StubRoutines::_vector_pow_double64    = CAST_FROM_FN_PTR(address, __svml_pow1_ha_ex);\n+      StubRoutines::_vector_pow_double128   = CAST_FROM_FN_PTR(address, __svml_pow2_ha_ex);\n+      StubRoutines::_vector_cbrt_float64    = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_ex);\n+      StubRoutines::_vector_cbrt_float128   = CAST_FROM_FN_PTR(address, __svml_cbrtf4_ha_ex);\n+      StubRoutines::_vector_cbrt_double64   = CAST_FROM_FN_PTR(address, __svml_cbrt1_ha_ex);\n+      StubRoutines::_vector_cbrt_double128  = CAST_FROM_FN_PTR(address, __svml_cbrt2_ha_ex);\n+    }\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":612,"deletions":0,"binary":false,"changes":612,"status":"modified"},{"patch":"@@ -1637,0 +1637,5 @@\n+    case Op_CallLeafVector:\n+      if (size_in_bits == 512 && !VM_Version::supports_avx512vlbwdq()) {\n+        return false;\n+      }\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1353,0 +1353,14 @@\n+\/\/ Vector calling convention not supported.\n+const bool Matcher::supports_vector_calling_convention() {\n+  return false;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  Unimplemented();\n+  return OptoRegPair(0, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1588,0 +1588,17 @@\n+const bool Matcher::supports_vector_calling_convention(void) {\n+  return true;\n+}\n+\n+void Matcher::vector_calling_convention(VMRegPair *regs, uint num_bits, uint total_args_passed) {\n+  (void) SharedRuntime::vector_calling_convention(regs, num_bits, total_args_passed);\n+}\n+\n+OptoRegPair Matcher::vector_return_value(uint ideal_reg) {\n+  int lo = XMM0_num;\n+  int hi = XMM0b_num;\n+  if (ideal_reg == Op_VecX) hi = XMM0d_num;\n+  else if (ideal_reg == Op_VecY) hi = XMM0h_num;\n+  else if (ideal_reg == Op_VecZ) hi = XMM0p_num;\n+  return OptoRegPair(hi, lo);\n+}\n+\n@@ -12420,0 +12437,12 @@\n+\/\/ Call runtime without safepoint and with vector arguments\n+instruct CallLeafDirectVector(method meth)\n+%{\n+  match(CallLeafVector);\n+  effect(USE meth);\n+\n+  ins_cost(300);\n+  format %{ \"call_leaf,vector \" %}\n+  ins_encode(Java_To_Runtime(meth));\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -422,0 +422,2 @@\n+  if(_matrule->find_type(\"CallLeafVector\",idx))   return Form::JAVA_LEAF;\n+  idx = 0;\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -771,0 +771,3 @@\n+  product(bool, UseVectorStubs, false, EXPERIMENTAL,                        \\\n+          \"Use stubs for vector transcendental operations\")                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -739,3 +739,5 @@\n-    OptoRegPair regs = is_CallRuntime()\n-      ? match->c_return_value(ideal_reg)  \/\/ Calls into C runtime\n-      : match->  return_value(ideal_reg); \/\/ Calls into compiled Java code\n+    OptoRegPair regs = Opcode() == Op_CallLeafVector\n+      ? match->vector_return_value(ideal_reg)      \/\/ Calls into assembly vector routine\n+      : is_CallRuntime()\n+        ? match->c_return_value(ideal_reg)  \/\/ Calls into C runtime\n+        : match->  return_value(ideal_reg); \/\/ Calls into compiled Java code\n@@ -743,0 +745,10 @@\n+\n+    \/\/ If the return is in vector, compute appropriate regmask taking into account the whole range\n+    if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+      if(OptoReg::is_valid(regs.second())) {\n+        for (OptoReg::Name r = regs.first(); r <= regs.second(); r = OptoReg::add(r, 1)) {\n+          rm.Insert(r);\n+        }\n+      }\n+    }\n+\n@@ -1198,0 +1210,5 @@\n+uint CallLeafVectorNode::size_of() const { return sizeof(*this); }\n+bool CallLeafVectorNode::cmp( const Node &n ) const {\n+  CallLeafVectorNode &call = (CallLeafVectorNode&)n;\n+  return CallLeafNode::cmp(call) && _num_bits == call._num_bits;\n+}\n@@ -1269,0 +1286,15 @@\n+void CallLeafVectorNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {\n+#ifdef ASSERT\n+  assert(tf()->range()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n+         \"return vector size must match\");\n+  const TypeTuple* d = tf()->domain();\n+  for (uint i = TypeFunc::Parms; i < d->cnt(); i++) {\n+    Node* arg = in(i);\n+    assert(arg->bottom_type()->is_vect()->length_in_bytes() * BitsPerByte == _num_bits,\n+           \"vector argument size must match\");\n+  }\n+#endif\n+\n+  Matcher::vector_calling_convention(parm_regs, _num_bits, argcnt);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+class         CallLeafVectorNode;\n@@ -787,0 +788,1 @@\n+protected:\n@@ -874,0 +876,18 @@\n+\/\/------------------------------CallLeafVectorNode-------------------------------\n+\/\/ CallLeafNode but calling with vector calling convention instead.\n+class CallLeafVectorNode : public CallLeafNode {\n+private:\n+  uint _num_bits;\n+protected:\n+  virtual bool cmp( const Node &n ) const;\n+  virtual uint size_of() const; \/\/ Size is bigger\n+public:\n+  CallLeafVectorNode(const TypeFunc* tf, address addr, const char* name,\n+                   const TypePtr* adr_type, uint num_bits)\n+    : CallLeafNode(tf, addr, name, adr_type), _num_bits(num_bits)\n+  {\n+  }\n+  virtual int   Opcode() const;\n+  virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+macro(CallLeafVector)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2183,1 +2183,2 @@\n-    for_igvn()->clear();\n+    Unique_Node_List* old_worklist = for_igvn();\n+    old_worklist->clear();\n@@ -2193,1 +2194,1 @@\n-    set_for_igvn(save_for_igvn);\n+    set_for_igvn(old_worklist); \/\/ new_worklist is dead beyond this point\n@@ -3006,0 +3007,1 @@\n+  case Op_CallLeafVector:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1020,0 +1020,1 @@\n+    case Op_CallLeafVector:\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2501,0 +2501,3 @@\n+  } else  if (flags & RC_VECTOR){\n+    uint num_bits = call_type->range()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte;\n+    call = new CallLeafVectorNode(call_type, call_addr, call_name, adr_type, num_bits);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -858,0 +858,1 @@\n+    case Op_CallLeafVector:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -328,0 +328,1 @@\n+  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1364,2 +1364,4 @@\n-      if( !parm_regs[i].first()->is_valid() &&\n-          !parm_regs[i].second()->is_valid() ) {\n+      VMReg first = parm_regs[i].first();\n+      VMReg second = parm_regs[i].second();\n+      if( !first->is_valid() &&\n+          !second->is_valid() ) {\n@@ -1368,0 +1370,9 @@\n+      \/\/ Handle case where arguments are in vector registers.\n+      if(call->in(TypeFunc::Parms + i)->bottom_type()->isa_vect()) {\n+        OptoReg::Name reg_fst = OptoReg::as_OptoReg(first);\n+        OptoReg::Name reg_snd = OptoReg::as_OptoReg(second);\n+        assert (reg_fst <= reg_snd, \"fst=%d snd=%d\", reg_fst, reg_snd);\n+        for (OptoReg::Name r = reg_fst; r <= reg_snd; r++) {\n+          rm->Insert(r);\n+        }\n+      }\n@@ -1369,1 +1380,1 @@\n-      OptoReg::Name reg1 = warp_outgoing_stk_arg(parm_regs[i].first(), begin_out_arg_area, out_arg_limit_per_call );\n+      OptoReg::Name reg1 = warp_outgoing_stk_arg(first, begin_out_arg_area, out_arg_limit_per_call );\n@@ -1373,1 +1384,1 @@\n-      OptoReg::Name reg2 = warp_outgoing_stk_arg(parm_regs[i].second(), begin_out_arg_area, out_arg_limit_per_call );\n+      OptoReg::Name reg2 = warp_outgoing_stk_arg(second, begin_out_arg_area, out_arg_limit_per_call );\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -429,0 +429,7 @@\n+  \/\/ Java-Native vector calling convention\n+  static const bool supports_vector_calling_convention();\n+  static void vector_calling_convention(VMRegPair *regs,\n+                                        uint num_bits,\n+                                        uint total_args_passed);\n+  static OptoRegPair vector_return_value(uint ideal_reg);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -243,0 +243,15 @@\n+  if (opc == Op_CallLeafVector) {\n+    if (!UseVectorStubs) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** vector stubs support is disabled\");\n+      }\n+      return false;\n+    }\n+    if (!Matcher::supports_vector_calling_convention()) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** no vector calling conventions supported\");\n+      }\n+      return false;\n+    }\n+  }\n+\n@@ -292,10 +307,22 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n-  switch (n) {\n-    case 1:\n-    case 2: {\n-      operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, vt));\n-      break;\n-    }\n-    case 3: {\n-      operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, opd3, vt));\n-      break;\n+  if (sopc == Op_CallLeafVector) {\n+    assert(UseVectorStubs, \"sanity\");\n+    operation = gen_call_to_svml(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n+    if (operation == NULL) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** svml call failed\");\n+      }\n+      return false;\n+     }\n+  } else {\n+    const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+    switch (n) {\n+      case 1:\n+      case 2: {\n+        operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, vt));\n+        break;\n+      }\n+      case 3: {\n+        operation = gvn().transform(VectorNode::make(sopc, opd1, opd2, opd3, vt));\n+        break;\n+      }\n+      default: fatal(\"unsupported arity: %d\", n);\n@@ -303,1 +330,0 @@\n-    default: fatal(\"unsupported arity: %d\", n);\n@@ -355,0 +381,3 @@\n+  if (!arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed)) {\n+    return false;\n+  }\n@@ -386,1 +415,1 @@\n-    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(1));\n+    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ge));\n@@ -1207,0 +1236,417 @@\n+static void get_svml_address(int op, int bits, BasicType bt, const char** name_ptr, address* addr_ptr) {\n+  assert(UseVectorStubs, \"sanity\");\n+  assert(name_ptr != NULL, \"unexpected\");\n+  assert(addr_ptr != NULL, \"unexpected\");\n+\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+  \/\/ Since the addresses are resolved at runtime, using switch instead of table - otherwise might get NULL addresses.\n+  if (bt == T_FLOAT) {\n+    switch(op) {\n+      case VectorSupport::VECTOR_OP_EXP: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_exp_float64\";  *addr_ptr = StubRoutines::vector_exp_float64();  break;\n+            case 128: *name_ptr = \"vector_exp_float128\"; *addr_ptr = StubRoutines::vector_exp_float128(); break;\n+            case 256: *name_ptr = \"vector_exp_float256\"; *addr_ptr = StubRoutines::vector_exp_float256(); break;\n+            case 512: *name_ptr = \"vector_exp_float512\"; *addr_ptr = StubRoutines::vector_exp_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG1P: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log1p_float64\";  *addr_ptr = StubRoutines::vector_log1p_float64();  break;\n+            case 128: *name_ptr = \"vector_log1p_float128\"; *addr_ptr = StubRoutines::vector_log1p_float128(); break;\n+            case 256: *name_ptr = \"vector_log1p_float256\"; *addr_ptr = StubRoutines::vector_log1p_float256(); break;\n+            case 512: *name_ptr = \"vector_log1p_float512\"; *addr_ptr = StubRoutines::vector_log1p_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log_float64\";  *addr_ptr = StubRoutines::vector_log_float64();  break;\n+            case 128: *name_ptr = \"vector_log_float128\"; *addr_ptr = StubRoutines::vector_log_float128(); break;\n+            case 256: *name_ptr = \"vector_log_float256\"; *addr_ptr = StubRoutines::vector_log_float256(); break;\n+            case 512: *name_ptr = \"vector_log_float512\"; *addr_ptr = StubRoutines::vector_log_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG10: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log10_float64\";  *addr_ptr = StubRoutines::vector_log10_float64();  break;\n+            case 128: *name_ptr = \"vector_log10_float128\"; *addr_ptr = StubRoutines::vector_log10_float128(); break;\n+            case 256: *name_ptr = \"vector_log10_float256\"; *addr_ptr = StubRoutines::vector_log10_float256(); break;\n+            case 512: *name_ptr = \"vector_log10_float512\"; *addr_ptr = StubRoutines::vector_log10_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_EXPM1: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_expm1_float64\";  *addr_ptr = StubRoutines::vector_expm1_float64();  break;\n+            case 128: *name_ptr = \"vector_expm1_float128\"; *addr_ptr = StubRoutines::vector_expm1_float128(); break;\n+            case 256: *name_ptr = \"vector_expm1_float256\"; *addr_ptr = StubRoutines::vector_expm1_float256(); break;\n+            case 512: *name_ptr = \"vector_expm1_float512\"; *addr_ptr = StubRoutines::vector_expm1_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sin_float64\";  *addr_ptr = StubRoutines::vector_sin_float64();  break;\n+            case 128: *name_ptr = \"vector_sin_float128\"; *addr_ptr = StubRoutines::vector_sin_float128(); break;\n+            case 256: *name_ptr = \"vector_sin_float256\"; *addr_ptr = StubRoutines::vector_sin_float256(); break;\n+            case 512: *name_ptr = \"vector_sin_float512\"; *addr_ptr = StubRoutines::vector_sin_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cos_float64\";  *addr_ptr = StubRoutines::vector_cos_float64();  break;\n+            case 128: *name_ptr = \"vector_cos_float128\"; *addr_ptr = StubRoutines::vector_cos_float128(); break;\n+            case 256: *name_ptr = \"vector_cos_float256\"; *addr_ptr = StubRoutines::vector_cos_float256(); break;\n+            case 512: *name_ptr = \"vector_cos_float512\"; *addr_ptr = StubRoutines::vector_cos_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tan_float64\";  *addr_ptr = StubRoutines::vector_tan_float64();  break;\n+            case 128: *name_ptr = \"vector_tan_float128\"; *addr_ptr = StubRoutines::vector_tan_float128(); break;\n+            case 256: *name_ptr = \"vector_tan_float256\"; *addr_ptr = StubRoutines::vector_tan_float256(); break;\n+            case 512: *name_ptr = \"vector_tan_float512\"; *addr_ptr = StubRoutines::vector_tan_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SINH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sinh_float64\";  *addr_ptr = StubRoutines::vector_sinh_float64();  break;\n+            case 128: *name_ptr = \"vector_sinh_float128\"; *addr_ptr = StubRoutines::vector_sinh_float128(); break;\n+            case 256: *name_ptr = \"vector_sinh_float256\"; *addr_ptr = StubRoutines::vector_sinh_float256(); break;\n+            case 512: *name_ptr = \"vector_sinh_float512\"; *addr_ptr = StubRoutines::vector_sinh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COSH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cosh_float64\";  *addr_ptr = StubRoutines::vector_cosh_float64();  break;\n+            case 128: *name_ptr = \"vector_cosh_float128\"; *addr_ptr = StubRoutines::vector_cosh_float128(); break;\n+            case 256: *name_ptr = \"vector_cosh_float256\"; *addr_ptr = StubRoutines::vector_cosh_float256(); break;\n+            case 512: *name_ptr = \"vector_cosh_float512\"; *addr_ptr = StubRoutines::vector_cosh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TANH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tanh_float64\";  *addr_ptr = StubRoutines::vector_tanh_float64();  break;\n+            case 128: *name_ptr = \"vector_tanh_float128\"; *addr_ptr = StubRoutines::vector_tanh_float128(); break;\n+            case 256: *name_ptr = \"vector_tanh_float256\"; *addr_ptr = StubRoutines::vector_tanh_float256(); break;\n+            case 512: *name_ptr = \"vector_tanh_float512\"; *addr_ptr = StubRoutines::vector_tanh_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ASIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_asin_float64\";  *addr_ptr = StubRoutines::vector_asin_float64();  break;\n+            case 128: *name_ptr = \"vector_asin_float128\"; *addr_ptr = StubRoutines::vector_asin_float128(); break;\n+            case 256: *name_ptr = \"vector_asin_float256\"; *addr_ptr = StubRoutines::vector_asin_float256(); break;\n+            case 512: *name_ptr = \"vector_asin_float512\"; *addr_ptr = StubRoutines::vector_asin_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ACOS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_acos_float64\";  *addr_ptr = StubRoutines::vector_acos_float64();  break;\n+            case 128: *name_ptr = \"vector_acos_float128\"; *addr_ptr = StubRoutines::vector_acos_float128(); break;\n+            case 256: *name_ptr = \"vector_acos_float256\"; *addr_ptr = StubRoutines::vector_acos_float256(); break;\n+            case 512: *name_ptr = \"vector_acos_float512\"; *addr_ptr = StubRoutines::vector_acos_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan_float64\";  *addr_ptr = StubRoutines::vector_atan_float64();  break;\n+            case 128: *name_ptr = \"vector_atan_float128\"; *addr_ptr = StubRoutines::vector_atan_float128(); break;\n+            case 256: *name_ptr = \"vector_atan_float256\"; *addr_ptr = StubRoutines::vector_atan_float256(); break;\n+            case 512: *name_ptr = \"vector_atan_float512\"; *addr_ptr = StubRoutines::vector_atan_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_CBRT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cbrt_float64\";  *addr_ptr = StubRoutines::vector_cbrt_float64();  break;\n+            case 128: *name_ptr = \"vector_cbrt_float128\"; *addr_ptr = StubRoutines::vector_cbrt_float128(); break;\n+            case 256: *name_ptr = \"vector_cbrt_float256\"; *addr_ptr = StubRoutines::vector_cbrt_float256(); break;\n+            case 512: *name_ptr = \"vector_cbrt_float512\"; *addr_ptr = StubRoutines::vector_cbrt_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+       case VectorSupport::VECTOR_OP_HYPOT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_hypot_float64\";  *addr_ptr = StubRoutines::vector_hypot_float64();  break;\n+            case 128: *name_ptr = \"vector_hypot_float128\"; *addr_ptr = StubRoutines::vector_hypot_float128(); break;\n+            case 256: *name_ptr = \"vector_hypot_float256\"; *addr_ptr = StubRoutines::vector_hypot_float256(); break;\n+            case 512: *name_ptr = \"vector_hypot_float512\"; *addr_ptr = StubRoutines::vector_hypot_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_POW: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_pow_float64\";  *addr_ptr = StubRoutines::vector_pow_float64();  break;\n+            case 128: *name_ptr = \"vector_pow_float128\"; *addr_ptr = StubRoutines::vector_pow_float128(); break;\n+            case 256: *name_ptr = \"vector_pow_float256\"; *addr_ptr = StubRoutines::vector_pow_float256(); break;\n+            case 512: *name_ptr = \"vector_pow_float512\"; *addr_ptr = StubRoutines::vector_pow_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN2: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan2_float64\";  *addr_ptr = StubRoutines::vector_atan2_float64();  break;\n+            case 128: *name_ptr = \"vector_atan2_float128\"; *addr_ptr = StubRoutines::vector_atan2_float128(); break;\n+            case 256: *name_ptr = \"vector_atan2_float256\"; *addr_ptr = StubRoutines::vector_atan2_float256(); break;\n+            case 512: *name_ptr = \"vector_atan2_float512\"; *addr_ptr = StubRoutines::vector_atan2_float512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      default:\n+        *name_ptr = \"invalid\";\n+        *addr_ptr = NULL;\n+        break;\n+    }\n+  } else {\n+    assert(bt == T_DOUBLE, \"must be FP type only\");\n+    switch(op) {\n+      case VectorSupport::VECTOR_OP_EXP: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_exp_double64\";  *addr_ptr = StubRoutines::vector_exp_double64();  break;\n+            case 128: *name_ptr = \"vector_exp_double128\"; *addr_ptr = StubRoutines::vector_exp_double128(); break;\n+            case 256: *name_ptr = \"vector_exp_double256\"; *addr_ptr = StubRoutines::vector_exp_double256(); break;\n+            case 512: *name_ptr = \"vector_exp_double512\"; *addr_ptr = StubRoutines::vector_exp_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG1P: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log1p_double64\";  *addr_ptr = StubRoutines::vector_log1p_double64();  break;\n+            case 128: *name_ptr = \"vector_log1p_double128\"; *addr_ptr = StubRoutines::vector_log1p_double128(); break;\n+            case 256: *name_ptr = \"vector_log1p_double256\"; *addr_ptr = StubRoutines::vector_log1p_double256(); break;\n+            case 512: *name_ptr = \"vector_log1p_double512\"; *addr_ptr = StubRoutines::vector_log1p_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log_double64\";  *addr_ptr = StubRoutines::vector_log_double64();  break;\n+            case 128: *name_ptr = \"vector_log_double128\"; *addr_ptr = StubRoutines::vector_log_double128(); break;\n+            case 256: *name_ptr = \"vector_log_double256\"; *addr_ptr = StubRoutines::vector_log_double256(); break;\n+            case 512: *name_ptr = \"vector_log_double512\"; *addr_ptr = StubRoutines::vector_log_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_LOG10: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_log10_double64\";  *addr_ptr = StubRoutines::vector_log10_double64();  break;\n+            case 128: *name_ptr = \"vector_log10_double128\"; *addr_ptr = StubRoutines::vector_log10_double128(); break;\n+            case 256: *name_ptr = \"vector_log10_double256\"; *addr_ptr = StubRoutines::vector_log10_double256(); break;\n+            case 512: *name_ptr = \"vector_log10_double512\"; *addr_ptr = StubRoutines::vector_log10_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_EXPM1: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_expm1_double64\";  *addr_ptr = StubRoutines::vector_expm1_double64();  break;\n+            case 128: *name_ptr = \"vector_expm1_double128\"; *addr_ptr = StubRoutines::vector_expm1_double128(); break;\n+            case 256: *name_ptr = \"vector_expm1_double256\"; *addr_ptr = StubRoutines::vector_expm1_double256(); break;\n+            case 512: *name_ptr = \"vector_expm1_double512\"; *addr_ptr = StubRoutines::vector_expm1_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sin_double64\";  *addr_ptr = StubRoutines::vector_sin_double64();  break;\n+            case 128: *name_ptr = \"vector_sin_double128\"; *addr_ptr = StubRoutines::vector_sin_double128(); break;\n+            case 256: *name_ptr = \"vector_sin_double256\"; *addr_ptr = StubRoutines::vector_sin_double256(); break;\n+            case 512: *name_ptr = \"vector_sin_double512\"; *addr_ptr = StubRoutines::vector_sin_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cos_double64\";  *addr_ptr = StubRoutines::vector_cos_double64();  break;\n+            case 128: *name_ptr = \"vector_cos_double128\"; *addr_ptr = StubRoutines::vector_cos_double128(); break;\n+            case 256: *name_ptr = \"vector_cos_double256\"; *addr_ptr = StubRoutines::vector_cos_double256(); break;\n+            case 512: *name_ptr = \"vector_cos_double512\"; *addr_ptr = StubRoutines::vector_cos_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tan_double64\";  *addr_ptr = StubRoutines::vector_tan_double64();  break;\n+            case 128: *name_ptr = \"vector_tan_double128\"; *addr_ptr = StubRoutines::vector_tan_double128(); break;\n+            case 256: *name_ptr = \"vector_tan_double256\"; *addr_ptr = StubRoutines::vector_tan_double256(); break;\n+            case 512: *name_ptr = \"vector_tan_double512\"; *addr_ptr = StubRoutines::vector_tan_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_SINH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_sinh_double64\";  *addr_ptr = StubRoutines::vector_sinh_double64();  break;\n+            case 128: *name_ptr = \"vector_sinh_double128\"; *addr_ptr = StubRoutines::vector_sinh_double128(); break;\n+            case 256: *name_ptr = \"vector_sinh_double256\"; *addr_ptr = StubRoutines::vector_sinh_double256(); break;\n+            case 512: *name_ptr = \"vector_sinh_double512\"; *addr_ptr = StubRoutines::vector_sinh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_COSH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cosh_double64\";  *addr_ptr = StubRoutines::vector_cosh_double64();  break;\n+            case 128: *name_ptr = \"vector_cosh_double128\"; *addr_ptr = StubRoutines::vector_cosh_double128(); break;\n+            case 256: *name_ptr = \"vector_cosh_double256\"; *addr_ptr = StubRoutines::vector_cosh_double256(); break;\n+            case 512: *name_ptr = \"vector_cosh_double512\"; *addr_ptr = StubRoutines::vector_cosh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_TANH: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_tanh_double64\";  *addr_ptr = StubRoutines::vector_tanh_double64();  break;\n+            case 128: *name_ptr = \"vector_tanh_double128\"; *addr_ptr = StubRoutines::vector_tanh_double128(); break;\n+            case 256: *name_ptr = \"vector_tanh_double256\"; *addr_ptr = StubRoutines::vector_tanh_double256(); break;\n+            case 512: *name_ptr = \"vector_tanh_double512\"; *addr_ptr = StubRoutines::vector_tanh_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ASIN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_asin_double64\";  *addr_ptr = StubRoutines::vector_asin_double64();  break;\n+            case 128: *name_ptr = \"vector_asin_double128\"; *addr_ptr = StubRoutines::vector_asin_double128(); break;\n+            case 256: *name_ptr = \"vector_asin_double256\"; *addr_ptr = StubRoutines::vector_asin_double256(); break;\n+            case 512: *name_ptr = \"vector_asin_double512\"; *addr_ptr = StubRoutines::vector_asin_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ACOS: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_acos_double64\";  *addr_ptr = StubRoutines::vector_acos_double64();  break;\n+            case 128: *name_ptr = \"vector_acos_double128\"; *addr_ptr = StubRoutines::vector_acos_double128(); break;\n+            case 256: *name_ptr = \"vector_acos_double256\"; *addr_ptr = StubRoutines::vector_acos_double256(); break;\n+            case 512: *name_ptr = \"vector_acos_double512\"; *addr_ptr = StubRoutines::vector_acos_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan_double64\";  *addr_ptr = StubRoutines::vector_atan_double64();  break;\n+            case 128: *name_ptr = \"vector_atan_double128\"; *addr_ptr = StubRoutines::vector_atan_double128(); break;\n+            case 256: *name_ptr = \"vector_atan_double256\"; *addr_ptr = StubRoutines::vector_atan_double256(); break;\n+            case 512: *name_ptr = \"vector_atan_double512\"; *addr_ptr = StubRoutines::vector_atan_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_CBRT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_cbrt_double64\";  *addr_ptr = StubRoutines::vector_cbrt_double64();  break;\n+            case 128: *name_ptr = \"vector_cbrt_double128\"; *addr_ptr = StubRoutines::vector_cbrt_double128(); break;\n+            case 256: *name_ptr = \"vector_cbrt_double256\"; *addr_ptr = StubRoutines::vector_cbrt_double256(); break;\n+            case 512: *name_ptr = \"vector_cbrt_double512\"; *addr_ptr = StubRoutines::vector_cbrt_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_HYPOT: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_hypot_double64\";  *addr_ptr = StubRoutines::vector_hypot_double64();  break;\n+            case 128: *name_ptr = \"vector_hypot_double128\"; *addr_ptr = StubRoutines::vector_hypot_double128(); break;\n+            case 256: *name_ptr = \"vector_hypot_double256\"; *addr_ptr = StubRoutines::vector_hypot_double256(); break;\n+            case 512: *name_ptr = \"vector_hypot_double512\"; *addr_ptr = StubRoutines::vector_hypot_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_POW: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_pow_double64\";  *addr_ptr = StubRoutines::vector_pow_double64();  break;\n+            case 128: *name_ptr = \"vector_pow_double128\"; *addr_ptr = StubRoutines::vector_pow_double128(); break;\n+            case 256: *name_ptr = \"vector_pow_double256\"; *addr_ptr = StubRoutines::vector_pow_double256(); break;\n+            case 512: *name_ptr = \"vector_pow_double512\"; *addr_ptr = StubRoutines::vector_pow_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+      case VectorSupport::VECTOR_OP_ATAN2: {\n+          switch(bits) {\n+            case 64:  *name_ptr = \"vector_atan2_double64\";  *addr_ptr = StubRoutines::vector_atan2_double64();  break;\n+            case 128: *name_ptr = \"vector_atan2_double128\"; *addr_ptr = StubRoutines::vector_atan2_double128(); break;\n+            case 256: *name_ptr = \"vector_atan2_double256\"; *addr_ptr = StubRoutines::vector_atan2_double256(); break;\n+            case 512: *name_ptr = \"vector_atan2_double512\"; *addr_ptr = StubRoutines::vector_atan2_double512(); break;\n+            default: Unimplemented(); break;\n+          }\n+        }\n+        break;\n+\n+      default:\n+        *name_ptr = \"invalid\";\n+        *addr_ptr = NULL;\n+        break;\n+    }\n+  }\n+#else\n+  *name_ptr = \"invalid\";\n+  *addr_ptr = NULL;\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+}\n+\n+Node* LibraryCallKit::gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n+  assert(UseVectorStubs, \"sanity\");\n+  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_SVML_START && vector_api_op_id <= VectorSupport::VECTOR_OP_SVML_END, \"need valid op id\");\n+  assert(opd1 != NULL, \"must not be null\");\n+  const TypeVect* vt = TypeVect::make(bt, num_elem);\n+  const TypeFunc* call_type = OptoRuntime::Math_Vector_Vector_Type(opd2 != NULL ? 2 : 1, vt, vt);\n+  const char* name = NULL;\n+  address addr = NULL;\n+\n+  \/\/ Get address for svml method.\n+  get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, &name, &addr);\n+\n+  if (addr == NULL) {\n+    return NULL;\n+  }\n+\n+  assert(name != NULL, \"name must not be null\");\n+  Node* operation = make_runtime_call(RC_VECTOR,\n+                                      call_type,\n+                                      addr,\n+                                      name,\n+                                      TypePtr::BOTTOM,\n+                                      opd1,\n+                                      opd2);\n+  return _gvn.transform(new ProjNode(_gvn.transform(operation), TypeFunc::Parms));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":458,"deletions":12,"binary":false,"changes":470,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1114,0 +1114,1 @@\n+    assert((BoolTest::mask)predicate_node->get_int() == predicate, \"Unmatched predicates\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -353,0 +353,19 @@\n+    case VECTOR_OP_TAN:\n+    case VECTOR_OP_TANH:\n+    case VECTOR_OP_SIN:\n+    case VECTOR_OP_SINH:\n+    case VECTOR_OP_COS:\n+    case VECTOR_OP_COSH:\n+    case VECTOR_OP_ASIN:\n+    case VECTOR_OP_ACOS:\n+    case VECTOR_OP_ATAN:\n+    case VECTOR_OP_ATAN2:\n+    case VECTOR_OP_CBRT:\n+    case VECTOR_OP_LOG:\n+    case VECTOR_OP_LOG10:\n+    case VECTOR_OP_LOG1P:\n+    case VECTOR_OP_POW:\n+    case VECTOR_OP_EXP:\n+    case VECTOR_OP_EXPM1:\n+    case VECTOR_OP_HYPOT:\n+      return Op_CallLeafVector;\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -4114,0 +4114,5 @@\n+\n+    if (!FLAG_IS_DEFAULT(UseVectorStubs) && UseVectorStubs) {\n+      warning(\"Disabling UseVectorStubs since EnableVectorSupport is turned off.\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorStubs, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -391,0 +391,4 @@\n+  static int vector_calling_convention(VMRegPair *regs,\n+                                       uint num_bits,\n+                                       uint total_args_passed);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,0 +185,147 @@\n+#ifdef __VECTOR_API_MATH_INTRINSICS_COMMON\n+address StubRoutines::_vector_exp_float64                = NULL;\n+address StubRoutines::_vector_exp_float128               = NULL;\n+address StubRoutines::_vector_exp_float256               = NULL;\n+address StubRoutines::_vector_exp_float512               = NULL;\n+address StubRoutines::_vector_exp_double64               = NULL;\n+address StubRoutines::_vector_exp_double128              = NULL;\n+address StubRoutines::_vector_exp_double256              = NULL;\n+address StubRoutines::_vector_exp_double512              = NULL;\n+address StubRoutines::_vector_expm1_float64              = NULL;\n+address StubRoutines::_vector_expm1_float128             = NULL;\n+address StubRoutines::_vector_expm1_float256             = NULL;\n+address StubRoutines::_vector_expm1_float512             = NULL;\n+address StubRoutines::_vector_expm1_double64             = NULL;\n+address StubRoutines::_vector_expm1_double128            = NULL;\n+address StubRoutines::_vector_expm1_double256            = NULL;\n+address StubRoutines::_vector_expm1_double512            = NULL;\n+address StubRoutines::_vector_log1p_float64              = NULL;\n+address StubRoutines::_vector_log1p_float128             = NULL;\n+address StubRoutines::_vector_log1p_float256             = NULL;\n+address StubRoutines::_vector_log1p_float512             = NULL;\n+address StubRoutines::_vector_log1p_double64             = NULL;\n+address StubRoutines::_vector_log1p_double128            = NULL;\n+address StubRoutines::_vector_log1p_double256            = NULL;\n+address StubRoutines::_vector_log1p_double512            = NULL;\n+address StubRoutines::_vector_log_float64                = NULL;\n+address StubRoutines::_vector_log_float128               = NULL;\n+address StubRoutines::_vector_log_float256               = NULL;\n+address StubRoutines::_vector_log_float512               = NULL;\n+address StubRoutines::_vector_log_double64               = NULL;\n+address StubRoutines::_vector_log_double128              = NULL;\n+address StubRoutines::_vector_log_double256              = NULL;\n+address StubRoutines::_vector_log_double512              = NULL;\n+address StubRoutines::_vector_log10_float64              = NULL;\n+address StubRoutines::_vector_log10_float128             = NULL;\n+address StubRoutines::_vector_log10_float256             = NULL;\n+address StubRoutines::_vector_log10_float512             = NULL;\n+address StubRoutines::_vector_log10_double64             = NULL;\n+address StubRoutines::_vector_log10_double128            = NULL;\n+address StubRoutines::_vector_log10_double256            = NULL;\n+address StubRoutines::_vector_log10_double512            = NULL;\n+address StubRoutines::_vector_sin_float64                = NULL;\n+address StubRoutines::_vector_sin_float128               = NULL;\n+address StubRoutines::_vector_sin_float256               = NULL;\n+address StubRoutines::_vector_sin_float512               = NULL;\n+address StubRoutines::_vector_sin_double64               = NULL;\n+address StubRoutines::_vector_sin_double128              = NULL;\n+address StubRoutines::_vector_sin_double256              = NULL;\n+address StubRoutines::_vector_sin_double512              = NULL;\n+address StubRoutines::_vector_cos_float64                = NULL;\n+address StubRoutines::_vector_cos_float128               = NULL;\n+address StubRoutines::_vector_cos_float256               = NULL;\n+address StubRoutines::_vector_cos_float512               = NULL;\n+address StubRoutines::_vector_cos_double64               = NULL;\n+address StubRoutines::_vector_cos_double128              = NULL;\n+address StubRoutines::_vector_cos_double256              = NULL;\n+address StubRoutines::_vector_cos_double512              = NULL;\n+address StubRoutines::_vector_tan_float64                = NULL;\n+address StubRoutines::_vector_tan_float128               = NULL;\n+address StubRoutines::_vector_tan_float256               = NULL;\n+address StubRoutines::_vector_tan_float512               = NULL;\n+address StubRoutines::_vector_tan_double64               = NULL;\n+address StubRoutines::_vector_tan_double128              = NULL;\n+address StubRoutines::_vector_tan_double256              = NULL;\n+address StubRoutines::_vector_tan_double512              = NULL;\n+address StubRoutines::_vector_sinh_float64               = NULL;\n+address StubRoutines::_vector_sinh_float128               = NULL;\n+address StubRoutines::_vector_sinh_float256               = NULL;\n+address StubRoutines::_vector_sinh_float512               = NULL;\n+address StubRoutines::_vector_sinh_double64               = NULL;\n+address StubRoutines::_vector_sinh_double128              = NULL;\n+address StubRoutines::_vector_sinh_double256              = NULL;\n+address StubRoutines::_vector_sinh_double512              = NULL;\n+address StubRoutines::_vector_cosh_float64                = NULL;\n+address StubRoutines::_vector_cosh_float128               = NULL;\n+address StubRoutines::_vector_cosh_float256               = NULL;\n+address StubRoutines::_vector_cosh_float512               = NULL;\n+address StubRoutines::_vector_cosh_double64               = NULL;\n+address StubRoutines::_vector_cosh_double128              = NULL;\n+address StubRoutines::_vector_cosh_double256              = NULL;\n+address StubRoutines::_vector_cosh_double512              = NULL;\n+address StubRoutines::_vector_tanh_float64                = NULL;\n+address StubRoutines::_vector_tanh_float128               = NULL;\n+address StubRoutines::_vector_tanh_float256               = NULL;\n+address StubRoutines::_vector_tanh_float512               = NULL;\n+address StubRoutines::_vector_tanh_double64               = NULL;\n+address StubRoutines::_vector_tanh_double128              = NULL;\n+address StubRoutines::_vector_tanh_double256              = NULL;\n+address StubRoutines::_vector_tanh_double512              = NULL;\n+address StubRoutines::_vector_acos_float64                = NULL;\n+address StubRoutines::_vector_acos_float128               = NULL;\n+address StubRoutines::_vector_acos_float256               = NULL;\n+address StubRoutines::_vector_acos_float512               = NULL;\n+address StubRoutines::_vector_acos_double64               = NULL;\n+address StubRoutines::_vector_acos_double128              = NULL;\n+address StubRoutines::_vector_acos_double256              = NULL;\n+address StubRoutines::_vector_acos_double512              = NULL;\n+address StubRoutines::_vector_asin_float64                = NULL;\n+address StubRoutines::_vector_asin_float128               = NULL;\n+address StubRoutines::_vector_asin_float256               = NULL;\n+address StubRoutines::_vector_asin_float512               = NULL;\n+address StubRoutines::_vector_asin_double64               = NULL;\n+address StubRoutines::_vector_asin_double128              = NULL;\n+address StubRoutines::_vector_asin_double256              = NULL;\n+address StubRoutines::_vector_asin_double512              = NULL;\n+address StubRoutines::_vector_atan_float64                = NULL;\n+address StubRoutines::_vector_atan_float128               = NULL;\n+address StubRoutines::_vector_atan_float256               = NULL;\n+address StubRoutines::_vector_atan_float512               = NULL;\n+address StubRoutines::_vector_atan_double64               = NULL;\n+address StubRoutines::_vector_atan_double128              = NULL;\n+address StubRoutines::_vector_atan_double256              = NULL;\n+address StubRoutines::_vector_atan_double512              = NULL;\n+address StubRoutines::_vector_pow_float64                 = NULL;\n+address StubRoutines::_vector_pow_float128                = NULL;\n+address StubRoutines::_vector_pow_float256                = NULL;\n+address StubRoutines::_vector_pow_float512                = NULL;\n+address StubRoutines::_vector_pow_double64                = NULL;\n+address StubRoutines::_vector_pow_double128               = NULL;\n+address StubRoutines::_vector_pow_double256               = NULL;\n+address StubRoutines::_vector_pow_double512               = NULL;\n+address StubRoutines::_vector_hypot_float64               = NULL;\n+address StubRoutines::_vector_hypot_float128              = NULL;\n+address StubRoutines::_vector_hypot_float256              = NULL;\n+address StubRoutines::_vector_hypot_float512              = NULL;\n+address StubRoutines::_vector_hypot_double64              = NULL;\n+address StubRoutines::_vector_hypot_double128             = NULL;\n+address StubRoutines::_vector_hypot_double256             = NULL;\n+address StubRoutines::_vector_hypot_double512             = NULL;\n+address StubRoutines::_vector_cbrt_float64                = NULL;\n+address StubRoutines::_vector_cbrt_float128               = NULL;\n+address StubRoutines::_vector_cbrt_float256               = NULL;\n+address StubRoutines::_vector_cbrt_float512               = NULL;\n+address StubRoutines::_vector_cbrt_double64               = NULL;\n+address StubRoutines::_vector_cbrt_double128              = NULL;\n+address StubRoutines::_vector_cbrt_double256              = NULL;\n+address StubRoutines::_vector_cbrt_double512              = NULL;\n+address StubRoutines::_vector_atan2_float64               = NULL;\n+address StubRoutines::_vector_atan2_float128              = NULL;\n+address StubRoutines::_vector_atan2_float256              = NULL;\n+address StubRoutines::_vector_atan2_float512              = NULL;\n+address StubRoutines::_vector_atan2_double64              = NULL;\n+address StubRoutines::_vector_atan2_double128             = NULL;\n+address StubRoutines::_vector_atan2_double256             = NULL;\n+address StubRoutines::_vector_atan2_double512             = NULL;\n+#endif \/\/ __VECTOR_API_MATH_INTRINSICS_COMMON\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":147,"deletions":0,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -1532,0 +1532,1 @@\n+  declare_c2_type(CallLeafVectorNode, CallLeafNode)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/globalDefinitions_vecApi.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -323,0 +323,11 @@\n+  void truncate_to(int idx) {\n+    for (int i = 0, j = idx; j < length(); i++, j++) {\n+      at_put(i, at(j));\n+    }\n+    trunc_to(length() - idx);\n+  }\n+\n+  void truncate_from(int idx) {\n+    trunc_to(idx);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -552,31 +552,0 @@\n-            if (op == SIN) {\n-                return uOp((i, a) -> (double) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> (double) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> (double) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> (double) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> (double) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> (double) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> (double) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> (double) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> (double) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> (double) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> (double) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> (double) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> (double) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> (double) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> (double) Math.log1p(a));\n-            }\n@@ -594,0 +563,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log10(a));\n@@ -596,0 +583,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> (double) Math.log1p(a));\n@@ -642,7 +641,0 @@\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> (double) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> (double) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> (double) Math.hypot(a, b));\n-            }\n@@ -668,0 +660,8 @@\n+                case VECTOR_OP_OR: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (double) Math.hypot(a, b));\n@@ -2732,0 +2732,1 @@\n+\n@@ -2864,1 +2865,1 @@\n-     * Stores this vector into an array of {@code double}\n+     * Stores this vector into an array of type {@code double[]}\n@@ -3021,0 +3022,1 @@\n+\n@@ -3127,0 +3129,1 @@\n+\n@@ -3262,0 +3265,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":43,"deletions":39,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -552,31 +552,0 @@\n-            if (op == SIN) {\n-                return uOp((i, a) -> (float) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> (float) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> (float) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> (float) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> (float) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> (float) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> (float) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> (float) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> (float) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> (float) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> (float) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> (float) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> (float) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> (float) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> (float) Math.log1p(a));\n-            }\n@@ -594,0 +563,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log10(a));\n@@ -596,0 +583,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> (float) Math.log1p(a));\n@@ -642,7 +641,0 @@\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> (float) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> (float) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> (float) Math.hypot(a, b));\n-            }\n@@ -668,0 +660,8 @@\n+                case VECTOR_OP_OR: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> (float) Math.hypot(a, b));\n@@ -2738,0 +2738,1 @@\n+\n@@ -2870,1 +2871,1 @@\n-     * Stores this vector into an array of {@code float}\n+     * Stores this vector into an array of type {@code float[]}\n@@ -3008,0 +3009,1 @@\n+\n@@ -3114,0 +3116,1 @@\n+\n@@ -3249,0 +3252,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":43,"deletions":39,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -572,33 +572,0 @@\n-#if[FP]\n-            if (op == SIN) {\n-                return uOp((i, a) -> ($type$) Math.sin(a));\n-            } else if (op == COS) {\n-                return uOp((i, a) -> ($type$) Math.cos(a));\n-            } else if (op == TAN) {\n-                return uOp((i, a) -> ($type$) Math.tan(a));\n-            } else if (op == ASIN) {\n-                return uOp((i, a) -> ($type$) Math.asin(a));\n-            } else if (op == ACOS) {\n-                return uOp((i, a) -> ($type$) Math.acos(a));\n-            } else if (op == ATAN) {\n-                return uOp((i, a) -> ($type$) Math.atan(a));\n-            } else if (op == EXP) {\n-                return uOp((i, a) -> ($type$) Math.exp(a));\n-            } else if (op == LOG) {\n-                return uOp((i, a) -> ($type$) Math.log(a));\n-            } else if (op == LOG10) {\n-                return uOp((i, a) -> ($type$) Math.log10(a));\n-            } else if (op == CBRT) {\n-                return uOp((i, a) -> ($type$) Math.cbrt(a));\n-            } else if (op == SINH) {\n-                return uOp((i, a) -> ($type$) Math.sinh(a));\n-            } else if (op == COSH) {\n-                return uOp((i, a) -> ($type$) Math.cosh(a));\n-            } else if (op == TANH) {\n-                return uOp((i, a) -> ($type$) Math.tanh(a));\n-            } else if (op == EXPM1) {\n-                return uOp((i, a) -> ($type$) Math.expm1(a));\n-            } else if (op == LOG1P) {\n-                return uOp((i, a) -> ($type$) Math.log1p(a));\n-            }\n-#end[FP]\n@@ -617,0 +584,18 @@\n+                case VECTOR_OP_SIN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.sin(a));\n+                case VECTOR_OP_COS: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cos(a));\n+                case VECTOR_OP_TAN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.tan(a));\n+                case VECTOR_OP_ASIN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.asin(a));\n+                case VECTOR_OP_ACOS: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.acos(a));\n+                case VECTOR_OP_ATAN: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.atan(a));\n+                case VECTOR_OP_EXP: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.exp(a));\n+                case VECTOR_OP_LOG: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log(a));\n+                case VECTOR_OP_LOG10: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log10(a));\n@@ -619,0 +604,12 @@\n+                case VECTOR_OP_CBRT: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cbrt(a));\n+                case VECTOR_OP_SINH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.sinh(a));\n+                case VECTOR_OP_COSH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.cosh(a));\n+                case VECTOR_OP_TANH: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.tanh(a));\n+                case VECTOR_OP_EXPM1: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.expm1(a));\n+                case VECTOR_OP_LOG1P: return v0 ->\n+                        v0.uOp((i, a) -> ($type$) Math.log1p(a));\n@@ -692,9 +689,0 @@\n-#if[FP]\n-            if (op == ATAN2) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.atan2(a, b));\n-            } else if (op == POW) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.pow(a, b));\n-            } else if (op == HYPOT) {\n-                return bOp(that, (i, a, b) -> ($type$) Math.hypot(a, b));\n-            }\n-#end[FP]\n@@ -734,0 +722,10 @@\n+#if[FP]\n+                case VECTOR_OP_OR: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n+                case VECTOR_OP_ATAN2: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.atan2(a, b));\n+                case VECTOR_OP_POW: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.pow(a, b));\n+                case VECTOR_OP_HYPOT: return (v0, v1) ->\n+                        v0.bOp(v1, (i, a, b) -> ($type$) Math.hypot(a, b));\n+#end[FP]\n@@ -3365,0 +3363,152 @@\n+#if[short]\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset.\n+     * For each vector lane, where {@code N} is the vector lane index, the\n+     * array element at index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, species.length(), a.length);\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.dummyVector().fromCharArray0(a, offset);\n+    }\n+\n+    \/**\n+     * Loads a vector from an array of type {@code char[]}\n+     * starting at an offset and using a mask.\n+     * Lanes where the mask is unset are filled with the default\n+     * value of {@code $type$} ({#if[FP]?positive }zero).\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then the array element at\n+     * index {@code offset + N}\n+     * is first cast to a {@code short} value and then\n+     * placed into the resulting vector at lane index\n+     * {@code N}, otherwise the default element value is placed into the\n+     * resulting vector at lane index {@code N}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from an array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        if (offset >= 0 && offset <= (a.length - species.length())) {\n+            $abstractvectortype$ zero = vsp.zero();\n+            return zero.blend(zero.fromCharArray0(a, offset), m);\n+        }\n+\n+        \/\/ FIXME: optimize\n+        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+        return vsp.vOp(m, i -> (short) a[offset + i]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+\n+    \/**\n+     * Gathers a new vector composed of elements from an array of type\n+     * {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the lane is set in the mask,\n+     * the lane is loaded from the expression\n+     * {@code (short) a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     * Unset lanes in the resulting vector are set to zero.\n+     *\n+     * @param species species of desired vector\n+     * @param a the array\n+     * @param offset the offset into the array, may be negative if relative\n+     * indexes in the index map compensate to produce a value within the\n+     * array bounds\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask controlling lane selection\n+     * @return the vector loaded from the indexed elements of the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public static\n+    $abstractvectortype$ fromCharArray(VectorSpecies<$Boxtype$> species,\n+                                       char[] a, int offset,\n+                                       int[] indexMap, int mapOffset,\n+                                       VectorMask<$Boxtype$> m) {\n+        $Type$Species vsp = ($Type$Species) species;\n+        return vsp.vOp(m, n -> (short) a[offset + indexMap[mapOffset + n]]);\n+    }\n+#end[short]\n+\n@@ -3503,1 +3653,1 @@\n-     * Stores this vector into an array of {@code $type$}\n+     * Stores this vector into an array of type {@code $type$[]}\n@@ -3694,0 +3844,154 @@\n+#if[short]\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at an offset.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset) {\n+        offset = checkFromIndexSize(offset, length(), a.length);\n+        $Type$Species vsp = vspecies();\n+        VectorSupport.store(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            this,\n+            a, offset,\n+            (arr, off, v)\n+            -> v.stOp(arr, off,\n+                      (arr_, off_, i, e) -> arr_[off_ + i] = (char) e));\n+    }\n+\n+    \/**\n+     * Stores this vector into an array of type {@code char[]}\n+     * starting at offset and using a mask.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array element {@code a[offset+N]}.\n+     * If the mask lane at {@code N} is unset then the corresponding\n+     * array element {@code a[offset+N]} is left unchanged.\n+     * <p>\n+     * Array range checking is done for lanes where the mask is set.\n+     * Lanes where the mask is unset are not stored and do not need\n+     * to correspond to legitimate elements of {@code a}.\n+     * That is, unset lanes may correspond to array indexes less than\n+     * zero or beyond the end of the array.\n+     *\n+     * @param a the array, of type {@code char[]}\n+     * @param offset the offset into the array\n+     * @param m the mask controlling lane storage\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code offset+N < 0} or {@code offset+N >= a.length}\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       VectorMask<$Boxtype$> m) {\n+        if (m.allTrue()) {\n+            intoCharArray(a, offset);\n+        } else {\n+            \/\/ FIXME: optimize\n+            $Type$Species vsp = vspecies();\n+            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n+            stOp(a, offset, m, (arr, off, i, v) -> arr[off+i] = (char) v);\n+        }\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]}\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset) {\n+        stOp(a, offset,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+\n+    \/**\n+     * Scatters this vector into an array of type {@code char[]},\n+     * under the control of a mask, and\n+     * using indexes obtained by adding a fixed {@code offset} to a\n+     * series of secondary offsets from an <em>index map<\/em>.\n+     * The index map is a contiguous sequence of {@code VLENGTH}\n+     * elements in a second array of {@code int}s, starting at a given\n+     * {@code mapOffset}.\n+     * <p>\n+     * For each vector lane, where {@code N} is the vector lane index,\n+     * if the mask lane at index {@code N} is set then\n+     * the lane element at index {@code N}\n+     * is first cast to a {@code char} value and then\n+     * stored into the array\n+     * element {@code a[f(N)]}, where {@code f(N)} is the\n+     * index mapping expression\n+     * {@code offset + indexMap[mapOffset + N]]}.\n+     *\n+     * @param a the array\n+     * @param offset an offset to combine with the index map offsets\n+     * @param indexMap the index map\n+     * @param mapOffset the offset into the index map\n+     * @param m the mask\n+     * @throws IndexOutOfBoundsException\n+     *         if {@code mapOffset+N < 0}\n+     *         or if {@code mapOffset+N >= indexMap.length},\n+     *         or if {@code f(N)=offset+indexMap[mapOffset+N]}\n+     *         is an invalid index into {@code a},\n+     *         for any lane {@code N} in the vector\n+     *         where the mask is set\n+     * @see $abstractvectortype$#toIntArray()\n+     *\/\n+    @ForceInline\n+    public final\n+    void intoCharArray(char[] a, int offset,\n+                       int[] indexMap, int mapOffset,\n+                       VectorMask<$Boxtype$> m) {\n+        stOp(a, offset, m,\n+             (arr, off, i, e) -> {\n+                 int j = indexMap[mapOffset + i];\n+                 arr[off + j] = (char) e;\n+             });\n+    }\n+#end[short]\n+\n@@ -3800,0 +4104,17 @@\n+#if[short]\n+    \/*package-private*\/\n+    abstract\n+    $abstractvectortype$ fromCharArray0(char[] a, int offset);\n+    @ForceInline\n+    final\n+    $abstractvectortype$ fromCharArray0Template(char[] a, int offset) {\n+        $Type$Species vsp = vspecies();\n+        return VectorSupport.load(\n+            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+            a, charArrayAddress(a, offset),\n+            a, offset, vsp,\n+            (arr, off, s) -> s.ldOp(arr, off,\n+                                    (arr_, off_, i) -> (short) arr_[off_ + i]));\n+    }\n+#end[short]\n+\n@@ -3937,0 +4258,12 @@\n+#if[short]\n+    static final int ARRAY_CHAR_SHIFT =\n+            31 - Integer.numberOfLeadingZeros(Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+    static final long ARRAY_CHAR_BASE =\n+            Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+\n+    @ForceInline\n+    static long charArrayAddress(char[] a, int index) {\n+        return ARRAY_CHAR_BASE + (((long)index) << ARRAY_CHAR_SHIFT);\n+    }\n+#end[short]\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":376,"deletions":43,"binary":false,"changes":419,"status":"modified"},{"patch":"@@ -1488,15 +1488,15 @@\n-generate(SpecialCases, [[\"ccmn\",   \"__ ccmn(zr, zr, 3u, Assembler::LE);\",                \"ccmn\\txzr, xzr, #3, LE\"],\n-                        [\"ccmnw\",  \"__ ccmnw(zr, zr, 5u, Assembler::EQ);\",               \"ccmn\\twzr, wzr, #5, EQ\"],\n-                        [\"ccmp\",   \"__ ccmp(zr, 1, 4u, Assembler::NE);\",                 \"ccmp\\txzr, 1, #4, NE\"],\n-                        [\"ccmpw\",  \"__ ccmpw(zr, 2, 2, Assembler::GT);\",                 \"ccmp\\twzr, 2, #2, GT\"],\n-                        [\"extr\",   \"__ extr(zr, zr, zr, 0);\",                            \"extr\\txzr, xzr, xzr, 0\"],\n-                        [\"stlxp\",  \"__ stlxp(r0, zr, zr, sp);\",                          \"stlxp\\tw0, xzr, xzr, [sp]\"],\n-                        [\"stlxpw\", \"__ stlxpw(r2, zr, zr, r3);\",                         \"stlxp\\tw2, wzr, wzr, [x3]\"],\n-                        [\"stxp\",   \"__ stxp(r4, zr, zr, r5);\",                           \"stxp\\tw4, xzr, xzr, [x5]\"],\n-                        [\"stxpw\",  \"__ stxpw(r6, zr, zr, sp);\",                          \"stxp\\tw6, wzr, wzr, [sp]\"],\n-                        [\"dup\",    \"__ dup(v0, __ T16B, zr);\",                           \"dup\\tv0.16b, wzr\"],\n-                        [\"mov\",    \"__ mov(v1, __ T1D, 0, zr);\",                         \"mov\\tv1.d[0], xzr\"],\n-                        [\"mov\",    \"__ mov(v1, __ T2S, 1, zr);\",                         \"mov\\tv1.s[1], wzr\"],\n-                        [\"mov\",    \"__ mov(v1, __ T4H, 2, zr);\",                         \"mov\\tv1.h[2], wzr\"],\n-                        [\"mov\",    \"__ mov(v1, __ T8B, 3, zr);\",                         \"mov\\tv1.b[3], wzr\"],\n-                        [\"ld1\",    \"__ ld1(v31, v0, __ T2D, Address(__ post(r1, r0)));\", \"ld1\\t{v31.2d, v0.2d}, [x1], x0\"],\n+generate(SpecialCases, [[\"ccmn\",    \"__ ccmn(zr, zr, 3u, Assembler::LE);\",                \"ccmn\\txzr, xzr, #3, LE\"],\n+                        [\"ccmnw\",   \"__ ccmnw(zr, zr, 5u, Assembler::EQ);\",               \"ccmn\\twzr, wzr, #5, EQ\"],\n+                        [\"ccmp\",    \"__ ccmp(zr, 1, 4u, Assembler::NE);\",                 \"ccmp\\txzr, 1, #4, NE\"],\n+                        [\"ccmpw\",   \"__ ccmpw(zr, 2, 2, Assembler::GT);\",                 \"ccmp\\twzr, 2, #2, GT\"],\n+                        [\"extr\",    \"__ extr(zr, zr, zr, 0);\",                            \"extr\\txzr, xzr, xzr, 0\"],\n+                        [\"stlxp\",   \"__ stlxp(r0, zr, zr, sp);\",                          \"stlxp\\tw0, xzr, xzr, [sp]\"],\n+                        [\"stlxpw\",  \"__ stlxpw(r2, zr, zr, r3);\",                         \"stlxp\\tw2, wzr, wzr, [x3]\"],\n+                        [\"stxp\",    \"__ stxp(r4, zr, zr, r5);\",                           \"stxp\\tw4, xzr, xzr, [x5]\"],\n+                        [\"stxpw\",   \"__ stxpw(r6, zr, zr, sp);\",                          \"stxp\\tw6, wzr, wzr, [sp]\"],\n+                        [\"dup\",     \"__ dup(v0, __ T16B, zr);\",                           \"dup\\tv0.16b, wzr\"],\n+                        [\"mov\",     \"__ mov(v1, __ T1D, 0, zr);\",                         \"mov\\tv1.d[0], xzr\"],\n+                        [\"mov\",     \"__ mov(v1, __ T2S, 1, zr);\",                         \"mov\\tv1.s[1], wzr\"],\n+                        [\"mov\",     \"__ mov(v1, __ T4H, 2, zr);\",                         \"mov\\tv1.h[2], wzr\"],\n+                        [\"mov\",     \"__ mov(v1, __ T8B, 3, zr);\",                         \"mov\\tv1.b[3], wzr\"],\n+                        [\"ld1\",     \"__ ld1(v31, v0, __ T2D, Address(__ post(r1, r0)));\", \"ld1\\t{v31.2d, v0.2d}, [x1], x0\"],\n@@ -1504,33 +1504,79 @@\n-                        [\"cpy\",    \"__ sve_cpy(z0, __ S, p0, v1);\",                      \"mov\\tz0.s, p0\/m, s1\"],\n-                        [\"inc\",    \"__ sve_inc(r0, __ S);\",                              \"incw\\tx0\"],\n-                        [\"dec\",    \"__ sve_dec(r1, __ H);\",                              \"dech\\tx1\"],\n-                        [\"lsl\",    \"__ sve_lsl(z0, __ B, z1, 7);\",                       \"lsl\\tz0.b, z1.b, #7\"],\n-                        [\"lsl\",    \"__ sve_lsl(z21, __ H, z1, 15);\",                     \"lsl\\tz21.h, z1.h, #15\"],\n-                        [\"lsl\",    \"__ sve_lsl(z0, __ S, z1, 31);\",                      \"lsl\\tz0.s, z1.s, #31\"],\n-                        [\"lsl\",    \"__ sve_lsl(z0, __ D, z1, 63);\",                      \"lsl\\tz0.d, z1.d, #63\"],\n-                        [\"lsr\",    \"__ sve_lsr(z0, __ B, z1, 7);\",                       \"lsr\\tz0.b, z1.b, #7\"],\n-                        [\"asr\",    \"__ sve_asr(z0, __ H, z11, 15);\",                     \"asr\\tz0.h, z11.h, #15\"],\n-                        [\"lsr\",    \"__ sve_lsr(z30, __ S, z1, 31);\",                     \"lsr\\tz30.s, z1.s, #31\"],\n-                        [\"asr\",    \"__ sve_asr(z0, __ D, z1, 63);\",                      \"asr\\tz0.d, z1.d, #63\"],\n-                        [\"addvl\",  \"__ sve_addvl(sp, r0, 31);\",                          \"addvl\\tsp, x0, #31\"],\n-                        [\"addpl\",  \"__ sve_addpl(r1, sp, -32);\",                         \"addpl\\tx1, sp, -32\"],\n-                        [\"cntp\",   \"__ sve_cntp(r8, __ B, p0, p1);\",                     \"cntp\\tx8, p0, p1.b\"],\n-                        [\"dup\",    \"__ sve_dup(z0, __ B, 127);\",                         \"dup\\tz0.b, 127\"],\n-                        [\"dup\",    \"__ sve_dup(z1, __ H, -128);\",                        \"dup\\tz1.h, -128\"],\n-                        [\"dup\",    \"__ sve_dup(z2, __ S, 32512);\",                       \"dup\\tz2.s, 32512\"],\n-                        [\"dup\",    \"__ sve_dup(z7, __ D, -32768);\",                      \"dup\\tz7.d, -32768\"],\n-                        [\"ld1b\",   \"__ sve_ld1b(z0, __ B, p0, Address(sp));\",            \"ld1b\\t{z0.b}, p0\/z, [sp]\"],\n-                        [\"ld1h\",   \"__ sve_ld1h(z10, __ H, p1, Address(sp, -8));\",       \"ld1h\\t{z10.h}, p1\/z, [sp, #-8, MUL VL]\"],\n-                        [\"ld1w\",   \"__ sve_ld1w(z20, __ S, p2, Address(r0, 7));\",        \"ld1w\\t{z20.s}, p2\/z, [x0, #7, MUL VL]\"],\n-                        [\"ld1b\",   \"__ sve_ld1b(z30, __ B, p3, Address(sp, r8));\",       \"ld1b\\t{z30.b}, p3\/z, [sp, x8]\"],\n-                        [\"ld1w\",   \"__ sve_ld1w(z0, __ S, p4, Address(sp, r28));\",       \"ld1w\\t{z0.s}, p4\/z, [sp, x28, LSL #2]\"],\n-                        [\"ld1d\",   \"__ sve_ld1d(z11, __ D, p5, Address(r0, r1));\",       \"ld1d\\t{z11.d}, p5\/z, [x0, x1, LSL #3]\"],\n-                        [\"st1b\",   \"__ sve_st1b(z22, __ B, p6, Address(sp));\",           \"st1b\\t{z22.b}, p6, [sp]\"],\n-                        [\"st1b\",   \"__ sve_st1b(z31, __ B, p7, Address(sp, -8));\",       \"st1b\\t{z31.b}, p7, [sp, #-8, MUL VL]\"],\n-                        [\"st1w\",   \"__ sve_st1w(z0, __ S, p1, Address(r0, 7));\",         \"st1w\\t{z0.s}, p1, [x0, #7, MUL VL]\"],\n-                        [\"st1b\",   \"__ sve_st1b(z0, __ B, p2, Address(sp, r1));\",        \"st1b\\t{z0.b}, p2, [sp, x1]\"],\n-                        [\"st1h\",   \"__ sve_st1h(z0, __ H, p3, Address(sp, r8));\",        \"st1h\\t{z0.h}, p3, [sp, x8, LSL #1]\"],\n-                        [\"st1d\",   \"__ sve_st1d(z0, __ D, p4, Address(r0, r17));\",       \"st1d\\t{z0.d}, p4, [x0, x17, LSL #3]\"],\n-                        [\"ldr\",    \"__ sve_ldr(z0, Address(sp));\",                       \"ldr\\tz0, [sp]\"],\n-                        [\"ldr\",    \"__ sve_ldr(z31, Address(sp, -256));\",                \"ldr\\tz31, [sp, #-256, MUL VL]\"],\n-                        [\"str\",    \"__ sve_str(z8, Address(r8, 255));\",                  \"str\\tz8, [x8, #255, MUL VL]\"],\n+                        [\"cpy\",     \"__ sve_cpy(z0, __ S, p0, v1);\",                      \"mov\\tz0.s, p0\/m, s1\"],\n+                        [\"cpy\",     \"__ sve_cpy(z0, __ B, p0, 127, true);\",               \"mov\\tz0.b, p0\/m, 127\"],\n+                        [\"cpy\",     \"__ sve_cpy(z1, __ H, p0, -128, true);\",              \"mov\\tz1.h, p0\/m, -128\"],\n+                        [\"cpy\",     \"__ sve_cpy(z2, __ S, p0, 32512, true);\",             \"mov\\tz2.s, p0\/m, 32512\"],\n+                        [\"cpy\",     \"__ sve_cpy(z5, __ D, p0, -32768, false);\",           \"mov\\tz5.d, p0\/z, -32768\"],\n+                        [\"cpy\",     \"__ sve_cpy(z10, __ B, p0, -1, false);\",              \"mov\\tz10.b, p0\/z, -1\"],\n+                        [\"cpy\",     \"__ sve_cpy(z11, __ S, p0, -1, false);\",              \"mov\\tz11.s, p0\/z, -1\"],\n+                        [\"inc\",     \"__ sve_inc(r0, __ S);\",                              \"incw\\tx0\"],\n+                        [\"dec\",     \"__ sve_dec(r1, __ H);\",                              \"dech\\tx1\"],\n+                        [\"lsl\",     \"__ sve_lsl(z0, __ B, z1, 7);\",                       \"lsl\\tz0.b, z1.b, #7\"],\n+                        [\"lsl\",     \"__ sve_lsl(z21, __ H, z1, 15);\",                     \"lsl\\tz21.h, z1.h, #15\"],\n+                        [\"lsl\",     \"__ sve_lsl(z0, __ S, z1, 31);\",                      \"lsl\\tz0.s, z1.s, #31\"],\n+                        [\"lsl\",     \"__ sve_lsl(z0, __ D, z1, 63);\",                      \"lsl\\tz0.d, z1.d, #63\"],\n+                        [\"lsr\",     \"__ sve_lsr(z0, __ B, z1, 7);\",                       \"lsr\\tz0.b, z1.b, #7\"],\n+                        [\"asr\",     \"__ sve_asr(z0, __ H, z11, 15);\",                     \"asr\\tz0.h, z11.h, #15\"],\n+                        [\"lsr\",     \"__ sve_lsr(z30, __ S, z1, 31);\",                     \"lsr\\tz30.s, z1.s, #31\"],\n+                        [\"asr\",     \"__ sve_asr(z0, __ D, z1, 63);\",                      \"asr\\tz0.d, z1.d, #63\"],\n+                        [\"addvl\",   \"__ sve_addvl(sp, r0, 31);\",                          \"addvl\\tsp, x0, #31\"],\n+                        [\"addpl\",   \"__ sve_addpl(r1, sp, -32);\",                         \"addpl\\tx1, sp, -32\"],\n+                        [\"cntp\",    \"__ sve_cntp(r8, __ B, p0, p1);\",                     \"cntp\\tx8, p0, p1.b\"],\n+                        [\"dup\",     \"__ sve_dup(z0, __ B, 127);\",                         \"dup\\tz0.b, 127\"],\n+                        [\"dup\",     \"__ sve_dup(z1, __ H, -128);\",                        \"dup\\tz1.h, -128\"],\n+                        [\"dup\",     \"__ sve_dup(z2, __ S, 32512);\",                       \"dup\\tz2.s, 32512\"],\n+                        [\"dup\",     \"__ sve_dup(z7, __ D, -32768);\",                      \"dup\\tz7.d, -32768\"],\n+                        [\"dup\",     \"__ sve_dup(z10, __ B, -1);\",                         \"dup\\tz10.b, -1\"],\n+                        [\"dup\",     \"__ sve_dup(z11, __ S, -1);\",                         \"dup\\tz11.s, -1\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ B, p0, Address(sp));\",            \"ld1b\\t{z0.b}, p0\/z, [sp]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ H, p1, Address(sp));\",            \"ld1b\\t{z0.h}, p1\/z, [sp]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ S, p2, Address(sp, r8));\",        \"ld1b\\t{z0.s}, p2\/z, [sp, x8]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z0, __ D, p3, Address(sp, 7));\",         \"ld1b\\t{z0.d}, p3\/z, [sp, #7, MUL VL]\"],\n+                        [\"ld1h\",    \"__ sve_ld1h(z10, __ H, p1, Address(sp, -8));\",       \"ld1h\\t{z10.h}, p1\/z, [sp, #-8, MUL VL]\"],\n+                        [\"ld1w\",    \"__ sve_ld1w(z20, __ S, p2, Address(r0, 7));\",        \"ld1w\\t{z20.s}, p2\/z, [x0, #7, MUL VL]\"],\n+                        [\"ld1b\",    \"__ sve_ld1b(z30, __ B, p3, Address(sp, r8));\",       \"ld1b\\t{z30.b}, p3\/z, [sp, x8]\"],\n+                        [\"ld1w\",    \"__ sve_ld1w(z0, __ S, p4, Address(sp, r28));\",       \"ld1w\\t{z0.s}, p4\/z, [sp, x28, LSL #2]\"],\n+                        [\"ld1d\",    \"__ sve_ld1d(z11, __ D, p5, Address(r0, r1));\",       \"ld1d\\t{z11.d}, p5\/z, [x0, x1, LSL #3]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z22, __ B, p6, Address(sp));\",           \"st1b\\t{z22.b}, p6, [sp]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z31, __ B, p7, Address(sp, -8));\",       \"st1b\\t{z31.b}, p7, [sp, #-8, MUL VL]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ H, p1, Address(sp));\",            \"st1b\\t{z0.h}, p1, [sp]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ S, p2, Address(sp, r8));\",        \"st1b\\t{z0.s}, p2, [sp, x8]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ D, p3, Address(sp));\",            \"st1b\\t{z0.d}, p3, [sp]\"],\n+                        [\"st1w\",    \"__ sve_st1w(z0, __ S, p1, Address(r0, 7));\",         \"st1w\\t{z0.s}, p1, [x0, #7, MUL VL]\"],\n+                        [\"st1b\",    \"__ sve_st1b(z0, __ B, p2, Address(sp, r1));\",        \"st1b\\t{z0.b}, p2, [sp, x1]\"],\n+                        [\"st1h\",    \"__ sve_st1h(z0, __ H, p3, Address(sp, r8));\",        \"st1h\\t{z0.h}, p3, [sp, x8, LSL #1]\"],\n+                        [\"st1d\",    \"__ sve_st1d(z0, __ D, p4, Address(r0, r17));\",       \"st1d\\t{z0.d}, p4, [x0, x17, LSL #3]\"],\n+                        [\"ldr\",     \"__ sve_ldr(z0, Address(sp));\",                       \"ldr\\tz0, [sp]\"],\n+                        [\"ldr\",     \"__ sve_ldr(z31, Address(sp, -256));\",                \"ldr\\tz31, [sp, #-256, MUL VL]\"],\n+                        [\"str\",     \"__ sve_str(z8, Address(r8, 255));\",                  \"str\\tz8, [x8, #255, MUL VL]\"],\n+                        [\"sel\",     \"__ sve_sel(z0, __ B, p0, z1, z2);\",                  \"sel\\tz0.b, p0, z1.b, z2.b\"],\n+                        [\"sel\",     \"__ sve_sel(z4, __ D, p0, z5, z6);\",                  \"sel\\tz4.d, p0, z5.d, z6.d\"],\n+                        [\"cmpeq\",   \"__ sve_cmpeq(p1, __ B, p0, z0, z1);\",                \"cmpeq\\tp1.b, p0\/z, z0.b, z1.b\"],\n+                        [\"cmpne\",   \"__ sve_cmpne(p1, __ H, p0, z2, z3);\",                \"cmpne\\tp1.h, p0\/z, z2.h, z3.h\"],\n+                        [\"cmpge\",   \"__ sve_cmpge(p1, __ S, p2, z4, z5);\",                \"cmpge\\tp1.s, p2\/z, z4.s, z5.s\"],\n+                        [\"cmpgt\",   \"__ sve_cmpgt(p1, __ D, p3, z6, z7);\",                \"cmpgt\\tp1.d, p3\/z, z6.d, z7.d\"],\n+                        [\"cmple\",   \"__ sve_cmpge(p2, __ B, p0, z10, z11);\",              \"cmple\\tp2.b, p0\/z, z11.b, z10.b\"],\n+                        [\"cmplt\",   \"__ sve_cmpgt(p3, __ S, p0, z16, z17);\",              \"cmplt\\tp3.s, p0\/z, z17.s, z16.s\"],\n+                        [\"cmpeq\",   \"__ sve_cmpeq(p1, __ B, p4, z0, 15);\",                \"cmpeq\\tp1.b, p4\/z, z0.b, #15\"],\n+                        [\"cmpne\",   \"__ sve_cmpne(p1, __ H, p0, z2, -16);\",               \"cmpne\\tp1.h, p0\/z, z2.h, #-16\"],\n+                        [\"cmple\",   \"__ sve_cmple(p1, __ S, p1, z4, 0);\",                 \"cmple\\tp1.s, p1\/z, z4.s, #0\"],\n+                        [\"cmplt\",   \"__ sve_cmplt(p1, __ D, p2, z6, -1);\",                \"cmplt\\tp1.d, p2\/z, z6.d, #-1\"],\n+                        [\"cmpge\",   \"__ sve_cmpge(p1, __ S, p3, z4, 5);\",                 \"cmpge\\tp1.s, p3\/z, z4.s, #5\"],\n+                        [\"cmpgt\",   \"__ sve_cmpgt(p1, __ B, p4, z6, -2);\",                \"cmpgt\\tp1.b, p4\/z, z6.b, #-2\"],\n+                        [\"fcmeq\",   \"__ sve_fcmeq(p1, __ S, p0, z0, z1);\",                \"fcmeq\\tp1.s, p0\/z, z0.s, z1.s\"],\n+                        [\"fcmne\",   \"__ sve_fcmne(p1, __ D, p0, z2, z3);\",                \"fcmne\\tp1.d, p0\/z, z2.d, z3.d\"],\n+                        [\"fcmgt\",   \"__ sve_fcmgt(p1, __ S, p2, z4, z5);\",                \"fcmgt\\tp1.s, p2\/z, z4.s, z5.s\"],\n+                        [\"fcmge\",   \"__ sve_fcmge(p1, __ D, p3, z6, z7);\",                \"fcmge\\tp1.d, p3\/z, z6.d, z7.d\"],\n+                        [\"fcmlt\",   \"__ sve_fcmgt(p2, __ S, p0, z10, z11);\",              \"fcmlt\\tp2.s, p0\/z, z11.s, z10.s\"],\n+                        [\"fcmle\",   \"__ sve_fcmge(p3, __ D, p0, z16, z17);\",              \"fcmle\\tp3.d, p0\/z, z17.d, z16.d\"],\n+                        [\"uunpkhi\", \"__ sve_uunpkhi(z0, __ H, z1);\",                      \"uunpkhi\\tz0.h, z1.b\"],\n+                        [\"uunpklo\", \"__ sve_uunpklo(z4, __ S, z5);\",                      \"uunpklo\\tz4.s, z5.h\"],\n+                        [\"sunpkhi\", \"__ sve_sunpkhi(z6, __ D, z7);\",                      \"sunpkhi\\tz6.d, z7.s\"],\n+                        [\"sunpklo\", \"__ sve_sunpklo(z10, __ H, z11);\",                    \"sunpklo\\tz10.h, z11.b\"],\n+                        [\"whilelt\", \"__ sve_whilelt(p0, __ B, r1, r2);\",                  \"whilelt\\tp0.b, x1, x2\"],\n+                        [\"whilelt\", \"__ sve_whileltw(p1, __ H, r3, r4);\",                 \"whilelt\\tp1.h, w3, w4\"],\n+                        [\"whilele\", \"__ sve_whilele(p2, __ S, r5, r6);\",                  \"whilele\\tp2.s, x5, x6\"],\n+                        [\"whilele\", \"__ sve_whilelew(p3, __ D, r10, r11);\",               \"whilele\\tp3.d, w10, w11\"],\n+                        [\"whilelo\", \"__ sve_whilelo(p4, __ B, r1, r2);\",                  \"whilelo\\tp4.b, x1, x2\"],\n+                        [\"whilelo\", \"__ sve_whilelow(p0, __ H, r3, r4);\",                 \"whilelo\\tp0.h, w3, w4\"],\n+                        [\"whilels\", \"__ sve_whilels(p1, __ S, r5, r6);\",                  \"whilels\\tp1.s, x5, x6\"],\n+                        [\"whilels\", \"__ sve_whilelsw(p2, __ D, r10, r11);\",               \"whilels\\tp2.d, w10, w11\"],\n@@ -1605,0 +1651,2 @@\n+                       [\"uzp1\", \"ZZZ\"],\n+                       [\"uzp2\", \"ZZZ\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":96,"deletions":48,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -690,0 +690,6 @@\n+    __ sve_cpy(z0, __ B, p0, 127, true);               \/\/       mov     z0.b, p0\/m, 127\n+    __ sve_cpy(z1, __ H, p0, -128, true);              \/\/       mov     z1.h, p0\/m, -128\n+    __ sve_cpy(z2, __ S, p0, 32512, true);             \/\/       mov     z2.s, p0\/m, 32512\n+    __ sve_cpy(z5, __ D, p0, -32768, false);           \/\/       mov     z5.d, p0\/z, -32768\n+    __ sve_cpy(z10, __ B, p0, -1, false);              \/\/       mov     z10.b, p0\/z, -1\n+    __ sve_cpy(z11, __ S, p0, -1, false);              \/\/       mov     z11.s, p0\/z, -1\n@@ -707,0 +713,2 @@\n+    __ sve_dup(z10, __ B, -1);                         \/\/       dup     z10.b, -1\n+    __ sve_dup(z11, __ S, -1);                         \/\/       dup     z11.s, -1\n@@ -708,0 +716,3 @@\n+    __ sve_ld1b(z0, __ H, p1, Address(sp));            \/\/       ld1b    {z0.h}, p1\/z, [sp]\n+    __ sve_ld1b(z0, __ S, p2, Address(sp, r8));        \/\/       ld1b    {z0.s}, p2\/z, [sp, x8]\n+    __ sve_ld1b(z0, __ D, p3, Address(sp, 7));         \/\/       ld1b    {z0.d}, p3\/z, [sp, #7, MUL VL]\n@@ -715,0 +726,3 @@\n+    __ sve_st1b(z0, __ H, p1, Address(sp));            \/\/       st1b    {z0.h}, p1, [sp]\n+    __ sve_st1b(z0, __ S, p2, Address(sp, r8));        \/\/       st1b    {z0.s}, p2, [sp, x8]\n+    __ sve_st1b(z0, __ D, p3, Address(sp));            \/\/       st1b    {z0.d}, p3, [sp]\n@@ -722,0 +736,32 @@\n+    __ sve_sel(z0, __ B, p0, z1, z2);                  \/\/       sel     z0.b, p0, z1.b, z2.b\n+    __ sve_sel(z4, __ D, p0, z5, z6);                  \/\/       sel     z4.d, p0, z5.d, z6.d\n+    __ sve_cmpeq(p1, __ B, p0, z0, z1);                \/\/       cmpeq   p1.b, p0\/z, z0.b, z1.b\n+    __ sve_cmpne(p1, __ H, p0, z2, z3);                \/\/       cmpne   p1.h, p0\/z, z2.h, z3.h\n+    __ sve_cmpge(p1, __ S, p2, z4, z5);                \/\/       cmpge   p1.s, p2\/z, z4.s, z5.s\n+    __ sve_cmpgt(p1, __ D, p3, z6, z7);                \/\/       cmpgt   p1.d, p3\/z, z6.d, z7.d\n+    __ sve_cmpge(p2, __ B, p0, z10, z11);              \/\/       cmple   p2.b, p0\/z, z11.b, z10.b\n+    __ sve_cmpgt(p3, __ S, p0, z16, z17);              \/\/       cmplt   p3.s, p0\/z, z17.s, z16.s\n+    __ sve_cmpeq(p1, __ B, p4, z0, 15);                \/\/       cmpeq   p1.b, p4\/z, z0.b, #15\n+    __ sve_cmpne(p1, __ H, p0, z2, -16);               \/\/       cmpne   p1.h, p0\/z, z2.h, #-16\n+    __ sve_cmple(p1, __ S, p1, z4, 0);                 \/\/       cmple   p1.s, p1\/z, z4.s, #0\n+    __ sve_cmplt(p1, __ D, p2, z6, -1);                \/\/       cmplt   p1.d, p2\/z, z6.d, #-1\n+    __ sve_cmpge(p1, __ S, p3, z4, 5);                 \/\/       cmpge   p1.s, p3\/z, z4.s, #5\n+    __ sve_cmpgt(p1, __ B, p4, z6, -2);                \/\/       cmpgt   p1.b, p4\/z, z6.b, #-2\n+    __ sve_fcmeq(p1, __ S, p0, z0, z1);                \/\/       fcmeq   p1.s, p0\/z, z0.s, z1.s\n+    __ sve_fcmne(p1, __ D, p0, z2, z3);                \/\/       fcmne   p1.d, p0\/z, z2.d, z3.d\n+    __ sve_fcmgt(p1, __ S, p2, z4, z5);                \/\/       fcmgt   p1.s, p2\/z, z4.s, z5.s\n+    __ sve_fcmge(p1, __ D, p3, z6, z7);                \/\/       fcmge   p1.d, p3\/z, z6.d, z7.d\n+    __ sve_fcmgt(p2, __ S, p0, z10, z11);              \/\/       fcmlt   p2.s, p0\/z, z11.s, z10.s\n+    __ sve_fcmge(p3, __ D, p0, z16, z17);              \/\/       fcmle   p3.d, p0\/z, z17.d, z16.d\n+    __ sve_uunpkhi(z0, __ H, z1);                      \/\/       uunpkhi z0.h, z1.b\n+    __ sve_uunpklo(z4, __ S, z5);                      \/\/       uunpklo z4.s, z5.h\n+    __ sve_sunpkhi(z6, __ D, z7);                      \/\/       sunpkhi z6.d, z7.s\n+    __ sve_sunpklo(z10, __ H, z11);                    \/\/       sunpklo z10.h, z11.b\n+    __ sve_whilelt(p0, __ B, r1, r2);                  \/\/       whilelt p0.b, x1, x2\n+    __ sve_whileltw(p1, __ H, r3, r4);                 \/\/       whilelt p1.h, w3, w4\n+    __ sve_whilele(p2, __ S, r5, r6);                  \/\/       whilele p2.s, x5, x6\n+    __ sve_whilelew(p3, __ D, r10, r11);               \/\/       whilele p3.d, w10, w11\n+    __ sve_whilelo(p4, __ B, r1, r2);                  \/\/       whilelo p4.b, x1, x2\n+    __ sve_whilelow(p0, __ H, r3, r4);                 \/\/       whilelo p0.h, w3, w4\n+    __ sve_whilels(p1, __ S, r5, r6);                  \/\/       whilels p1.s, x5, x6\n+    __ sve_whilelsw(p2, __ D, r10, r11);               \/\/       whilels p2.d, w10, w11\n@@ -858,38 +904,40 @@\n-    __ sve_add(z26, __ D, z6, z9);                     \/\/       add     z26.d, z6.d, z9.d\n-    __ sve_sub(z17, __ B, z7, z4);                     \/\/       sub     z17.b, z7.b, z4.b\n-    __ sve_fadd(z15, __ S, z9, z22);                   \/\/       fadd    z15.s, z9.s, z22.s\n-    __ sve_fmul(z2, __ D, z27, z20);                   \/\/       fmul    z2.d, z27.d, z20.d\n-    __ sve_fsub(z5, __ D, z26, z0);                    \/\/       fsub    z5.d, z26.d, z0.d\n-    __ sve_abs(z14, __ H, p1, z25);                    \/\/       abs     z14.h, p1\/m, z25.h\n-    __ sve_add(z27, __ D, p5, z26);                    \/\/       add     z27.d, p5\/m, z27.d, z26.d\n-    __ sve_asr(z24, __ B, p5, z0);                     \/\/       asr     z24.b, p5\/m, z24.b, z0.b\n-    __ sve_cnt(z6, __ B, p4, z0);                      \/\/       cnt     z6.b, p4\/m, z0.b\n-    __ sve_lsl(z15, __ B, p0, z9);                     \/\/       lsl     z15.b, p0\/m, z15.b, z9.b\n-    __ sve_lsr(z5, __ B, p2, z27);                     \/\/       lsr     z5.b, p2\/m, z5.b, z27.b\n-    __ sve_mul(z20, __ B, p5, z20);                    \/\/       mul     z20.b, p5\/m, z20.b, z20.b\n-    __ sve_neg(z10, __ D, p2, z16);                    \/\/       neg     z10.d, p2\/m, z16.d\n-    __ sve_not(z6, __ H, p4, z2);                      \/\/       not     z6.h, p4\/m, z2.h\n-    __ sve_smax(z29, __ D, p7, z2);                    \/\/       smax    z29.d, p7\/m, z29.d, z2.d\n-    __ sve_smin(z22, __ H, p7, z14);                   \/\/       smin    z22.h, p7\/m, z22.h, z14.h\n-    __ sve_sub(z27, __ B, p4, z23);                    \/\/       sub     z27.b, p4\/m, z27.b, z23.b\n-    __ sve_fabs(z2, __ D, p3, z10);                    \/\/       fabs    z2.d, p3\/m, z10.d\n-    __ sve_fadd(z10, __ S, p6, z22);                   \/\/       fadd    z10.s, p6\/m, z10.s, z22.s\n-    __ sve_fdiv(z3, __ S, p5, z16);                    \/\/       fdiv    z3.s, p5\/m, z3.s, z16.s\n-    __ sve_fmax(z1, __ D, p4, z16);                    \/\/       fmax    z1.d, p4\/m, z1.d, z16.d\n-    __ sve_fmin(z12, __ S, p3, z12);                   \/\/       fmin    z12.s, p3\/m, z12.s, z12.s\n-    __ sve_fmul(z16, __ D, p0, z20);                   \/\/       fmul    z16.d, p0\/m, z16.d, z20.d\n-    __ sve_fneg(z5, __ D, p1, z7);                     \/\/       fneg    z5.d, p1\/m, z7.d\n-    __ sve_frintm(z12, __ D, p7, z16);                 \/\/       frintm  z12.d, p7\/m, z16.d\n-    __ sve_frintn(z6, __ S, p0, z28);                  \/\/       frintn  z6.s, p0\/m, z28.s\n-    __ sve_frintp(z4, __ D, p1, z17);                  \/\/       frintp  z4.d, p1\/m, z17.d\n-    __ sve_fsqrt(z13, __ S, p3, z19);                  \/\/       fsqrt   z13.s, p3\/m, z19.s\n-    __ sve_fsub(z24, __ S, p5, z17);                   \/\/       fsub    z24.s, p5\/m, z24.s, z17.s\n-    __ sve_fmla(z10, __ D, p6, z6, z19);               \/\/       fmla    z10.d, p6\/m, z6.d, z19.d\n-    __ sve_fmls(z13, __ S, p4, z6, z0);                \/\/       fmls    z13.s, p4\/m, z6.s, z0.s\n-    __ sve_fnmla(z14, __ S, p4, z25, z8);              \/\/       fnmla   z14.s, p4\/m, z25.s, z8.s\n-    __ sve_fnmls(z22, __ S, p5, z22, z27);             \/\/       fnmls   z22.s, p5\/m, z22.s, z27.s\n-    __ sve_mla(z3, __ B, p3, z17, z20);                \/\/       mla     z3.b, p3\/m, z17.b, z20.b\n-    __ sve_mls(z4, __ H, p7, z7, z0);                  \/\/       mls     z4.h, p7\/m, z7.h, z0.h\n-    __ sve_and(z16, z19, z22);                         \/\/       and     z16.d, z19.d, z22.d\n-    __ sve_eor(z15, z9, z22);                          \/\/       eor     z15.d, z9.d, z22.d\n-    __ sve_orr(z25, z5, z30);                          \/\/       orr     z25.d, z5.d, z30.d\n+    __ sve_add(z27, __ S, z29, z28);                   \/\/       add     z27.s, z29.s, z28.s\n+    __ sve_sub(z26, __ D, z6, z9);                     \/\/       sub     z26.d, z6.d, z9.d\n+    __ sve_fadd(z17, __ S, z7, z4);                    \/\/       fadd    z17.s, z7.s, z4.s\n+    __ sve_fmul(z15, __ S, z9, z22);                   \/\/       fmul    z15.s, z9.s, z22.s\n+    __ sve_fsub(z2, __ D, z27, z20);                   \/\/       fsub    z2.d, z27.d, z20.d\n+    __ sve_abs(z5, __ S, p6, z0);                      \/\/       abs     z5.s, p6\/m, z0.s\n+    __ sve_add(z14, __ H, p1, z25);                    \/\/       add     z14.h, p1\/m, z14.h, z25.h\n+    __ sve_asr(z27, __ D, p5, z26);                    \/\/       asr     z27.d, p5\/m, z27.d, z26.d\n+    __ sve_cnt(z24, __ B, p5, z0);                     \/\/       cnt     z24.b, p5\/m, z0.b\n+    __ sve_lsl(z6, __ B, p4, z0);                      \/\/       lsl     z6.b, p4\/m, z6.b, z0.b\n+    __ sve_lsr(z15, __ B, p0, z9);                     \/\/       lsr     z15.b, p0\/m, z15.b, z9.b\n+    __ sve_mul(z5, __ B, p2, z27);                     \/\/       mul     z5.b, p2\/m, z5.b, z27.b\n+    __ sve_neg(z20, __ B, p5, z20);                    \/\/       neg     z20.b, p5\/m, z20.b\n+    __ sve_not(z10, __ D, p2, z16);                    \/\/       not     z10.d, p2\/m, z16.d\n+    __ sve_smax(z6, __ H, p4, z2);                     \/\/       smax    z6.h, p4\/m, z6.h, z2.h\n+    __ sve_smin(z29, __ D, p7, z2);                    \/\/       smin    z29.d, p7\/m, z29.d, z2.d\n+    __ sve_sub(z22, __ H, p7, z14);                    \/\/       sub     z22.h, p7\/m, z22.h, z14.h\n+    __ sve_fabs(z27, __ S, p4, z23);                   \/\/       fabs    z27.s, p4\/m, z23.s\n+    __ sve_fadd(z2, __ D, p3, z10);                    \/\/       fadd    z2.d, p3\/m, z2.d, z10.d\n+    __ sve_fdiv(z10, __ S, p6, z22);                   \/\/       fdiv    z10.s, p6\/m, z10.s, z22.s\n+    __ sve_fmax(z3, __ S, p5, z16);                    \/\/       fmax    z3.s, p5\/m, z3.s, z16.s\n+    __ sve_fmin(z1, __ D, p4, z16);                    \/\/       fmin    z1.d, p4\/m, z1.d, z16.d\n+    __ sve_fmul(z12, __ S, p3, z12);                   \/\/       fmul    z12.s, p3\/m, z12.s, z12.s\n+    __ sve_fneg(z16, __ D, p0, z20);                   \/\/       fneg    z16.d, p0\/m, z20.d\n+    __ sve_frintm(z5, __ D, p1, z7);                   \/\/       frintm  z5.d, p1\/m, z7.d\n+    __ sve_frintn(z12, __ D, p7, z16);                 \/\/       frintn  z12.d, p7\/m, z16.d\n+    __ sve_frintp(z6, __ S, p0, z28);                  \/\/       frintp  z6.s, p0\/m, z28.s\n+    __ sve_fsqrt(z4, __ D, p1, z17);                   \/\/       fsqrt   z4.d, p1\/m, z17.d\n+    __ sve_fsub(z13, __ S, p3, z19);                   \/\/       fsub    z13.s, p3\/m, z13.s, z19.s\n+    __ sve_fmla(z24, __ S, p5, z17, z0);               \/\/       fmla    z24.s, p5\/m, z17.s, z0.s\n+    __ sve_fmls(z23, __ S, p1, z19, z30);              \/\/       fmls    z23.s, p1\/m, z19.s, z30.s\n+    __ sve_fnmla(z16, __ S, p1, z0, z7);               \/\/       fnmla   z16.s, p1\/m, z0.s, z7.s\n+    __ sve_fnmls(z17, __ D, p6, z8, z10);              \/\/       fnmls   z17.d, p6\/m, z8.d, z10.d\n+    __ sve_mla(z20, __ B, p5, z27, z2);                \/\/       mla     z20.b, p5\/m, z27.b, z2.b\n+    __ sve_mls(z15, __ B, p4, z20, z7);                \/\/       mls     z15.b, p4\/m, z20.b, z7.b\n+    __ sve_and(z28, z7, z0);                           \/\/       and     z28.d, z7.d, z0.d\n+    __ sve_eor(z16, z19, z22);                         \/\/       eor     z16.d, z19.d, z22.d\n+    __ sve_orr(z15, z9, z22);                          \/\/       orr     z15.d, z9.d, z22.d\n+    __ sve_uzp1(z25, __ S, z5, z30);                   \/\/       uzp1    z25.s, z5.s, z30.s\n+    __ sve_uzp2(z13, __ B, z22, z11);                  \/\/       uzp2    z13.b, z22.b, z11.b\n@@ -898,9 +946,9 @@\n-    __ sve_andv(v13, __ B, p5, z11);                   \/\/       andv b13, p5, z11.b\n-    __ sve_orv(v13, __ S, p2, z20);                    \/\/       orv s13, p2, z20.s\n-    __ sve_eorv(v25, __ B, p3, z4);                    \/\/       eorv b25, p3, z4.b\n-    __ sve_smaxv(v17, __ D, p2, z6);                   \/\/       smaxv d17, p2, z6.d\n-    __ sve_sminv(v4, __ D, p7, z16);                   \/\/       sminv d4, p7, z16.d\n-    __ sve_fminv(v26, __ S, p2, z14);                  \/\/       fminv s26, p2, z14.s\n-    __ sve_fmaxv(v11, __ S, p7, z3);                   \/\/       fmaxv s11, p7, z3.s\n-    __ sve_fadda(v1, __ D, p6, z21);                   \/\/       fadda d1, p6, d1, z21.d\n-    __ sve_uaddv(v14, __ S, p2, z17);                  \/\/       uaddv d14, p2, z17.s\n+    __ sve_andv(v13, __ S, p2, z20);                   \/\/       andv s13, p2, z20.s\n+    __ sve_orv(v25, __ B, p3, z4);                     \/\/       orv b25, p3, z4.b\n+    __ sve_eorv(v17, __ D, p2, z6);                    \/\/       eorv d17, p2, z6.d\n+    __ sve_smaxv(v4, __ D, p7, z16);                   \/\/       smaxv d4, p7, z16.d\n+    __ sve_sminv(v26, __ B, p2, z14);                  \/\/       sminv b26, p2, z14.b\n+    __ sve_fminv(v11, __ S, p7, z3);                   \/\/       fminv s11, p7, z3.s\n+    __ sve_fmaxv(v1, __ D, p6, z21);                   \/\/       fmaxv d1, p6, z21.d\n+    __ sve_fadda(v14, __ D, p2, z17);                  \/\/       fadda d14, p2, d14, z17.d\n+    __ sve_uaddv(v24, __ S, p1, z19);                  \/\/       uaddv d24, p1, z19.s\n@@ -925,7 +973,7 @@\n-    0x14000000,     0x17ffffd7,     0x140002d4,     0x94000000,\n-    0x97ffffd4,     0x940002d1,     0x3400000a,     0x34fffa2a,\n-    0x340059ca,     0x35000008,     0x35fff9c8,     0x35005968,\n-    0xb400000b,     0xb4fff96b,     0xb400590b,     0xb500001d,\n-    0xb5fff91d,     0xb50058bd,     0x10000013,     0x10fff8b3,\n-    0x10005853,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363057d6,     0x3758000c,     0x375ff7cc,     0x3758576c,\n+    0x14000000,     0x17ffffd7,     0x14000300,     0x94000000,\n+    0x97ffffd4,     0x940002fd,     0x3400000a,     0x34fffa2a,\n+    0x34005f4a,     0x35000008,     0x35fff9c8,     0x35005ee8,\n+    0xb400000b,     0xb4fff96b,     0xb4005e8b,     0xb500001d,\n+    0xb5fff91d,     0xb5005e3d,     0x10000013,     0x10fff8b3,\n+    0x10005dd3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36305d56,     0x3758000c,     0x375ff7cc,     0x37585cec,\n@@ -936,13 +984,13 @@\n-    0x54005540,     0x54000001,     0x54fff541,     0x540054e1,\n-    0x54000002,     0x54fff4e2,     0x54005482,     0x54000002,\n-    0x54fff482,     0x54005422,     0x54000003,     0x54fff423,\n-    0x540053c3,     0x54000003,     0x54fff3c3,     0x54005363,\n-    0x54000004,     0x54fff364,     0x54005304,     0x54000005,\n-    0x54fff305,     0x540052a5,     0x54000006,     0x54fff2a6,\n-    0x54005246,     0x54000007,     0x54fff247,     0x540051e7,\n-    0x54000008,     0x54fff1e8,     0x54005188,     0x54000009,\n-    0x54fff189,     0x54005129,     0x5400000a,     0x54fff12a,\n-    0x540050ca,     0x5400000b,     0x54fff0cb,     0x5400506b,\n-    0x5400000c,     0x54fff06c,     0x5400500c,     0x5400000d,\n-    0x54fff00d,     0x54004fad,     0x5400000e,     0x54ffefae,\n-    0x54004f4e,     0x5400000f,     0x54ffef4f,     0x54004eef,\n+    0x54005ac0,     0x54000001,     0x54fff541,     0x54005a61,\n+    0x54000002,     0x54fff4e2,     0x54005a02,     0x54000002,\n+    0x54fff482,     0x540059a2,     0x54000003,     0x54fff423,\n+    0x54005943,     0x54000003,     0x54fff3c3,     0x540058e3,\n+    0x54000004,     0x54fff364,     0x54005884,     0x54000005,\n+    0x54fff305,     0x54005825,     0x54000006,     0x54fff2a6,\n+    0x540057c6,     0x54000007,     0x54fff247,     0x54005767,\n+    0x54000008,     0x54fff1e8,     0x54005708,     0x54000009,\n+    0x54fff189,     0x540056a9,     0x5400000a,     0x54fff12a,\n+    0x5400564a,     0x5400000b,     0x54fff0cb,     0x540055eb,\n+    0x5400000c,     0x54fff06c,     0x5400558c,     0x5400000d,\n+    0x54fff00d,     0x5400552d,     0x5400000e,     0x54ffefae,\n+    0x540054ce,     0x5400000f,     0x54ffef4f,     0x5400546f,\n@@ -980,1 +1028,1 @@\n-    0xbd1b1869,     0x58003f3b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x580044bb,     0x1800000b,     0xf8945060,\n@@ -1058,49 +1106,61 @@\n-    0x4e071fe1,     0x4cc0ac3f,     0x05a08020,     0x04b0e3e0,\n-    0x0470e7e1,     0x042f9c20,     0x043f9c35,     0x047f9c20,\n-    0x04ff9c20,     0x04299420,     0x04319160,     0x0461943e,\n-    0x04a19020,     0x042053ff,     0x047f5401,     0x25208028,\n-    0x2538cfe0,     0x2578d001,     0x25b8efe2,     0x25f8f007,\n-    0xa400a3e0,     0xa4a8a7ea,     0xa547a814,     0xa4084ffe,\n-    0xa55c53e0,     0xa5e1540b,     0xe400fbf6,     0xe408ffff,\n-    0xe547e400,     0xe4014be0,     0xe4a84fe0,     0xe5f15000,\n-    0x858043e0,     0x85a043ff,     0xe59f5d08,     0x1e601000,\n-    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n-    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n-    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n-    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n-    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n-    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n-    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n-    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf8238358,\n-    0xf83702af,     0xf8231118,     0xf8392214,     0xf8313022,\n-    0xf8205098,     0xf82343ec,     0xf83c734a,     0xf82261ec,\n-    0xf8bf81a1,     0xf8bd0260,     0xf8ac12d1,     0xf8ad23dc,\n-    0xf8bf3341,     0xf8bc53c4,     0xf8a443c6,     0xf8ba7130,\n-    0xf8a8600c,     0xf8f48301,     0xf8e20120,     0xf8f8121a,\n-    0xf8fe2143,     0xf8f7308a,     0xf8f05162,     0xf8e841ea,\n-    0xf8f17142,     0xf8ec61ec,     0xf86d80e2,     0xf874021a,\n-    0xf8641082,     0xf86c22b0,     0xf8703170,     0xf8755197,\n-    0xf87a4397,     0xf86e730b,     0xf86163ec,     0xb82a80f0,\n-    0xb82201a3,     0xb8331211,     0xb8232161,     0xb83e3105,\n-    0xb82f53dd,     0xb82040f4,     0xb8347397,     0xb835633b,\n-    0xb8a582e1,     0xb8b000bf,     0xb8ac1389,     0xb8af22dd,\n-    0xb8bf33f3,     0xb8a551ee,     0xb8bf4370,     0xb8b47190,\n-    0xb8ab60c9,     0xb8fe8371,     0xb8fc00fe,     0xb8ea1154,\n-    0xb8e42238,     0xb8f13076,     0xb8fd52cf,     0xb8f342d3,\n-    0xb8e270cf,     0xb8ec6170,     0xb86d8037,     0xb87e00b3,\n-    0xb8711202,     0xb876214d,     0xb875337d,     0xb86c507b,\n-    0xb861431f,     0xb8737131,     0xb87c61fb,     0xce367a86,\n-    0xce1e6858,     0xce768d51,     0xce910451,     0xce768338,\n-    0xce6c8622,     0xcec08363,     0xce708b9d,     0x04e900da,\n-    0x042404f1,     0x6596012f,     0x65d40b62,     0x65c00745,\n-    0x0456a72e,     0x04c0175b,     0x04109418,     0x041ab006,\n-    0x0413812f,     0x04118b65,     0x04101694,     0x04d7aa0a,\n-    0x045eb046,     0x04c81c5d,     0x044a1dd6,     0x040112fb,\n-    0x04dcad42,     0x65809aca,     0x658d9603,     0x65c69201,\n-    0x65878d8c,     0x65c28290,     0x04dda4e5,     0x65c2be0c,\n-    0x6580a386,     0x65c1a624,     0x658dae6d,     0x65819638,\n-    0x65f318ca,     0x65a030cd,     0x65a8532e,     0x65bb76d6,\n-    0x04144e23,     0x04407ce4,     0x04363270,     0x04b6312f,\n-    0x047e30b9,     0x041a356d,     0x04982a8d,     0x04192c99,\n-    0x04c828d1,     0x04ca3e04,     0x658729da,     0x65863c6b,\n-    0x65d83aa1,     0x04812a2e,\n+    0x4e071fe1,     0x4cc0ac3f,     0x05a08020,     0x05104fe0,\n+    0x05505001,     0x05906fe2,     0x05d03005,     0x05101fea,\n+    0x05901feb,     0x04b0e3e0,     0x0470e7e1,     0x042f9c20,\n+    0x043f9c35,     0x047f9c20,     0x04ff9c20,     0x04299420,\n+    0x04319160,     0x0461943e,     0x04a19020,     0x042053ff,\n+    0x047f5401,     0x25208028,     0x2538cfe0,     0x2578d001,\n+    0x25b8efe2,     0x25f8f007,     0x2538dfea,     0x25b8dfeb,\n+    0xa400a3e0,     0xa420a7e0,     0xa4484be0,     0xa467afe0,\n+    0xa4a8a7ea,     0xa547a814,     0xa4084ffe,     0xa55c53e0,\n+    0xa5e1540b,     0xe400fbf6,     0xe408ffff,     0xe420e7e0,\n+    0xe4484be0,     0xe460efe0,     0xe547e400,     0xe4014be0,\n+    0xe4a84fe0,     0xe5f15000,     0x858043e0,     0x85a043ff,\n+    0xe59f5d08,     0x0522c020,     0x05e6c0a4,     0x2401a001,\n+    0x2443a051,     0x24858881,     0x24c78cd1,     0x240b8142,\n+    0x24918213,     0x250f9001,     0x25508051,     0x25802491,\n+    0x25df28c1,     0x25850c81,     0x251e10d1,     0x65816001,\n+    0x65c36051,     0x65854891,     0x65c74cc1,     0x658b4152,\n+    0x65d14203,     0x05733820,     0x05b238a4,     0x05f138e6,\n+    0x0570396a,     0x25221420,     0x25640461,     0x25a614b2,\n+    0x25eb0553,     0x25221c24,     0x25640c60,     0x25a61cb1,\n+    0x25eb0d52,     0x1e601000,     0x1e603000,     0x1e621000,\n+    0x1e623000,     0x1e641000,     0x1e643000,     0x1e661000,\n+    0x1e663000,     0x1e681000,     0x1e683000,     0x1e6a1000,\n+    0x1e6a3000,     0x1e6c1000,     0x1e6c3000,     0x1e6e1000,\n+    0x1e6e3000,     0x1e701000,     0x1e703000,     0x1e721000,\n+    0x1e723000,     0x1e741000,     0x1e743000,     0x1e761000,\n+    0x1e763000,     0x1e781000,     0x1e783000,     0x1e7a1000,\n+    0x1e7a3000,     0x1e7c1000,     0x1e7c3000,     0x1e7e1000,\n+    0x1e7e3000,     0xf8388355,     0xf8380303,     0xf83a11f7,\n+    0xf8352303,     0xf8283299,     0xf8305051,     0xf8214300,\n+    0xf8247183,     0xf83f615c,     0xf8ba8182,     0xf8b0003f,\n+    0xf8ad101d,     0xf8b3222c,     0xf8b6338d,     0xf8be503f,\n+    0xf8ba409c,     0xf8be70c4,     0xf8be61fa,     0xf8e98188,\n+    0xf8e00034,     0xf8f81002,     0xf8e92358,     0xf8f0307e,\n+    0xf8ea5157,     0xf8e44050,     0xf8eb7148,     0xf8ef6051,\n+    0xf86a818c,     0xf86f004d,     0xf8671354,     0xf8702044,\n+    0xf86431ec,     0xf87551f0,     0xf86b42f5,     0xf86c72fa,\n+    0xf87c616e,     0xb8388181,     0xb83f020a,     0xb8271062,\n+    0xb82d2233,     0xb8303023,     0xb82b50be,     0xb82843af,\n+    0xb83e7280,     0xb82762f4,     0xb8bc8375,     0xb8b90025,\n+    0xb8b713f0,     0xb8a5212c,     0xb8bc33af,     0xb8b6527f,\n+    0xb8bf41c5,     0xb8b071ff,     0xb8bb6214,     0xb8ec812b,\n+    0xb8e6023e,     0xb8fb13dc,     0xb8e7228a,     0xb8ea3304,\n+    0xb8f152d1,     0xb8e341fd,     0xb8f67273,     0xb8f661e2,\n+    0xb866820c,     0xb86b02ed,     0xb861127e,     0xb8652051,\n+    0xb87031b6,     0xb86a53b5,     0xb87b436c,     0xb86373e1,\n+    0xb8786233,     0xce3a3b69,     0xce167a86,     0xce7e8c58,\n+    0xce8aba3a,     0xce718051,     0xce798700,     0xcec08056,\n+    0xce638991,     0x04bc03bb,     0x04e904da,     0x658400f1,\n+    0x6596092f,     0x65d40762,     0x0496b805,     0x0440072e,\n+    0x04d0975b,     0x041ab418,     0x04139006,     0x0411812f,\n+    0x04100b65,     0x0417b694,     0x04deaa0a,     0x04481046,\n+    0x04ca1c5d,     0x04411dd6,     0x049cb2fb,     0x65c08d42,\n+    0x658d9aca,     0x65869603,     0x65c79201,     0x65828d8c,\n+    0x04dda290,     0x65c2a4e5,     0x65c0be0c,     0x6581a386,\n+    0x65cda624,     0x65818e6d,     0x65a01638,     0x65be2677,\n+    0x65a74410,     0x65ea7911,     0x04025774,     0x0407728f,\n+    0x042030fc,     0x04b63270,     0x0476312f,     0x05be68b9,\n+    0x052b6ecd,     0x049a2a8d,     0x04182c99,     0x04d928d1,\n+    0x04c83e04,     0x040a29da,     0x65873c6b,     0x65c63aa1,\n+    0x65d82a2e,     0x04812678,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":177,"deletions":117,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -951,0 +951,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+                int upper = m;\n@@ -984,1 +985,1 @@\n-                    a[i] = (byte)RAND.nextInt(m);\n+                    a[i] = (byte)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -951,0 +951,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+                int upper = m;\n@@ -984,1 +985,1 @@\n-                    a[i] = (byte)RAND.nextInt(m);\n+                    a[i] = (byte)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -951,0 +951,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+                int upper = m;\n@@ -984,1 +985,1 @@\n-                    a[i] = (byte)RAND.nextInt(m);\n+                    a[i] = (byte)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -951,0 +951,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -983,0 +983,1 @@\n+                int upper = m;\n@@ -984,1 +985,1 @@\n-                    a[i] = (byte)RAND.nextInt(m);\n+                    a[i] = (byte)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -960,0 +960,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -988,0 +988,1 @@\n+                int upper = Math.min(Byte.MAX_VALUE + 1, m);\n@@ -989,1 +990,1 @@\n-                    a[i] = (byte)RAND.nextInt(m);\n+                    a[i] = (byte)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1115,0 +1115,1 @@\n+                int upper = m;\n@@ -1116,1 +1117,1 @@\n-                    a[i] = (double)RAND.nextInt(m);\n+                    a[i] = (double)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1115,0 +1115,1 @@\n+                int upper = m;\n@@ -1116,1 +1117,1 @@\n-                    a[i] = (double)RAND.nextInt(m);\n+                    a[i] = (double)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1115,0 +1115,1 @@\n+                int upper = m;\n@@ -1116,1 +1117,1 @@\n-                    a[i] = (double)RAND.nextInt(m);\n+                    a[i] = (double)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1115,0 +1115,1 @@\n+                int upper = m;\n@@ -1116,1 +1117,1 @@\n-                    a[i] = (double)RAND.nextInt(m);\n+                    a[i] = (double)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -971,0 +971,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1120,0 +1120,1 @@\n+                int upper = m;\n@@ -1121,1 +1122,1 @@\n-                    a[i] = (double)RAND.nextInt(m);\n+                    a[i] = (double)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1125,0 +1125,1 @@\n+                int upper = m;\n@@ -1126,1 +1127,1 @@\n-                    a[i] = (float)RAND.nextInt(m);\n+                    a[i] = (float)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1125,0 +1125,1 @@\n+                int upper = m;\n@@ -1126,1 +1127,1 @@\n-                    a[i] = (float)RAND.nextInt(m);\n+                    a[i] = (float)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1125,0 +1125,1 @@\n+                int upper = m;\n@@ -1126,1 +1127,1 @@\n-                    a[i] = (float)RAND.nextInt(m);\n+                    a[i] = (float)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1125,0 +1125,1 @@\n+                int upper = m;\n@@ -1126,1 +1127,1 @@\n-                    a[i] = (float)RAND.nextInt(m);\n+                    a[i] = (float)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -971,0 +971,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1130,0 +1130,1 @@\n+                int upper = m;\n@@ -1131,1 +1132,1 @@\n-                    a[i] = (float)RAND.nextInt(m);\n+                    a[i] = (float)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -971,0 +971,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -969,0 +969,1 @@\n+                int upper = m;\n@@ -970,1 +971,1 @@\n-                    a[i] = (long)RAND.nextInt(m);\n+                    a[i] = (long)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -969,0 +969,1 @@\n+                int upper = m;\n@@ -970,1 +971,1 @@\n-                    a[i] = (long)RAND.nextInt(m);\n+                    a[i] = (long)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -969,0 +969,1 @@\n+                int upper = m;\n@@ -970,1 +971,1 @@\n-                    a[i] = (long)RAND.nextInt(m);\n+                    a[i] = (long)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -969,0 +969,1 @@\n+                int upper = m;\n@@ -970,1 +971,1 @@\n-                    a[i] = (long)RAND.nextInt(m);\n+                    a[i] = (long)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -971,0 +971,2 @@\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -974,0 +974,1 @@\n+                int upper = m;\n@@ -975,1 +976,1 @@\n-                    a[i] = (long)RAND.nextInt(m);\n+                    a[i] = (long)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,246 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+                int upper = m;\n@@ -974,1 +975,1 @@\n-                    a[i] = (short)RAND.nextInt(m);\n+                    a[i] = (short)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,246 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+                int upper = m;\n@@ -974,1 +975,1 @@\n-                    a[i] = (short)RAND.nextInt(m);\n+                    a[i] = (short)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,246 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+                int upper = m;\n@@ -974,1 +975,1 @@\n-                    a[i] = (short)RAND.nextInt(m);\n+                    a[i] = (short)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,0 +962,246 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+                int upper = m;\n@@ -974,1 +975,1 @@\n-                    a[i] = (short)RAND.nextInt(m);\n+                    a[i] = (short)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -971,0 +971,246 @@\n+\n+\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i) {\n+        return ShortVector.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static ShortVector fromCharArray(char[] a, int i, VectorMask<Short> m) {\n+        return ShortVector.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray(ShortVector v, char[] a, int i, VectorMask<Short> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            ShortVector av = ShortVector.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -978,0 +978,1 @@\n+                int upper = m;\n@@ -979,1 +980,1 @@\n-                    a[i] = (short)RAND.nextInt(m);\n+                    a[i] = (short)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- *      Vector64ConversionTests\n+ * Vector64ConversionTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Vector64ConversionTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1187,0 +1187,5 @@\n+#if[ByteMax]\n+                int upper = Math.min(Byte.MAX_VALUE + 1, m);\n+#else[ByteMax]\n+                int upper = m;\n+#end[ByteMax]\n@@ -1188,1 +1193,1 @@\n-                    a[i] = ($type$)RAND.nextInt(m);\n+                    a[i] = ($type$)RAND.nextInt(upper);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -994,0 +994,248 @@\n+\n+\n+#if[short]\n+    static void assertArraysEquals(char[] a, char[] r, boolean[] mask) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(mask[i % SPECIES.length()] ? a[i] : (char) 0, r[i], \"at index #\" + i);\n+        }\n+    }\n+\n+    static final List<IntFunction<char[]>> CHAR_GENERATORS = List.of(\n+            withToString(\"char[i * 5]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (char)(i * 5));\n+            }),\n+            withToString(\"char[i + 1]\", (int s) -> {\n+                return fillChar(s * BUFFER_REPS,\n+                            i -> (((char)(i + 1) == 0) ? 1 : (char)(i + 1)));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] charProvider() {\n+        return CHAR_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi};\n+                }).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> CHAR_GENERATORS.stream().map(fa -> {\n+                    return new Object[] {fa, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] charMaskProviderForIOOBE() {\n+        var f = CHAR_GENERATORS.get(0);\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INDEX_GENERATORS.stream().map(fi -> {\n+                    return new Object[] {f, fi, fm};\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+    interface ToCharF {\n+        char apply(int i);\n+    }\n+\n+    static char[] fillChar(int s , ToCharF f) {\n+        return fillChar(new char[s], f);\n+    }\n+\n+    static char[] fillChar(char[] a, ToCharF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    @DontInline\n+    static $abstractvectortype$ fromCharArray(char[] a, int i) {\n+        return $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+    }\n+\n+    @DontInline\n+    static $abstractvectortype$ fromCharArray(char[] a, int i, VectorMask<$Boxtype$> m) {\n+        return $abstractvectortype$.fromCharArray(SPECIES, a, i, m);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray($abstractvectortype$ v, char[] a, int i) {\n+        v.intoCharArray(a, i);\n+    }\n+\n+    @DontInline\n+    static void intoCharArray($abstractvectortype$ v, char[] a, int i, VectorMask<$Boxtype$> m) {\n+        v.intoCharArray(a, i, m);\n+    }\n+\n+    @Test(dataProvider = \"charProvider\")\n+    static void loadStoreCharArray(IntFunction<char[]> fa) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        Assert.assertEquals(a, r);\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void loadCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = fromCharArray(a, i);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            fromCharArray(a, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charProviderForIOOBE\")\n+    static void storeCharArrayIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.length(), index, a.length);\n+        try {\n+            $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, r, index);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProvider\")\n+    static void loadStoreMaskCharArray(IntFunction<char[]> fa,\n+                                       IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+\n+\n+        r = new char[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                av.intoCharArray(r, i, vmask);\n+            }\n+        }\n+        assertArraysEquals(a, r, mask);\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void loadCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = fromCharArray(a, i, vmask);\n+                av.intoCharArray(r, i);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            fromCharArray(a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"charMaskProviderForIOOBE\")\n+    static void storeCharArrayMaskIOOBE(IntFunction<char[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        char[] a = fa.apply(SPECIES.length());\n+        char[] r = new char[a.length];\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, i);\n+                intoCharArray(av, r, i, vmask);\n+            }\n+        }\n+\n+        int index = fi.apply(a.length);\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length);\n+        try {\n+            $abstractvectortype$ av = $abstractvectortype$.fromCharArray(SPECIES, a, 0);\n+            intoCharArray(av, a, index, vmask);\n+            if (shouldFail) {\n+                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            if (!shouldFail) {\n+                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n+            }\n+        }\n+    }\n+\n+#end[short]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":248,"deletions":0,"binary":false,"changes":248,"status":"modified"}]}