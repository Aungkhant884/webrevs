{"files":[{"patch":"@@ -4723,0 +4723,9 @@\n+void Assembler::vpmovzxwq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_128bit? VM_Version::supports_avx() :\n+  vector_len == AVX_256bit? VM_Version::supports_avx2() :\n+  vector_len == AVX_512bit? VM_Version::supports_evex() : 0, \" \");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ _legacy_mode_bw, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x34, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1837,0 +1837,1 @@\n+  void vpmovzxwq(XMMRegister dst, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1457,0 +1457,3 @@\n+    case Op_VectorUCastB2X:\n+    case Op_VectorUCastS2X:\n+    case Op_VectorUCastI2X:\n@@ -1802,0 +1805,15 @@\n+    case Op_VectorUCastB2X:\n+      if (size_in_bits == 256 && UseAVX < 2) {\n+        return false; \/\/ Implementation limitation\n+      }\n+      break;\n+    case Op_VectorUCastS2X:\n+      if (is_integral_type(bt) && size_in_bits == 256 && UseAVX < 2) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorUCastI2X:\n+      if (is_integral_type(bt) && size_in_bits == 256 && UseAVX < 2) {\n+        return false;\n+      }\n+      break;\n@@ -7179,0 +7197,66 @@\n+instruct vucastBtoX(vec dst, vec src) %{\n+  match(Set dst (VectorUCastB2X src));\n+  format %{ \"vector_ucast_b2x $dst,$src\\t!\" %}\n+  ins_encode %{\n+    assert(UseAVX > 0, \"required\");\n+\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    switch (to_elem_bt) {\n+      case T_SHORT:\n+        __ vpmovzxbw($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+        break;\n+      case T_INT:\n+        __ vpmovzxbd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+        break;\n+      case T_LONG:\n+        __ vpmovzxbq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vucastStoX(vec dst, vec src) %{\n+  match(Set dst (VectorUCastS2X src));\n+  format %{ \"vector_ucast_s2x $dst,$src\\t!\" %}\n+  ins_encode %{\n+    assert(UseAVX > 0, \"required\");\n+\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    switch (to_elem_bt) {\n+      case T_INT:\n+        __ vpmovzxwd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+        break;\n+      case T_LONG:\n+        __ vpmovzxwq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vucastItoX(vec dst, vec src) %{\n+  match(Set dst (VectorUCastI2X src));\n+  format %{ \"vector_ucast_i2x $dst,$src\\t!\" %}\n+  ins_encode %{\n+    assert(UseAVX > 0, \"required\");\n+\n+    BasicType to_elem_bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    switch (to_elem_bt) {\n+      case T_LONG:\n+        __ vpmovzxdq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -4236,0 +4236,1 @@\n+    \"VectorUCastB2X\", \"VectorUCastS2X\", \"VectorUCastI2X\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -478,0 +478,3 @@\n+macro(VectorUCastB2X)\n+macro(VectorUCastS2X)\n+macro(VectorUCastI2X)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2343,0 +2343,1 @@\n+         opr->get_con() == VectorSupport::VECTOR_OP_UCAST ||\n@@ -2344,1 +2345,2 @@\n-  bool is_cast = (opr->get_con() == VectorSupport::VECTOR_OP_CAST);\n+  bool is_cast = (opr->get_con() == VectorSupport::VECTOR_OP_CAST || opr->get_con() == VectorSupport::VECTOR_OP_UCAST);\n+  bool is_ucast = (opr->get_con() == VectorSupport::VECTOR_OP_UCAST);\n@@ -2456,1 +2458,1 @@\n-      op = gvn().transform(VectorCastNode::make(cast_vopc, op, elem_bt_to, num_elem_for_cast));\n+      op = gvn().transform(VectorCastNode::make(cast_vopc, op, elem_bt_to, num_elem_for_cast, is_ucast));\n@@ -2481,1 +2483,1 @@\n-      op = gvn().transform(VectorCastNode::make(cast_vopc, op, elem_bt_to, num_elem_to));\n+      op = gvn().transform(VectorCastNode::make(cast_vopc, op, elem_bt_to, num_elem_to, is_ucast));\n@@ -2507,1 +2509,1 @@\n-        op = gvn().transform(VectorCastNode::make(cast_vopc, op, elem_bt_to, num_elem_to));\n+        op = gvn().transform(VectorCastNode::make(cast_vopc, op, elem_bt_to, num_elem_to, is_ucast));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1072,1 +1072,1 @@\n-VectorCastNode* VectorCastNode::make(int vopc, Node* n1, BasicType bt, uint vlen) {\n+VectorCastNode* VectorCastNode::make(int vopc, Node* n1, BasicType bt, uint vlen, bool is_unsigned) {\n@@ -1074,10 +1074,27 @@\n-  switch (vopc) {\n-    case Op_VectorCastB2X: return new VectorCastB2XNode(n1, vt);\n-    case Op_VectorCastS2X: return new VectorCastS2XNode(n1, vt);\n-    case Op_VectorCastI2X: return new VectorCastI2XNode(n1, vt);\n-    case Op_VectorCastL2X: return new VectorCastL2XNode(n1, vt);\n-    case Op_VectorCastF2X: return new VectorCastF2XNode(n1, vt);\n-    case Op_VectorCastD2X: return new VectorCastD2XNode(n1, vt);\n-    default:\n-      assert(false, \"unknown node: %s\", NodeClassNames[vopc]);\n-      return NULL;\n+  if (!is_unsigned) {\n+    switch (vopc) {\n+      case Op_VectorCastB2X: return new VectorCastB2XNode(n1, vt);\n+      case Op_VectorCastS2X: return new VectorCastS2XNode(n1, vt);\n+      case Op_VectorCastI2X: return new VectorCastI2XNode(n1, vt);\n+      case Op_VectorCastL2X: return new VectorCastL2XNode(n1, vt);\n+      case Op_VectorCastF2X: return new VectorCastF2XNode(n1, vt);\n+      case Op_VectorCastD2X: return new VectorCastD2XNode(n1, vt);\n+      default:\n+        assert(false, \"unknown node: %s\", NodeClassNames[vopc]);\n+        return NULL;\n+    }\n+  } else {\n+    switch (vopc) {\n+      case Op_VectorCastB2X:\n+        assert(bt == T_SHORT || bt == T_INT || bt == T_LONG, \"illegal\");\n+        return new VectorUCastB2XNode(n1, vt);\n+      case Op_VectorCastS2X:\n+        assert(bt == T_INT || bt == T_LONG, \"illegal\");\n+        return new VectorUCastS2XNode(n1, vt);\n+      case Op_VectorCastI2X:\n+        assert(bt == T_LONG, \"illegal\");\n+        return new VectorUCastI2XNode(n1, vt);\n+      default:\n+        assert(false, \"unknown node: %s\", NodeClassNames[vopc]);\n+        return NULL;\n+    }\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1425,1 +1425,1 @@\n-  static VectorCastNode* make(int vopc, Node* n1, BasicType bt, uint vlen);\n+  static VectorCastNode* make(int vopc, Node* n1, BasicType bt, uint vlen, bool is_unsigned = false);\n@@ -1480,0 +1480,24 @@\n+class VectorUCastB2XNode : public VectorCastNode {\n+ public:\n+  VectorUCastB2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be byte\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorUCastS2XNode : public VectorCastNode {\n+ public:\n+  VectorUCastS2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_SHORT, \"must be short\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class VectorUCastI2XNode : public VectorCastNode {\n+ public:\n+  VectorUCastI2XNode(Node* in, const TypeVect* vt) : VectorCastNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_INT, \"must be int\");\n+  }\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+    VECTOR_OP_UCAST       = 24,\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1844,0 +1844,3 @@\n+  declare_c2_type(VectorUCastB2XNode, VectorNode)                         \\\n+  declare_c2_type(VectorUCastS2XNode, VectorNode)                         \\\n+  declare_c2_type(VectorUCastI2XNode, VectorNode)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    public static final int VECTOR_OP_UCAST       = 24;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -642,0 +642,13 @@\n+    \/**\n+     * Helper function for unsigned upcasts.\n+     * This function kicks in after intrinsic failure.\n+     *\/\n+    \/*package-private*\/\n+    @ForceInline\n+    final <F>\n+    AbstractVector<F> defaultUnsignedCast(AbstractSpecies<F> dsp) {\n+        AbstractSpecies<?> dspi = dsp.asIntegral();\n+        AbstractVector<?> bitv = resizeLanes0(this, dspi);\n+        return (dspi == dsp ? bitv.check0(dsp) : bitv.convert0('X', dsp));\n+    }\n+\n@@ -668,4 +681,10 @@\n-            \/\/ Maybe this should be an intrinsic also.\n-            AbstractSpecies<?> rspi = rsp.asIntegral();\n-            AbstractVector<?> bitv = resizeLanes0(this, rspi);\n-            return (rspi == rsp ? bitv.check0(rsp) : bitv.convert0('X', rsp));\n+            rtype = rsp.elementType();\n+            rlength = rsp.laneCount();\n+            etype = this.elementType(); \/\/ (profile)\n+            vlength = this.length();  \/\/ (profile)\n+            rvtype = rsp.dummyVector().getClass();  \/\/ (profile)\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_UCAST,\n+                    this.getClass(), etype, vlength,\n+                    rvtype, rtype, rlength,\n+                    this, rsp,\n+                    AbstractVector::defaultUnsignedCast);\n@@ -710,1 +729,1 @@\n-        long mask = -1L >>> sizeChange;\n+        long mask = -1L >>> -dsp.elementSize();\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -3337,0 +3337,321 @@\n+    @ForceInline\n+    static\n+    void testVectorUCastByteToShort(VectorSpecies<Byte> a, VectorSpecies<Short> b, byte[] input, short[] output) {\n+        assert(input.length == a.length());\n+        assert(output.length == b.length());\n+\n+        ByteVector av = ByteVector.fromArray(a, input, 0);\n+        ShortVector bv = (ShortVector) av.convertShape(VectorOperators.ZERO_EXTEND_B2S, b, 0);\n+        bv.intoArray(output, 0);\n+\n+        for (int i = 0; i < Math.min(input.length, output.length); i++) {\n+            Assert.assertEquals(output[i], Byte.toUnsignedLong(input[i]));\n+        }\n+        for(int i = input.length; i < output.length; i++) {\n+            Assert.assertEquals(output[i], (short)0);\n+        }\n+    }\n+\n+    @ForceInline\n+    static\n+    void testVectorUCastByteToInt(VectorSpecies<Byte> a, VectorSpecies<Integer> b, byte[] input, int[] output) {\n+        assert(input.length == a.length());\n+        assert(output.length == b.length());\n+\n+        ByteVector av = ByteVector.fromArray(a, input, 0);\n+        IntVector bv = (IntVector) av.convertShape(VectorOperators.ZERO_EXTEND_B2I, b, 0);\n+        bv.intoArray(output, 0);\n+\n+        for (int i = 0; i < Math.min(input.length, output.length); i++) {\n+            Assert.assertEquals(output[i], Byte.toUnsignedLong(input[i]));\n+        }\n+        for(int i = input.length; i < output.length; i++) {\n+            Assert.assertEquals(output[i], (int)0);\n+        }\n+    }\n+\n+    @ForceInline\n+    static\n+    void testVectorUCastByteToLong(VectorSpecies<Byte> a, VectorSpecies<Long> b, byte[] input, long[] output) {\n+        assert(input.length == a.length());\n+        assert(output.length == b.length());\n+\n+        ByteVector av = ByteVector.fromArray(a, input, 0);\n+        LongVector bv = (LongVector) av.convertShape(VectorOperators.ZERO_EXTEND_B2L, b, 0);\n+        bv.intoArray(output, 0);\n+\n+        for (int i = 0; i < Math.min(input.length, output.length); i++) {\n+            Assert.assertEquals(output[i], Byte.toUnsignedLong(input[i]));\n+        }\n+        for(int i = input.length; i < output.length; i++) {\n+            Assert.assertEquals(output[i], (long)0);\n+        }\n+    }\n+\n+    @ForceInline\n+    static\n+    void testVectorUCastShortToInt(VectorSpecies<Short> a, VectorSpecies<Integer> b, short[] input, int[] output) {\n+        assert(input.length == a.length());\n+        assert(output.length == b.length());\n+\n+        ShortVector av = ShortVector.fromArray(a, input, 0);\n+        IntVector bv = (IntVector) av.convertShape(VectorOperators.ZERO_EXTEND_S2I, b, 0);\n+        bv.intoArray(output, 0);\n+\n+        for (int i = 0; i < Math.min(input.length, output.length); i++) {\n+            Assert.assertEquals(output[i], Short.toUnsignedLong(input[i]));\n+        }\n+        for(int i = input.length; i < output.length; i++) {\n+            Assert.assertEquals(output[i], (int)0);\n+        }\n+    }\n+\n+    @ForceInline\n+    static\n+    void testVectorUCastShortToLong(VectorSpecies<Short> a, VectorSpecies<Long> b, short[] input, long[] output) {\n+        assert(input.length == a.length());\n+        assert(output.length == b.length());\n+\n+        ShortVector av = ShortVector.fromArray(a, input, 0);\n+        LongVector bv = (LongVector) av.convertShape(VectorOperators.ZERO_EXTEND_S2L, b, 0);\n+        bv.intoArray(output, 0);\n+\n+        for (int i = 0; i < Math.min(input.length, output.length); i++) {\n+            Assert.assertEquals(output[i], Short.toUnsignedLong(input[i]));\n+        }\n+        for(int i = input.length; i < output.length; i++) {\n+            Assert.assertEquals(output[i], (long)0);\n+        }\n+    }\n+\n+    @ForceInline\n+    static\n+    void testVectorUCastIntToLong(VectorSpecies<Integer> a, VectorSpecies<Long> b, int[] input, long[] output) {\n+        assert(input.length == a.length());\n+        assert(output.length == b.length());\n+\n+        IntVector av = IntVector.fromArray(a, input, 0);\n+        LongVector bv = (LongVector) av.convertShape(VectorOperators.ZERO_EXTEND_I2L, b, 0);\n+        bv.intoArray(output, 0);\n+\n+        for (int i = 0; i < Math.min(input.length, output.length); i++) {\n+            Assert.assertEquals(output[i], Integer.toUnsignedLong(input[i]));\n+        }\n+        for(int i = input.length; i < output.length; i++) {\n+            Assert.assertEquals(output[i], (long)0);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void testUCastFromByte(IntFunction<byte[]> fa) {\n+        byte[] bin64 = fa.apply(bspec64.length());\n+        byte[] bin128 = fa.apply(bspec128.length());\n+        byte[] bin256 = fa.apply(bspec256.length());\n+        byte[] bin512 = fa.apply(bspec512.length());\n+\n+        short[] sout64 = new short[sspec64.length()];\n+        short[] sout128 = new short[sspec128.length()];\n+        short[] sout256 = new short[sspec256.length()];\n+        short[] sout512 = new short[sspec512.length()];\n+\n+        int[] iout64 = new int[ispec64.length()];\n+        int[] iout128 = new int[ispec128.length()];\n+        int[] iout256 = new int[ispec256.length()];\n+        int[] iout512 = new int[ispec512.length()];\n+\n+        long[] lout64 = new long[lspec64.length()];\n+        long[] lout128 = new long[lspec128.length()];\n+        long[] lout256 = new long[lspec256.length()];\n+        long[] lout512 = new long[lspec512.length()];\n+\n+        for (int i = 0; i < NUM_ITER; i++) {\n+            \/\/ B2S exact fit\n+            testVectorUCastByteToShort(bspec64, sspec128, bin64, sout128);\n+            testVectorUCastByteToShort(bspec128, sspec256, bin128, sout256);\n+            testVectorUCastByteToShort(bspec256, sspec512, bin256, sout512);\n+\n+            \/\/ B2S expansion\n+            testVectorUCastByteToShort(bspec64, sspec64, bin64, sout64);\n+            testVectorUCastByteToShort(bspec128, sspec128, bin128, sout128);\n+            testVectorUCastByteToShort(bspec256, sspec256, bin256, sout256);\n+            testVectorUCastByteToShort(bspec512, sspec512, bin512, sout512);\n+\n+            testVectorUCastByteToShort(bspec128, sspec64, bin128, sout64);\n+            testVectorUCastByteToShort(bspec256, sspec128, bin256, sout128);\n+            testVectorUCastByteToShort(bspec512, sspec256, bin512, sout256);\n+\n+            testVectorUCastByteToShort(bspec256, sspec64, bin256, sout64);\n+            testVectorUCastByteToShort(bspec512, sspec128, bin512, sout128);\n+\n+            testVectorUCastByteToShort(bspec512, sspec64, bin512, sout64);\n+\n+            \/\/ B2S contraction\n+            testVectorUCastByteToShort(bspec64, sspec256, bin64, sout256);\n+            testVectorUCastByteToShort(bspec128, sspec512, bin128, sout512);\n+\n+            testVectorUCastByteToShort(bspec64, sspec512, bin64, sout512);\n+\n+            \/\/ B2I exact fit\n+            testVectorUCastByteToInt(bspec64, ispec256, bin64, iout256);\n+            testVectorUCastByteToInt(bspec128, ispec512, bin128, iout512);\n+\n+            \/\/ B2I expansion\n+            testVectorUCastByteToInt(bspec64, ispec128, bin64, iout128);\n+            testVectorUCastByteToInt(bspec128, ispec256, bin128, iout256);\n+            testVectorUCastByteToInt(bspec256, ispec512, bin256, iout512);\n+\n+            testVectorUCastByteToInt(bspec64, ispec64, bin64, iout64);\n+            testVectorUCastByteToInt(bspec128, ispec128, bin128, iout128);\n+            testVectorUCastByteToInt(bspec256, ispec256, bin256, iout256);\n+            testVectorUCastByteToInt(bspec512, ispec512, bin512, iout512);\n+\n+            testVectorUCastByteToInt(bspec128, ispec64, bin128, iout64);\n+            testVectorUCastByteToInt(bspec256, ispec128, bin256, iout128);\n+            testVectorUCastByteToInt(bspec512, ispec256, bin512, iout256);\n+\n+            testVectorUCastByteToInt(bspec256, ispec64, bin256, iout64);\n+            testVectorUCastByteToInt(bspec512, ispec128, bin512, iout128);\n+\n+            testVectorUCastByteToInt(bspec512, ispec64, bin512, iout64);\n+\n+            \/\/ B2I contraction\n+            testVectorUCastByteToInt(bspec64, ispec512, bin64, iout512);\n+\n+            \/\/ B2L exact fit\n+            testVectorUCastByteToLong(bspec64, lspec512, bin64, lout512);\n+\n+            \/\/ B2L expansion\n+            testVectorUCastByteToLong(bspec64, lspec256, bin64, lout256);\n+            testVectorUCastByteToLong(bspec128, lspec512, bin128, lout512);\n+\n+            testVectorUCastByteToLong(bspec64, lspec128, bin64, lout128);\n+            testVectorUCastByteToLong(bspec128, lspec256, bin128, lout256);\n+            testVectorUCastByteToLong(bspec256, lspec512, bin256, lout512);\n+\n+            testVectorUCastByteToLong(bspec64, lspec64, bin64, lout64);\n+            testVectorUCastByteToLong(bspec128, lspec128, bin128, lout128);\n+            testVectorUCastByteToLong(bspec256, lspec256, bin256, lout256);\n+            testVectorUCastByteToLong(bspec512, lspec512, bin512, lout512);\n+\n+            testVectorUCastByteToLong(bspec128, lspec64, bin128, lout64);\n+            testVectorUCastByteToLong(bspec256, lspec128, bin256, lout128);\n+            testVectorUCastByteToLong(bspec512, lspec256, bin512, lout256);\n+\n+            testVectorUCastByteToLong(bspec256, lspec64, bin256, lout64);\n+            testVectorUCastByteToLong(bspec512, lspec128, bin512, lout128);\n+\n+            testVectorUCastByteToLong(bspec512, lspec64, bin512, lout64);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void testUCastFromShort(IntFunction<short[]> fa) {\n+        short[] sin64 = fa.apply(sspec64.length());\n+        short[] sin128 = fa.apply(sspec128.length());\n+        short[] sin256 = fa.apply(sspec256.length());\n+        short[] sin512 = fa.apply(sspec512.length());\n+\n+        int[] iout64 = new int[ispec64.length()];\n+        int[] iout128 = new int[ispec128.length()];\n+        int[] iout256 = new int[ispec256.length()];\n+        int[] iout512 = new int[ispec512.length()];\n+\n+        long[] lout64 = new long[lspec64.length()];\n+        long[] lout128 = new long[lspec128.length()];\n+        long[] lout256 = new long[lspec256.length()];\n+        long[] lout512 = new long[lspec512.length()];\n+\n+        for (int i = 0; i < NUM_ITER; i++) {\n+            \/\/ S2I exact fit\n+            testVectorUCastShortToInt(sspec64, ispec128, sin64, iout128);\n+            testVectorUCastShortToInt(sspec128, ispec256, sin128, iout256);\n+            testVectorUCastShortToInt(sspec256, ispec512, sin256, iout512);\n+\n+            \/\/ S2I expansion\n+            testVectorUCastShortToInt(sspec64, ispec64, sin64, iout64);\n+            testVectorUCastShortToInt(sspec128, ispec128, sin128, iout128);\n+            testVectorUCastShortToInt(sspec256, ispec256, sin256, iout256);\n+            testVectorUCastShortToInt(sspec512, ispec512, sin512, iout512);\n+\n+            testVectorUCastShortToInt(sspec128, ispec64, sin128, iout64);\n+            testVectorUCastShortToInt(sspec256, ispec128, sin256, iout128);\n+            testVectorUCastShortToInt(sspec512, ispec256, sin512, iout256);\n+\n+            testVectorUCastShortToInt(sspec256, ispec64, sin256, iout64);\n+            testVectorUCastShortToInt(sspec512, ispec128, sin512, iout128);\n+\n+            testVectorUCastShortToInt(sspec512, ispec64, sin512, iout64);\n+\n+            \/\/ S2I contraction\n+            testVectorUCastShortToInt(sspec64, ispec256, sin64, iout256);\n+            testVectorUCastShortToInt(sspec128, ispec512, sin128, iout512);\n+\n+            testVectorUCastShortToInt(sspec64, ispec512, sin64, iout512);\n+\n+            \/\/ S2L exact fit\n+            testVectorUCastShortToLong(sspec64, lspec256, sin64, lout256);\n+            testVectorUCastShortToLong(sspec128, lspec512, sin128, lout512);\n+\n+            \/\/ S2L expansion\n+            testVectorUCastShortToLong(sspec64, lspec128, sin64, lout128);\n+            testVectorUCastShortToLong(sspec128, lspec256, sin128, lout256);\n+            testVectorUCastShortToLong(sspec256, lspec512, sin256, lout512);\n+\n+            testVectorUCastShortToLong(sspec64, lspec64, sin64, lout64);\n+            testVectorUCastShortToLong(sspec128, lspec128, sin128, lout128);\n+            testVectorUCastShortToLong(sspec256, lspec256, sin256, lout256);\n+            testVectorUCastShortToLong(sspec512, lspec512, sin512, lout512);\n+\n+            testVectorUCastShortToLong(sspec128, lspec64, sin128, lout64);\n+            testVectorUCastShortToLong(sspec256, lspec128, sin256, lout128);\n+            testVectorUCastShortToLong(sspec512, lspec256, sin512, lout256);\n+\n+            testVectorUCastShortToLong(sspec256, lspec64, sin256, lout64);\n+            testVectorUCastShortToLong(sspec512, lspec128, sin512, lout128);\n+\n+            testVectorUCastShortToLong(sspec512, lspec64, sin512, lout64);\n+\n+            \/\/ S2L contraction\n+            testVectorUCastShortToLong(sspec64, lspec512, sin64, lout512);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void testUCastFromInt(IntFunction<int[]> fa) {\n+        int[] iin64 = fa.apply(ispec64.length());\n+        int[] iin128 = fa.apply(ispec128.length());\n+        int[] iin256 = fa.apply(ispec256.length());\n+        int[] iin512 = fa.apply(ispec512.length());\n+\n+        long[] lout64 = new long[lspec64.length()];\n+        long[] lout128 = new long[lspec128.length()];\n+        long[] lout256 = new long[lspec256.length()];\n+        long[] lout512 = new long[lspec512.length()];\n+\n+        \/\/ I2L exact fit\n+        testVectorUCastIntToLong(ispec64, lspec128, iin64, lout128);\n+        testVectorUCastIntToLong(ispec128, lspec256, iin128, lout256);\n+        testVectorUCastIntToLong(ispec256, lspec512, iin256, lout512);\n+\n+        \/\/ I2L expansion\n+        testVectorUCastIntToLong(ispec64, lspec64, iin64, lout64);\n+        testVectorUCastIntToLong(ispec128, lspec128, iin128, lout128);\n+        testVectorUCastIntToLong(ispec256, lspec256, iin256, lout256);\n+        testVectorUCastIntToLong(ispec512, lspec512, iin512, lout512);\n+\n+        testVectorUCastIntToLong(ispec128, lspec64, iin128, lout64);\n+        testVectorUCastIntToLong(ispec256, lspec128, iin256, lout128);\n+        testVectorUCastIntToLong(ispec512, lspec256, iin512, lout256);\n+\n+        testVectorUCastIntToLong(ispec256, lspec64, iin256, lout64);\n+        testVectorUCastIntToLong(ispec512, lspec128, iin512, lout128);\n+\n+        testVectorUCastIntToLong(ispec512, lspec64, iin512, lout64);\n+\n+        \/\/ I2L contraction\n+        testVectorUCastIntToLong(ispec64, lspec256, iin64, lout256);\n+        testVectorUCastIntToLong(ispec128, lspec512, iin128, lout512);\n+\n+        testVectorUCastIntToLong(ispec64, lspec512, iin64, lout512);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorReshapeTests.java","additions":321,"deletions":0,"binary":false,"changes":321,"status":"modified"}]}