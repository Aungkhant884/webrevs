{"files":[{"patch":"@@ -2485,1 +2485,1 @@\n-const TypeVect* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n+const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n@@ -3910,31 +3910,34 @@\n-    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-    __ orr(tmp, disp_hdr, markWord::unlocked_value);\n-\n-    \/\/ Initialize the box. (Must happen before we update the object mark!)\n-    __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ Compare object markWord with an unlocked value (tmp) and if\n-    \/\/ equal exchange the stack address of our box with object markWord.\n-    \/\/ On failure disp_hdr contains the possibly locked markWord.\n-    __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n-               \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n-    __ br(Assembler::EQ, cont);\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object, will have now locked it will continue at label cont\n-\n-    __ bind(cas_failed);\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if the owner is self by comparing the value in the\n-    \/\/ markWord of object (disp_hdr) with the stack pointer.\n-    __ mov(rscratch1, sp);\n-    __ sub(disp_hdr, disp_hdr, rscratch1);\n-    __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-    \/\/ If condition is true we are cont and hence we can store 0 as the\n-    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-    __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n-    __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n+    if (!UseHeavyMonitors) {\n+      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+      __ orr(tmp, disp_hdr, markWord::unlocked_value);\n+\n+      \/\/ Initialize the box. (Must happen before we update the object mark!)\n+      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+      \/\/ Compare object markWord with an unlocked value (tmp) and if\n+      \/\/ equal exchange the stack address of our box with object markWord.\n+      \/\/ On failure disp_hdr contains the possibly locked markWord.\n+      __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n+                 \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n+      __ br(Assembler::EQ, cont);\n+\n+      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+      \/\/ object, will have now locked it will continue at label cont\n+\n+      __ bind(cas_failed);\n+      \/\/ We did not see an unlocked object so try the fast recursive case.\n+\n+      \/\/ Check if the owner is self by comparing the value in the\n+      \/\/ markWord of object (disp_hdr) with the stack pointer.\n+      __ mov(rscratch1, sp);\n+      __ sub(disp_hdr, disp_hdr, rscratch1);\n+      __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n+      \/\/ If condition is true we are cont and hence we can store 0 as the\n+      \/\/ displaced header in the box, which indicates that it is a recursive lock.\n+      __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n+      __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    } else {\n+      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    }\n@@ -3986,2 +3989,3 @@\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    if (!UseHeavyMonitors) {\n+      \/\/ Find the lock address and load the displaced header from the stack.\n+      __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n@@ -3989,3 +3993,4 @@\n-    \/\/ If the displaced header is 0, we have a recursive unlock.\n-    __ cmp(disp_hdr, zr);\n-    __ br(Assembler::EQ, cont);\n+      \/\/ If the displaced header is 0, we have a recursive unlock.\n+      __ cmp(disp_hdr, zr);\n+      __ br(Assembler::EQ, cont);\n+    }\n@@ -3997,3 +4002,4 @@\n-    \/\/ Check if it is still a light weight lock, this is is true if we\n-    \/\/ see the stack address of the basicLock in the markWord of the\n-    \/\/ object.\n+    if (!UseHeavyMonitors) {\n+      \/\/ Check if it is still a light weight lock, this is is true if we\n+      \/\/ see the stack address of the basicLock in the markWord of the\n+      \/\/ object.\n@@ -4001,2 +4007,5 @@\n-    __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n-               \/*release*\/ true, \/*weak*\/ false, tmp);\n+      __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n+                 \/*release*\/ true, \/*weak*\/ false, tmp);\n+    } else {\n+      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    }\n@@ -4011,1 +4020,0 @@\n-    __ ldr(rscratch1, Address(tmp, ObjectMonitor::owner_offset_in_bytes()));\n@@ -4015,3 +4023,0 @@\n-    __ cmp(rscratch1, rthread);\n-    __ br(Assembler::NE, cont);\n-\n@@ -4023,1 +4028,1 @@\n-    \/\/ flag == EQ was set in the ownership check above\n+    __ cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n@@ -8564,1 +8569,1 @@\n-    __ mov($tmp$$FloatRegister, __ T1D, 0, $src$$Register);\n+    __ mov($tmp$$FloatRegister, __ D, 0, $src$$Register);\n@@ -8567,1 +8572,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n@@ -8589,1 +8594,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n@@ -8607,1 +8612,1 @@\n-    __ mov($tmp$$FloatRegister, __ T1D, 0, $src$$Register);\n+    __ mov($tmp$$FloatRegister, __ D, 0, $src$$Register);\n@@ -8610,1 +8615,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n@@ -8632,1 +8637,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":58,"deletions":53,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-\/\/ maskAll\n+\/\/ maskAll (full or partial predicate size)\n@@ -422,1 +422,1 @@\n-  format %{ \"sve_ptrue\/sve_pfalse $dst\\t# mask all (sve) (B\/H\/S)\" %}\n+  format %{ \"sve_ptrue_lanecnt\/sve_pfalse $dst\\t# mask all (sve) (B\/H\/S)\" %}\n@@ -430,1 +430,2 @@\n-      __ sve_ptrue(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt));\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+                           Matcher::vector_length(this));\n@@ -440,1 +441,1 @@\n-  ins_cost(2 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -442,1 +443,2 @@\n-            \"sve_cmpne $dst, $tmp, 0\\t# mask all (sve) (B\/H\/S)\" %}\n+            \"sve_ptrue_lanecnt $dst\\n\\t\"\n+            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) (B\/H\/S)\" %}\n@@ -446,0 +448,1 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -447,1 +450,7 @@\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    if (length_in_bytes < MaxVectorSize) {\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), size, Matcher::vector_length(this));\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n+                 as_PRegister($dst$$reg), as_FloatRegister($tmp$$reg), 0);\n+    } else {\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    }\n@@ -456,1 +465,1 @@\n-  format %{ \"sve_ptrue\/sve_pfalse $dst\\t# mask all (sve) (D)\" %}\n+  format %{ \"sve_ptrue_lanecnt\/sve_pfalse $dst\\t# mask all (sve) (D)\" %}\n@@ -464,1 +473,2 @@\n-      __ sve_ptrue(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt));\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+                           Matcher::vector_length(this));\n@@ -474,1 +484,1 @@\n-  ins_cost(2 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -476,1 +486,2 @@\n-            \"sve_cmpne $dst, $tmp, 0\\t# mask all (sve) (D)\" %}\n+            \"sve_ptrue_lanecnt $dst\\n\\t\"\n+            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) (D)\" %}\n@@ -480,0 +491,1 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -481,1 +493,7 @@\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    if (length_in_bytes < MaxVectorSize) {\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), size, Matcher::vector_length(this));\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n+                 as_PRegister($dst$$reg), as_FloatRegister($tmp$$reg), 0);\n+    } else {\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    }\n@@ -3089,0 +3107,1 @@\n+  effect(TEMP_DEF dst);\n@@ -3103,0 +3122,1 @@\n+  effect(TEMP_DEF dst);\n@@ -3385,0 +3405,1 @@\n+  effect(TEMP_DEF dst);\n@@ -3399,0 +3420,1 @@\n+  effect(TEMP_DEF dst);\n@@ -5751,0 +5773,17 @@\n+instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length() <= 64);\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve)\" %}\n+  ins_encode %{\n+    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n+                        Matcher::vector_element_basic_type(this, $src),\n+                        Matcher::vector_length(this, $src),\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n+                        as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5764,1 +5803,16 @@\n-%}\n+%}\n+\n+\/\/ ---------------------------- Vector mask generation ---------------------------\n+instruct vmask_gen(pRegGov pg, iRegL len, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pg (VectorMaskGen len));\n+  effect(KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_whilelo $pg, zr, $len\\t # sve\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo(as_PRegister($pg$$reg), size, zr, as_Register($len$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":66,"deletions":12,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-  format %{ \"sve_ptrue\/sve_pfalse $dst\\t# mask all (sve) ($2)\" %}\n+  format %{ \"sve_ptrue_lanecnt\/sve_pfalse $dst\\t# mask all (sve) ($2)\" %}\n@@ -369,1 +369,2 @@\n-      __ sve_ptrue(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt));\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+                           Matcher::vector_length(this));\n@@ -382,1 +383,1 @@\n-  ins_cost(2 * SVE_COST);\n+  ins_cost(3 * SVE_COST);\n@@ -384,1 +385,2 @@\n-            \"sve_cmpne $dst, $tmp, 0\\t# mask all (sve) ($2)\" %}\n+            \"sve_ptrue_lanecnt $dst\\n\\t\"\n+            \"sve_cmpne $dst, $dst, $tmp, 0\\t# mask all (sve) ($2)\" %}\n@@ -388,0 +390,1 @@\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -389,1 +392,7 @@\n-    __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    if (length_in_bytes < MaxVectorSize) {\n+      __ sve_ptrue_lanecnt(as_PRegister($dst$$reg), size, Matcher::vector_length(this));\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size,\n+                 as_PRegister($dst$$reg), as_FloatRegister($tmp$$reg), 0);\n+    } else {\n+      __ sve_cmp(Assembler::NE, as_PRegister($dst$$reg), size, ptrue, as_FloatRegister($tmp$$reg), 0);\n+    }\n@@ -394,1 +403,1 @@\n-\/\/ maskAll\n+\/\/ maskAll (full or partial predicate size)\n@@ -1812,0 +1821,1 @@\n+  effect(TEMP_DEF dst);\n@@ -3179,1 +3189,1 @@\n-%}dnl\n+%}\n@@ -3181,0 +3191,16 @@\n+instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            n->in(1)->bottom_type()->is_vect()->length() <= 64);\n+  match(Set dst (VectorMaskToLong src));\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"vmask_tolong $dst, $src\\t# vector mask tolong (sve)\" %}\n+  ins_encode %{\n+    __ sve_vmask_tolong(as_Register($dst$$reg), as_PRegister($src$$reg),\n+                        Matcher::vector_element_basic_type(this, $src),\n+                        Matcher::vector_length(this, $src),\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n+                        as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -3195,1 +3221,16 @@\n-%}dnl\n+%}\n+\n+\/\/ ---------------------------- Vector mask generation ---------------------------\n+instruct vmask_gen(pRegGov pg, iRegL len, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set pg (VectorMaskGen len));\n+  effect(KILL cr);\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_whilelo $pg, zr, $len\\t # sve\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_whilelo(as_PRegister($pg$$reg), size, zr, as_Register($len$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":49,"deletions":8,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -481,0 +481,2 @@\n+        assert(offset_ok_for_immed(_offset, size),\n+               \"must be, was: \" INT64_FORMAT \", %d\", _offset, size);\n@@ -482,9 +484,8 @@\n-        if (_offset < 0 || _offset & mask)\n-          {\n-            i->f(0b00, 25, 24);\n-            i->f(0, 21), i->f(0b00, 11, 10);\n-            i->sf(_offset, 20, 12);\n-          } else {\n-            i->f(0b01, 25, 24);\n-            i->f(_offset >> size, 21, 10);\n-          }\n+        if (_offset < 0 || _offset & mask) {\n+          i->f(0b00, 25, 24);\n+          i->f(0, 21), i->f(0b00, 11, 10);\n+          i->sf(_offset, 20, 12);\n+        } else {\n+          i->f(0b01, 25, 24);\n+          i->f(_offset >> size, 21, 10);\n+        }\n@@ -2758,1 +2759,2 @@\n-  void mov(FloatRegister Vd, SIMD_Arrangement T, int index, Register Xn) {\n+  void mov(FloatRegister Vd, SIMD_RegVariant T, int index, Register Xn) {\n+    guarantee(T != Q, \"invalid register variant\");\n@@ -2760,1 +2762,1 @@\n-    f(0b01001110000, 31, 21), f(((1 << (T >> 1)) | (index << ((T >> 1) + 1))), 20, 16);\n+    f(0b01001110000, 31, 21), f(((1 << T) | (index << (T + 1))), 20, 16);\n@@ -2766,6 +2768,3 @@\n-  void mov(Register Xd, FloatRegister Vn, SIMD_Arrangement T, int index) {\n-    guarantee(T >= T2S && T < T1Q, \"only D and S arrangements are supported\");\n-    starti;\n-    f(0, 31), f((T >= T1D) ? 1:0, 30), f(0b001110000, 29, 21);\n-    f(((1 << (T >> 1)) | (index << ((T >> 1) + 1))), 20, 16);\n-    f(0b001111, 15, 10), rf(Vn, 5), rf(Xd, 0);\n+  void mov(Register Xd, FloatRegister Vn, SIMD_RegVariant T, int index) {\n+    guarantee(T == S || T == D, \"invalid register variant\");\n+    umov(Xd, Vn, T, index);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-  RelocationHolder rspec;\n+  RelocationHolder rspec = RelocationHolder::none;\n@@ -2063,0 +2063,7 @@\n+void Assembler::vcvttps2dq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len <= AVX_256bit ? VM_Version::supports_avx() : VM_Version::supports_evex(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x5B, (0xC0 | encode));\n+}\n+\n@@ -2071,0 +2078,8 @@\n+void Assembler::evcvttpd2qq(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 2 && VM_Version::supports_avx512dq(), \"\");\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x7A, (0xC0 | encode));\n+}\n+\n@@ -2776,0 +2791,9 @@\n+void Assembler::kshiftlql(KRegister dst, KRegister src, int imm8) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0 , src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int16(0x33, (0xC0 | encode));\n+  emit_int8(imm8);\n+}\n+\n+\n@@ -2807,0 +2831,7 @@\n+void Assembler::kunpckdql(KRegister dst, KRegister src1, KRegister src2) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  InstructionAttr attributes(AVX_256bit, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x4B, (0xC0 | encode));\n+}\n+\n@@ -4309,0 +4340,14 @@\n+void Assembler::vmovmskps(Register dst, XMMRegister src, int vec_enc) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vec_enc, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x50, (0xC0 | encode));\n+}\n+\n+void Assembler::vmovmskpd(Register dst, XMMRegister src, int vec_enc) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vec_enc, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x50, (0xC0 | encode));\n+}\n+\n@@ -11153,0 +11198,4 @@\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for xmm0. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n@@ -11176,0 +11225,1 @@\n+PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1171,0 +1171,3 @@\n+  \/\/ Convert vector float and int\n+  void vcvttps2dq(XMMRegister dst, XMMRegister src, int vector_len);\n+\n@@ -1175,0 +1178,3 @@\n+  \/\/ Convert vector double to long\n+  void evcvttpd2qq(XMMRegister dst, XMMRegister src, int vector_len);\n+\n@@ -1507,0 +1513,1 @@\n+  void kshiftlql(KRegister dst, KRegister src, int imm8);\n@@ -1513,0 +1520,2 @@\n+  void kunpckdql(KRegister dst, KRegister src1, KRegister src2);\n+\n@@ -1777,0 +1786,2 @@\n+  void vmovmskps(Register dst, XMMRegister src, int vec_enc);\n+  void vmovmskpd(Register dst, XMMRegister src, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -488,0 +488,1 @@\n+    assert(!UseHeavyMonitors, \"+UseHeavyMonitors and +UseRTMForStackLocks are mutually exclusive\");\n@@ -498,14 +499,19 @@\n-  \/\/ Attempt stack-locking ...\n-  orptr (tmpReg, markWord::unlocked_value);\n-  movptr(Address(boxReg, 0), tmpReg);          \/\/ Anticipate successful CAS\n-  lock();\n-  cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      \/\/ Updates tmpReg\n-  jcc(Assembler::equal, DONE_LABEL);           \/\/ Success\n-\n-  \/\/ Recursive locking.\n-  \/\/ The object is stack-locked: markword contains stack pointer to BasicLock.\n-  \/\/ Locked by current thread if difference with current SP is less than one page.\n-  subptr(tmpReg, rsp);\n-  \/\/ Next instruction set ZFlag == 1 (Success) if difference is less then one page.\n-  andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - os::vm_page_size())) );\n-  movptr(Address(boxReg, 0), tmpReg);\n+  if (!UseHeavyMonitors) {\n+    \/\/ Attempt stack-locking ...\n+    orptr (tmpReg, markWord::unlocked_value);\n+    movptr(Address(boxReg, 0), tmpReg);          \/\/ Anticipate successful CAS\n+    lock();\n+    cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      \/\/ Updates tmpReg\n+    jcc(Assembler::equal, DONE_LABEL);           \/\/ Success\n+\n+    \/\/ Recursive locking.\n+    \/\/ The object is stack-locked: markword contains stack pointer to BasicLock.\n+    \/\/ Locked by current thread if difference with current SP is less than one page.\n+    subptr(tmpReg, rsp);\n+    \/\/ Next instruction set ZFlag == 1 (Success) if difference is less then one page.\n+    andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - os::vm_page_size())) );\n+    movptr(Address(boxReg, 0), tmpReg);\n+  } else {\n+    \/\/ Clear ZF so that we take the slow path at the DONE label. objReg is known to be not 0.\n+    testptr(objReg, objReg);\n+  }\n@@ -641,0 +647,1 @@\n+    assert(!UseHeavyMonitors, \"+UseHeavyMonitors and +UseRTMForStackLocks are mutually exclusive\");\n@@ -652,2 +659,4 @@\n-  cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   \/\/ Examine the displaced header\n-  jcc   (Assembler::zero, DONE_LABEL);                              \/\/ 0 indicates recursive stack-lock\n+  if (!UseHeavyMonitors) {\n+    cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   \/\/ Examine the displaced header\n+    jcc   (Assembler::zero, DONE_LABEL);                              \/\/ 0 indicates recursive stack-lock\n+  }\n@@ -655,2 +664,4 @@\n-  testptr(tmpReg, markWord::monitor_value);                         \/\/ Inflated?\n-  jccb  (Assembler::zero, Stacked);\n+  if (!UseHeavyMonitors) {\n+    testptr(tmpReg, markWord::monitor_value);                         \/\/ Inflated?\n+    jccb  (Assembler::zero, Stacked);\n+  }\n@@ -798,5 +809,6 @@\n-  bind  (Stacked);\n-  movptr(tmpReg, Address (boxReg, 0));      \/\/ re-fetch\n-  lock();\n-  cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ Uses RAX which is box\n-\n+  if (!UseHeavyMonitors) {\n+    bind  (Stacked);\n+    movptr(tmpReg, Address (boxReg, 0));      \/\/ re-fetch\n+    lock();\n+    cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ Uses RAX which is box\n+  }\n@@ -4062,0 +4074,81 @@\n+\/*\n+ * Algorithm for vector D2L and F2I conversions:-\n+ * a) Perform vector D2L\/F2I cast.\n+ * b) Choose fast path if none of the result vector lane contains 0x80000000 value.\n+ *    It signifies that source value could be any of the special floating point\n+ *    values(NaN,-Inf,Inf,Max,-Min).\n+ * c) Set destination to zero if source is NaN value.\n+ * d) Replace 0x80000000 with MaxInt if source lane contains a +ve value.\n+ *\/\n+\n+void C2_MacroAssembler::vector_castD2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                                            Register scratch, int vec_enc) {\n+  Label done;\n+  evcvttpd2qq(dst, src, vec_enc);\n+  evmovdqul(xtmp1, k0, double_sign_flip, false, vec_enc, scratch);\n+  evpcmpeqq(ktmp1, xtmp1, dst, vec_enc);\n+  kortestwl(ktmp1, ktmp1);\n+  jccb(Assembler::equal, done);\n+\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  evcmppd(ktmp2, k0, src, src, Assembler::UNORD_Q, vec_enc);\n+  evmovdquq(dst, ktmp2, xtmp2, true, vec_enc);\n+\n+  kxorwl(ktmp1, ktmp1, ktmp2);\n+  evcmppd(ktmp1, ktmp1, src, xtmp2, Assembler::NLT_UQ, vec_enc);\n+  vpternlogq(xtmp2, 0x11, xtmp1, xtmp1, vec_enc);\n+  evmovdquq(dst, ktmp1, xtmp2, true, vec_enc);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::vector_castF2I_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                           AddressLiteral float_sign_flip, Register scratch, int vec_enc) {\n+  Label done;\n+  vcvttps2dq(dst, src, vec_enc);\n+  vmovdqu(xtmp1, float_sign_flip, scratch, vec_enc);\n+  vpcmpeqd(xtmp2, dst, xtmp1, vec_enc);\n+  vptest(xtmp2, xtmp2, vec_enc);\n+  jccb(Assembler::equal, done);\n+\n+  vpcmpeqd(xtmp4, xtmp4, xtmp4, vec_enc);\n+  vpxor(xtmp1, xtmp1, xtmp4, vec_enc);\n+\n+  vpxor(xtmp4, xtmp4, xtmp4, vec_enc);\n+  vcmpps(xtmp3, src, src, Assembler::UNORD_Q, vec_enc);\n+  vblendvps(dst, dst, xtmp4, xtmp3, vec_enc);\n+\n+  \/\/ Recompute the mask for remaining special value.\n+  vpxor(xtmp2, xtmp2, xtmp3, vec_enc);\n+  \/\/ Extract SRC values corresponding to TRUE mask lanes.\n+  vpand(xtmp4, xtmp2, src, vec_enc);\n+  \/\/ Flip mask bits so that MSB bit of MASK lanes corresponding to +ve special\n+  \/\/ values are set.\n+  vpxor(xtmp3, xtmp2, xtmp4, vec_enc);\n+\n+  vblendvps(dst, dst, xtmp1, xtmp3, vec_enc);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::vector_castF2I_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n+                                            Register scratch, int vec_enc) {\n+  Label done;\n+  vcvttps2dq(dst, src, vec_enc);\n+  evmovdqul(xtmp1, k0, float_sign_flip, false, vec_enc, scratch);\n+  Assembler::evpcmpeqd(ktmp1, k0, xtmp1, dst, vec_enc);\n+  kortestwl(ktmp1, ktmp1);\n+  jccb(Assembler::equal, done);\n+\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  evcmpps(ktmp2, k0, src, src, Assembler::UNORD_Q, vec_enc);\n+  evmovdqul(dst, ktmp2, xtmp2, true, vec_enc);\n+\n+  kxorwl(ktmp1, ktmp1, ktmp2);\n+  evcmpps(ktmp1, ktmp1, src, xtmp2, Assembler::NLT_UQ, vec_enc);\n+  vpternlogd(xtmp2, 0x11, xtmp1, xtmp1, vec_enc);\n+  evmovdqul(dst, ktmp1, xtmp2, true, vec_enc);\n+  bind(done);\n+}\n+\n@@ -4063,11 +4156,36 @@\n-void C2_MacroAssembler::vector_mask_operation(int opc, Register dst, KRegister mask,\n-                                              Register tmp, int masklen, int masksize,\n-                                              int vec_enc) {\n-  if(VM_Version::supports_avx512bw()) {\n-    kmovql(tmp, mask);\n-  } else {\n-    assert(masklen <= 16, \"\");\n-    kmovwl(tmp, mask);\n-  }\n-  if (masksize < 16) {\n-    andq(tmp, (((jlong)1 << masklen) - 1));\n+void C2_MacroAssembler::vector_long_to_maskvec(XMMRegister dst, Register src, Register rtmp1,\n+                                               Register rtmp2, XMMRegister xtmp, int mask_len,\n+                                               int vec_enc) {\n+  int index = 0;\n+  int vindex = 0;\n+  mov64(rtmp1, 0x0101010101010101L);\n+  pdep(rtmp1, src, rtmp1);\n+  if (mask_len > 8) {\n+    movq(rtmp2, src);\n+    vpxor(xtmp, xtmp, xtmp, vec_enc);\n+    movq(xtmp, rtmp1);\n+  }\n+  movq(dst, rtmp1);\n+\n+  mask_len -= 8;\n+  while (mask_len > 0) {\n+    assert ((mask_len & 0x7) == 0, \"mask must be multiple of 8\");\n+    index++;\n+    if ((index % 2) == 0) {\n+      pxor(xtmp, xtmp);\n+    }\n+    mov64(rtmp1, 0x0101010101010101L);\n+    shrq(rtmp2, 8);\n+    pdep(rtmp1, rtmp2, rtmp1);\n+    pinsrq(xtmp, rtmp1, index % 2);\n+    vindex = index \/ 2;\n+    if (vindex) {\n+      \/\/ Write entire 16 byte vector when both 64 bit\n+      \/\/ lanes are update to save redundant instructions.\n+      if (index % 2) {\n+        vinsertf128(dst, dst, xtmp, vindex);\n+      }\n+    } else {\n+      vmovdqu(dst, xtmp);\n+    }\n+    mask_len -= 8;\n@@ -4075,0 +4193,3 @@\n+}\n+\n+void C2_MacroAssembler::vector_mask_operation_helper(int opc, Register dst, Register tmp, int masklen) {\n@@ -4080,3 +4201,9 @@\n-      mov64(dst, -1);\n-      bsrq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+      if (VM_Version::supports_lzcnt()) {\n+        lzcntq(tmp, tmp);\n+        movl(dst, 63);\n+        subl(dst, tmp);\n+      } else {\n+        movl(dst, -1);\n+        bsrq(tmp, tmp);\n+        cmov32(Assembler::notZero, dst, tmp);\n+      }\n@@ -4085,3 +4212,28 @@\n-      mov64(dst, masklen);\n-      bsfq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+      if (VM_Version::supports_bmi1()) {\n+        if (masklen < 32) {\n+          orl(tmp, 1 << masklen);\n+          tzcntl(dst, tmp);\n+        } else if (masklen == 32) {\n+          tzcntl(dst, tmp);\n+        } else {\n+          assert(masklen == 64, \"\");\n+          tzcntq(dst, tmp);\n+        }\n+      } else {\n+        if (masklen < 32) {\n+          orl(tmp, 1 << masklen);\n+          bsfl(dst, tmp);\n+        } else {\n+          assert(masklen == 32 || masklen == 64, \"\");\n+          movl(dst, masklen);\n+          if (masklen == 32)  {\n+            bsfl(tmp, tmp);\n+          } else {\n+            bsfq(tmp, tmp);\n+          }\n+          cmov32(Assembler::notZero, dst, tmp);\n+        }\n+      }\n+      break;\n+    case Op_VectorMaskToLong:\n+      assert(dst == tmp, \"Dst and tmp should be the same for toLong operations\");\n@@ -4093,9 +4245,9 @@\n-void C2_MacroAssembler::vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp,\n-                                              XMMRegister xtmp1, Register tmp, int masklen, int masksize,\n-                                              int vec_enc) {\n-  assert(VM_Version::supports_avx(), \"\");\n-  vpxor(xtmp, xtmp, xtmp, vec_enc);\n-  vpsubb(xtmp, xtmp, mask, vec_enc);\n-  vpmovmskb(tmp, xtmp, vec_enc);\n-  if (masksize < 16) {\n-    andq(tmp, (((jlong)1 << masklen) - 1));\n+void C2_MacroAssembler::vector_mask_operation(int opc, Register dst, KRegister mask, Register tmp,\n+                                              int masklen, int masksize, int vec_enc) {\n+  assert(VM_Version::supports_popcnt(), \"\");\n+\n+  if(VM_Version::supports_avx512bw()) {\n+    kmovql(tmp, mask);\n+  } else {\n+    assert(masklen <= 16, \"\");\n+    kmovwl(tmp, mask);\n@@ -4103,3 +4255,24 @@\n-  switch(opc) {\n-    case Op_VectorMaskTrueCount:\n-      popcntq(dst, tmp);\n+\n+  \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n+  \/\/ operations needs to be clipped.\n+  if (masksize < 16 && opc != Op_VectorMaskFirstTrue) {\n+    andq(tmp, (1 << masklen) - 1);\n+  }\n+\n+  vector_mask_operation_helper(opc, dst, tmp, masklen);\n+}\n+\n+void C2_MacroAssembler::vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp,\n+                                              Register tmp, int masklen, BasicType bt, int vec_enc) {\n+  assert(vec_enc == AVX_128bit && VM_Version::supports_avx() ||\n+         vec_enc == AVX_256bit && (VM_Version::supports_avx2() || type2aelembytes(bt) >= 4), \"\");\n+  assert(VM_Version::supports_popcnt(), \"\");\n+\n+  bool need_clip = false;\n+  switch(bt) {\n+    case T_BOOLEAN:\n+      \/\/ While masks of other types contain 0, -1; boolean masks contain lane values of 0, 1\n+      vpxor(xtmp, xtmp, xtmp, vec_enc);\n+      vpsubb(xtmp, xtmp, mask, vec_enc);\n+      vpmovmskb(tmp, xtmp, vec_enc);\n+      need_clip = masklen < 16;\n@@ -4107,4 +4280,3 @@\n-    case Op_VectorMaskLastTrue:\n-      mov64(dst, -1);\n-      bsrq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+    case T_BYTE:\n+      vpmovmskb(tmp, mask, vec_enc);\n+      need_clip = masklen < 16;\n@@ -4112,4 +4284,7 @@\n-    case Op_VectorMaskFirstTrue:\n-      mov64(dst, masklen);\n-      bsfq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+    case T_SHORT:\n+      vpacksswb(xtmp, mask, mask, vec_enc);\n+      if (masklen >= 16) {\n+        vpermpd(xtmp, xtmp, 8, vec_enc);\n+      }\n+      vpmovmskb(tmp, xtmp, Assembler::AVX_128bit);\n+      need_clip = masklen < 16;\n@@ -4117,1 +4292,11 @@\n-    default: assert(false, \"Unhandled mask operation\");\n+    case T_INT:\n+    case T_FLOAT:\n+      vmovmskps(tmp, mask, vec_enc);\n+      need_clip = masklen < 4;\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      vmovmskpd(tmp, mask, vec_enc);\n+      need_clip = masklen < 2;\n+      break;\n+    default: assert(false, \"Unhandled type, %s\", type2name(bt));\n@@ -4119,0 +4304,9 @@\n+\n+  \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n+  \/\/ operations needs to be clipped.\n+  if (need_clip && opc != Op_VectorMaskFirstTrue) {\n+    \/\/ need_clip implies masklen < 32\n+    andq(tmp, (1 << masklen) - 1);\n+  }\n+\n+  vector_mask_operation_helper(opc, dst, tmp, masklen);\n@@ -4186,0 +4380,27 @@\n+\n+void C2_MacroAssembler::vector_maskall_operation(KRegister dst, Register src, int mask_len) {\n+  if (VM_Version::supports_avx512bw()) {\n+    if (mask_len > 32) {\n+      kmovql(dst, src);\n+    } else {\n+      kmovdl(dst, src);\n+      if (mask_len != 32) {\n+        kshiftrdl(dst, dst, 32 - mask_len);\n+      }\n+    }\n+  } else {\n+    assert(mask_len <= 16, \"\");\n+    kmovwl(dst, src);\n+    if (mask_len != 16) {\n+      kshiftrwl(dst, dst, 16 - mask_len);\n+    }\n+  }\n+}\n+\n+#ifndef _LP64\n+void C2_MacroAssembler::vector_maskall_operation32(KRegister dst, Register src, KRegister tmp, int mask_len) {\n+  assert(VM_Version::supports_avx512bw(), \"\");\n+  kmovdl(tmp, src);\n+  kunpckdql(dst, tmp, tmp);\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":282,"deletions":61,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -232,0 +232,2 @@\n+  void vector_mask_operation_helper(int opc, Register dst, Register tmp, int masklen);\n+\n@@ -234,2 +236,10 @@\n-  void vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp, XMMRegister xtmp1,\n-                             Register tmp, int masklen, int masksize, int vec_enc);\n+  void vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp,\n+                             Register tmp, int masklen, BasicType bt, int vec_enc);\n+  void vector_long_to_maskvec(XMMRegister dst, Register src, Register rtmp1,\n+                              Register rtmp2, XMMRegister xtmp, int mask_len, int vec_enc);\n+#endif\n+\n+  void vector_maskall_operation(KRegister dst, Register src, int mask_len);\n+\n+#ifndef _LP64\n+  void vector_maskall_operation32(KRegister dst, Register src, KRegister ktmp, int mask_len);\n@@ -237,0 +247,1 @@\n+\n@@ -296,0 +307,12 @@\n+\n+  void vector_castF2I_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                          XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                          AddressLiteral float_sign_flip, Register scratch, int vec_enc);\n+\n+  void vector_castF2I_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                           KRegister ktmp1, KRegister ktmp2, AddressLiteral float_sign_flip,\n+                           Register scratch, int vec_enc);\n+\n+  void vector_castD2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                           KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n+                           Register scratch, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1385,0 +1385,2 @@\n+  static address vector_float_signflip() { return StubRoutines::x86::vector_float_sign_flip();}\n+  static address vector_double_signflip() { return StubRoutines::x86::vector_double_sign_flip();}\n@@ -1613,0 +1615,10 @@\n+    case Op_SqrtF:\n+      if (UseSSE < 1) {\n+        return false;\n+      }\n+      break;\n+    case Op_SqrtD:\n+      if (UseSSE < 2) {\n+        return false;\n+      }\n+      break;\n@@ -1806,5 +1818,10 @@\n-    case Op_VectorCastF2X:\n-      if (is_integral_type(bt)) {\n-        \/\/ Casts from FP to integral types require special fixup logic not easily\n-        \/\/ implementable with vectors.\n-        return false; \/\/ Implementation limitation\n+      if (is_subword_type(bt) || bt == T_INT) {\n+        return false;\n+      }\n+      if (bt == T_LONG && !VM_Version::supports_avx512dq()) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastF2X:\n+      if (is_subword_type(bt) || bt == T_LONG) {\n+        return false;\n@@ -1813,0 +1830,1 @@\n+      break;\n@@ -1833,1 +1851,1 @@\n-      if (!is_LP64 || !VM_Version::supports_evex()) {\n+      if (!VM_Version::supports_evex()) {\n@@ -1865,0 +1883,8 @@\n+    case Op_VectorLongToMask:\n+      if (UseAVX < 1 || !is_LP64) {\n+        return false;\n+      }\n+      if (UseAVX < 3 && !VM_Version::supports_bmi2()) {\n+        return false;\n+      }\n+      break;\n@@ -2074,1 +2100,1 @@\n-const TypeVect* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n+const TypeVectMask* Matcher::predicate_reg_type(const Type* elemTy, int length) {\n@@ -4595,1 +4621,2 @@\n-    __ insertps($dst$$XMMRegister, $val$$XMMRegister, $idx$$constant << 4);\n+    uint x_idx = $idx$$constant & right_n_bits(2);\n+    __ insertps($dst$$XMMRegister, $val$$XMMRegister, x_idx << 4);\n@@ -7188,1 +7215,1 @@\n-  format %{ \"vector_cast_f2x  $dst,$src\\t!\" %}\n+  format %{ \"vector_cast_f2d  $dst,$src\\t!\" %}\n@@ -7196,0 +7223,32 @@\n+instruct vcastFtoI_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, rRegP scratch, rFlagsReg cr) %{\n+  predicate(!VM_Version::supports_avx512vl() &&\n+            Matcher::vector_length_in_bytes(n) < 64 &&\n+            Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, TEMP scratch, KILL cr);\n+  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $xtmp3 and $xtmp4 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_castF2I_avx($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                          $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister,\n+                          ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcastFtoI_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+  predicate((VM_Version::supports_avx512vl() ||\n+             Matcher::vector_length_in_bytes(n) == 64) &&\n+             Matcher::vector_element_basic_type(n) == T_INT);\n+  match(Set dst (VectorCastF2X src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, TEMP scratch, KILL cr);\n+  format %{ \"vector_cast_f2i $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_castF2I_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                           $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                           ExternalAddress(vector_float_signflip()), $scratch$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -7207,0 +7266,14 @@\n+instruct vcastDtoL_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, kReg ktmp1, kReg ktmp2, rRegP scratch, rFlagsReg cr) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (VectorCastD2X src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP ktmp1, TEMP ktmp2, TEMP scratch, KILL cr);\n+  format %{ \"vector_cast_d2l $dst,$src\\t! using $xtmp1, $xtmp2, $ktmp1 and $ktmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vector_castD2L_evex($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                           $xtmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister,\n+                           ExternalAddress(vector_double_signflip()), $scratch$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -8678,1 +8751,1 @@\n-    int mask_len = Matcher::vector_length(this, $mask);\n+    int opcode = this->ideal_Opcode();\n@@ -8680,8 +8753,1 @@\n-    if (VM_Version::supports_avx512vlbw()) {\n-      __ kmovql($dst$$Register, $mask$$KRegister);\n-    } else {\n-      assert(mask_len <= 16, \"\");\n-      __ kmovwl($dst$$Register, $mask$$KRegister);\n-    }\n-    \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n-    \/\/ operations needs to be clipped.\n+    int mask_len = Matcher::vector_length(this, $mask);\n@@ -8689,3 +8755,3 @@\n-    if (mask_size < 16) {\n-      __ andq($dst$$Register, (((jlong)1 << mask_len) - 1));\n-    }\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister,\n+                             $dst$$Register, mask_len, mask_size, vlen_enc);\n@@ -8696,3 +8762,2 @@\n-instruct vmask_tolong_avx(rRegL dst, vec mask, vec xtmp, rFlagsReg cr) %{\n-  predicate(n->in(1)->bottom_type()->isa_vectmask() == NULL &&\n-            n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+instruct vmask_tolong_bool(rRegL dst, vec mask, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->bottom_type()->isa_vectmask() == NULL);\n@@ -8700,1 +8765,1 @@\n-  format %{ \"vector_tolong_avx $dst, $mask \\t! using $xtmp as TEMP\" %}\n+  format %{ \"vector_tolong_bool $dst, $mask \\t! using $xtmp as TEMP\" %}\n@@ -8703,0 +8768,2 @@\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n@@ -8704,0 +8771,14 @@\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $dst$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_tolong_avx(rRegL dst, vec mask, immI size, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskToLong (VectorStoreMask mask size)));\n+  format %{ \"vector_tolong_avx $dst, $mask \\t! using $xtmp as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP xtmp, KILL cr);\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n@@ -8705,0 +8786,1 @@\n+    int mask_len = Matcher::vector_length(this, $mask);\n@@ -8706,9 +8788,2 @@\n-    __ vpxor($xtmp$$XMMRegister, $xtmp$$XMMRegister, $xtmp$$XMMRegister, vlen_enc);\n-    __ vpsubb($xtmp$$XMMRegister, $xtmp$$XMMRegister, $mask$$XMMRegister, vlen_enc);\n-    __ vpmovmskb($dst$$Register, $xtmp$$XMMRegister, vlen_enc);\n-    \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n-    \/\/ operations needs to be clipped.\n-    int mask_size = mask_len * type2aelembytes(mbt);\n-    if (mask_size < 16) {\n-      __ andq($dst$$Register, (((jlong)1 << mask_len) - 1));\n-    }\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $dst$$Register, mask_len, mbt, vlen_enc);\n@@ -8730,2 +8805,2 @@\n-    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister, $tmp$$Register,\n-                             mask_len, mask_size, vlen_enc);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister,\n+                             $tmp$$Register, mask_len, mask_size, vlen_enc);\n@@ -8736,1 +8811,1 @@\n-instruct vmask_truecount_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1, rFlagsReg cr) %{\n+instruct vmask_truecount_bool(rRegI dst, vec mask, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n@@ -8739,2 +8814,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1, KILL cr);\n-  format %{ \"vector_truecount_avx $dst, $mask \\t! using $tmp, $xtmp and $xtmp1 as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_truecount_bool $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n@@ -8745,1 +8820,0 @@\n-    int mask_size = mask_len * type2aelembytes(mbt);\n@@ -8748,1 +8822,17 @@\n-                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, mask_size, vlen_enc);\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_truecount_avx(rRegI dst, vec mask, immI size, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskTrueCount (VectorStoreMask mask size)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_truecount_avx $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n@@ -8765,2 +8855,2 @@\n-    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister, $tmp$$Register, mask_len,\n-                             mask_size, vlen_enc);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister,\n+                             $tmp$$Register, mask_len, mask_size, vlen_enc);\n@@ -8771,1 +8861,1 @@\n-instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1, rFlagsReg cr) %{\n+instruct vmask_first_or_last_true_bool(rRegI dst, vec mask, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n@@ -8775,2 +8865,19 @@\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1, KILL cr);\n-  format %{ \"vector_mask_first_or_last_true_avx $dst, $mask \\t! using $tmp, $xtmp and $xtmp1 as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_bool $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, immI size, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskFirstTrue (VectorStoreMask mask size)));\n+  match(Set dst (VectorMaskLastTrue (VectorStoreMask mask size)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_avx $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n@@ -8781,1 +8888,0 @@\n-    int mask_size = mask_len * type2aelembytes(mbt);\n@@ -8784,1 +8890,1 @@\n-                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, mask_size, vlen_enc);\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n@@ -9423,22 +9529,2 @@\n-#ifdef _LP64\n-instruct mask_all_evexI_imm(kReg dst, immI cnt, rRegL tmp) %{\n-  match(Set dst (MaskAll cnt));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"mask_all_evexI $dst, $cnt \\t! using $tmp as TEMP\" %}\n-  ins_encode %{\n-    int vec_len = Matcher::vector_length(this);\n-    if (VM_Version::supports_avx512bw()) {\n-      __ movq($tmp$$Register, $cnt$$constant);\n-      __ kmovql($dst$$KRegister, $tmp$$Register);\n-      __ kshiftrql($dst$$KRegister, $dst$$KRegister, 64 - vec_len);\n-    } else {\n-      assert(vec_len <= 16, \"\");\n-      __ movq($tmp$$Register, $cnt$$constant);\n-      __ kmovwl($dst$$KRegister, $tmp$$Register);\n-      __ kshiftrwl($dst$$KRegister, $dst$$KRegister, 16 - vec_len);\n-    }\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct mask_all_evexI(kReg dst, rRegI src, rRegL tmp) %{\n+instruct mask_all_evexI_LE32(kReg dst, rRegI src) %{\n+  predicate(Matcher::vector_length(n) <= 32);\n@@ -9446,2 +9532,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"mask_all_evexI $dst, $src \\t! using $tmp as TEMP\" %}\n+  format %{ \"mask_all_evexI_LE32 $dst, $src \\t\" %}\n@@ -9449,28 +9534,2 @@\n-    int vec_len = Matcher::vector_length(this);\n-    if (VM_Version::supports_avx512bw()) {\n-      __ movslq($tmp$$Register, $src$$Register);\n-      __ kmovql($dst$$KRegister, $tmp$$Register);\n-      __ kshiftrql($dst$$KRegister, $dst$$KRegister, 64 - vec_len);\n-    } else {\n-      assert(vec_len <= 16, \"\");\n-      __ kmovwl($dst$$KRegister, $src$$Register);\n-      __ kshiftrwl($dst$$KRegister, $dst$$KRegister, 16 - vec_len);\n-    }\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n-instruct mask_all_evexL(kReg dst, rRegL src) %{\n-  match(Set dst (MaskAll src));\n-  effect(TEMP_DEF dst);\n-  format %{ \"mask_all_evexL $dst, $src \\t! mask all operation\" %}\n-  ins_encode %{\n-    int vec_len = Matcher::vector_length(this);\n-    if (VM_Version::supports_avx512bw()) {\n-      __ kmovql($dst$$KRegister, $src$$Register);\n-      __ kshiftrql($dst$$KRegister, $dst$$KRegister, 64 - vec_len);\n-    } else {\n-      assert(vec_len <= 16, \"\");\n-      __ kmovwl($dst$$KRegister, $src$$Register);\n-      __ kshiftrwl($dst$$KRegister, $dst$$KRegister, 16 - vec_len);\n-    }\n+    int mask_len = Matcher::vector_length(this);\n+    __ vector_maskall_operation($dst$$KRegister, $src$$Register, mask_len);\n@@ -9481,0 +9540,1 @@\n+#ifdef _LP64\n@@ -9505,0 +9565,40 @@\n+\n+instruct long_to_maskLE8_avx(vec dst, rRegL src, rRegL rtmp1, rRegL rtmp2, vec xtmp) %{\n+  predicate(n->bottom_type()->isa_vectmask() == NULL && Matcher::vector_length(n) <= 8);\n+  match(Set dst (VectorLongToMask src));\n+  effect(TEMP dst, TEMP rtmp1, TEMP rtmp2, TEMP xtmp);\n+  format %{ \"long_to_mask_avx $dst, $src\\t! using $rtmp1, $rtmp2, $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int mask_len = Matcher::vector_length(this);\n+    int vec_enc  = vector_length_encoding(mask_len);\n+    __ vector_long_to_maskvec($dst$$XMMRegister, $src$$Register, $rtmp1$$Register,\n+                              $rtmp2$$Register, xnoreg, mask_len, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n+instruct long_to_maskGT8_avx(vec dst, rRegL src, rRegL rtmp1, rRegL rtmp2, vec xtmp1, rFlagsReg cr) %{\n+  predicate(n->bottom_type()->isa_vectmask() == NULL && Matcher::vector_length(n) > 8);\n+  match(Set dst (VectorLongToMask src));\n+  effect(TEMP dst, TEMP rtmp1, TEMP rtmp2, TEMP xtmp1, KILL cr);\n+  format %{ \"long_to_mask_avx $dst, $src\\t! using $rtmp1, $rtmp2, $xtmp1, as TEMP\" %}\n+  ins_encode %{\n+    int mask_len = Matcher::vector_length(this);\n+    assert(mask_len <= 32, \"invalid mask length\");\n+    int vec_enc  = vector_length_encoding(mask_len);\n+    __ vector_long_to_maskvec($dst$$XMMRegister, $src$$Register, $rtmp1$$Register,\n+                              $rtmp2$$Register, $xtmp1$$XMMRegister, mask_len, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct long_to_mask_evex(kReg dst, rRegL src) %{\n+  predicate(n->bottom_type()->isa_vectmask());\n+  match(Set dst (VectorLongToMask src));\n+  format %{ \"long_to_mask_evex $dst, $src\\t!\" %}\n+  ins_encode %{\n+    __ kmov($dst$$KRegister, $src$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -9524,0 +9624,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":201,"deletions":100,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -4238,2 +4238,2 @@\n-    \"VectorMaskWrapper\", \"VectorMaskCmp\", \"VectorReinterpret\",\"LoadVectorMasked\",\"StoreVectorMasked\",\n-    \"FmaVD\", \"FmaVF\",\"PopCountVI\",\n+    \"VectorMaskWrapper\",\"VectorMaskCmp\",\"VectorReinterpret\",\"LoadVectorMasked\",\"StoreVectorMasked\",\n+    \"FmaVD\",\"FmaVF\",\"PopCountVI\",\"VectorLongToMask\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -872,2 +872,2 @@\n-  do_intrinsic(_VectorBroadcastCoerced, jdk_internal_vm_vector_VectorSupport, vector_broadcast_coerced_name, vector_broadcast_coerced_sig, F_S)\\\n-   do_signature(vector_broadcast_coerced_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n+  do_intrinsic(_VectorFromBitsCoerced, jdk_internal_vm_vector_VectorSupport, vector_frombits_coerced_name, vector_frombits_coerced_sig, F_S)   \\\n+   do_signature(vector_frombits_coerced_sig, \"(Ljava\/lang\/Class;\"                                                                              \\\n@@ -877,0 +877,1 @@\n+                                               \"I\"                                                                                             \\\n@@ -878,1 +879,1 @@\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$BroadcastOperation;)\"                                    \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$FromBitsCoercedOperation;)\"                              \\\n@@ -880,1 +881,1 @@\n-   do_name(vector_broadcast_coerced_name, \"broadcastCoerced\")                                                                                  \\\n+   do_name(vector_frombits_coerced_name, \"fromBitsCoerced\")                                                                                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+const char* C2Compiler::retry_no_iterative_escape_analysis() {\n+  return \"retry without iterative escape analysis\";\n+}\n@@ -102,0 +105,1 @@\n+  bool do_iterative_escape_analysis = DoEscapeAnalysis;\n@@ -107,1 +111,1 @@\n-    Options options(subsume_loads, do_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code);\n+    Options options(subsume_loads, do_escape_analysis, do_iterative_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code);\n@@ -128,0 +132,6 @@\n+      if (C.failure_reason_is(retry_no_iterative_escape_analysis())) {\n+        assert(do_iterative_escape_analysis, \"must make progress\");\n+        do_iterative_escape_analysis = false;\n+        env->report_failure(C.failure_reason());\n+        continue;  \/\/ retry\n+      }\n@@ -697,1 +707,1 @@\n-  case vmIntrinsics::_VectorBroadcastCoerced:\n+  case vmIntrinsics::_VectorFromBitsCoerced:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -434,0 +434,1 @@\n+macro(VectorLongToMask)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -655,2 +655,2 @@\n-  case vmIntrinsics::_VectorBroadcastCoerced:\n-    return inline_vector_broadcast_coerced();\n+  case vmIntrinsics::_VectorFromBitsCoerced:\n+    return inline_vector_frombits_coerced();\n@@ -5432,1 +5432,1 @@\n-        Node* vmask      = _gvn.transform(new VectorMaskGenNode(ConvI2X(casted_length), TypeVect::VECTMASK, elem_bt));\n+        Node* vmask      = _gvn.transform(VectorMaskGenNode::make(ConvI2X(casted_length), elem_bt));\n@@ -6800,1 +6800,1 @@\n-      return false;\n+    return false;\n@@ -6816,1 +6816,0 @@\n-\n@@ -6822,16 +6821,0 @@\n-  ciKlass* klass = ciTypeArrayKlass::make(T_LONG);\n-  Node* klass_node = makecon(TypeKlassPtr::make(klass));\n-\n-  \/\/ Does this target support this intrinsic?\n-  if (Matcher::htbl_entries == -1) return false;\n-\n-  Node* subkeyHtbl_48_entries_start;\n-  if (Matcher::htbl_entries != 0) {\n-    \/\/ new array to hold 48 computed htbl entries\n-    Node* subkeyHtbl_48_entries = new_array(klass_node, intcon(Matcher::htbl_entries), 0);\n-    if (subkeyHtbl_48_entries == NULL) return false;\n-    subkeyHtbl_48_entries_start = array_element_address(subkeyHtbl_48_entries, intcon(0), T_LONG);\n-  } else {\n-    \/\/ This target doesn't need the extra-large Htbl.\n-    subkeyHtbl_48_entries_start = ConvL2X(intcon(0));\n-  }\n@@ -6843,1 +6826,1 @@\n-                               in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, subkeyHtbl_48_entries_start, cnt_start);\n+                               in_start, len, ct_start, out_start, k_start, state_start, subkeyHtbl_start, cnt_start);\n@@ -6848,0 +6831,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":22,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-  bool inline_vector_broadcast_coerced();\n+  bool inline_vector_frombits_coerced();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -637,6 +637,7 @@\n-    \/\/ Exclude last input arg stack slots to avoid spilling vector register there,\n-    \/\/ otherwise RegVectMask spills could stomp over stack slots in caller frame.\n-    for (; (in >= init_in) && (k < scalable_predicate_reg_slots()); k++) {\n-      scalable_stack_mask.Remove(in);\n-      in = OptoReg::add(in, -1);\n-    }\n+    if (Matcher::has_predicated_vectors()) {\n+      \/\/ Exclude last input arg stack slots to avoid spilling vector register there,\n+      \/\/ otherwise RegVectMask spills could stomp over stack slots in caller frame.\n+      for (; (in >= init_in) && (k < scalable_predicate_reg_slots()); k++) {\n+        scalable_stack_mask.Remove(in);\n+        in = OptoReg::add(in, -1);\n+      }\n@@ -644,5 +645,6 @@\n-    \/\/ For RegVectMask\n-    scalable_stack_mask.clear_to_sets(scalable_predicate_reg_slots());\n-    assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n-    idealreg2spillmask[Op_RegVectMask]->OR(scalable_stack_mask);\n+      \/\/ For RegVectMask\n+      scalable_stack_mask.clear_to_sets(scalable_predicate_reg_slots());\n+      assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+      *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n+      idealreg2spillmask[Op_RegVectMask]->OR(scalable_stack_mask);\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1277,6 +1277,0 @@\n-public:\n-  virtual bool operates_on(BasicType bt, bool signed_int) const {\n-    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n-    Unimplemented();\n-    return false;\n-  }\n@@ -1847,0 +1841,35 @@\n+#include \"opto\/opcodes.hpp\"\n+\n+#define Op_IL(op) \\\n+  inline int Op_ ## op(BasicType bt) { \\\n+  assert(bt == T_INT || bt == T_LONG, \"only for int or longs\"); \\\n+  if (bt == T_INT) { \\\n+    return Op_## op ## I; \\\n+  } \\\n+  return Op_## op ## L; \\\n+}\n+\n+Op_IL(Add)\n+Op_IL(Sub)\n+Op_IL(Mul)\n+Op_IL(URShift)\n+Op_IL(LShift)\n+Op_IL(Xor)\n+Op_IL(Cmp)\n+\n+inline int Op_Cmp_unsigned(BasicType bt) {\n+  assert(bt == T_INT || bt == T_LONG, \"only for int or longs\");\n+  if (bt == T_INT) {\n+    return Op_CmpU;\n+  }\n+  return Op_CmpUL;\n+}\n+\n+inline int Op_Cast(BasicType bt) {\n+  assert(bt == T_INT || bt == T_LONG, \"only for int or longs\");\n+  if (bt == T_INT) {\n+    return Op_CastII;\n+  }\n+  return Op_CastLL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -787,2 +787,2 @@\n-\/\/ M broadcastCoerced(Class<? extends M> vmClass, Class<E> elementType, int length,\n-\/\/                    long bits, S s,\n+\/\/ M fromBitsCoerced(Class<? extends M> vmClass, Class<E> elementType, int length,\n+\/\/                    long bits, int mode, S s,\n@@ -790,1 +790,1 @@\n-bool LibraryCallKit::inline_vector_broadcast_coerced() {\n+bool LibraryCallKit::inline_vector_frombits_coerced() {\n@@ -794,0 +794,5 @@\n+  const TypeLong*    bits_type    = gvn().type(argument(3))->isa_long();\n+  \/\/ Mode argument determines the mode of operation it can take following values:-\n+  \/\/ MODE_BROADCAST for vector Vector.boradcast and VectorMask.maskAll operations.\n+  \/\/ MODE_BITS_COERCED_LONG_TO_MASK for VectorMask.fromLong operation.\n+  const TypeInt*     mode         = gvn().type(argument(5))->isa_int();\n@@ -795,2 +800,3 @@\n-  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n-      vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL || mode == NULL ||\n+      bits_type == NULL || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL ||\n+      !vlen->is_con() || !mode->is_con()) {\n@@ -798,1 +804,1 @@\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s bitwise=%s\",\n@@ -801,1 +807,2 @@\n-                    NodeClassNames[argument(2)->Opcode()]);\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -824,3 +831,6 @@\n-  \/\/ TODO When mask usage is supported, VecMaskNotUsed needs to be VecMaskUseLoad.\n-  if (!arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt,\n-                            (is_vector_mask(vbox_klass) ? VecMaskUseStore : VecMaskNotUsed), true \/*has_scalar_args*\/)) {\n+  bool is_mask = is_vector_mask(vbox_klass);\n+  int  bcast_mode = mode->get_con();\n+  VectorMaskUseType checkFlags = (VectorMaskUseType)(is_mask ? VecMaskUseAll : VecMaskNotUsed);\n+  int opc = bcast_mode == VectorSupport::MODE_BITS_COERCED_LONG_TO_MASK ? Op_VectorLongToMask : VectorNode::replicate_opcode(elem_bt);\n+\n+  if (!arch_supports_vector(opc, num_elem, elem_bt, checkFlags, true \/*has_scalar_args*\/)) {\n@@ -828,1 +838,1 @@\n-      tty->print_cr(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d\",\n+      tty->print_cr(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d bcast_mode=%d\",\n@@ -830,1 +840,2 @@\n-                    is_vector_mask(vbox_klass) ? 1 : 0);\n+                    is_mask ? 1 : 0,\n+                    bcast_mode);\n@@ -835,19 +846,12 @@\n-  Node* bits = argument(3); \/\/ long\n-  Node* elem = NULL;\n-  switch (elem_bt) {\n-    case T_BOOLEAN: \/\/ fall-through\n-    case T_BYTE:    \/\/ fall-through\n-    case T_SHORT:   \/\/ fall-through\n-    case T_CHAR:    \/\/ fall-through\n-    case T_INT: {\n-      elem = gvn().transform(new ConvL2INode(bits));\n-      break;\n-    }\n-    case T_DOUBLE: {\n-      elem = gvn().transform(new MoveL2DNode(bits));\n-      break;\n-    }\n-    case T_FLOAT: {\n-      bits = gvn().transform(new ConvL2INode(bits));\n-      elem = gvn().transform(new MoveI2FNode(bits));\n-      break;\n+  Node* broadcast = NULL;\n+  Node* bits = argument(3);\n+  Node* elem = bits;\n+\n+  if (opc == Op_VectorLongToMask) {\n+    const TypeVect* vt = TypeVect::makemask(elem_bt, num_elem);\n+    if (vt->isa_vectmask()) {\n+      broadcast = gvn().transform(new VectorLongToMaskNode(elem, vt));\n+    } else {\n+      const TypeVect* mvt = TypeVect::make(T_BOOLEAN, num_elem);\n+      broadcast = gvn().transform(new VectorLongToMaskNode(elem, mvt));\n+      broadcast = gvn().transform(new VectorLoadMaskNode(broadcast, vt));\n@@ -855,3 +859,24 @@\n-    case T_LONG: {\n-      elem = bits; \/\/ no conversion needed\n-      break;\n+  } else {\n+    switch (elem_bt) {\n+      case T_BOOLEAN: \/\/ fall-through\n+      case T_BYTE:    \/\/ fall-through\n+      case T_SHORT:   \/\/ fall-through\n+      case T_CHAR:    \/\/ fall-through\n+      case T_INT: {\n+        elem = gvn().transform(new ConvL2INode(bits));\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        elem = gvn().transform(new MoveL2DNode(bits));\n+        break;\n+      }\n+      case T_FLOAT: {\n+        bits = gvn().transform(new ConvL2INode(bits));\n+        elem = gvn().transform(new MoveI2FNode(bits));\n+        break;\n+      }\n+      case T_LONG: {\n+        \/\/ no conversion needed\n+        break;\n+      }\n+      default: fatal(\"%s\", type2name(elem_bt));\n@@ -859,1 +884,2 @@\n-    default: fatal(\"%s\", type2name(elem_bt));\n+    broadcast = VectorNode::scalar2vector(elem, num_elem, Type::get_const_basic_type(elem_bt), is_mask);\n+    broadcast = gvn().transform(broadcast);\n@@ -862,3 +888,0 @@\n-  Node* broadcast = VectorNode::scalar2vector(elem, num_elem, Type::get_const_basic_type(elem_bt), is_vector_mask(vbox_klass));\n-  broadcast = gvn().transform(broadcast);\n-\n@@ -2483,15 +2506,1 @@\n-          \/\/ Special handling for casting operation involving floating point types.\n-          \/\/ Case A) F -> X :=  F -> VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2X\n-          \/\/ Case B) X -> F :=  X -> VectorCastX2[I\/L] -> VectorMaskCast ([I\/L]->F [NOP])\n-          \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectotMaskCast (L\/I->F [NOP])\n-          if (is_floating_point_type(elem_bt_from)) {\n-            const TypeVect* new_src_type = TypeVect::make(new_elem_bt_from, num_elem_to, is_mask);\n-            op = gvn().transform(new VectorMaskCastNode(op, new_src_type));\n-          }\n-          if (is_floating_point_type(elem_bt_to)) {\n-            new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-          }\n-          op = gvn().transform(VectorCastNode::make(cast_vopc, op, new_elem_bt_to, num_elem_to));\n-          if (new_elem_bt_to != elem_bt_to) {\n-            op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n-          }\n+          op = VectorMaskCastNode::makeCastNode(&gvn(), op, dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":62,"deletions":53,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -603,3 +603,1 @@\n-  const TypeVect* vt = opd_t->singleton() ? TypeVect::make(opd_t, vlen, is_mask)\n-                                          : TypeVect::make(bt, vlen, is_mask);\n-\n+    const TypeVect* vt = TypeVect::make(opd_t, vlen, true);\n@@ -610,0 +608,2 @@\n+  const TypeVect* vt = opd_t->singleton() ? TypeVect::make(opd_t, vlen)\n+                                          : TypeVect::make(bt, vlen);\n@@ -808,4 +808,4 @@\n-      BasicType mask_bt = ((VectorMaskGenNode*)in(3))->get_elem_type();\n-      uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n-      if ( load_sz == 32 || load_sz == 64) {\n-        assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected load size\");\n+      BasicType mask_bt = Matcher::vector_element_basic_type(in(3));\n+      int load_sz = type2aelembytes(mask_bt) * ty->get_con();\n+      assert(load_sz <= MaxVectorSize, \"Unexpected load size\");\n+      if (load_sz == MaxVectorSize) {\n@@ -827,4 +827,4 @@\n-      BasicType mask_bt = ((VectorMaskGenNode*)in(4))->get_elem_type();\n-      uint load_sz      = type2aelembytes(mask_bt) * ty->get_con();\n-      if ( load_sz == 32 || load_sz == 64) {\n-        assert(load_sz == 32 || MaxVectorSize > 32, \"Unexpected store size\");\n+      BasicType mask_bt = Matcher::vector_element_basic_type(in(4));\n+      int load_sz = type2aelembytes(mask_bt) * ty->get_con();\n+      assert(load_sz <= MaxVectorSize, \"Unexpected store size\");\n+      if (load_sz == MaxVectorSize) {\n@@ -1432,0 +1432,6 @@\n+Node* VectorMaskGenNode::make(Node* length, BasicType mask_bt) {\n+  int max_vector = Matcher::max_vector_size(mask_bt);\n+  const TypeVectMask* t_vmask = TypeVectMask::make(mask_bt, max_vector);\n+  return new VectorMaskGenNode(length, t_vmask);\n+}\n+\n@@ -1448,0 +1454,76 @@\n+Node* VectorMaskToLongNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_VectorLongToMask) {\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+\n+Node* VectorMaskCastNode::makeCastNode(PhaseGVN* phase, Node* src, const TypeVect* dst_type) {\n+  const TypeVect* src_type = src->bottom_type()->is_vect();\n+  assert(src_type->length() == dst_type->length(), \"\");\n+\n+  int num_elem = src_type->length();\n+  BasicType elem_bt_from = src_type->element_basic_type();\n+  BasicType elem_bt_to = dst_type->element_basic_type();\n+\n+  if (dst_type->isa_vectmask() == NULL && src_type->isa_vectmask() == NULL &&\n+      type2aelembytes(elem_bt_from) != type2aelembytes(elem_bt_to)) {\n+\n+    Node* op = src;\n+    BasicType new_elem_bt_from = elem_bt_from;\n+    BasicType new_elem_bt_to = elem_bt_to;\n+    if (is_floating_point_type(elem_bt_from)) {\n+      new_elem_bt_from =  elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n+    }\n+    if (is_floating_point_type(elem_bt_to)) {\n+      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n+    }\n+\n+    \/\/ Special handling for casting operation involving floating point types.\n+    \/\/ Case A) F -> X :=  F -> VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2X\n+    \/\/ Case B) X -> F :=  X -> VectorCastX2[I\/L] -> VectorMaskCast ([I\/L]->F [NOP])\n+    \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectotMaskCast (L\/I->F [NOP])\n+\n+    if (new_elem_bt_from != elem_bt_from) {\n+      const TypeVect* new_src_type = TypeVect::makemask(new_elem_bt_from, num_elem);\n+      op = phase->transform(new VectorMaskCastNode(op, new_src_type));\n+    }\n+\n+    op = phase->transform(VectorCastNode::make(VectorCastNode::opcode(new_elem_bt_from), op, new_elem_bt_to, num_elem));\n+\n+    if (new_elem_bt_to != elem_bt_to) {\n+      op = phase->transform(new VectorMaskCastNode(op, dst_type));\n+    }\n+    return op;\n+  } else {\n+    return new VectorMaskCastNode(src, dst_type);\n+  }\n+}\n+\n+Node* VectorLongToMaskNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeVect* dst_type = bottom_type()->is_vect();\n+  if (in(1)->Opcode() == Op_AndL &&\n+      in(1)->in(1)->Opcode() == Op_VectorMaskToLong &&\n+      in(1)->in(2)->bottom_type()->isa_long() &&\n+      in(1)->in(2)->bottom_type()->is_long()->is_con() &&\n+      in(1)->in(2)->bottom_type()->is_long()->get_con() == ((1L << dst_type->length()) - 1)) {\n+      \/\/ Different src\/dst mask length represents a re-interpretation operation,\n+      \/\/ we can however generate a mask casting operation if length matches.\n+     Node* src = in(1)->in(1)->in(1);\n+     if (dst_type->isa_vectmask() == NULL) {\n+       if (src->Opcode() != Op_VectorStoreMask) {\n+         return NULL;\n+       }\n+       src = src->in(1);\n+     }\n+     const TypeVect* src_type = src->bottom_type()->is_vect();\n+     if (src_type->length() == dst_type->length() &&\n+         ((src_type->isa_vectmask() == NULL && dst_type->isa_vectmask() == NULL) ||\n+          (src_type->isa_vectmask() && dst_type->isa_vectmask()))) {\n+       return VectorMaskCastNode::makeCastNode(phase, src, dst_type);\n+     }\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":93,"deletions":11,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -953,0 +954,1 @@\n+\/\/------------------------------VectorMaskGenNode----------------------------------\n@@ -955,1 +957,1 @@\n-  VectorMaskGenNode(Node* length, const Type* ty, BasicType ety): TypeNode(ty, 2), _elemType(ety) {\n+  VectorMaskGenNode(Node* length, const Type* ty): TypeNode(ty, 2) {\n@@ -960,8 +962,2 @@\n-  BasicType get_elem_type()  { return _elemType;}\n-  virtual  uint  size_of() const { return sizeof(VectorMaskGenNode); }\n-  virtual uint  ideal_reg() const {\n-    return Op_RegVectMask;\n-  }\n-\n-  private:\n-   BasicType _elemType;\n+  virtual uint ideal_reg() const { return Op_RegVectMask; }\n+  static Node* make(Node* length, BasicType vmask_bt);\n@@ -970,0 +966,1 @@\n+\/\/------------------------------VectorMaskOpNode-----------------------------------\n@@ -1015,0 +1012,10 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n+};\n+\n+class VectorLongToMaskNode : public VectorNode {\n+ public:\n+  VectorLongToMaskNode(Node* mask, const TypeVect* ty):\n+    VectorNode(mask, ty) {\n+  }\n+  virtual int Opcode() const;\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1438,1 +1445,1 @@\n-\n+  static Node* makeCastNode(PhaseGVN* phase, Node* in1, const TypeVect * vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -128,0 +128,5 @@\n+  enum {\n+    MODE_BROADCAST = 0,\n+    MODE_BITS_COERCED_LONG_TO_MASK = 1\n+  };\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -122,0 +122,4 @@\n+    \/\/ Various broadcasting modes.\n+    public static final int MODE_BROADCAST = 0;\n+    public static final int MODE_BITS_COERCED_LONG_TO_MASK = 1;\n+\n@@ -165,3 +169,3 @@\n-    public interface BroadcastOperation<VM extends VectorPayload,\n-                                        S extends VectorSpecies<?>> {\n-        VM broadcast(long l, S s);\n+    public interface FromBitsCoercedOperation<VM extends VectorPayload,\n+                                              S extends VectorSpecies<?>> {\n+        VM fromBits(long l, S s);\n@@ -175,4 +179,4 @@\n-    VM broadcastCoerced(Class<? extends VM> vmClass, Class<E> eClass,\n-                        int length,\n-                        long bits, S s,\n-                        BroadcastOperation<VM, S> defaultImpl) {\n+    VM fromBitsCoerced(Class<? extends VM> vmClass, Class<E> eClass,\n+                       int length,\n+                       long bits, int mode, S s,\n+                       FromBitsCoercedOperation<VM, S> defaultImpl) {\n@@ -180,1 +184,1 @@\n-        return defaultImpl.broadcast(bits, s);\n+        return defaultImpl.fromBits(bits, s);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -785,3 +785,3 @@\n-            return VectorSupport.broadcastCoerced(Byte128Mask.class, byte.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Byte128Mask.class, byte.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -817,3 +817,3 @@\n-            return VectorSupport.broadcastCoerced(Byte256Mask.class, byte.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Byte256Mask.class, byte.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -881,3 +881,3 @@\n-            return VectorSupport.broadcastCoerced(Byte512Mask.class, byte.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Byte512Mask.class, byte.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -769,3 +769,3 @@\n-            return VectorSupport.broadcastCoerced(Byte64Mask.class, byte.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Byte64Mask.class, byte.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -755,3 +755,3 @@\n-            return VectorSupport.broadcastCoerced(ByteMaxMask.class, byte.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -488,2 +488,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), byte.class, species.length(),\n-                                0, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), byte.class, species.length(),\n+                                0, MODE_BROADCAST, vsp,\n@@ -4219,1 +4219,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -4221,1 +4221,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -746,3 +746,3 @@\n-            return VectorSupport.broadcastCoerced(Double128Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Double128Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -750,3 +750,3 @@\n-            return VectorSupport.broadcastCoerced(Double256Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Double256Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -758,3 +758,3 @@\n-            return VectorSupport.broadcastCoerced(Double512Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Double512Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -744,3 +744,3 @@\n-            return VectorSupport.broadcastCoerced(Double64Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Double64Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -743,3 +743,3 @@\n-            return VectorSupport.broadcastCoerced(DoubleMaxMask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -477,2 +477,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), double.class, species.length(),\n-                        toBits(0.0f), vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), double.class, species.length(),\n+                        toBits(0.0f), MODE_BROADCAST, vsp,\n@@ -3824,1 +3824,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -3826,1 +3826,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -750,3 +750,3 @@\n-            return VectorSupport.broadcastCoerced(Float128Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Float128Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -758,3 +758,3 @@\n-            return VectorSupport.broadcastCoerced(Float256Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Float256Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -774,3 +774,3 @@\n-            return VectorSupport.broadcastCoerced(Float512Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Float512Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -746,3 +746,3 @@\n-            return VectorSupport.broadcastCoerced(Float64Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Float64Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -743,3 +743,3 @@\n-            return VectorSupport.broadcastCoerced(FloatMaxMask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -477,2 +477,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), float.class, species.length(),\n-                        toBits(0.0f), vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), float.class, species.length(),\n+                        toBits(0.0f), MODE_BROADCAST, vsp,\n@@ -3774,1 +3774,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -3776,1 +3776,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -761,3 +761,3 @@\n-            return VectorSupport.broadcastCoerced(Int128Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Int128Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -769,3 +769,3 @@\n-            return VectorSupport.broadcastCoerced(Int256Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Int256Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -785,3 +785,3 @@\n-            return VectorSupport.broadcastCoerced(Int512Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Int512Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -757,3 +757,3 @@\n-            return VectorSupport.broadcastCoerced(Int64Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Int64Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -755,3 +755,3 @@\n-            return VectorSupport.broadcastCoerced(IntMaxMask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -488,2 +488,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), int.class, species.length(),\n-                                0, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), int.class, species.length(),\n+                                0, MODE_BROADCAST, vsp,\n@@ -3944,1 +3944,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -3946,1 +3946,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -747,3 +747,3 @@\n-            return VectorSupport.broadcastCoerced(Long128Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Long128Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -751,3 +751,3 @@\n-            return VectorSupport.broadcastCoerced(Long256Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Long256Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -759,3 +759,3 @@\n-            return VectorSupport.broadcastCoerced(Long512Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Long512Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -745,3 +745,3 @@\n-            return VectorSupport.broadcastCoerced(Long64Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Long64Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -745,3 +745,3 @@\n-            return VectorSupport.broadcastCoerced(LongMaxMask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -488,2 +488,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), long.class, species.length(),\n-                                0, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), long.class, species.length(),\n+                                0, MODE_BROADCAST, vsp,\n@@ -3879,1 +3879,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -3881,1 +3881,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -769,3 +769,3 @@\n-            return VectorSupport.broadcastCoerced(Short128Mask.class, short.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Short128Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -785,3 +785,3 @@\n-            return VectorSupport.broadcastCoerced(Short256Mask.class, short.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Short256Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -817,3 +817,3 @@\n-            return VectorSupport.broadcastCoerced(Short512Mask.class, short.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Short512Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -761,3 +761,3 @@\n-            return VectorSupport.broadcastCoerced(Short64Mask.class, short.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Short64Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -755,3 +755,3 @@\n-            return VectorSupport.broadcastCoerced(ShortMaxMask.class, short.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -488,2 +488,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), short.class, species.length(),\n-                                0, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, species.length(),\n+                                0, MODE_BROADCAST, vsp,\n@@ -4213,1 +4213,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -4215,1 +4215,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -240,20 +240,19 @@\n-        AbstractSpecies<E> vspecies = (AbstractSpecies<E>) species;\n-        int laneCount = vspecies.laneCount();\n-        if (laneCount < Long.SIZE) {\n-            int extraSignBits = Long.SIZE - laneCount;\n-            bits <<= extraSignBits;\n-            bits >>= extraSignBits;\n-        }\n-        if (bits == (bits >> 1)) {\n-            \/\/ Special case.\n-            assert(bits == 0 || bits == -1);\n-            return vspecies.maskAll(bits != 0);\n-        }\n-        \/\/ FIXME: Intrinsify this.\n-        long shifted = bits;\n-        boolean[] a = new boolean[laneCount];\n-        for (int i = 0; i < a.length; i++) {\n-            a[i] = ((shifted & 1) != 0);\n-            shifted >>= 1;  \/\/ replicate sign bit\n-        }\n-        return fromValues(vspecies, a);\n+        AbstractSpecies<E> vsp = (AbstractSpecies<E>) species;\n+        bits = bits & (0xFFFFFFFFFFFFFFFFL >>> (64 - vsp.laneCount()));\n+        return VectorSupport.fromBitsCoerced(vsp.maskType(), vsp.elementType(), vsp.laneCount(), bits,\n+                                             VectorSupport.MODE_BITS_COERCED_LONG_TO_MASK, vsp,\n+                                             (m, s) -> {\n+                                                 if (m == (m >> 1)) {\n+                                                     \/\/ Special case.\n+                                                     assert(m == 0 || m == -1);\n+                                                     return s.maskAll(m != 0);\n+                                                 }\n+\n+                                                 long shifted = m;\n+                                                 boolean[] a = new boolean[s.laneCount()];\n+                                                 for (int i = 0; i < a.length; i++) {\n+                                                     a[i] = ((shifted & 1) != 0);\n+                                                     shifted >>= 1;  \/\/ replicate sign bit\n+                                                 }\n+                                                 return fromValues(s, a);\n+                                              });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -503,2 +503,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), $type$.class, species.length(),\n-                        toBits(0.0f), vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),\n+                        toBits(0.0f), MODE_BROADCAST, vsp,\n@@ -507,2 +507,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), $type$.class, species.length(),\n-                                0, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),\n+                                0, MODE_BROADCAST, vsp,\n@@ -5397,1 +5397,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -5399,1 +5399,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1028,3 +1028,3 @@\n-            return VectorSupport.broadcastCoerced($masktype$.class, $bitstype$.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1574,4 +1574,4 @@\n-                        [\"mov\",    \"__ mov(v1, __ T1D, 0, zr);\",                         \"mov\\tv1.d[0], xzr\"],\n-                        [\"mov\",    \"__ mov(v1, __ T2S, 1, zr);\",                         \"mov\\tv1.s[1], wzr\"],\n-                        [\"mov\",    \"__ mov(v1, __ T4H, 2, zr);\",                         \"mov\\tv1.h[2], wzr\"],\n-                        [\"mov\",    \"__ mov(v1, __ T8B, 3, zr);\",                         \"mov\\tv1.b[3], wzr\"],\n+                        [\"mov\",    \"__ mov(v1, __ D, 0, zr);\",                           \"mov\\tv1.d[0], xzr\"],\n+                        [\"mov\",    \"__ mov(v1, __ S, 1, zr);\",                           \"mov\\tv1.s[1], wzr\"],\n+                        [\"mov\",    \"__ mov(v1, __ H, 2, zr);\",                           \"mov\\tv1.h[2], wzr\"],\n+                        [\"mov\",    \"__ mov(v1, __ B, 3, zr);\",                           \"mov\\tv1.b[3], wzr\"],\n@@ -1726,0 +1726,4 @@\n+                        [\"ptrue\",   \"__ sve_ptrue(p1, __ B, 0b00001);\",                   \"ptrue\\tp1.b, vl1\"],\n+                        [\"ptrue\",   \"__ sve_ptrue(p1, __ B, 0b00101);\",                   \"ptrue\\tp1.b, vl5\"],\n+                        [\"ptrue\",   \"__ sve_ptrue(p1, __ B, 0b01001);\",                   \"ptrue\\tp1.b, vl16\"],\n+                        [\"ptrue\",   \"__ sve_ptrue(p1, __ B, 0b01101);\",                   \"ptrue\\tp1.b, vl256\"],\n@@ -1727,0 +1731,3 @@\n+                        [\"ptrue\",   \"__ sve_ptrue(p2, __ H, 0b00010);\",                   \"ptrue\\tp2.h, vl2\"],\n+                        [\"ptrue\",   \"__ sve_ptrue(p2, __ H, 0b00110);\",                   \"ptrue\\tp2.h, vl6\"],\n+                        [\"ptrue\",   \"__ sve_ptrue(p2, __ H, 0b01010);\",                   \"ptrue\\tp2.h, vl32\"],\n@@ -1728,0 +1735,3 @@\n+                        [\"ptrue\",   \"__ sve_ptrue(p3, __ S, 0b00011);\",                   \"ptrue\\tp3.s, vl3\"],\n+                        [\"ptrue\",   \"__ sve_ptrue(p3, __ S, 0b00111);\",                   \"ptrue\\tp3.s, vl7\"],\n+                        [\"ptrue\",   \"__ sve_ptrue(p3, __ S, 0b01011);\",                   \"ptrue\\tp3.s, vl64\"],\n@@ -1729,0 +1739,3 @@\n+                        [\"ptrue\",   \"__ sve_ptrue(p4, __ D, 0b00100);\",                   \"ptrue\\tp4.d, vl4\"],\n+                        [\"ptrue\",   \"__ sve_ptrue(p4, __ D, 0b01000);\",                   \"ptrue\\tp4.d, vl8\"],\n+                        [\"ptrue\",   \"__ sve_ptrue(p4, __ D, 0b01100);\",                   \"ptrue\\tp4.d, vl128\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -716,4 +716,4 @@\n-    __ mov(v1, __ T1D, 0, zr);                         \/\/       mov     v1.d[0], xzr\n-    __ mov(v1, __ T2S, 1, zr);                         \/\/       mov     v1.s[1], wzr\n-    __ mov(v1, __ T4H, 2, zr);                         \/\/       mov     v1.h[2], wzr\n-    __ mov(v1, __ T8B, 3, zr);                         \/\/       mov     v1.b[3], wzr\n+    __ mov(v1, __ D, 0, zr);                           \/\/       mov     v1.d[0], xzr\n+    __ mov(v1, __ S, 1, zr);                           \/\/       mov     v1.s[1], wzr\n+    __ mov(v1, __ H, 2, zr);                           \/\/       mov     v1.h[2], wzr\n+    __ mov(v1, __ B, 3, zr);                           \/\/       mov     v1.b[3], wzr\n@@ -867,0 +867,4 @@\n+    __ sve_ptrue(p1, __ B, 0b00001);                   \/\/       ptrue   p1.b, vl1\n+    __ sve_ptrue(p1, __ B, 0b00101);                   \/\/       ptrue   p1.b, vl5\n+    __ sve_ptrue(p1, __ B, 0b01001);                   \/\/       ptrue   p1.b, vl16\n+    __ sve_ptrue(p1, __ B, 0b01101);                   \/\/       ptrue   p1.b, vl256\n@@ -868,0 +872,3 @@\n+    __ sve_ptrue(p2, __ H, 0b00010);                   \/\/       ptrue   p2.h, vl2\n+    __ sve_ptrue(p2, __ H, 0b00110);                   \/\/       ptrue   p2.h, vl6\n+    __ sve_ptrue(p2, __ H, 0b01010);                   \/\/       ptrue   p2.h, vl32\n@@ -869,0 +876,3 @@\n+    __ sve_ptrue(p3, __ S, 0b00011);                   \/\/       ptrue   p3.s, vl3\n+    __ sve_ptrue(p3, __ S, 0b00111);                   \/\/       ptrue   p3.s, vl7\n+    __ sve_ptrue(p3, __ S, 0b01011);                   \/\/       ptrue   p3.s, vl64\n@@ -870,0 +880,3 @@\n+    __ sve_ptrue(p4, __ D, 0b00100);                   \/\/       ptrue   p4.d, vl4\n+    __ sve_ptrue(p4, __ D, 0b01000);                   \/\/       ptrue   p4.d, vl8\n+    __ sve_ptrue(p4, __ D, 0b01100);                   \/\/       ptrue   p4.d, vl128\n@@ -1135,7 +1148,7 @@\n-    0x14000000,     0x17ffffd7,     0x1400039a,     0x94000000,\n-    0x97ffffd4,     0x94000397,     0x3400000a,     0x34fffa2a,\n-    0x3400728a,     0x35000008,     0x35fff9c8,     0x35007228,\n-    0xb400000b,     0xb4fff96b,     0xb40071cb,     0xb500001d,\n-    0xb5fff91d,     0xb500717d,     0x10000013,     0x10fff8b3,\n-    0x10007113,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36307096,     0x3758000c,     0x375ff7cc,     0x3758702c,\n+    0x14000000,     0x17ffffd7,     0x140003a7,     0x94000000,\n+    0x97ffffd4,     0x940003a4,     0x3400000a,     0x34fffa2a,\n+    0x3400742a,     0x35000008,     0x35fff9c8,     0x350073c8,\n+    0xb400000b,     0xb4fff96b,     0xb400736b,     0xb500001d,\n+    0xb5fff91d,     0xb500731d,     0x10000013,     0x10fff8b3,\n+    0x100072b3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307236,     0x3758000c,     0x375ff7cc,     0x375871cc,\n@@ -1146,13 +1159,13 @@\n-    0x54006e00,     0x54000001,     0x54fff541,     0x54006da1,\n-    0x54000002,     0x54fff4e2,     0x54006d42,     0x54000002,\n-    0x54fff482,     0x54006ce2,     0x54000003,     0x54fff423,\n-    0x54006c83,     0x54000003,     0x54fff3c3,     0x54006c23,\n-    0x54000004,     0x54fff364,     0x54006bc4,     0x54000005,\n-    0x54fff305,     0x54006b65,     0x54000006,     0x54fff2a6,\n-    0x54006b06,     0x54000007,     0x54fff247,     0x54006aa7,\n-    0x54000008,     0x54fff1e8,     0x54006a48,     0x54000009,\n-    0x54fff189,     0x540069e9,     0x5400000a,     0x54fff12a,\n-    0x5400698a,     0x5400000b,     0x54fff0cb,     0x5400692b,\n-    0x5400000c,     0x54fff06c,     0x540068cc,     0x5400000d,\n-    0x54fff00d,     0x5400686d,     0x5400000e,     0x54ffefae,\n-    0x5400680e,     0x5400000f,     0x54ffef4f,     0x540067af,\n+    0x54006fa0,     0x54000001,     0x54fff541,     0x54006f41,\n+    0x54000002,     0x54fff4e2,     0x54006ee2,     0x54000002,\n+    0x54fff482,     0x54006e82,     0x54000003,     0x54fff423,\n+    0x54006e23,     0x54000003,     0x54fff3c3,     0x54006dc3,\n+    0x54000004,     0x54fff364,     0x54006d64,     0x54000005,\n+    0x54fff305,     0x54006d05,     0x54000006,     0x54fff2a6,\n+    0x54006ca6,     0x54000007,     0x54fff247,     0x54006c47,\n+    0x54000008,     0x54fff1e8,     0x54006be8,     0x54000009,\n+    0x54fff189,     0x54006b89,     0x5400000a,     0x54fff12a,\n+    0x54006b2a,     0x5400000b,     0x54fff0cb,     0x54006acb,\n+    0x5400000c,     0x54fff06c,     0x54006a6c,     0x5400000d,\n+    0x54fff00d,     0x54006a0d,     0x5400000e,     0x54ffefae,\n+    0x540069ae,     0x5400000f,     0x54ffef4f,     0x5400694f,\n@@ -1190,1 +1203,1 @@\n-    0xbd1b1869,     0x580057fb,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x5800599b,     0x1800000b,     0xf8945060,\n@@ -1313,54 +1326,57 @@\n-    0x2558e3e2,     0x2598e3e3,     0x25d8e3e4,     0x2518e407,\n-    0x05214800,     0x05614800,     0x05a14800,     0x05e14800,\n-    0x05214c00,     0x05614c00,     0x05a14c00,     0x05e14c00,\n-    0x05304001,     0x05314001,     0x05a18610,     0x05e18610,\n-    0x1e601000,     0x1e603000,     0x1e621000,     0x1e623000,\n-    0x1e641000,     0x1e643000,     0x1e661000,     0x1e663000,\n-    0x1e681000,     0x1e683000,     0x1e6a1000,     0x1e6a3000,\n-    0x1e6c1000,     0x1e6c3000,     0x1e6e1000,     0x1e6e3000,\n-    0x1e701000,     0x1e703000,     0x1e721000,     0x1e723000,\n-    0x1e741000,     0x1e743000,     0x1e761000,     0x1e763000,\n-    0x1e781000,     0x1e783000,     0x1e7a1000,     0x1e7a3000,\n-    0x1e7c1000,     0x1e7c3000,     0x1e7e1000,     0x1e7e3000,\n-    0xf8208193,     0xf83101b6,     0xf83c13fe,     0xf821239a,\n-    0xf824309e,     0xf826535e,     0xf8304109,     0xf82c7280,\n-    0xf8216058,     0xf8a08309,     0xf8ba03d0,     0xf8a312ea,\n-    0xf8aa21e4,     0xf8a2310b,     0xf8aa522f,     0xf8a2418a,\n-    0xf8ac71af,     0xf8a26287,     0xf8fa8090,     0xf8e20184,\n-    0xf8f01215,     0xf8f022ab,     0xf8f7334c,     0xf8f751dc,\n-    0xf8eb4038,     0xf8ec715f,     0xf8f06047,     0xf863826d,\n-    0xf8710070,     0xf86113cb,     0xf86521e8,     0xf87d301e,\n-    0xf8745287,     0xf87742bc,     0xf87b70b9,     0xf8616217,\n-    0xb83f8185,     0xb82901fc,     0xb83d13f6,     0xb83320bf,\n-    0xb82e33f0,     0xb830529b,     0xb830416c,     0xb82973c6,\n-    0xb831639b,     0xb8be8147,     0xb8b4008a,     0xb8b81231,\n-    0xb8b623a3,     0xb8af3276,     0xb8b35056,     0xb8af4186,\n-    0xb8b071ab,     0xb8b763c1,     0xb8f38225,     0xb8e202d0,\n-    0xb8ed12aa,     0xb8fd219b,     0xb8fb3023,     0xb8ff5278,\n-    0xb8f14389,     0xb8fb70ef,     0xb8f563f7,     0xb87983e2,\n-    0xb87b0150,     0xb8771073,     0xb8702320,     0xb87a3057,\n-    0xb870508c,     0xb87c43be,     0xb87070db,     0xb86961fd,\n-    0xce273c87,     0xce080ac9,     0xce7e8e9b,     0xce808b45,\n-    0xce79806e,     0xce758768,     0xcec0835a,     0xce608ad8,\n-    0x2520d264,     0x2521cf80,     0x058074c1,     0x054242c9,\n-    0x05004476,     0x25a0df08,     0x25a1c206,     0x0583288b,\n-    0x05401c3a,     0x05027e8d,     0x2520ce05,     0x25a1cb0a,\n-    0x0580989a,     0x0540e096,     0x0500fb73,     0x2560c2ce,\n-    0x2521d590,     0x05803e97,     0x05400d31,     0x05003ed0,\n-    0x2520c623,     0x25a1cdd1,     0x058052ac,     0x0540ba33,\n-    0x05003ed7,     0x25a0c6cd,     0x2521cf00,     0x0583c5b1,\n-    0x05407336,     0x05001e62,     0x04e400f4,     0x04a80407,\n-    0x65c402d3,     0x65cb0ac9,     0x659007c5,     0x0456ac36,\n-    0x04c01608,     0x049a048f,     0x041087a8,     0x04dab3bc,\n-    0x04590c49,     0x041380fc,     0x0451963a,     0x04d012a8,\n-    0x0497b6a5,     0x049eb3b6,     0x04980093,     0x04080677,\n-    0x040a1a77,     0x04c109c8,     0x049cbeb1,     0x65c0815e,\n-    0x658d812c,     0x65c69098,     0x65c78b66,     0x65c293cd,\n-    0x04ddb7d6,     0x6582ae69,     0x6580bd34,     0x6581ae6d,\n-    0x658daa78,     0x65819211,     0x65a78160,     0x65ef108e,\n-    0x65f52145,     0x65f34123,     0x65b3786a,     0x04555db7,\n-    0x049e6e3a,     0x043d304e,     0x04a73295,     0x047a3022,\n-    0x04f13209,     0x05e26880,     0x05ab6cce,     0x045a33ae,\n-    0x045822c3,     0x04193b63,     0x04c834f3,     0x044a2cb5,\n-    0x65c726b9,     0x65862071,     0x65982cf3,     0x0441322e,\n-\n+    0x2518e021,     0x2518e0a1,     0x2518e121,     0x2518e1a1,\n+    0x2558e3e2,     0x2558e042,     0x2558e0c2,     0x2558e142,\n+    0x2598e3e3,     0x2598e063,     0x2598e0e3,     0x2598e163,\n+    0x25d8e3e4,     0x25d8e084,     0x25d8e104,     0x25d8e184,\n+    0x2518e407,     0x05214800,     0x05614800,     0x05a14800,\n+    0x05e14800,     0x05214c00,     0x05614c00,     0x05a14c00,\n+    0x05e14c00,     0x05304001,     0x05314001,     0x05a18610,\n+    0x05e18610,     0x1e601000,     0x1e603000,     0x1e621000,\n+    0x1e623000,     0x1e641000,     0x1e643000,     0x1e661000,\n+    0x1e663000,     0x1e681000,     0x1e683000,     0x1e6a1000,\n+    0x1e6a3000,     0x1e6c1000,     0x1e6c3000,     0x1e6e1000,\n+    0x1e6e3000,     0x1e701000,     0x1e703000,     0x1e721000,\n+    0x1e723000,     0x1e741000,     0x1e743000,     0x1e761000,\n+    0x1e763000,     0x1e781000,     0x1e783000,     0x1e7a1000,\n+    0x1e7a3000,     0x1e7c1000,     0x1e7c3000,     0x1e7e1000,\n+    0x1e7e3000,     0xf8208193,     0xf83101b6,     0xf83c13fe,\n+    0xf821239a,     0xf824309e,     0xf826535e,     0xf8304109,\n+    0xf82c7280,     0xf8216058,     0xf8a08309,     0xf8ba03d0,\n+    0xf8a312ea,     0xf8aa21e4,     0xf8a2310b,     0xf8aa522f,\n+    0xf8a2418a,     0xf8ac71af,     0xf8a26287,     0xf8fa8090,\n+    0xf8e20184,     0xf8f01215,     0xf8f022ab,     0xf8f7334c,\n+    0xf8f751dc,     0xf8eb4038,     0xf8ec715f,     0xf8f06047,\n+    0xf863826d,     0xf8710070,     0xf86113cb,     0xf86521e8,\n+    0xf87d301e,     0xf8745287,     0xf87742bc,     0xf87b70b9,\n+    0xf8616217,     0xb83f8185,     0xb82901fc,     0xb83d13f6,\n+    0xb83320bf,     0xb82e33f0,     0xb830529b,     0xb830416c,\n+    0xb82973c6,     0xb831639b,     0xb8be8147,     0xb8b4008a,\n+    0xb8b81231,     0xb8b623a3,     0xb8af3276,     0xb8b35056,\n+    0xb8af4186,     0xb8b071ab,     0xb8b763c1,     0xb8f38225,\n+    0xb8e202d0,     0xb8ed12aa,     0xb8fd219b,     0xb8fb3023,\n+    0xb8ff5278,     0xb8f14389,     0xb8fb70ef,     0xb8f563f7,\n+    0xb87983e2,     0xb87b0150,     0xb8771073,     0xb8702320,\n+    0xb87a3057,     0xb870508c,     0xb87c43be,     0xb87070db,\n+    0xb86961fd,     0xce273c87,     0xce080ac9,     0xce7e8e9b,\n+    0xce808b45,     0xce79806e,     0xce758768,     0xcec0835a,\n+    0xce608ad8,     0x2520d264,     0x2521cf80,     0x058074c1,\n+    0x054242c9,     0x05004476,     0x25a0df08,     0x25a1c206,\n+    0x0583288b,     0x05401c3a,     0x05027e8d,     0x2520ce05,\n+    0x25a1cb0a,     0x0580989a,     0x0540e096,     0x0500fb73,\n+    0x2560c2ce,     0x2521d590,     0x05803e97,     0x05400d31,\n+    0x05003ed0,     0x2520c623,     0x25a1cdd1,     0x058052ac,\n+    0x0540ba33,     0x05003ed7,     0x25a0c6cd,     0x2521cf00,\n+    0x0583c5b1,     0x05407336,     0x05001e62,     0x04e400f4,\n+    0x04a80407,     0x65c402d3,     0x65cb0ac9,     0x659007c5,\n+    0x0456ac36,     0x04c01608,     0x049a048f,     0x041087a8,\n+    0x04dab3bc,     0x04590c49,     0x041380fc,     0x0451963a,\n+    0x04d012a8,     0x0497b6a5,     0x049eb3b6,     0x04980093,\n+    0x04080677,     0x040a1a77,     0x04c109c8,     0x049cbeb1,\n+    0x65c0815e,     0x658d812c,     0x65c69098,     0x65c78b66,\n+    0x65c293cd,     0x04ddb7d6,     0x6582ae69,     0x6580bd34,\n+    0x6581ae6d,     0x658daa78,     0x65819211,     0x65a78160,\n+    0x65ef108e,     0x65f52145,     0x65f34123,     0x65b3786a,\n+    0x04555db7,     0x049e6e3a,     0x043d304e,     0x04a73295,\n+    0x047a3022,     0x04f13209,     0x05e26880,     0x05ab6cce,\n+    0x045a33ae,     0x045822c3,     0x04193b63,     0x04c834f3,\n+    0x044a2cb5,     0x65c726b9,     0x65862071,     0x65982cf3,\n+    0x0441322e,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":95,"deletions":79,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3496,1 +3496,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3498,1 +3498,1 @@\n-                av.withLane(0, (byte)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n@@ -3502,1 +3502,4 @@\n-        assertInsertArraysEquals(r, a, (byte)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5617,1 +5620,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5719,0 +5722,7 @@\n+\n+    @Test\n+    static void MaskAllTrueByte128VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3496,1 +3496,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3498,1 +3498,1 @@\n-                av.withLane(0, (byte)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n@@ -3502,1 +3502,4 @@\n-        assertInsertArraysEquals(r, a, (byte)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5617,1 +5620,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5719,0 +5722,7 @@\n+\n+    @Test\n+    static void MaskAllTrueByte256VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Byte512VectorTests\n+ * @run testng\/othervm\/timeout=240 -ea -esa -Xbatch -XX:-TieredCompilation Byte512VectorTests\n@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3496,1 +3496,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3498,1 +3498,1 @@\n-                av.withLane(0, (byte)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n@@ -3502,1 +3502,4 @@\n-        assertInsertArraysEquals(r, a, (byte)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5617,1 +5620,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5719,0 +5722,7 @@\n+\n+    @Test\n+    static void MaskAllTrueByte512VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3496,1 +3496,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3498,1 +3498,1 @@\n-                av.withLane(0, (byte)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n@@ -3502,1 +3502,4 @@\n-        assertInsertArraysEquals(r, a, (byte)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5617,1 +5620,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5719,0 +5722,7 @@\n+\n+    @Test\n+    static void MaskAllTrueByte64VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation ByteMaxVectorTests\n+ * @run testng\/othervm\/timeout=240 -ea -esa -Xbatch -XX:-TieredCompilation ByteMaxVectorTests\n@@ -234,2 +234,2 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n+        int i = start;\n@@ -237,1 +237,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3501,1 +3501,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3503,1 +3503,1 @@\n-                av.withLane(0, (byte)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n@@ -3507,1 +3507,4 @@\n-        assertInsertArraysEquals(r, a, (byte)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5708,0 +5711,7 @@\n+\n+    @Test\n+    static void MaskAllTrueByteMaxVectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2509,1 +2509,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2511,1 +2511,1 @@\n-                av.withLane(0, (double)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n@@ -2515,1 +2515,4 @@\n-        assertInsertArraysEquals(r, a, (double)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -4996,1 +4999,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5098,0 +5101,7 @@\n+\n+    @Test\n+    static void MaskAllTrueDouble128VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2509,1 +2509,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2511,1 +2511,1 @@\n-                av.withLane(0, (double)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n@@ -2515,1 +2515,4 @@\n-        assertInsertArraysEquals(r, a, (double)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -4996,1 +4999,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5098,0 +5101,7 @@\n+\n+    @Test\n+    static void MaskAllTrueDouble256VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2509,1 +2509,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2511,1 +2511,1 @@\n-                av.withLane(0, (double)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n@@ -2515,1 +2515,4 @@\n-        assertInsertArraysEquals(r, a, (double)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -4996,1 +4999,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5098,0 +5101,7 @@\n+\n+    @Test\n+    static void MaskAllTrueDouble512VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2509,1 +2509,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2511,1 +2511,1 @@\n-                av.withLane(0, (double)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n@@ -2515,1 +2515,4 @@\n-        assertInsertArraysEquals(r, a, (double)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -4996,1 +4999,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5098,0 +5101,7 @@\n+\n+    @Test\n+    static void MaskAllTrueDouble64VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n+        int i = start;\n@@ -237,1 +237,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2514,1 +2514,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2516,1 +2516,1 @@\n-                av.withLane(0, (double)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n@@ -2520,1 +2520,4 @@\n-        assertInsertArraysEquals(r, a, (double)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5087,0 +5090,7 @@\n+\n+    @Test\n+    static void MaskAllTrueDoubleMaxVectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2519,1 +2519,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2521,1 +2521,1 @@\n-                av.withLane(0, (float)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n@@ -2525,1 +2525,4 @@\n-        assertInsertArraysEquals(r, a, (float)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -4974,1 +4977,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5076,0 +5079,7 @@\n+\n+    @Test\n+    static void MaskAllTrueFloat128VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2519,1 +2519,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2521,1 +2521,1 @@\n-                av.withLane(0, (float)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n@@ -2525,1 +2525,4 @@\n-        assertInsertArraysEquals(r, a, (float)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -4974,1 +4977,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5076,0 +5079,7 @@\n+\n+    @Test\n+    static void MaskAllTrueFloat256VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2519,1 +2519,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2521,1 +2521,1 @@\n-                av.withLane(0, (float)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n@@ -2525,1 +2525,4 @@\n-        assertInsertArraysEquals(r, a, (float)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -4974,1 +4977,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5076,0 +5079,7 @@\n+\n+    @Test\n+    static void MaskAllTrueFloat512VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2519,1 +2519,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2521,1 +2521,1 @@\n-                av.withLane(0, (float)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n@@ -2525,1 +2525,4 @@\n-        assertInsertArraysEquals(r, a, (float)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -4974,1 +4977,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5076,0 +5079,7 @@\n+\n+    @Test\n+    static void MaskAllTrueFloat64VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n+        int i = start;\n@@ -237,1 +237,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -2524,1 +2524,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -2526,1 +2526,1 @@\n-                av.withLane(0, (float)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n@@ -2530,1 +2530,4 @@\n-        assertInsertArraysEquals(r, a, (float)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5065,0 +5068,7 @@\n+\n+    @Test\n+    static void MaskAllTrueFloatMaxVectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3461,1 +3461,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3463,1 +3463,1 @@\n-                av.withLane(0, (int)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n@@ -3467,1 +3467,4 @@\n-        assertInsertArraysEquals(r, a, (int)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5571,1 +5574,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5673,0 +5676,7 @@\n+\n+    @Test\n+    static void MaskAllTrueInt128VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3461,1 +3461,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3463,1 +3463,1 @@\n-                av.withLane(0, (int)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n@@ -3467,1 +3467,4 @@\n-        assertInsertArraysEquals(r, a, (int)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5571,1 +5574,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5673,0 +5676,7 @@\n+\n+    @Test\n+    static void MaskAllTrueInt256VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3461,1 +3461,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3463,1 +3463,1 @@\n-                av.withLane(0, (int)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n@@ -3467,1 +3467,4 @@\n-        assertInsertArraysEquals(r, a, (int)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5571,1 +5574,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5673,0 +5676,7 @@\n+\n+    @Test\n+    static void MaskAllTrueInt512VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3461,1 +3461,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3463,1 +3463,1 @@\n-                av.withLane(0, (int)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n@@ -3467,1 +3467,4 @@\n-        assertInsertArraysEquals(r, a, (int)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5571,1 +5574,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5673,0 +5676,7 @@\n+\n+    @Test\n+    static void MaskAllTrueInt64VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n+        int i = start;\n@@ -237,1 +237,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3466,1 +3466,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3468,1 +3468,1 @@\n-                av.withLane(0, (int)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n@@ -3472,1 +3472,4 @@\n-        assertInsertArraysEquals(r, a, (int)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5662,0 +5665,7 @@\n+\n+    @Test\n+    static void MaskAllTrueIntMaxVectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n+        int i = start;\n@@ -189,1 +189,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3483,1 +3483,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3485,1 +3485,1 @@\n-                av.withLane(0, (long)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n@@ -3489,1 +3489,4 @@\n-        assertInsertArraysEquals(r, a, (long)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5455,1 +5458,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5557,0 +5560,7 @@\n+\n+    @Test\n+    static void MaskAllTrueLong128VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n+        int i = start;\n@@ -189,1 +189,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3483,1 +3483,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3485,1 +3485,1 @@\n-                av.withLane(0, (long)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n@@ -3489,1 +3489,4 @@\n-        assertInsertArraysEquals(r, a, (long)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5455,1 +5458,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5557,0 +5560,7 @@\n+\n+    @Test\n+    static void MaskAllTrueLong256VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n+        int i = start;\n@@ -189,1 +189,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3483,1 +3483,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3485,1 +3485,1 @@\n-                av.withLane(0, (long)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n@@ -3489,1 +3489,4 @@\n-        assertInsertArraysEquals(r, a, (long)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5455,1 +5458,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5557,0 +5560,7 @@\n+\n+    @Test\n+    static void MaskAllTrueLong512VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n+        int i = start;\n@@ -189,1 +189,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3483,1 +3483,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3485,1 +3485,1 @@\n-                av.withLane(0, (long)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n@@ -3489,1 +3489,4 @@\n-        assertInsertArraysEquals(r, a, (long)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5455,1 +5458,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5557,0 +5560,7 @@\n+\n+    @Test\n+    static void MaskAllTrueLong64VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -191,2 +191,2 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n+        int i = start;\n@@ -194,1 +194,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3488,1 +3488,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3490,1 +3490,1 @@\n-                av.withLane(0, (long)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n@@ -3494,1 +3494,4 @@\n-        assertInsertArraysEquals(r, a, (long)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5546,0 +5549,7 @@\n+\n+    @Test\n+    static void MaskAllTrueLongMaxVectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3486,1 +3486,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3488,1 +3488,1 @@\n-                av.withLane(0, (short)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n@@ -3492,1 +3492,4 @@\n-        assertInsertArraysEquals(r, a, (short)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5596,1 +5599,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5698,0 +5701,7 @@\n+\n+    @Test\n+    static void MaskAllTrueShort128VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3486,1 +3486,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3488,1 +3488,1 @@\n-                av.withLane(0, (short)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n@@ -3492,1 +3492,4 @@\n-        assertInsertArraysEquals(r, a, (short)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5596,1 +5599,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5698,0 +5701,7 @@\n+\n+    @Test\n+    static void MaskAllTrueShort256VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3486,1 +3486,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3488,1 +3488,1 @@\n-                av.withLane(0, (short)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n@@ -3492,1 +3492,4 @@\n-        assertInsertArraysEquals(r, a, (short)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5596,1 +5599,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5698,0 +5701,7 @@\n+\n+    @Test\n+    static void MaskAllTrueShort512VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -229,2 +229,2 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n@@ -232,1 +232,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3486,1 +3486,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3488,1 +3488,1 @@\n-                av.withLane(0, (short)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n@@ -3492,1 +3492,4 @@\n-        assertInsertArraysEquals(r, a, (short)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5596,1 +5599,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -5698,0 +5701,7 @@\n+\n+    @Test\n+    static void MaskAllTrueShort64VectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -234,2 +234,2 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n+        int i = start;\n@@ -237,1 +237,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n@@ -3491,1 +3491,1 @@\n-            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n@@ -3493,1 +3493,1 @@\n-                av.withLane(0, (short)4).intoArray(r, i);\n+                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n@@ -3497,1 +3497,4 @@\n-        assertInsertArraysEquals(r, a, (short)4, 0);\n+\n+        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n+        }\n@@ -5687,0 +5690,7 @@\n+\n+    @Test\n+    static void MaskAllTrueShortMaxVectorTestsSmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+TEST_ITER_COUNT=100\n","filename":"test\/jdk\/jdk\/incubator\/vector\/config.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,7 +31,0 @@\n-list_mech_gen() {\n-    ( # List MG files physically present\n-      grep -il 'mechanically generated.*do not edit' $(find * -name \\*.java -print)\n-      # List MG files currently deleted (via --clean)\n-      hg status -nd .\n-    ) | egrep '(^|\/)(Byte|Short|Int|Long|Float|Double)(Scalar|([0-9Max]+Vector)).*\\.java$'\n-}\n@@ -41,4 +34,1 @@\n---clean)        MG=$(list_mech_gen); set -x; rm -f $MG; exit;;\n---revert)       MG=$(list_mech_gen); set -x; hg revert $MG; exit;;\n---list)         list_mech_gen; exit;;\n---help|*)       echo \"Usage: $0 [--generate [file] | --clean | --revert | --list]\"; exit 1;;\n+--help|*)       echo \"Usage: $0 [--generate [file]]\"; exit 1;;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -519,1 +519,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n@@ -622,0 +622,7 @@\n+\n+    @Test\n+    static void MaskAllTrue$vectorteststype$SmokeTest() {\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+          Assert.assertEquals(SPECIES.maskAll(true).toLong(), -1L >>> (64 - SPECIES.length()));\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -260,2 +260,2 @@\n-    static void assertInsertArraysEquals($type$[] r, $type$[] a, $type$ element, int index) {\n-        int i = 0;\n+    static void assertInsertArraysEquals($type$[] r, $type$[] a, $type$ element, int index, int start, int end) {\n+        int i = start;\n@@ -263,1 +263,1 @@\n-            for (; i < a.length; i += 1) {\n+            for (; i < end; i += 1) {\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}