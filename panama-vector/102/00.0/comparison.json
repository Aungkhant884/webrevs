{"files":[{"patch":"@@ -1298,1 +1298,25 @@\n- bool is_CAS(int opcode, bool maybe_volatile);\n+  static inline BasicType vector_element_basic_type(const MachNode* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  static inline BasicType vector_element_basic_type(const MachNode* use, const MachOper* opnd) {\n+    int def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->element_basic_type();\n+  }\n+\n+  static inline uint vector_length(const MachNode* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->length();\n+  }\n+\n+  static inline uint vector_length(const MachNode* use, const MachOper* opnd) {\n+    int def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->length();\n+  }\n+\n+  bool is_CAS(int opcode, bool maybe_volatile);\n@@ -2426,0 +2450,8 @@\n+    case Op_VectorMaskCmp:\n+    \/\/ We don't have VectorReinterpret with bit_size less than 64 support for\n+    \/\/ now, even for byte type. To be refined with fully VectorCast support.\n+    case Op_VectorReinterpret:\n+      if (vlen < 2 || bit_size < 64) {\n+        return false;\n+      }\n+      break;\n@@ -2439,0 +2471,17 @@\n+    \/\/ Some types of VectorCast are not implemented for now.\n+    case Op_VectorCastI2X:\n+      if (bt == T_BYTE) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastS2X:\n+      if (vlen < 4 || bit_size < 64) {\n+        return false;\n+      }\n+      break;\n+    case Op_VectorCastF2X:\n+    case Op_VectorCastD2X:\n+      if (bt == T_INT || bt == T_SHORT || bt == T_BYTE || bt == T_LONG) {\n+        return false;\n+      }\n+      break;\n@@ -2471,4 +2520,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -2542,1 +2587,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -2583,0 +2628,33 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  \/\/ JDK-8183543: When taking the number of available registers as int\n+  \/\/ register pressure threshold, the jtreg test:\n+  \/\/ test\/hotspot\/jtreg\/compiler\/regalloc\/TestC2IntPressure.java\n+  \/\/ failed due to C2 compilation failure with\n+  \/\/ \"COMPILE SKIPPED: failed spill-split-recycle sanity check\".\n+  \/\/\n+  \/\/ A derived pointer is live at CallNode and then is flagged by RA\n+  \/\/ as a spilled LRG. Spilling heuristics(Spill-USE) explicitly skip\n+  \/\/ derived pointers and lastly fail to spill after reaching maximum\n+  \/\/ number of iterations. Lowering the default pressure threshold to\n+  \/\/ (_NO_SPECIAL_REG32_mask.Size() minus 1) forces CallNode to become\n+  \/\/ a high register pressure area of the code so that split_DEF can\n+  \/\/ generate DefinitionSpillCopy for the derived pointer.\n+  uint default_int_pressure_threshold = _NO_SPECIAL_REG32_mask.Size() - 1;\n+  if (!PreserveFramePointer) {\n+    \/\/ When PreserveFramePointer is off, frame pointer is allocatable,\n+    \/\/ but different from other SOC registers, it is excluded from\n+    \/\/ fatproj's mask because its save type is No-Save. Decrease 1 to\n+    \/\/ ensure high pressure at fatproj when PreserveFramePointer is off.\n+    \/\/ See check_pressure_at_fatproj().\n+    default_int_pressure_threshold--;\n+  }\n+  return (INTPRESSURE == -1) ? default_int_pressure_threshold : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  \/\/ _FLOAT_REG_mask is generated by adlc from the float_reg register class.\n+  return (FLOATPRESSURE == -1) ? _FLOAT_REG_mask.Size() : FLOATPRESSURE;\n+}\n+\n@@ -3796,4 +3874,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_enter(box, oop, disp_hdr, tmp, true, cont);\n-    }\n-\n@@ -3870,4 +3944,0 @@\n-    if (UseBiasedLocking && !UseOptoBiasInlining) {\n-      __ biased_locking_exit(oop, tmp, cont);\n-    }\n-\n@@ -5496,0 +5566,9 @@\n+operand pReg()\n+%{\n+  constraint(ALLOC_IN_RC(pr_reg));\n+  match(RegVectMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -8905,5 +8984,0 @@\n-\n-\/\/ storeLConditional is used by PhaseMacroExpand::expand_lock_node\n-\/\/ when attempting to rebias a lock towards the current thread.  We\n-\/\/ must use the acquire form of cmpxchg in order to guarantee acquire\n-\/\/ semantics in this case.\n@@ -16666,2 +16740,2 @@\n-                              iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n-                              iRegINoSp tmp3, rFlagsReg cr)\n+                             iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n+                             iRegINoSp tmp3, rFlagsReg cr)\n@@ -16670,1 +16744,1 @@\n-  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U);\n+  predicate((UseSVE == 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n@@ -16689,1 +16763,1 @@\n-  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L);\n+  predicate((UseSVE == 0) && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n@@ -16697,2 +16771,2 @@\n-                           $result$$Register, $tmp1$$Register, $tmp2$$Register,\n-                           $tmp3$$Register);\n+                            $result$$Register, $tmp1$$Register, $tmp2$$Register,\n+                            $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":99,"deletions":25,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -250,3 +250,3 @@\n-    unsigned mask = checked_cast<unsigned>(right_n_bits(nbits));\n-    mask <<= lsb;\n-    assert_cond((bits & mask) == 0);\n+    unsigned mask = checked_cast<unsigned>(right_n_bits(nbits));\n+    mask <<= lsb;\n+    assert_cond((bits & mask) == 0);\n@@ -316,1 +316,1 @@\n-#define starti Instruction_aarch64 do_not_use(this); set_current(&do_not_use)\n+#define starti Instruction_aarch64 current_insn(this);\n@@ -697,40 +697,8 @@\n-  Instruction_aarch64* current;\n-\n-  void set_current(Instruction_aarch64* i) { current = i; }\n-\n-  void f(unsigned val, int msb, int lsb) {\n-    current->f(val, msb, lsb);\n-  }\n-  void f(unsigned val, int msb) {\n-    current->f(val, msb, msb);\n-  }\n-  void sf(int64_t val, int msb, int lsb) {\n-    current->sf(val, msb, lsb);\n-  }\n-  void rf(Register reg, int lsb) {\n-    current->rf(reg, lsb);\n-  }\n-  void srf(Register reg, int lsb) {\n-    current->srf(reg, lsb);\n-  }\n-  void zrf(Register reg, int lsb) {\n-    current->zrf(reg, lsb);\n-  }\n-  void rf(FloatRegister reg, int lsb) {\n-    current->rf(reg, lsb);\n-  }\n-  void prf(PRegister reg, int lsb) {\n-    current->prf(reg, lsb);\n-  }\n-  void pgrf(PRegister reg, int lsb) {\n-    current->pgrf(reg, lsb);\n-  }\n-  void fixed(unsigned value, unsigned mask) {\n-    current->fixed(value, mask);\n-  }\n-\n-  void emit() {\n-    emit_long(current->get_insn());\n-    assert_cond(current->get_bits() == 0xffffffff);\n-    current = NULL;\n-  }\n+#define f current_insn.f\n+#define sf current_insn.sf\n+#define rf current_insn.rf\n+#define srf current_insn.srf\n+#define zrf current_insn.zrf\n+#define prf current_insn.prf\n+#define pgrf current_insn.pgrf\n+#define fixed current_insn.fixed\n@@ -767,2 +735,2 @@\n-  void add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int op,\n-                         int negated_op);\n+  void add_sub_immediate(Instruction_aarch64 &current_insn, Register Rd, Register Rn,\n+                         unsigned uimm, int op, int negated_op);\n@@ -780,1 +748,1 @@\n-    add_sub_immediate(Rd, Rn, imm, decode, negated);                    \\\n+    add_sub_immediate(current_insn, Rd, Rn, imm, decode, negated);      \\\n@@ -793,1 +761,1 @@\n-    add_sub_immediate(Rd, Rn, imm, decode, negated);    \\\n+    add_sub_immediate(current_insn, Rd, Rn, imm, decode, negated);     \\\n@@ -1095,1 +1063,1 @@\n-           Register rt = (Register)0b11111) {\n+           Register rt = as_Register(0b11111)) {\n@@ -1364,1 +1332,1 @@\n-    rf((Register)Rt, 0);                                                \\\n+    rf(as_Register(Rt), 0);                                             \\\n@@ -1378,1 +1346,1 @@\n-    rf(Rn, 5), rf((Register)Rt, 0);                                     \\\n+    rf(Rn, 5), rf(as_Register(Rt), 0);                                  \\\n@@ -1411,1 +1379,1 @@\n-      adr.encode_nontemporal_pair(current);\n+      adr.encode_nontemporal_pair(&current_insn);\n@@ -1413,1 +1381,1 @@\n-      adr.encode_pair(current);\n+      adr.encode_pair(&current_insn);\n@@ -1439,1 +1407,2 @@\n-    ld_st1(size, p1, V, L, (Register)Rt1, (Register)Rt2, adr, no_allocate); \\\n+    ld_st1(size, p1, V, L,                                              \\\n+           as_Register(Rt1), as_Register(Rt2), adr, no_allocate);       \\\n@@ -1474,1 +1443,1 @@\n-    adr.encode(current);\n+    adr.encode(&current_insn);\n@@ -1502,1 +1471,1 @@\n-    ld_st2((Register)pfop, adr, size, op);                      \\\n+    ld_st2(as_Register(pfop), adr, size, op);                   \\\n@@ -1513,1 +1482,1 @@\n-    ld_st2((Register)Rt, adr, size, op, 1);             \\\n+    ld_st2(as_Register(Rt), adr, size, op, 1);          \\\n@@ -1542,2 +1511,0 @@\n-  static SIMD_Arrangement esize2arrangement(int esize, bool isQ);\n-\n@@ -1548,0 +1515,4 @@\n+  static SIMD_Arrangement esize2arrangement(int esize, bool isQ);\n+  static SIMD_RegVariant elemType_to_regVariant(BasicType bt);\n+  static SIMD_RegVariant elemBytes_to_regVariant(int esize);\n+\n@@ -1550,1 +1521,1 @@\n-  void op_shifted_reg(unsigned decode,\n+  void op_shifted_reg(Instruction_aarch64 &current_insn, unsigned decode,\n@@ -1561,8 +1532,8 @@\n-#define INSN(NAME, size, op, N)                                 \\\n-  void NAME(Register Rd, Register Rn, Register Rm,              \\\n-            enum shift_kind kind = LSL, unsigned shift = 0) {   \\\n-    starti;                                                     \\\n-    guarantee(size == 1 || shift < 32, \"incorrect shift\");      \\\n-    f(N, 21);                                                   \\\n-    zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                        \\\n-    op_shifted_reg(0b01010, kind, shift, size, op);             \\\n+#define INSN(NAME, size, op, N)                                         \\\n+  void NAME(Register Rd, Register Rn, Register Rm,                      \\\n+            enum shift_kind kind = LSL, unsigned shift = 0) {           \\\n+    starti;                                                             \\\n+    guarantee(size == 1 || shift < 32, \"incorrect shift\");              \\\n+    f(N, 21);                                                           \\\n+    zrf(Rm, 16), zrf(Rn, 5), zrf(Rd, 0);                                \\\n+    op_shifted_reg(current_insn, 0b01010, kind, shift, size, op);       \\\n@@ -1588,1 +1559,1 @@\n-    op_shifted_reg(0b01010, kind, shift, size, op);                     \\\n+    op_shifted_reg(current_insn, 0b01010, kind, shift, size, op);       \\\n@@ -1635,1 +1606,1 @@\n-    op_shifted_reg(0b01011, kind, shift, size, op);     \\\n+    op_shifted_reg(current_insn, 0b01011, kind, shift, size, op);      \\\n@@ -1656,1 +1627,1 @@\n-    add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n+    add_sub_extended_reg(current_insn, op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n@@ -1659,1 +1630,1 @@\n-  void add_sub_extended_reg(unsigned op, unsigned decode,\n+  void add_sub_extended_reg(Instruction_aarch64 &current_insn, unsigned op, unsigned decode,\n@@ -1679,1 +1650,1 @@\n-    add_sub_extended_reg(op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n+    add_sub_extended_reg(current_insn, op, 0b01011, Rd, Rn, Rm, 0b00, option, amount); \\\n@@ -1780,1 +1751,1 @@\n-  void NAME(Register Rd, Register Rn, Register Rm, Condition cond) { \\\n+  void NAME(Register Rd, Register Rn, Register Rm, Condition cond) {    \\\n@@ -1796,1 +1767,1 @@\n-  void data_processing(unsigned op29, unsigned opcode,\n+  void data_processing(Instruction_aarch64 &current_insn, unsigned op29, unsigned opcode,\n@@ -1804,5 +1775,5 @@\n-#define INSN(NAME, op29, opcode2, opcode)       \\\n-  void NAME(Register Rd, Register Rn) {         \\\n-    starti;                                     \\\n-    f(opcode2, 20, 16);                         \\\n-    data_processing(op29, opcode, Rd, Rn);      \\\n+#define INSN(NAME, op29, opcode2, opcode)                       \\\n+  void NAME(Register Rd, Register Rn) {                         \\\n+    starti;                                                     \\\n+    f(opcode2, 20, 16);                                         \\\n+    data_processing(current_insn, op29, opcode, Rd, Rn);        \\\n@@ -1827,5 +1798,5 @@\n-#define INSN(NAME, op29, opcode)                        \\\n-  void NAME(Register Rd, Register Rn, Register Rm) {    \\\n-    starti;                                             \\\n-    rf(Rm, 16);                                         \\\n-    data_processing(op29, opcode, Rd, Rn);              \\\n+#define INSN(NAME, op29, opcode)                                \\\n+  void NAME(Register Rd, Register Rn, Register Rm) {            \\\n+    starti;                                                     \\\n+    rf(Rm, 16);                                                 \\\n+    data_processing(current_insn, op29, opcode, Rd, Rn);        \\\n@@ -1876,3 +1847,3 @@\n-#define INSN(NAME, op54, op31, o0)                      \\\n-  void NAME(Register Rd, Register Rn, Register Rm) {    \\\n-    data_processing(op54, op31, o0, Rd, Rn, Rm, (Register)31);  \\\n+#define INSN(NAME, op54, op31, o0)                                      \\\n+  void NAME(Register Rd, Register Rn, Register Rm) {                    \\\n+    data_processing(op54, op31, o0, Rd, Rn, Rm, as_Register(31));       \\\n@@ -2057,1 +2028,1 @@\n-    float_int_convert(op31, type, rmode, opcode, Rd, (Register)Vn);     \\\n+    float_int_convert(op31, type, rmode, opcode, Rd, as_Register(Vn));  \\\n@@ -2068,1 +2039,1 @@\n-  \/\/ INSN(fmovhid, 0b100, 0b10, 0b01, 0b110);\n+  INSN(fmovhid, 0b100, 0b10, 0b01, 0b110);\n@@ -2074,1 +2045,1 @@\n-    float_int_convert(op31, type, rmode, opcode, (Register)Vd, Rn);     \\\n+    float_int_convert(op31, type, rmode, opcode, as_Register(Vd), Rn);  \\\n@@ -2129,1 +2100,1 @@\n-                     FloatRegister Vn, FloatRegister Vm = (FloatRegister)0) {\n+                     FloatRegister Vn, FloatRegister Vm = as_FloatRegister(0)) {\n@@ -2259,4 +2230,4 @@\n-#define INSN(NAME, op)                                            \\\n-  void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &adr) {   \\\n-    ld_st2((Register)Rt, adr, (int)T & 3, op + ((T==Q) ? 0b10:0b00), 1); \\\n-  }                                                                      \\\n+#define INSN(NAME, op)                                                  \\\n+  void NAME(FloatRegister Rt, SIMD_RegVariant T, const Address &adr) {  \\\n+    ld_st2(as_Register(Rt), adr, (int)T & 3, op + ((T==Q) ? 0b10:0b00), 1); \\\n+  }\n@@ -3223,8 +3194,0 @@\n-  \/\/ SVE predicate count\n-  void sve_cntp(Register Xd, SIMD_RegVariant T, PRegister Pg, PRegister Pn) {\n-    starti;\n-    assert(T != Q, \"invalid size\");\n-    f(0b00100101, 31, 24), f(T, 23, 22), f(0b10000010, 21, 14);\n-    prf(Pg, 10), f(0, 9), prf(Pn, 5), rf(Xd, 0);\n-  }\n-\n@@ -3327,2 +3290,2 @@\n-    f(op, 31, 24), f(T, 23, 22), f(0b0, 21), rf(Zm, 16), f((cond >> 1) & 0x7, 15, 13);            \\\n-    pgrf(Pg, 10), rf(Zn, 5), f(cond & 0x1, 4), prf(Pd, 0);                                        \\\n+    f(op, 31, 24), f(T, 23, 22), f(0, 21), rf(Zm, 16), f((cond >> 1) & 7, 15, 13);                \\\n+    pgrf(Pg, 10), rf(Zn, 5), f(cond & 1, 4), prf(Pd, 0);                                          \\\n@@ -3331,8 +3294,8 @@\n-  INSN(sve_cmpeq, 0b00100100, 0b1010, 0);\n-  INSN(sve_cmpne, 0b00100100, 0b1011, 0);\n-  INSN(sve_cmpge, 0b00100100, 0b1000, 0);\n-  INSN(sve_cmpgt, 0b00100100, 0b1001, 0);\n-  INSN(sve_fcmeq, 0b01100101, 0b0110, 1);\n-  INSN(sve_fcmne, 0b01100101, 0b0111, 1);\n-  INSN(sve_fcmgt, 0b01100101, 0b0101, 1);\n-  INSN(sve_fcmge, 0b01100101, 0b0100, 1);\n+  INSN(sve_cmpeq, 0b00100100, 0b1010, 0);  \/\/ Compare signed equal to vector\n+  INSN(sve_cmpne, 0b00100100, 0b1011, 0);  \/\/ Compare not equal to vector\n+  INSN(sve_cmpge, 0b00100100, 0b1000, 0);  \/\/ Compare signed greater than or equal to vector\n+  INSN(sve_cmpgt, 0b00100100, 0b1001, 0);  \/\/ Compare signed greater than vector\n+  INSN(sve_fcmeq, 0b01100101, 0b0110, 1);  \/\/ Floating-point compare vectors: Equal\n+  INSN(sve_fcmne, 0b01100101, 0b0111, 1);  \/\/ Floating-point compare vectors: Not Equal\n+  INSN(sve_fcmgt, 0b01100101, 0b0101, 1);  \/\/ Floating-point compare vectors: Greater than\n+  INSN(sve_fcmge, 0b01100101, 0b0100, 1);  \/\/ Floating-point compare vectors: Greater than or equal\n@@ -3387,2 +3350,2 @@\n-\/\/ SVE while[cond]\n-#define INSN(NAME, decode, sf)                                            \\\n+\/\/ Predicate counted loop (SVE) (32-bit variants are not included)\n+#define INSN(NAME, decode)                                                \\\n@@ -3393,2 +3356,36 @@\n-    zrf(Rm, 16), f(0, 15, 13), f(sf, 12), f(decode >> 1, 11, 10),         \\\n-    zrf(Rn, 5), f(decode & 0b1, 4), prf(Pd, 0);                           \\\n+    zrf(Rm, 16), f(0, 15, 13), f(1, 12), f(decode >> 1, 11, 10),          \\\n+    zrf(Rn, 5), f(decode & 1, 4), prf(Pd, 0);                             \\\n+  }\n+\n+  INSN(sve_whilelt, 0b010);  \/\/ While incrementing signed scalar less than scalar\n+  INSN(sve_whilele, 0b011);  \/\/ While incrementing signed scalar less than or equal to scalar\n+  INSN(sve_whilelo, 0b110);  \/\/ While incrementing unsigned scalar lower than scalar\n+  INSN(sve_whilels, 0b111);  \/\/ While incrementing unsigned scalar lower than or the same as scalar\n+#undef INSN\n+\n+  \/\/ SVE predicate reverse\n+  void sve_rev(PRegister Pd, SIMD_RegVariant T, PRegister Pn) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1101000100000, 21, 9);\n+    prf(Pn, 5), f(0, 4), prf(Pd, 0);\n+  }\n+\n+\/\/ SVE predicate break after\/before first true condition\n+#define INSN(NAME, op) \\\n+  void NAME(PRegister Pd, PRegister Pg, PRegister Pn, bool isMerge) {      \\\n+    starti;                                                                \\\n+    f(0b00100101, 31, 24), f(op, 23, 22), f(0b01000001, 21, 14);           \\\n+    prf(Pg, 10), f(0b0, 9), prf(Pn, 5), f(isMerge ? 1 : 0, 4), prf(Pd, 0); \\\n+  }\n+\n+  INSN(sve_brka, 0b00);\n+  INSN(sve_brkb, 0b10);\n+#undef INSN\n+\n+\/\/ Element count and increment scalar (SVE)\n+#define INSN(NAME, TYPE)                                                             \\\n+  void NAME(Register Xdn, unsigned imm4 = 1, int pattern = 0b11111) {                \\\n+    starti;                                                                          \\\n+    f(0b00000100, 31, 24), f(TYPE, 23, 22), f(0b10, 21, 20);                         \\\n+    f(imm4 - 1, 19, 16), f(0b11100, 15, 11), f(0, 10), f(pattern, 9, 5), rf(Xdn, 0); \\\n@@ -3397,8 +3394,4 @@\n-  INSN(sve_whilelt,  0b010, 1);\n-  INSN(sve_whileltw, 0b010, 0);\n-  INSN(sve_whilele,  0b011, 1);\n-  INSN(sve_whilelew, 0b011, 0);\n-  INSN(sve_whilelo,  0b110, 1);\n-  INSN(sve_whilelow, 0b110, 0);\n-  INSN(sve_whilels,  0b111, 1);\n-  INSN(sve_whilelsw, 0b111, 0);\n+  INSN(sve_cntb, B);  \/\/ Set scalar to multiple of 8-bit predicate constraint element count\n+  INSN(sve_cnth, H);  \/\/ Set scalar to multiple of 16-bit predicate constraint element count\n+  INSN(sve_cntw, S);  \/\/ Set scalar to multiple of 32-bit predicate constraint element count\n+  INSN(sve_cntd, D);  \/\/ Set scalar to multiple of 64-bit predicate constraint element count\n@@ -3407,0 +3400,16 @@\n+  \/\/ Set scalar to active predicate element count\n+  void sve_cntp(Register Xd, SIMD_RegVariant T, PRegister Pg, PRegister Pn) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b10000010, 21, 14);\n+    prf(Pg, 10), f(0, 9), prf(Pn, 5), rf(Xd, 0);\n+  }\n+\n+  \/\/ Increment scalar by active predicate element count\n+  void sve_incp(const Register rd, SIMD_RegVariant T, PRegister pg) {\n+    starti;\n+    assert(T != Q, \"invalid size\");\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b1011001000100, 21, 9),\n+    prf(pg, 5), rf(rd, 0);\n+  }\n+\n@@ -3475,1 +3484,1 @@\n-\/\/ SVE conditionally extract element to general-purpose register\n+\/\/ SVE extract element to general-purpose register\n@@ -3488,0 +3497,1 @@\n+\/\/ SVE extract element to SIMD&FP scalar register\n@@ -3536,1 +3546,2 @@\n-  assem->emit();\n+  assem->emit_int32(insn);\n+  assert_cond(get_bits() == 0xffffffff);\n@@ -3539,0 +3550,9 @@\n+#undef f\n+#undef sf\n+#undef rf\n+#undef srf\n+#undef zrf\n+#undef prf\n+#undef pgrf\n+#undef fixed\n+\n@@ -3546,2 +3566,0 @@\n-class BiasedLockingCounters;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":148,"deletions":130,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -445,172 +444,0 @@\n-void MacroAssembler::biased_locking_enter(Register lock_reg,\n-                                          Register obj_reg,\n-                                          Register swap_reg,\n-                                          Register tmp_reg,\n-                                          bool swap_reg_contains_mark,\n-                                          Label& done,\n-                                          Label* slow_case,\n-                                          BiasedLockingCounters* counters) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-  assert_different_registers(lock_reg, obj_reg, swap_reg);\n-\n-  if (PrintBiasedLockingStatistics && counters == NULL)\n-    counters = BiasedLocking::counters();\n-\n-  assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg, rscratch1, rscratch2, noreg);\n-  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());\n-  Address klass_addr     (obj_reg, oopDesc::klass_offset_in_bytes());\n-  Address saved_mark_addr(lock_reg, 0);\n-\n-  \/\/ Biased locking\n-  \/\/ See whether the lock is currently biased toward our thread and\n-  \/\/ whether the epoch is still valid\n-  \/\/ Note that the runtime guarantees sufficient alignment of JavaThread\n-  \/\/ pointers to allow age to be placed into low bits\n-  \/\/ First check to see whether biasing is even enabled for this object\n-  Label cas_label;\n-  if (!swap_reg_contains_mark) {\n-    ldr(swap_reg, mark_addr);\n-  }\n-  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n-  cmp(tmp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::NE, cas_label);\n-  \/\/ The bias pattern is present in the object's header. Need to check\n-  \/\/ whether the bias owner and the epoch are both still current.\n-  load_prototype_header(tmp_reg, obj_reg);\n-  orr(tmp_reg, tmp_reg, rthread);\n-  eor(tmp_reg, swap_reg, tmp_reg);\n-  andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));\n-  if (counters != NULL) {\n-    Label around;\n-    cbnz(tmp_reg, around);\n-    atomic_incw(Address((address)counters->biased_lock_entry_count_addr()), tmp_reg, rscratch1, rscratch2);\n-    b(done);\n-    bind(around);\n-  } else {\n-    cbz(tmp_reg, done);\n-  }\n-\n-  Label try_revoke_bias;\n-  Label try_rebias;\n-\n-  \/\/ At this point we know that the header has the bias pattern and\n-  \/\/ that we are not the bias owner in the current epoch. We need to\n-  \/\/ figure out more details about the state of the header in order to\n-  \/\/ know what operations can be legally performed on the object's\n-  \/\/ header.\n-\n-  \/\/ If the low three bits in the xor result aren't clear, that means\n-  \/\/ the prototype header is no longer biased and we have to revoke\n-  \/\/ the bias on this object.\n-  andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);\n-  cbnz(rscratch1, try_revoke_bias);\n-\n-  \/\/ Biasing is still enabled for this data type. See whether the\n-  \/\/ epoch of the current bias is still valid, meaning that the epoch\n-  \/\/ bits of the mark word are equal to the epoch bits of the\n-  \/\/ prototype header. (Note that the prototype header's epoch bits\n-  \/\/ only change at a safepoint.) If not, attempt to rebias the object\n-  \/\/ toward the current thread. Note that we must be absolutely sure\n-  \/\/ that the current epoch is invalid in order to do this because\n-  \/\/ otherwise the manipulations it performs on the mark word are\n-  \/\/ illegal.\n-  andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);\n-  cbnz(rscratch1, try_rebias);\n-\n-  \/\/ The epoch of the current bias is still valid but we know nothing\n-  \/\/ about the owner; it might be set or it might be clear. Try to\n-  \/\/ acquire the bias of the object using an atomic operation. If this\n-  \/\/ fails we will go in to the runtime to revoke the object's bias.\n-  \/\/ Note that we first construct the presumed unbiased header so we\n-  \/\/ don't accidentally blow away another thread's valid bias.\n-  {\n-    Label here;\n-    mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n-    andr(swap_reg, swap_reg, rscratch1);\n-    orr(tmp_reg, swap_reg, rthread);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, this means that\n-    \/\/ another thread succeeded in biasing it toward itself and we\n-    \/\/ need to revoke that bias. The revocation will occur in the\n-    \/\/ interpreter runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->anonymously_biased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_rebias);\n-  \/\/ At this point we know the epoch has expired, meaning that the\n-  \/\/ current \"bias owner\", if any, is actually invalid. Under these\n-  \/\/ circumstances _only_, we are allowed to use the current header's\n-  \/\/ value as the comparison value when doing the cas to acquire the\n-  \/\/ bias in the current epoch. In other words, we allow transfer of\n-  \/\/ the bias from one thread to another directly in this situation.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    orr(tmp_reg, rthread, tmp_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);\n-    \/\/ If the biasing toward our thread failed, then another thread\n-    \/\/ succeeded in biasing it toward itself and we need to revoke that\n-    \/\/ bias. The revocation will occur in the runtime in the slow case.\n-    bind(here);\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->rebiased_lock_entry_count_addr()),\n-                  tmp_reg, rscratch1, rscratch2);\n-    }\n-  }\n-  b(done);\n-\n-  bind(try_revoke_bias);\n-  \/\/ The prototype mark in the klass doesn't have the bias bit set any\n-  \/\/ more, indicating that objects of this data type are not supposed\n-  \/\/ to be biased any more. We are going to try to reset the mark of\n-  \/\/ this object to the prototype value and fall through to the\n-  \/\/ CAS-based locking scheme. Note that if our CAS fails, it means\n-  \/\/ that another thread raced us for the privilege of revoking the\n-  \/\/ bias of this particular object, so it's okay to continue in the\n-  \/\/ normal locking code.\n-  \/\/\n-  \/\/ FIXME: due to a lack of registers we currently blow away the age\n-  \/\/ bits in this situation. Should attempt to preserve them.\n-  {\n-    Label here, nope;\n-    load_prototype_header(tmp_reg, obj_reg);\n-    cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, &nope);\n-    bind(here);\n-\n-    \/\/ Fall through to the normal CAS-based lock, because no matter what\n-    \/\/ the result of the above CAS, some thread must have succeeded in\n-    \/\/ removing the bias bit from the object's header.\n-    if (counters != NULL) {\n-      atomic_incw(Address((address)counters->revoked_lock_entry_count_addr()), tmp_reg,\n-                  rscratch1, rscratch2);\n-    }\n-    bind(nope);\n-  }\n-\n-  bind(cas_label);\n-}\n-\n-void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label& done) {\n-  assert(UseBiasedLocking, \"why call this otherwise?\");\n-\n-  \/\/ Check for biased locking unlock case, which is a no-op\n-  \/\/ Note: we do not have to check the thread ID for two reasons.\n-  \/\/ First, the interpreter checks for IllegalMonitorStateException at\n-  \/\/ a higher level. Second, if the bias was revoked while we held the\n-  \/\/ lock, the object could not be rebiased toward another thread, so\n-  \/\/ the bias bit would be clear.\n-  ldr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-  andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n-  cmp(temp_reg, (u1)markWord::biased_lock_pattern);\n-  br(Assembler::EQ, done);\n-}\n-\n@@ -3928,5 +3755,0 @@\n-void MacroAssembler::load_prototype_header(Register dst, Register src) {\n-  load_klass(dst, src);\n-  ldr(dst, Address(dst, Klass::prototype_header_offset()));\n-}\n-\n@@ -5432,43 +5254,0 @@\n-void MacroAssembler::neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1,\n-                                  FloatRegister src2, int cond, bool isQ) {\n-  SIMD_Arrangement size = esize2arrangement(type2aelembytes(bt), isQ);\n-  if (bt == T_FLOAT || bt == T_DOUBLE) {\n-    switch (cond) {\n-      case BoolTest::eq: fcmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        fcmeq(dst, size, src1, src2);\n-        notr(dst, T16B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: fcmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: fcmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: fcmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: fcmgt(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-  } else {\n-    switch (cond) {\n-      case BoolTest::eq: cmeq(dst, size, src1, src2); break;\n-      case BoolTest::ne: {\n-        cmeq(dst, size, src1, src2);\n-        notr(dst, T16B, dst);\n-        break;\n-      }\n-      case BoolTest::ge: cmge(dst, size, src1, src2); break;\n-      case BoolTest::gt: cmgt(dst, size, src1, src2); break;\n-      case BoolTest::le: cmge(dst, size, src2, src1); break;\n-      case BoolTest::lt: cmgt(dst, size, src2, src1); break;\n-      case BoolTest::uge: cmhs(dst, size, src1, src2); break;\n-      case BoolTest::ugt: cmhi(dst, size, src1, src2); break;\n-      case BoolTest::ult: cmhi(dst, size, src2, src1); break;\n-      case BoolTest::ule: cmhs(dst, size, src2, src1); break;\n-      default:\n-        assert(false, \"unsupported\");\n-        ShouldNotReachHere();\n-    }\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":221,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -108,14 +108,0 @@\n-  \/\/ Biased locking support\n-  \/\/ lock_reg and obj_reg must be loaded up with the appropriate values.\n-  \/\/ swap_reg is killed.\n-  \/\/ tmp_reg must be supplied and must not be rscratch1 or rscratch2\n-  \/\/ Optional slow case is for implementations (interpreter and C1) which branch to\n-  \/\/ slow case directly. Leaves condition codes set for C2's Fast_Lock node.\n-  void biased_locking_enter(Register lock_reg, Register obj_reg,\n-                            Register swap_reg, Register tmp_reg,\n-                            bool swap_reg_contains_mark,\n-                            Label& done, Label* slow_case = NULL,\n-                            BiasedLockingCounters* counters = NULL);\n-  void biased_locking_exit (Register obj_reg, Register temp_reg, Label& done);\n-\n-\n@@ -856,2 +842,0 @@\n-  void load_prototype_header(Register dst, Register src);\n-\n@@ -1067,2 +1051,0 @@\n-  \/\/ SIMD&FP comparison\n-  void neon_compare(FloatRegister dst, BasicType bt, FloatRegister src1, FloatRegister src2, int cond, bool isQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-inline Register as_Register(int encoding) {\n+inline const Register as_Register(int encoding) {\n@@ -56,1 +56,1 @@\n-  inline friend Register as_Register(int encoding);\n+  inline friend const Register as_Register(int encoding);\n@@ -265,0 +265,1 @@\n+  bool  is_governing() const      { return 0 <= (intptr_t)this && (intptr_t)this < number_of_governing_registers; }\n@@ -429,0 +430,4 @@\n+inline Register as_Register(FloatRegister reg) {\n+  return as_Register(reg->encoding());\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1811,4 +1811,0 @@\n-    if (UseBiasedLocking) {\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, lock_done, &slow_path_lock);\n-    }\n-\n@@ -1962,5 +1958,0 @@\n-\n-    if (UseBiasedLocking) {\n-      __ biased_locking_exit(obj_reg, old_hdr, done);\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1008,4 +1008,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -1062,1 +1058,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -1107,0 +1103,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 12 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 30 : FLOATPRESSURE;\n+}\n+\n@@ -5461,1 +5467,0 @@\n-    \/\/ used by biased locking only. Requires a membar.\n@@ -8961,1 +8966,0 @@\n-  predicate(!(UseBiasedLocking && !UseOptoBiasInlining));\n@@ -8973,16 +8977,0 @@\n-instruct cmpFastLock_noBiasInline(flagsRegP pcc, iRegP object, iRegP box, iRegP scratch2,\n-                                  iRegP scratch, iRegP scratch3) %{\n-  match(Set pcc (FastLock object box));\n-  predicate(UseBiasedLocking && !UseOptoBiasInlining);\n-\n-  effect(TEMP scratch, TEMP scratch2, TEMP scratch3);\n-  ins_cost(DEFAULT_COST*5);\n-\n-  format %{ \"FASTLOCK  $object, $box; KILL $scratch, $scratch2, $scratch3\" %}\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register, $scratch$$Register, $scratch2$$Register, $scratch3$$Register);\n-  %}\n-  ins_pipe(long_memory_op);\n-%}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":11,"deletions":23,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2111,0 +2111,2 @@\n+    case Op_RoundDoubleMode:\n+      return VM_Version::has_vsx();\n@@ -2200,4 +2202,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -2279,1 +2277,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -2370,0 +2368,10 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  return (INTPRESSURE == -1) ? 26 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 28 : FLOATPRESSURE;\n+}\n+\n@@ -12124,2 +12132,1 @@\n-                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0,\n-                                 UseBiasedLocking && !UseOptoBiasInlining);\n+                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0);\n@@ -12143,1 +12150,0 @@\n-                                 \/*Biased Locking*\/ false,\n@@ -12146,1 +12152,1 @@\n-                                 \/*TM*\/ true, ra_->C->profile_rtm());\n+                                 \/*RTM*\/ true, ra_->C->profile_rtm());\n@@ -12163,1 +12169,0 @@\n-                                   UseBiasedLocking && !UseOptoBiasInlining,\n@@ -12181,1 +12186,1 @@\n-                                   \/*Biased Locking*\/ false, \/*TM*\/ true);\n+                                   \/*RTM*\/ true);\n@@ -13968,1 +13973,1 @@\n-        __ frin($dst$$FloatRegister, $src$$FloatRegister);\n+        __ xvrdpic($dst$$FloatRegister->to_vsr(), $src$$FloatRegister->to_vsr());\n@@ -13992,1 +13997,1 @@\n-        __ xvrdpi($dst$$VectorSRegister, $src$$VectorSRegister);\n+        __ xvrdpic($dst$$VectorSRegister, $src$$VectorSRegister);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1561,4 +1561,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  return default_pressure_threshold;\n-}\n-\n@@ -1616,1 +1612,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -1672,0 +1668,11 @@\n+uint Matcher::int_pressure_limit()\n+{\n+  \/\/ Medium size register set, 6 special purpose regs, 3 SOE regs.\n+  return (INTPRESSURE == -1) ? 10 : INTPRESSURE;\n+}\n+\n+uint Matcher::float_pressure_limit()\n+{\n+  return (FLOATPRESSURE == -1) ? 15 : FLOATPRESSURE;\n+}\n+\n@@ -9816,2 +9823,1 @@\n-  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,\n-                                             UseBiasedLocking && !UseOptoBiasInlining); %}\n+  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n@@ -9825,1 +9831,1 @@\n-  \/\/ TODO: s390 port size(FIXED_SIZE);  \/\/ emitted code depends on UseBiasedLocking being on\/off.\n+  \/\/ TODO: s390 port size(FIXED_SIZE);\n@@ -9827,2 +9833,1 @@\n-  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,\n-                                               UseBiasedLocking && !UseOptoBiasInlining); %}\n+  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1838,0 +1838,5 @@\n+    case Op_VectorMaskCmp:\n+      if (vlen < 2 || size_in_bits < 32) {\n+        return false;\n+      }\n+      break;\n@@ -1875,1 +1880,1 @@\n-bool Matcher::is_generic_reg2reg_move(MachNode* m) {\n+bool Matcher::is_reg2reg_move(MachNode* m) {\n@@ -1879,0 +1884,8 @@\n+    case MoveF2VL_rule:\n+    case MoveF2LEG_rule:\n+    case MoveVL2F_rule:\n+    case MoveLEG2F_rule:\n+    case MoveD2VL_rule:\n+    case MoveD2LEG_rule:\n+    case MoveVL2D_rule:\n+    case MoveLEG2D_rule:\n@@ -1905,12 +1918,0 @@\n-const int Matcher::float_pressure(int default_pressure_threshold) {\n-  int float_pressure_threshold = default_pressure_threshold;\n-#ifdef _LP64\n-  if (UseAVX > 2) {\n-    \/\/ Increase pressure threshold on machines with AVX3 which have\n-    \/\/ 2x more XMM registers.\n-    float_pressure_threshold = default_pressure_threshold * 2;\n-  }\n-#endif\n-  return float_pressure_threshold;\n-}\n-\n@@ -4851,1 +4852,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4884,1 +4886,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4918,1 +4921,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4951,1 +4955,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -4984,1 +4989,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5017,1 +5023,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5052,1 +5059,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5086,1 +5094,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5119,1 +5128,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5153,1 +5163,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5186,1 +5197,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5219,1 +5231,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5367,1 +5380,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5401,1 +5415,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5425,1 +5440,2 @@\n-  predicate(VM_Version::supports_avx512dq());\n+  predicate(VM_Version::supports_avx512dq() &&\n+              (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5510,1 +5526,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5543,1 +5560,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5614,1 +5632,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5647,1 +5666,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -5831,0 +5851,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -5854,0 +5875,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -6466,1 +6488,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -6500,1 +6523,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -6534,1 +6558,2 @@\n-  predicate(UseAVX > 0);\n+  predicate((UseAVX > 0) &&\n+            (vector_length_in_bytes(n->in(1)) > 8));\n@@ -6580,1 +6605,1 @@\n-  predicate(UseAVX <= 2 &&\n+  predicate((UseAVX <= 2 || !VM_Version::supports_avx512vlbw()) &&\n@@ -6596,1 +6621,1 @@\n-  predicate(UseAVX <= 2 &&\n+  predicate((UseAVX <= 2 || !VM_Version::supports_avx512vlbw()) &&\n@@ -6614,1 +6639,1 @@\n-  predicate(UseAVX > 2 ||\n+  predicate((UseAVX > 2 && VM_Version::supports_avx512vlbw()) ||\n@@ -6729,1 +6754,1 @@\n-        __ vcvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister, dst_vlen_enc);\n+        __ vcvtdq2ps($dst$$XMMRegister, $src$$XMMRegister, dst_vlen_enc);\n@@ -6735,1 +6760,1 @@\n-        __ vcvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister, dst_vlen_enc);\n+        __ vcvtdq2pd($dst$$XMMRegister, $src$$XMMRegister, dst_vlen_enc);\n@@ -6901,1 +6926,1 @@\n-            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  4 && \/\/ src1\n@@ -7438,1 +7463,16 @@\n-instruct loadMask(vec dst, vec src) %{\n+instruct loadMask(legVec dst, legVec src) %{\n+  predicate(!VM_Version::supports_avx512vlbw());\n+  match(Set dst (VectorLoadMask src));\n+  effect(TEMP dst);\n+  format %{ \"vector_loadmask_byte $dst,$src\\n\\t\" %}\n+  ins_encode %{\n+    int vlen_in_bytes = vector_length_in_bytes(this);\n+    BasicType elem_bt = vector_element_basic_type(this);\n+\n+    __ load_vector_mask($dst$$XMMRegister, $src$$XMMRegister, vlen_in_bytes, elem_bt, true);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct loadMask_evex(vec dst, vec src) %{\n+  predicate(VM_Version::supports_avx512vlbw());\n@@ -7446,1 +7486,1 @@\n-    __ load_vector_mask($dst$$XMMRegister, $src$$XMMRegister, vlen_in_bytes, elem_bt);\n+    __ load_vector_mask($dst$$XMMRegister, $src$$XMMRegister, vlen_in_bytes, elem_bt, false);\n@@ -7955,0 +7995,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -7979,0 +8020,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)) > 8);\n@@ -8056,0 +8098,1 @@\n+  predicate(vector_length_in_bytes(n->in(1)->in(1)) > 8);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":86,"deletions":43,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -344,4 +344,0 @@\n-  do_class(java_nio_Buffer,               \"java\/nio\/Buffer\")                                                            \\\n-  do_intrinsic(_checkIndex,               java_nio_Buffer,        checkIndex_name, int_int_signature,            F_R)   \\\n-   do_name(     checkIndex_name,                                 \"checkIndex\")                                          \\\n-                                                                                                                        \\\n@@ -460,1 +456,1 @@\n-   do_signature(decodeBlock_signature, \"([BII[BIZ)I\")                                                                   \\\n+   do_signature(decodeBlock_signature, \"([BII[BIZZ)I\")                                                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+const char* C2Compiler::retry_no_locks_coarsening() {\n+  return \"retry without locks coarsening\";\n+}\n@@ -100,0 +103,1 @@\n+  bool do_locks_coarsening = EliminateLocks;\n@@ -103,1 +107,1 @@\n-    Compile C(env, target, entry_bci, subsume_loads, do_escape_analysis, eliminate_boxing, install_code, directive);\n+    Compile C(env, target, entry_bci, subsume_loads, do_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code, directive);\n@@ -123,0 +127,6 @@\n+      if (C.failure_reason_is(retry_no_locks_coarsening())) {\n+        assert(do_locks_coarsening, \"must make progress\");\n+        do_locks_coarsening = false;\n+        env->report_failure(C.failure_reason());\n+        continue;  \/\/ retry\n+      }\n@@ -144,0 +154,4 @@\n+      if (do_locks_coarsening) {\n+        do_locks_coarsening = false;\n+        continue;  \/\/ retry\n+      }\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -214,4 +214,4 @@\n-  , _sched_int_pressure(0, INTPRESSURE)\n-  , _sched_float_pressure(0, FLOATPRESSURE)\n-  , _scratch_int_pressure(0, INTPRESSURE)\n-  , _scratch_float_pressure(0, FLOATPRESSURE)\n+  , _sched_int_pressure(0, Matcher::int_pressure_limit())\n+  , _sched_float_pressure(0, Matcher::float_pressure_limit())\n+  , _scratch_int_pressure(0, Matcher::int_pressure_limit())\n+  , _scratch_float_pressure(0, Matcher::float_pressure_limit())\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -435,0 +435,1 @@\n+  remove_useless_coarsened_locks(useful);            \/\/ remove useless coarsened locks nodes\n@@ -504,0 +505,6 @@\n+  if ((_do_locks_coarsening != EliminateLocks) && PrintOpto) {\n+    \/\/ Recompiling without locks coarsening\n+    tty->print_cr(\"*********************************************************\");\n+    tty->print_cr(\"** Bailout: Recompile without locks coarsening         **\");\n+    tty->print_cr(\"*********************************************************\");\n+  }\n@@ -531,1 +538,2 @@\n-                  bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, bool install_code, DirectiveSet* directive)\n+                  bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing,\n+                  bool do_locks_coarsening, bool install_code, DirectiveSet* directive)\n@@ -538,0 +546,1 @@\n+                  _do_locks_coarsening(do_locks_coarsening),\n@@ -569,0 +578,1 @@\n+                  _coarsened_locks   (comp_arena(), 8, 0, NULL),\n@@ -835,0 +845,1 @@\n+    _do_locks_coarsening(false),\n@@ -4132,1 +4143,1 @@\n-    value = new CastIINode(value, itype, carry_dependency, true \/* range check dependency *\/);\n+    value = new CastIINode(value, itype, carry_dependency ? ConstraintCastNode::StrongDependency : ConstraintCastNode::RegularDependency, true \/* range check dependency *\/);\n@@ -4455,0 +4466,97 @@\n+\/**\n+ * Track coarsened Lock and Unlock nodes.\n+ *\/\n+\n+class Lock_List : public Node_List {\n+  uint _origin_cnt;\n+public:\n+  Lock_List(Arena *a, uint cnt) : Node_List(a), _origin_cnt(cnt) {}\n+  uint origin_cnt() const { return _origin_cnt; }\n+};\n+\n+void Compile::add_coarsened_locks(GrowableArray<AbstractLockNode*>& locks) {\n+  int length = locks.length();\n+  if (length > 0) {\n+    \/\/ Have to keep this list until locks elimination during Macro nodes elimination.\n+    Lock_List* locks_list = new (comp_arena()) Lock_List(comp_arena(), length);\n+    for (int i = 0; i < length; i++) {\n+      AbstractLockNode* lock = locks.at(i);\n+      assert(lock->is_coarsened(), \"expecting only coarsened AbstractLock nodes, but got '%s'[%d] node\", lock->Name(), lock->_idx);\n+      locks_list->push(lock);\n+    }\n+    _coarsened_locks.append(locks_list);\n+  }\n+}\n+\n+void Compile::remove_useless_coarsened_locks(Unique_Node_List& useful) {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    Node_List* locks_list = _coarsened_locks.at(i);\n+    for (uint j = 0; j < locks_list->size(); j++) {\n+      Node* lock = locks_list->at(j);\n+      assert(lock->is_AbstractLock(), \"sanity\");\n+      if (!useful.member(lock)) {\n+        locks_list->yank(lock);\n+      }\n+    }\n+  }\n+}\n+\n+void Compile::remove_coarsened_lock(Node* n) {\n+  if (n->is_AbstractLock()) {\n+    int count = coarsened_count();\n+    for (int i = 0; i < count; i++) {\n+      Node_List* locks_list = _coarsened_locks.at(i);\n+      locks_list->yank(n);\n+    }\n+  }\n+}\n+\n+bool Compile::coarsened_locks_consistent() {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    bool unbalanced = false;\n+    bool modified = false; \/\/ track locks kind modifications\n+    Lock_List* locks_list = (Lock_List*)_coarsened_locks.at(i);\n+    uint size = locks_list->size();\n+    if (size == 0) {\n+      unbalanced = false; \/\/ All locks were eliminated - good\n+    } else if (size != locks_list->origin_cnt()) {\n+      unbalanced = true; \/\/ Some locks were removed from list\n+    } else {\n+      for (uint j = 0; j < size; j++) {\n+        Node* lock = locks_list->at(j);\n+        \/\/ All nodes in group should have the same state (modified or not)\n+        if (!lock->as_AbstractLock()->is_coarsened()) {\n+          if (j == 0) {\n+            \/\/ first on list was modified, the rest should be too for consistency\n+            modified = true;\n+          } else if (!modified) {\n+            \/\/ this lock was modified but previous locks on the list were not\n+            unbalanced = true;\n+            break;\n+          }\n+        } else if (modified) {\n+          \/\/ previous locks on list were modified but not this lock\n+          unbalanced = true;\n+          break;\n+        }\n+      }\n+    }\n+    if (unbalanced) {\n+      \/\/ unbalanced monitor enter\/exit - only some [un]lock nodes were removed or modified\n+#ifdef ASSERT\n+      if (PrintEliminateLocks) {\n+        tty->print_cr(\"=== unbalanced coarsened locks ===\");\n+        for (uint l = 0; l < size; l++) {\n+          locks_list->at(l)->dump();\n+        }\n+      }\n+#endif\n+      record_failure(C2Compiler::retry_no_locks_coarsening());\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -4481,4 +4589,6 @@\n-      uint max = n->len();\n-      for( uint i = 0; i < max; ++i ) {\n-        Node *m = n->in(i);\n-        if (not_a_node(m))  continue;\n+      \/\/ Iterate over outs - endless loops is unreachable from below\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node *m = n->fast_out(i);\n+        if (not_a_node(m)) {\n+          continue;\n+        }\n@@ -4505,4 +4615,6 @@\n-      uint max = n->len();\n-      for( uint i = 0; i < max; ++i ) {\n-        Node *m = n->in(i);\n-        if (not_a_node(m))  continue;\n+      \/\/ Iterate over outs - endless loops is unreachable from below\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node *m = n->fast_out(i);\n+        if (not_a_node(m)) {\n+          continue;\n+        }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":122,"deletions":10,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-  if (get_block_for_node(ctrl) == not_null_block) {\n+  if (ctrl != NULL && get_block_for_node(ctrl) == not_null_block) {\n@@ -1081,5 +1081,4 @@\n-    uint float_pressure = Matcher::float_pressure(FLOATPRESSURE);\n-    _regalloc->_sched_int_pressure.init(INTPRESSURE);\n-    _regalloc->_sched_float_pressure.init(float_pressure);\n-    _regalloc->_scratch_int_pressure.init(INTPRESSURE);\n-    _regalloc->_scratch_float_pressure.init(float_pressure);\n+    _regalloc->_sched_int_pressure.init(Matcher::int_pressure_limit());\n+    _regalloc->_sched_float_pressure.init(Matcher::float_pressure_limit());\n+    _regalloc->_scratch_int_pressure.init(Matcher::int_pressure_limit());\n+    _regalloc->_scratch_float_pressure.init(Matcher::float_pressure_limit());\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1039,0 +1039,5 @@\n+  if (stopped()) {\n+    \/\/ Length is known to be always negative during compilation and the IR graph so far constructed is good so return success\n+    return true;\n+  }\n+\n@@ -1046,4 +1051,0 @@\n-  if (stopped()) {\n-    return false;\n-  }\n-\n@@ -1068,1 +1069,2 @@\n-    return false;\n+    \/\/ Range check is known to always fail during compilation and the IR graph so far constructed is good so return success\n+    return true;\n@@ -3817,1 +3819,1 @@\n-  Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);\n+  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n@@ -4124,0 +4126,2 @@\n+#undef XTOP\n+\n@@ -4450,0 +4454,30 @@\n+\n+    \/\/ The CastIINode created in GraphKit::new_array (in AllocateArrayNode::make_ideal_length) must stay below\n+    \/\/ the allocation (i.e. is only valid if the allocation succeeds):\n+    \/\/ 1) replace CastIINode with AllocateArrayNode's length here\n+    \/\/ 2) Create CastIINode again once allocation has moved (see below) at the end of this method\n+    \/\/\n+    \/\/ Multiple identical CastIINodes might exist here. Each GraphKit::load_array_length() call will generate\n+    \/\/ new separate CastIINode (arraycopy guard checks or any array length use between array allocation and ararycopy)\n+    Node* init_control = init->proj_out(TypeFunc::Control);\n+    Node* alloc_length = alloc->Ideal_length();\n+#ifdef ASSERT\n+    Node* prev_cast = NULL;\n+#endif\n+    for (uint i = 0; i < init_control->outcnt(); i++) {\n+      Node* init_out = init_control->raw_out(i);\n+      if (init_out->is_CastII() && init_out->in(TypeFunc::Control) == init_control && init_out->in(1) == alloc_length) {\n+#ifdef ASSERT\n+        if (prev_cast == NULL) {\n+          prev_cast = init_out;\n+        } else {\n+          if (prev_cast->cmp(*init_out) == false) {\n+            prev_cast->dump();\n+            init_out->dump();\n+            assert(false, \"not equal CastIINode\");\n+          }\n+        }\n+#endif\n+        C->gvn_replace_by(init_out, alloc_length);\n+      }\n+    }\n@@ -4481,0 +4515,2 @@\n+\n+    array_ideal_length(alloc, ary_type, true);\n@@ -5316,2 +5352,0 @@\n-    const TypeVect* vt = TypeVect::make(elem_bt, inline_limit);\n-\n@@ -5322,0 +5356,1 @@\n+      const TypeVect* vt = TypeVect::make(elem_bt, inline_limit);\n@@ -6387,1 +6422,1 @@\n-  assert(callee()->signature()->size() == 6, \"base64_decodeBlock has 6 parameters\");\n+  assert(callee()->signature()->size() == 7, \"base64_decodeBlock has 7 parameters\");\n@@ -6399,0 +6434,1 @@\n+  Node* isMIME = argument(7);\n@@ -6411,1 +6447,1 @@\n-                                 src_start, src_offset, len, dest_start, dest_offset, isURL);\n+                                 src_start, src_offset, len, dest_start, dest_offset, isURL, isMIME);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":46,"deletions":10,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-  RegMask *rms = (RegMask*)C->comp_arena()->Amalloc_D(sizeof(RegMask) * NOF_STACK_MASKS);\n+  RegMask *rms = (RegMask*)C->comp_arena()->AmallocWords(sizeof(RegMask) * NOF_STACK_MASKS);\n@@ -2698,1 +2698,1 @@\n-      } else if (is_generic_reg2reg_move(def->as_Mach())) {\n+      } else if (is_reg2reg_move(def->as_Mach())) {\n@@ -2724,3 +2724,0 @@\n-  if (C->max_vector_size() == 0) {\n-    return; \/\/ no vector instructions or operands\n-  }\n@@ -2735,1 +2732,1 @@\n-      if (Matcher::is_generic_reg2reg_move(m)) {\n+      if (Matcher::is_reg2reg_move(m)) {\n@@ -2758,1 +2755,1 @@\n-        assert(!Matcher::is_generic_reg2reg_move(m), \"no MoveVec nodes allowed\");\n+        assert(!Matcher::is_reg2reg_move(m), \"no MoveVec nodes allowed\");\n@@ -2827,3 +2824,1 @@\n-    \/\/ With biased locking we're no longer guaranteed that a monitor\n-    \/\/ enter operation contains a serializing instruction.\n-    if ((xop == Op_FastLock) && !UseBiasedLocking) {\n+    if (xop == Op_FastLock) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -236,0 +236,4 @@\n+  \/\/ Number of integer live ranges that constitute high register pressure\n+  static uint int_pressure_limit();\n+  \/\/ Number of float live ranges that constitute high register pressure\n+  static uint float_pressure_limit();\n@@ -333,3 +337,0 @@\n-  \/\/ Some uarchs have different sized float register resources\n-  static const int float_pressure(int default_pressure_threshold);\n-\n@@ -476,1 +477,1 @@\n-  static bool is_generic_reg2reg_move(MachNode* m);\n+  static bool is_reg2reg_move(MachNode* m);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1837,7 +1837,0 @@\n-  AllocateNode* alloc = is_new_object_mark_load(phase);\n-  if (alloc != NULL && alloc->Opcode() == Op_Allocate && UseBiasedLocking) {\n-    InitializeNode* init = alloc->initialization();\n-    Node* control = init->proj_out(0);\n-    return alloc->make_ideal_mark(phase, address, control, mem);\n-  }\n-\n@@ -2106,1 +2099,1 @@\n-  if (alloc != NULL && !(alloc->Opcode() == Op_Allocate && UseBiasedLocking)) {\n+  if (alloc != NULL) {\n@@ -3316,1 +3309,2 @@\n-    return;\n+    assert(Opcode() == Op_Initialize, \"Only seen when there are no use of init memory\");\n+    assert(outcnt() == 1, \"Only control then\");\n@@ -3325,2 +3319,6 @@\n-  igvn->replace_node(proj_out(TypeFunc::Memory), in(TypeFunc::Memory));\n-  igvn->replace_node(proj_out(TypeFunc::Control), in(TypeFunc::Control));\n+  if (proj_out_or_null(TypeFunc::Memory) != NULL) {\n+    igvn->replace_node(proj_out(TypeFunc::Memory), in(TypeFunc::Memory));\n+  }\n+  if (proj_out_or_null(TypeFunc::Control) != NULL) {\n+    igvn->replace_node(proj_out(TypeFunc::Control), in(TypeFunc::Control));\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -223,2 +223,1 @@\n-  Node(const Node&);            \/\/ not defined; linker error to use these\n-  Node &operator=(const Node &rhs);\n+  NONCOPYABLE(Node);\n@@ -242,1 +241,1 @@\n-    Node* n = (Node*)C->node_arena()->Amalloc_D(x);\n+    Node* n = (Node*)C->node_arena()->AmallocWords(x);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-  const Type **fboth =(const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **fboth =(const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -506,1 +506,1 @@\n-  const Type **ffalse =(const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **ffalse =(const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -511,1 +511,1 @@\n-  const Type **fneither =(const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **fneither =(const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -516,1 +516,1 @@\n-  const Type **ftrue =(const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **ftrue =(const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -521,1 +521,1 @@\n-  const Type **floop =(const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **floop =(const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -536,1 +536,1 @@\n-  const Type **fsc = (const Type**)shared_type_arena->Amalloc_4(2*sizeof(Type*));\n+  const Type **fsc = (const Type**)shared_type_arena->AmallocWords(2*sizeof(Type*));\n@@ -2058,1 +2058,1 @@\n-  const Type **flds = (const Type **)(Compile::current()->type_arena()->Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));\n+  const Type **flds = (const Type **)(Compile::current()->type_arena()->AmallocWords((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));\n@@ -2086,1 +2086,1 @@\n-    const Type **fields = (const Type **)(Compile::current()->type_arena()->Amalloc_4( _cnt*sizeof(Type*) ));\n+    const Type **fields = (const Type **)(Compile::current()->type_arena()->AmallocWords( _cnt*sizeof(Type*) ));\n@@ -2100,1 +2100,1 @@\n-  const Type **fields = (const Type **)(Compile::current()->type_arena()->Amalloc_4( _cnt*sizeof(Type*) ));\n+  const Type **fields = (const Type **)(Compile::current()->type_arena()->AmallocWords( _cnt*sizeof(Type*) ));\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-    return compile->type_arena()->Amalloc_D(x);\n+    return compile->type_arena()->AmallocWords(x);\n@@ -383,1 +383,1 @@\n-#endif\n+#endif \/\/ !PRODUCT\n@@ -1877,3 +1877,1 @@\n-\/\/ UseOptoBiasInlining\n-#define XorXNode     XorLNode\n-#define StoreXConditionalNode StoreLConditionalNode\n+\/\/ For shenandoahSupport\n@@ -1925,3 +1923,1 @@\n-\/\/ UseOptoBiasInlining\n-#define XorXNode     XorINode\n-#define StoreXConditionalNode StoreIConditionalNode\n+\/\/ For shenandoahSupport\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -498,3 +498,0 @@\n-  if (num_elem < 4)\n-    return false;\n-\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -924,1 +924,1 @@\n-    assert(mask->Opcode() == Op_VectorStoreMask, \"\");\n+    assert(mask->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN, \"\");\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,5 +169,0 @@\n-typedef HashtableEntry<intptr_t, mtInternal>  IntptrHashtableEntry;\n-typedef Hashtable<intptr_t, mtInternal>       IntptrHashtable;\n-typedef Hashtable<InstanceKlass*, mtClass>       KlassHashtable;\n-typedef HashtableEntry<InstanceKlass*, mtClass>  KlassHashtableEntry;\n-\n@@ -269,1 +264,0 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -474,21 +468,0 @@\n-  \/* HashtableBucket *\/                                                                                                              \\\n-  \/*******************\/                                                                                                              \\\n-                                                                                                                                     \\\n-  nonstatic_field(HashtableBucket<mtInternal>, _entry,                                        BasicHashtableEntry<mtInternal>*)      \\\n-                                                                                                                                     \\\n-  \/******************\/                                                                                                               \\\n-  \/* HashtableEntry *\/                                                                                                               \\\n-  \/******************\/                                                                                                               \\\n-                                                                                                                                     \\\n-  nonstatic_field(BasicHashtableEntry<mtInternal>, _next,                                     BasicHashtableEntry<mtInternal>*)      \\\n-  nonstatic_field(BasicHashtableEntry<mtInternal>, _hash,                                     unsigned int)                          \\\n-  nonstatic_field(IntptrHashtableEntry,            _literal,                                  intptr_t)                              \\\n-                                                                                                                                     \\\n-  \/*************\/                                                                                                                    \\\n-  \/* Hashtable *\/                                                                                                                    \\\n-  \/*************\/                                                                                                                    \\\n-                                                                                                                                     \\\n-  nonstatic_field(BasicHashtable<mtInternal>,  _table_size,                                   int)                                   \\\n-  nonstatic_field(BasicHashtable<mtInternal>,  _buckets,                                      HashtableBucket<mtInternal>*)          \\\n-                                                                                                                                     \\\n-  \/*******************\/                                                                                                              \\\n@@ -501,1 +474,0 @@\n-  volatile_nonstatic_field(ClassLoaderData,    _dictionary,                                   Dictionary*)                           \\\n@@ -884,2 +856,2 @@\n-  nonstatic_field(ObjectMonitor,               _contentions,                                  jint)                                  \\\n-  volatile_nonstatic_field(ObjectMonitor,      _waiters,                                      jint)                                  \\\n+  nonstatic_field(ObjectMonitor,               _contentions,                                  int)                                   \\\n+  volatile_nonstatic_field(ObjectMonitor,      _waiters,                                      int)                                   \\\n@@ -1313,8 +1285,0 @@\n-  declare_toplevel_type(BasicHashtable<mtInternal>)                       \\\n-    declare_type(IntptrHashtable, BasicHashtable<mtInternal>)             \\\n-  declare_toplevel_type(BasicHashtable<mtSymbol>)                         \\\n-    declare_type(Dictionary, KlassHashtable)                              \\\n-  declare_toplevel_type(BasicHashtableEntry<mtInternal>)                  \\\n-  declare_type(IntptrHashtableEntry, BasicHashtableEntry<mtInternal>)     \\\n-    declare_type(DictionaryEntry, KlassHashtableEntry)                    \\\n-  declare_toplevel_type(HashtableBucket<mtInternal>)                      \\\n@@ -2411,0 +2375,1 @@\n+  declare_constant(Deoptimization::Reason_receiver_constraint)            \\\n@@ -2638,1 +2603,0 @@\n-  declare_constant(markWord::biased_lock_bits)                            \\\n@@ -2643,1 +2607,0 @@\n-  declare_constant(markWord::biased_lock_shift)                           \\\n@@ -2649,3 +2612,0 @@\n-  declare_constant(markWord::biased_lock_mask)                            \\\n-  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n-  declare_constant(markWord::biased_lock_bit_in_place)                    \\\n@@ -2654,2 +2614,0 @@\n-  declare_constant(markWord::epoch_mask)                                  \\\n-  declare_constant(markWord::epoch_mask_in_place)                         \\\n@@ -2658,1 +2616,0 @@\n-  declare_constant(markWord::biased_lock_alignment)                       \\\n@@ -2664,1 +2621,0 @@\n-  declare_constant(markWord::biased_lock_pattern)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":47,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -630,1 +630,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -632,10 +633,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -812,18 +804,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -662,1 +662,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -664,10 +665,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -844,18 +836,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -726,1 +726,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -728,10 +729,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -908,18 +900,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -614,1 +614,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -616,10 +617,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -796,18 +788,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -600,1 +600,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -602,10 +603,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -782,18 +774,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -3762,9 +3763,8 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            bb, offset, vsp,\n-            (buf, off, s) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.get(o + i * 1));\n-           });\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.get(o + i * 1));\n+                });\n@@ -3849,9 +3849,8 @@\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            this, bb, offset,\n-            (buf, off, v) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n-            });\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -591,1 +591,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -593,10 +594,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -773,18 +765,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -595,1 +595,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -597,10 +598,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -777,18 +769,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -603,1 +603,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -605,10 +606,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -589,1 +589,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -591,10 +592,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -771,18 +763,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -588,1 +588,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -590,10 +591,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -770,18 +762,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -3347,9 +3348,8 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            bb, offset, vsp,\n-            (buf, off, s) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-           });\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                });\n@@ -3469,9 +3469,8 @@\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            this, bb, offset,\n-            (buf, off, v) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n-            });\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -595,1 +595,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -597,10 +598,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -777,18 +769,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -603,1 +603,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -605,10 +606,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -785,18 +777,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -619,1 +619,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -621,10 +622,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -801,18 +793,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -591,1 +591,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -593,10 +594,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -773,18 +765,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -588,1 +588,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -590,10 +591,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -770,18 +762,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -3316,9 +3317,8 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            bb, offset, vsp,\n-            (buf, off, s) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-           });\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                });\n@@ -3419,9 +3419,8 @@\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            this, bb, offset,\n-            (buf, off, v) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n-            });\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -606,1 +606,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -608,10 +609,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -788,18 +780,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -614,1 +614,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -616,10 +617,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -796,18 +788,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -630,1 +630,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -632,10 +633,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -812,18 +804,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -602,1 +602,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -604,10 +605,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -784,18 +776,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -600,1 +600,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -602,10 +603,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -793,18 +785,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -3480,9 +3481,8 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            bb, offset, vsp,\n-            (buf, off, s) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.getInt(o + i * 4));\n-           });\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                });\n@@ -3583,9 +3583,8 @@\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            this, bb, offset,\n-            (buf, off, v) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n-            });\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -592,1 +592,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -594,10 +595,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -774,18 +766,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -596,1 +596,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -598,10 +599,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -778,18 +770,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -604,1 +604,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -606,10 +607,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -786,18 +778,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -590,1 +590,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -592,10 +593,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -772,18 +764,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -590,1 +590,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -592,10 +593,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -772,18 +764,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -3396,9 +3397,8 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            bb, offset, vsp,\n-            (buf, off, s) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.getLong(o + i * 8));\n-           });\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                });\n@@ -3518,9 +3518,8 @@\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            this, bb, offset,\n-            (buf, off, v) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n-            });\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -614,1 +614,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -616,10 +617,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte128Vector.Byte128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short128Vector.Short128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int128Vector.Int128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long128Vector.Long128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float128Vector.Float128Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double128Vector.Double128Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -796,18 +788,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte128Vector.Byte128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short128Vector.Short128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int128Vector.Int128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long128Vector.Long128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float128Vector.Float128Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double128Vector.Double128Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -630,1 +630,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -632,10 +633,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte256Vector.Byte256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short256Vector.Short256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int256Vector.Int256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long256Vector.Long256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float256Vector.Float256Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double256Vector.Double256Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -812,18 +804,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte256Vector.Byte256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short256Vector.Short256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int256Vector.Int256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long256Vector.Long256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float256Vector.Float256Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double256Vector.Double256Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -662,1 +662,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -664,10 +665,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte512Vector.Byte512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short512Vector.Short512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int512Vector.Int512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long512Vector.Long512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float512Vector.Float512Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double512Vector.Double512Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -844,18 +836,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte512Vector.Byte512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short512Vector.Short512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int512Vector.Int512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long512Vector.Long512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float512Vector.Float512Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double512Vector.Double512Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -606,1 +606,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -608,10 +609,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte64Vector.Byte64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short64Vector.Short64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int64Vector.Int64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long64Vector.Long64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float64Vector.Float64Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double64Vector.Double64Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -788,18 +780,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte64Vector.Byte64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short64Vector.Short64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int64Vector.Int64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long64Vector.Long64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float64Vector.Float64Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double64Vector.Double64Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -600,1 +600,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -602,10 +603,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new ByteMaxVector.ByteMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new ShortMaxVector.ShortMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new IntMaxVector.IntMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new LongMaxVector.LongMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new FloatMaxVector.FloatMaxMask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new DoubleMaxVector.DoubleMaxMask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -782,18 +774,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new ByteMaxVector.ByteMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new ShortMaxVector.ShortMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new IntMaxVector.IntMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new LongMaxVector.LongMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new FloatMaxVector.FloatMaxShuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new DoubleMaxVector.DoubleMaxShuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -3748,9 +3749,8 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            bb, offset, vsp,\n-            (buf, off, s) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.getShort(o + i * 2));\n-           });\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                });\n@@ -3818,9 +3818,8 @@\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            this, bb, offset,\n-            (buf, off, v) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n-            });\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -4806,9 +4807,8 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            bb, offset, vsp,\n-            (buf, off, s) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-           });\n+        return ScopedMemoryAccess.loadFromByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                bb, offset, vsp,\n+                (buf, off, s) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    return s.ldOp(wb, off,\n+                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                });\n@@ -4956,9 +4956,8 @@\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            bufferBase(bb), bufferAddress(bb, offset),\n-            this, bb, offset,\n-            (buf, off, v) -> {\n-                ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-            });\n+        ScopedMemoryAccess.storeIntoByteBuffer(\n+                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                this, bb, offset,\n+                (buf, off, v) -> {\n+                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                    v.stOp(wb, off,\n+                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -873,1 +873,2 @@\n-            assert(length() == dsp.laneCount());\n+            if (length() != dsp.laneCount())\n+                throw new IllegalArgumentException(\"VectorMask length and species length differ\");\n@@ -875,10 +876,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            return switch (dsp.laneType.switchKey) {\n-                     case LaneType.SK_BYTE   -> new Byte$bits$Vector.Byte$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_SHORT  -> new Short$bits$Vector.Short$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_INT    -> new Int$bits$Vector.Int$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_LONG   -> new Long$bits$Vector.Long$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_FLOAT  -> new Float$bits$Vector.Float$bits$Mask(maskArray).check(dsp);\n-                     case LaneType.SK_DOUBLE -> new Double$bits$Vector.Double$bits$Mask(maskArray).check(dsp);\n-                     default                 -> throw new AssertionError(dsp);\n-            };\n+            return  dsp.maskFactory(maskArray).check(dsp);\n@@ -1070,18 +1062,1 @@\n-            \/\/ enum-switches don't optimize properly JDK-8161245\n-            switch (species.laneType.switchKey) {\n-            case LaneType.SK_BYTE:\n-                return new Byte$bits$Vector.Byte$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_SHORT:\n-                return new Short$bits$Vector.Short$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_INT:\n-                return new Int$bits$Vector.Int$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_LONG:\n-                return new Long$bits$Vector.Long$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_FLOAT:\n-                return new Float$bits$Vector.Float$bits$Shuffle(shuffleArray).check(species);\n-            case LaneType.SK_DOUBLE:\n-                return new Double$bits$Vector.Double$bits$Shuffle(shuffleArray).check(species);\n-            }\n-\n-            \/\/ Should not reach here.\n-            throw new AssertionError(species);\n+            return s.shuffleFromArray(shuffleArray, 0).check(s);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"}]}