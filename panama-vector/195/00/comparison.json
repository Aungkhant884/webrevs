{"files":[{"patch":"@@ -11617,1 +11617,15 @@\n-void Assembler::pext(Register dst, Register src1, Register src2) {\n+void Assembler::pextl(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n+void Assembler::pdepl(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n+void Assembler::pextq(Register dst, Register src1, Register src2) {\n@@ -11624,1 +11638,1 @@\n-void Assembler::pdep(Register dst, Register src1, Register src2) {\n+void Assembler::pdepq(Register dst, Register src1, Register src2) {\n@@ -11631,0 +11645,36 @@\n+void Assembler::pextl(Register dst, Register src1, Address src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0xF5);\n+  emit_operand(dst, src2);\n+}\n+\n+void Assembler::pdepl(Register dst, Register src1, Address src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0xF5);\n+  emit_operand(dst, src2);\n+}\n+\n+void Assembler::pextq(Register dst, Register src1, Address src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0xF5);\n+  emit_operand(dst, src2);\n+}\n+\n+void Assembler::pdepq(Register dst, Register src1, Address src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src2, src1->encoding(), dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int8((unsigned char)0xF5);\n+  emit_operand(dst, src2);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":52,"deletions":2,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2203,2 +2203,9 @@\n-  void pext(Register dst, Register src1, Register src2);\n-  void pdep(Register dst, Register src1, Register src2);\n+\n+  void pextl(Register dst, Register src1, Register src2);\n+  void pdepl(Register dst, Register src1, Register src2);\n+  void pextq(Register dst, Register src1, Register src2);\n+  void pdepq(Register dst, Register src1, Register src2);\n+  void pextl(Register dst, Register src1, Address src2);\n+  void pdepl(Register dst, Register src1, Address src2);\n+  void pextq(Register dst, Register src1, Address src2);\n+  void pdepq(Register dst, Register src1, Address src2);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4269,1 +4269,1 @@\n-  pdep(rtmp1, src, rtmp1);\n+  pdepq(rtmp1, src, rtmp1);\n@@ -4286,1 +4286,1 @@\n-    pdep(rtmp1, rtmp2, rtmp1);\n+    pdepq(rtmp1, rtmp2, rtmp1);\n@@ -4427,1 +4427,1 @@\n-  pext(rtmp2, rtmp2, rtmp1);\n+  pextq(rtmp2, rtmp2, rtmp1);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1618,0 +1618,6 @@\n+    case Op_CompressBits:\n+    case Op_ExpandBits:\n+      if (!VM_Version::supports_bmi2()) {\n+        return false;\n+      }\n+      break;\n@@ -6178,1 +6184,0 @@\n-#endif \/\/ _LP64\n@@ -6180,0 +6185,81 @@\n+\/\/----------------------------- CompressBits\/ExpandBits ------------------------\n+instruct compressBitsI_reg(rRegI dst, rRegI src, rRegI mask) %{\n+  predicate(n->bottom_type()->isa_int());\n+  match(Set dst (CompressBits src mask));\n+  format %{ \"pextl  $dst, $src, $mask\\t! parallel bit extract\" %}\n+  ins_encode %{\n+    __ pextl($dst$$Register, $src$$Register, $mask$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct compressBitsL_reg(rRegL dst, rRegL src, rRegL mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (CompressBits src mask));\n+  format %{ \"pextq  $dst, $src, $mask\\t! parallel bit extract\" %}\n+  ins_encode %{\n+    __ pextq($dst$$Register, $src$$Register, $mask$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct expandBitsI_reg(rRegI dst, rRegI src, rRegI mask) %{\n+  predicate(n->bottom_type()->isa_int());\n+  match(Set dst (ExpandBits src mask));\n+  format %{ \"pdepl  $dst, $src, $mask\\t! parallel bit deposit\" %}\n+  ins_encode %{\n+    __ pdepl($dst$$Register, $src$$Register, $mask$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct expandBitsL_reg(rRegL dst, rRegL src, rRegL mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (ExpandBits src mask));\n+  format %{ \"pdepq  $dst, $src, $mask\\t! parallel bit deposit\" %}\n+  ins_encode %{\n+    __ pdepq($dst$$Register, $src$$Register, $mask$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct compressBitsI_mem(rRegI dst, rRegI src, memory mask) %{\n+  predicate(n->bottom_type()->isa_int());\n+  match(Set dst (CompressBits src (LoadI mask)));\n+  format %{ \"pextl  $dst, $src, $mask\\t! parallel bit extract\" %}\n+  ins_encode %{\n+    __ pextl($dst$$Register, $src$$Register, $mask$$Address);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct compressBitsL_mem(rRegL dst, rRegL src, memory mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (CompressBits src (LoadL mask)));\n+  format %{ \"pextq  $dst, $src, $mask\\t! parallel bit extract\" %}\n+  ins_encode %{\n+    __ pextq($dst$$Register, $src$$Register, $mask$$Address);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct expandBitsI_mem(rRegI dst, rRegI src, memory mask) %{\n+  predicate(n->bottom_type()->isa_int());\n+  match(Set dst (ExpandBits src (LoadI mask)));\n+  format %{ \"pdepl  $dst, $src, $mask\\t! parallel bit deposit\" %}\n+  ins_encode %{\n+    __ pdepl($dst$$Register, $src$$Register, $mask$$Address);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct expandBitsL_mem(rRegL dst, rRegL src, memory mask) %{\n+  predicate(n->bottom_type()->isa_long());\n+  match(Set dst (ExpandBits src (LoadL mask)));\n+  format %{ \"pdepq  $dst, $src, $mask\\t! parallel bit deposit\" %}\n+  ins_encode %{\n+    __ pdepq($dst$$Register, $src$$Register, $mask$$Address);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":87,"deletions":1,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+  do_name(expand_name,\"expand\")                                                                                         \\\n@@ -233,0 +234,4 @@\n+  do_intrinsic(_compress_i,               java_lang_Integer,      compress_name,            int2_int_signature,   F_S)  \\\n+  do_intrinsic(_compress_l,               java_lang_Long,         compress_name,            long2_long_signature, F_S)  \\\n+  do_intrinsic(_expand_i,                 java_lang_Integer,      expand_name,              int2_int_signature,   F_S)  \\\n+  do_intrinsic(_expand_l,                 java_lang_Long,         expand_name,              long2_long_signature, F_S)  \\\n@@ -246,1 +251,1 @@\n-                                                                                                                        \\\n+                                                                                                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -246,0 +246,8 @@\n+  case vmIntrinsics::_compress_i:\n+  case vmIntrinsics::_compress_l:\n+    if (!Matcher::match_rule_supported(Op_CompressBits)) return false;\n+    break;\n+  case vmIntrinsics::_expand_i:\n+  case vmIntrinsics::_expand_l:\n+    if (!Matcher::match_rule_supported(Op_ExpandBits)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+macro(CompressBitsV)\n+macro(ExpandBitsV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"opto\/addnode.hpp\"\n+#include \"opto\/mulnode.hpp\"\n@@ -115,0 +117,106 @@\n+Node* CompressBitsNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* src = in(1);\n+  Node* mask = in(2);\n+  if (bottom_type()->isa_int()) {\n+    if (mask->Opcode() == Op_LShiftI && phase->type(mask->in(1))->is_int()->is_con()) {\n+      \/\/ compress(x, 1 << n) == (x >> n & 1)\n+      if (phase->type(mask->in(1))->higher_equal(TypeInt::ONE)) {\n+        Node* rshift = phase->transform(new RShiftINode(in(1), mask->in(2)));\n+        return new AndINode(rshift, phase->makecon(TypeInt::ONE));\n+      \/\/ compress(x, -1 << n) == x >>> n\n+      } else if (phase->type(mask->in(1))->higher_equal(TypeInt::MINUS_1)) {\n+        return new URShiftINode(in(1), mask->in(2));\n+      }\n+    }\n+    \/\/ compress(expand(x, m), m) == x & compress(m, m)\n+    if (src->Opcode() == Op_ExpandBits &&\n+        src->in(2) == mask) {\n+      Node* compr = phase->transform(new CompressBitsNode(mask, mask, TypeInt::INT));\n+      return new AndINode(compr, src->in(1));\n+    }\n+  } else {\n+    assert(bottom_type()->isa_long(), \"\");\n+    if (mask->Opcode() == Op_LShiftL && phase->type(mask->in(1))->is_long()->is_con()) {\n+      \/\/ compress(x, 1 << n) == (x >> n & 1)\n+      if (phase->type(mask->in(1))->higher_equal(TypeLong::ONE)) {\n+        Node* rshift = phase->transform(new RShiftLNode(in(1), mask->in(2)));\n+        return new AndLNode(rshift, phase->makecon(TypeLong::ONE));\n+      \/\/ compress(x, -1 << n) == x >>> n\n+      } else if (phase->type(mask->in(1))->higher_equal(TypeLong::MINUS_1)) {\n+        return new URShiftLNode(in(1), mask->in(2));\n+      }\n+    }\n+    \/\/ compress(expand(x, m), m) == x & compress(m, m)\n+    if (src->Opcode() == Op_ExpandBits &&\n+        src->in(2) == mask) {\n+      Node* compr = phase->transform(new CompressBitsNode(mask, mask, TypeLong::LONG));\n+      return new AndLNode(compr, src->in(1));\n+    }\n+  }\n+  return NULL;\n+}\n+\n+Node* compress_expand_identity(PhaseGVN* phase, Node* n) {\n+  if (n->bottom_type()->isa_int()) {\n+    \/\/ compress(x, 0) == 0\n+    if(phase->type(n->in(2))->higher_equal(TypeInt::ZERO)) return n->in(2);\n+    \/\/ compress(x, -1) == x\n+    if(phase->type(n->in(2))->higher_equal( TypeInt::MINUS_1)) return n->in(1);\n+  } else {\n+    assert(n->bottom_type()->isa_long(), \"\");\n+    \/\/ compress(x, 0) == 0\n+    if(phase->type(n->in(2))->higher_equal(TypeLong::ZERO)) return n->in(2);\n+    \/\/ compress(x, -1) == x\n+    if(phase->type(n->in(2))->higher_equal( TypeLong::MINUS_1)) return n->in(1);\n+  }\n+  return n;\n+}\n+\n+Node* CompressBitsNode::Identity(PhaseGVN* phase) {\n+  return compress_expand_identity(phase, this);\n+}\n+\n+\n+Node* ExpandBitsNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* src = in(1);\n+  Node* mask = in(2);\n+  if (bottom_type()->isa_int()) {\n+    if (mask->Opcode() == Op_LShiftI && phase->type(mask->in(1))->is_int()->is_con()) {\n+      \/\/ expand(x, 1 << n) == (x & 1) << n\n+      if (phase->type(mask->in(1))->higher_equal(TypeInt::ONE)) {\n+        Node* andnode = phase->transform(new AndINode(in(1), phase->makecon(TypeInt::ONE)));\n+        return new LShiftINode(andnode, mask->in(2));\n+      \/\/ expand(x, -1 << n) == x << n\n+      } else if (phase->type(mask->in(1))->higher_equal(TypeInt::MINUS_1)) {\n+        return new LShiftINode(in(1), mask->in(2));\n+      }\n+    }\n+    \/\/ expand(compress(x, m), m) == x & m\n+    if (src->Opcode() == Op_CompressBits &&\n+        src->in(2) == mask) {\n+      return new AndINode(src->in(1), mask);\n+    }\n+  } else {\n+    assert(bottom_type()->isa_long(), \"\");\n+    if (mask->Opcode() == Op_LShiftL && phase->type(mask->in(1))->is_long()->is_con()) {\n+      \/\/ expand(x, 1 << n) == (x & 1) << n\n+      if (phase->type(mask->in(1))->higher_equal(TypeLong::ONE)) {\n+        Node* andnode = phase->transform(new AndLNode(in(1), phase->makecon(TypeLong::ONE)));\n+        return new LShiftLNode(andnode, mask->in(2));\n+      \/\/ expand(x, -1 << n) == x << n\n+      } else if (phase->type(mask->in(1))->higher_equal(TypeLong::MINUS_1)) {\n+        return new LShiftLNode(in(1), mask->in(2));\n+      }\n+    }\n+    \/\/ expand(compress(x, m), m) == x & m\n+    if (src->Opcode() == Op_CompressBits &&\n+        src->in(2) == mask) {\n+      return new AndLNode(src->in(1), mask);\n+    }\n+  }\n+  return NULL;\n+}\n+\n+Node* ExpandBitsNode::Identity(PhaseGVN* phase) {\n+  return compress_expand_identity(phase, this);\n+}\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":108,"deletions":0,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -264,0 +264,23 @@\n+\/\/----------------------------CompressBits\/ExpandBits---------------------------\n+class CompressBitsNode : public TypeNode {\n+ public:\n+  CompressBitsNode(Node* in1, Node* in2, const Type* type) : TypeNode(type, 3) {\n+    init_req(1, in1);\n+    init_req(2, in2);\n+  }\n+  virtual int Opcode() const;\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n+};\n+\n+class ExpandBitsNode : public TypeNode {\n+ public:\n+  ExpandBitsNode(Node* in1, Node* in2, const Type* type) : TypeNode(type, 3) {\n+    init_req(1, in1);\n+    init_req(2, in2);\n+  }\n+  virtual int Opcode() const;\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n+\n+};\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -530,0 +530,5 @@\n+  case vmIntrinsics::_compress_i:\n+  case vmIntrinsics::_compress_l:\n+  case vmIntrinsics::_expand_i:\n+  case vmIntrinsics::_expand_l:                 return inline_bitshuffle_methods(intrinsic_id());\n+\n@@ -2198,0 +2203,18 @@\n+\/\/--------------------------inline_bitshuffle_methods-----------------------------\n+\/\/ inline int Integer.compress(int, int)\n+\/\/ inline int Integer.expand(int, int)\n+\/\/ inline long Long.compress(long, long)\n+\/\/ inline long Long.expand(long, long)\n+bool LibraryCallKit::inline_bitshuffle_methods(vmIntrinsics::ID id) {\n+  Node* n = NULL;\n+  switch (id) {\n+    case vmIntrinsics::_compress_i:  n = new CompressBitsNode(argument(0), argument(1), TypeInt::INT); break;\n+    case vmIntrinsics::_expand_i:    n = new ExpandBitsNode(argument(0),  argument(1), TypeInt::INT); break;\n+    case vmIntrinsics::_compress_l:  n = new CompressBitsNode(argument(0), argument(2), TypeLong::LONG); break;\n+    case vmIntrinsics::_expand_l:    n = new ExpandBitsNode(argument(0), argument(2), TypeLong::LONG); break;\n+    default:  fatal_unexpected_iid(id);  break;\n+  }\n+  set_result(_gvn.transform(n));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -267,0 +267,1 @@\n+  bool inline_bitshuffle_methods(vmIntrinsics::ID id);\n@@ -336,0 +337,1 @@\n+  Node* gen_bitshuffle_operation(int voper, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n@@ -348,0 +350,1 @@\n+  bool arch_supports_vector_bitshuffle(int opc, int num_elem, BasicType elem_bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -392,16 +392,0 @@\n-\/\/------------------------------CompressBitsNode-------------------------------\n-\/\/ CompressBits placeholder node\n-class CompressBitsNode : public Node {\n-public:\n-  CompressBitsNode(Node *in1, Node *in2) : Node(0,in1,in2) {}\n-  virtual int Opcode() const;\n-};\n-\n-\/\/------------------------------ExpandBitsNode---------------------------------\n-\/\/ ExpandBits placeholder node\n-class ExpandBitsNode : public Node {\n-public:\n-  ExpandBitsNode(Node *in1, Node *in2) : Node(0,in1,in2) {}\n-  virtual int Opcode() const;\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -70,0 +70,14 @@\n+bool LibraryCallKit::arch_supports_vector_bitshuffle(int opc, int num_elem, BasicType elem_bt) {\n+  \/\/ Currently Vectorized bit compression and expansion may be supported through their\n+  \/\/ scalar counterparts using lane exaction and insertion operations.\n+  int eopc = ExtractNode::opcode(elem_bt);\n+  int sopc = opc == Op_CompressBitsV ? Op_CompressBits : Op_ExpandBits;\n+  if (!Matcher::match_rule_supported_vector(opc, num_elem, elem_bt) &&\n+      (!Matcher::match_rule_supported_vector(sopc, num_elem, elem_bt) ||\n+       !Matcher::match_rule_supported_vector(eopc, num_elem, elem_bt) ||\n+       !Matcher::match_rule_supported_vector(Op_VectorInsert, num_elem, elem_bt))) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n@@ -203,0 +217,10 @@\n+#endif\n+      return false;\n+    }\n+  } else if (VectorNode::is_bitshuffle_opcode(sopc)) {\n+    if(!arch_supports_vector_bitshuffle(sopc, num_elem, type)) {\n+#ifndef PRODUCT\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support variable vector shifts\",\n+                      NodeClassNames[sopc], type2name(type), num_elem);\n+      }\n@@ -325,0 +349,18 @@\n+Node* LibraryCallKit::gen_bitshuffle_operation(int voper, BasicType elem_bt, int num_elem, Node* opd1, Node* opd2) {\n+  \/\/ Vectorized bit compression and expansion operations are supported using their\n+  \/\/ scalar counterparts, lane exaction and insertion operations.\n+  assert(elem_bt == T_INT || elem_bt == T_LONG, \"\");\n+  const Type* type_bt = Type::get_const_basic_type(elem_bt);\n+  Node* dst = VectorNode::scalar2vector(gvn().zerocon(elem_bt), num_elem, type_bt);\n+  for(int i = 0; i < num_elem; i++) {\n+    dst = gvn().transform(dst);\n+    Node* src_elem = gvn().transform(ExtractNode::make(opd1, i, elem_bt));\n+    Node* mask_elem = gvn().transform(ExtractNode::make(opd2, i, elem_bt));\n+    Node* oper = voper == Op_CompressBits ? (Node*)new CompressBitsNode(src_elem, mask_elem, type_bt)\n+                                          : (Node*)new ExpandBitsNode(src_elem, mask_elem, type_bt);\n+    oper = gvn().transform(oper);\n+    dst = VectorInsertNode::make(dst, oper, i);\n+  }\n+  return dst;\n+}\n+\n@@ -545,0 +587,2 @@\n+  } else if (VectorNode::is_bitshuffle_opcode(sopc) && !Matcher::match_rule_supported_vector(sopc, num_elem, elem_bt)) {\n+    operation = gen_bitshuffle_operation(opc, elem_bt, num_elem, opd1, opd2);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -176,2 +176,1 @@\n-    \/\/ Not implemented. Returning 0 temporarily\n-    return 0;\n+    return (bt == T_INT || bt == T_LONG ? Op_CompressBitsV : 0);\n@@ -179,2 +178,1 @@\n-    \/\/ Not implemented. Returning 0 temporarily\n-    return 0;\n+    return (bt == T_INT || bt == T_LONG ? Op_ExpandBitsV : 0);\n@@ -445,0 +443,10 @@\n+bool VectorNode::is_bitshuffle_opcode(int opc) {\n+  switch (opc) {\n+  case Op_CompressBitsV:\n+  case Op_ExpandBitsV:\n+    return true;\n+  default:\n+    return false;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+  static bool is_bitshuffle_opcode(int opc);\n+\n@@ -1731,0 +1733,16 @@\n+\n+class ExpandBitsVNode : public VectorNode {\n+public:\n+  ExpandBitsVNode(Node* in, Node* mask, const TypeVect* vt)\n+  : VectorNode(in, mask, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n+class CompressBitsVNode : public VectorNode {\n+public:\n+  CompressBitsVNode(Node* in, Node* mask, const TypeVect* vt)\n+  : VectorNode(in, mask, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1842,1 +1842,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n@@ -1930,1 +1930,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1981,1 +1981,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n@@ -2069,1 +2069,1 @@\n-    \/\/ @IntrinsicCandidate\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -872,1 +872,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> Integer.compress(a, n));\n@@ -874,1 +874,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> Integer.expand(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -830,1 +830,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> Long.compress(a, n));\n@@ -832,1 +832,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> Long.expand(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -972,1 +972,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.compress(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> $Boxtype$.compress(a, n));\n@@ -974,1 +974,1 @@\n-                    v0.bOp(v1, vm, (i, a, n) -> CompressExpand.expand(a, n));\n+                    v0.bOp(v1, vm, (i, a, n) -> $Boxtype$.expand(a, n));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8285281\n+ * @key randomness\n+ * @summary To test various tansforms added for bit COMPRESS_BITS and EXPAND_BITS operations\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.cpu.features ~= \".*bmi2.*\"\n+ * @requires os.simpleArch == \"x64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.intrinsics.TestBitShuffleOpers\n+ *\/\n+\n+package compiler.intrinsics;\n+\n+import java.util.concurrent.Callable;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+\n+public class TestBitShuffleOpers {\n+    int [] ri;\n+    int [] ai;\n+    int [] bi;\n+\n+    long [] rl;\n+    long [] al;\n+    long [] bl;\n+\n+    \/\/===================== Compress Bits Transforms ================\n+    @Test\n+    @IR(counts = {\"RShiftI\", \" > 0 \", \"AndI\", \" > 0\"})\n+    public void test1(int[] ri, int[] ai, int[] bi) {\n+        for (int i = 0; i < ri.length; i++) {\n+           ri[i] = Integer.compress(ai[i], 1 << bi[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test1\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test1() {\n+        for (int i = 0; i < 10000; i++) {\n+            test1(ri, ai, bi);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"URShiftI\", \" > 0 \"})\n+    public void test2(int[] ri, int[] ai, int[] bi) {\n+        for (int i = 0; i < ri.length; i++) {\n+           ri[i] = Integer.compress(ai[i], -1 << bi[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test2\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test2() {\n+        for (int i = 0; i < 10000; i++) {\n+            test2(ri, ai, bi);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"CompressBits\", \" > 0 \", \"AndI\" , \" > 0 \"})\n+    public void test3(int[] ri, int[] ai, int[] bi) {\n+        for (int i = 0; i < ri.length; i++) {\n+           ri[i] = Integer.compress(Integer.expand(ai[i], bi[i]), bi[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test3\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test3() {\n+        for (int i = 0; i < 10000; i++) {\n+            test3(ri, ai, bi);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"RShiftL\", \" > 0 \", \"AndL\", \" > 0\"})\n+    public void test4(long[] rl, long[] al, long[] bl) {\n+        for (int i = 0; i < rl.length; i++) {\n+           rl[i] = Long.compress(al[i], 1L << bl[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test4\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test4() {\n+        for (int i = 0; i < 10000; i++) {\n+            test4(rl, al, bl);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"URShiftL\", \" > 0 \"})\n+    public void test5(long[] rl, long[] al, long[] bl) {\n+        for (int i = 0; i < rl.length; i++) {\n+           rl[i] = Long.compress(al[i], -1L << bl[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test5\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test5() {\n+        for (int i = 0; i < 10000; i++) {\n+            test5(rl, al, bl);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"CompressBits\", \" > 0 \", \"AndL\" , \" > 0 \"})\n+    public void test6(long[] rl, long[] al, long[] bl) {\n+        for (int i = 0; i < rl.length; i++) {\n+           rl[i] = Long.compress(Long.expand(al[i], bl[i]), bl[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test6\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test6() {\n+        for (int i = 0; i < 10000; i++) {\n+            test6(rl, al, bl);\n+        }\n+    }\n+    \/\/===================== Expand Bits Transforms ================\n+    @Test\n+    @IR(counts = {\"LShiftI\", \" > 0 \", \"AndI\", \" > 0\"})\n+    public void test7(int[] ri, int[] ai, int[] bi) {\n+        for (int i = 0; i < ri.length; i++) {\n+           ri[i] = Integer.expand(ai[i], 1 << bi[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test7\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test7() {\n+        for (int i = 0; i < 10000; i++) {\n+            test7(ri, ai, bi);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"LShiftI\", \" > 0 \"})\n+    public void test8(int[] ri, int[] ai, int[] bi) {\n+        for (int i = 0; i < ri.length; i++) {\n+           ri[i] = Integer.expand(ai[i], -1 << bi[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test8\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test8() {\n+        for (int i = 0; i < 10000; i++) {\n+            test8(ri, ai, bi);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"AndI\" , \" > 0 \"})\n+    public void test9(int[] ri, int[] ai, int[] bi) {\n+        for (int i = 0; i < ri.length; i++) {\n+           ri[i] = Integer.expand(Integer.compress(ai[i], bi[i]), bi[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test9\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test9() {\n+        for (int i = 0; i < 10000; i++) {\n+            test9(ri, ai, bi);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"LShiftL\", \" > 0 \", \"AndL\", \" > 0\"})\n+    public void test10(long[] rl, long[] al, long[] bl) {\n+        for (int i = 0; i < rl.length; i++) {\n+           rl[i] = Long.expand(al[i], 1L << bl[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test10\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test10() {\n+        for (int i = 0; i < 10000; i++) {\n+            test10(rl, al, bl);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"LShiftL\", \" > 0 \"})\n+    public void test11(long[] rl, long[] al, long[] bl) {\n+        for (int i = 0; i < rl.length; i++) {\n+           rl[i] = Long.expand(al[i], -1L << bl[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test11\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test11() {\n+        for (int i = 0; i < 10000; i++) {\n+            test11(rl, al, bl);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {\"AndL\" , \" > 0 \"})\n+    public void test12(long[] rl, long[] al, long[] bl) {\n+        for (int i = 0; i < rl.length; i++) {\n+           rl[i] = Long.expand(Long.compress(al[i], bl[i]), bl[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"test12\"}, mode = RunMode.STANDALONE)\n+    public void kernel_test12() {\n+        for (int i = 0; i < 10000; i++) {\n+            test12(rl, al, bl);\n+        }\n+    }\n+    \/\/ ===================================================== \/\/\n+\n+    private static final Random R = Utils.getRandomInstance();\n+\n+    static int[] fillIntRandom(Callable<int[]> factory) {\n+        try {\n+            int[] arr = factory.call();\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = R.nextInt();\n+            }\n+            return arr;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+    static long[] fillLongRandom(Callable<long[]> factory) {\n+        try {\n+            long[] arr = factory.call();\n+            for (int i = 0; i < arr.length; i++) {\n+                arr[i] = R.nextLong();\n+            }\n+            return arr;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/\/ ===================================================== \/\/\n+\n+    static final int SIZE = 512;\n+\n+\n+    public TestBitShuffleOpers() {\n+        ri = new int[SIZE];\n+        ai = fillIntRandom(()-> new int[SIZE]);\n+        bi = fillIntRandom(()-> new int[SIZE]);\n+\n+        rl = new long[SIZE];\n+        al = fillLongRandom(() -> new long[SIZE]);\n+        bl = fillLongRandom(() -> new long[SIZE]);\n+\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                   \"-XX:UseAVX=3\",\n+                                   \"--add-modules=jdk.incubator.vector\",\n+                                   \"-XX:CompileThresholdScaling=0.3\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestBitShuffleOpers.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"}]}