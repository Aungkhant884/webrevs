{"files":[{"patch":"@@ -160,12 +160,5 @@\n-  if (n->bottom_type()->isa_int()) {\n-    \/\/ compress(x, 0) == 0\n-    if(phase->type(n->in(2))->higher_equal(TypeInt::ZERO)) return n->in(2);\n-    \/\/ compress(x, -1) == x\n-    if(phase->type(n->in(2))->higher_equal( TypeInt::MINUS_1)) return n->in(1);\n-  } else {\n-    assert(n->bottom_type()->isa_long(), \"\");\n-    \/\/ compress(x, 0) == 0\n-    if(phase->type(n->in(2))->higher_equal(TypeLong::ZERO)) return n->in(2);\n-    \/\/ compress(x, -1) == x\n-    if(phase->type(n->in(2))->higher_equal( TypeLong::MINUS_1)) return n->in(1);\n-  }\n+  BasicType bt = n->bottom_type()->array_element_basic_type();\n+  \/\/ compress(x, 0) == 0\n+  if(phase->type(n->in(2))->higher_equal(TypeInteger::zero(bt)) return n->in(2);\n+  \/\/ compress(x, -1) == x\n+  if(phase->type(n->in(2))->higher_equal(TypeInteger::minus_1(bt)) return n->in(1);\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -264,0 +264,1 @@\n+\n@@ -285,1 +286,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support variable vector shifts\",\n+        tty->print_cr(\"  ** Rejected vector op (%s,%s,%d) because architecture does not support bitshuffle operations\",\n@@ -349,1 +349,1 @@\n-Node* LibraryCallKit::gen_bitshuffle_operation(int voper, BasicType elem_bt, int num_elem, Node* opd1, Node* opd2) {\n+Node* LibraryCallKit::gen_bitshuffle_operation(int opc, BasicType elem_bt, int num_elem, Node* opd1, Node* opd2) {\n@@ -353,0 +353,1 @@\n+  assert(opc == Op_CompressBits || opc == Op_ExpandBits, \"\");\n@@ -359,2 +360,2 @@\n-    Node* oper = voper == Op_CompressBits ? (Node*)new CompressBitsNode(src_elem, mask_elem, type_bt)\n-                                          : (Node*)new ExpandBitsNode(src_elem, mask_elem, type_bt);\n+    Node* oper = opc == Op_CompressBits ? (Node*)new CompressBitsNode(src_elem, mask_elem, type_bt)\n+                                        : (Node*)new ExpandBitsNode(src_elem, mask_elem, type_bt);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}