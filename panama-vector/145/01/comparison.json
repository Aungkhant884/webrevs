{"files":[{"patch":"@@ -1094,0 +1094,12 @@\n+  do_intrinsic(_VectorSelectiveOp, jdk_internal_vm_vector_VectorSupport, vector_selective_op_name, vector_selective_op_sig, F_S)               \\\n+   do_signature(vector_selective_op_sig, \"(Z\"                                                                                                  \\\n+                                         \"Ljava\/lang\/Class;\"                                                                                   \\\n+                                         \"Ljava\/lang\/Class;\"                                                                                   \\\n+                                         \"Ljava\/lang\/Class;\"                                                                                   \\\n+                                         \"I\"                                                                                                   \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                       \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;\"                                                   \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSelectiveOp;)\"                                           \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                      \\\n+   do_name(vector_selective_op_name, \"selectiveOp\")                                                                                            \\\n+                                                                                                                                               \\\n@@ -1202,1 +1214,1 @@\n-  LAST_COMPILER_INLINE = _VectorMaskOp,\n+  LAST_COMPILER_INLINE = _VectorSelectiveOp,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -700,0 +700,1 @@\n+  case vmIntrinsics::_VectorSelectiveOp:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -683,0 +683,2 @@\n+  case vmIntrinsics::_VectorSelectiveOp:\n+    return inline_vector_compress_expand();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -332,0 +332,1 @@\n+  bool inline_vector_compress_expand();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2691,0 +2691,92 @@\n+\/\/ public static\n+\/\/ <V extends Vector<E>,\n+\/\/  M extends VectorMask<E>,\n+\/\/  E>\n+\/\/ V selectiveOp(boolean is_compress,\n+\/\/               Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+\/\/               int length,\n+\/\/               V v, M m,\n+\/\/               VectorSelectiveOp<V, M> defaultImpl)\n+\/\/\n+bool LibraryCallKit::inline_vector_compress_expand() {\n+  const TypeInt*     opr          = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+\n+  if (vector_klass == NULL || mask_klass == NULL || elem_klass == NULL || opr == NULL || vlen == NULL ||\n+      vector_klass->const_oop() == NULL || mask_klass->const_oop() == NULL || elem_klass->const_oop() == NULL ||\n+      !(opr == TypeInt::ONE || opr == TypeInt::ZERO) || !vlen->is_con()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(3)->Opcode()],\n+                    NodeClassNames[argument(4)->Opcode()]);\n+    }\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(vector_klass) || !is_klass_initialized(mask_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  const Type* vmask_type = gvn().type(argument(6));\n+  if (vmask_type->maybe_null()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** null mask values are not allowed for compress\/expand\");\n+    }\n+    return false;\n+  }\n+\n+  bool is_compress = (opr == TypeInt::ONE);\n+  int num_elem = vlen->get_con();\n+  int sopc = is_compress ? Op_CompressV : Op_ExpandV;\n+\n+  BasicType elem_bt = elem_type->basic_type();\n+  BasicType mask_bt = elem_bt;\n+\n+  if (!arch_supports_vector(sopc, num_elem, elem_bt, VecMaskUsePred)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: arity=2 op=compress vlen=%d etype=%s ismask=useload\",\n+                    num_elem, type2name(elem_bt));\n+    }\n+    return false; \/\/ not supported\n+  }\n+  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+\n+  ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);\n+\n+  Node* vec1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+  Node* mask = unbox_vector(argument(6), mbox_type, mask_bt, num_elem);\n+\n+  if (vec1 == NULL || mask == NULL) {\n+    return false; \/\/ operand unboxing failed\n+  }\n+\n+  Node* ret;\n+  if (is_compress) {\n+    ret = gvn().transform(new CompressVNode(vec1, mask));\n+  }\n+\n+  Node* box = box_vector(ret, vbox_type, elem_bt, num_elem);\n+  set_result(box);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -654,0 +654,21 @@\n+    public interface VectorSelectiveOp<V extends Vector<?>,\n+                                       M extends VectorMask<?>> {\n+        V apply(V v, M m);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     M extends VectorMask<E>,\n+     E>\n+    V selectiveOp(boolean is_compress,\n+                  Class<? extends V> vClass, Class<M> mClass, Class<E> eClass,\n+                  int length,\n+                  V v, M m,\n+                  VectorSelectiveOp<V, M> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v, m);\n+    }\n+\n+    \/* ============================================================================ *\/\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}