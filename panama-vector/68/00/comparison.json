{"files":[{"patch":"@@ -2454,0 +2454,4 @@\n+bool Matcher::supports_unsigned_vector_comparison(int vlen, BasicType bt) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1008,0 +1008,4 @@\n+bool Matcher::supports_unsigned_vector_comparison(int vlen, BasicType bt) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2171,0 +2171,4 @@\n+bool Matcher::supports_unsigned_vector_comparison(int vlen, BasicType bt) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1561,0 +1561,4 @@\n+bool Matcher::supports_unsigned_vector_comparison(int vlen, BasicType bt) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3861,10 +3861,0 @@\n-void Assembler::evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {\n-  assert(VM_Version::supports_avx512vlbw(), \"\");\n-  InstructionAttr attributes(vector_len, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n-  attributes.reset_is_clear_context();\n-  attributes.set_embedded_opmask_register_specifier(mask);\n-  attributes.set_is_evex_instruction();\n-  int encode = vex_prefix_and_encode(kdst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n-  emit_int24(0x3E, (0xC0 | encode), vcc);\n-}\n-\n@@ -8977,1 +8967,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -8986,1 +8976,2 @@\n-  emit_int24(0x1F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -8990,1 +8981,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9002,1 +8993,2 @@\n-  emit_int8((unsigned char)0x1F);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int8((unsigned char)opcode);\n@@ -9008,1 +9000,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9017,1 +9009,2 @@\n-  emit_int24(0x1F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -9021,1 +9014,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9033,1 +9026,2 @@\n-  emit_int8((unsigned char)0x1F);\n+  int opcode = is_signed ? 0x1F : 0x1E;\n+  emit_int8((unsigned char)opcode);\n@@ -9039,1 +9033,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9049,1 +9043,2 @@\n-  emit_int24(0x3F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -9053,1 +9048,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9066,1 +9061,2 @@\n-  emit_int8((unsigned char)0x3F);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int8((unsigned char)opcode);\n@@ -9072,1 +9068,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9082,1 +9078,2 @@\n-  emit_int24(0x3F, (0xC0 | encode), comparison);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int24(opcode, (0xC0 | encode), comparison);\n@@ -9086,1 +9083,1 @@\n-                        int comparison, int vector_len) {\n+                        int comparison, bool is_signed, int vector_len) {\n@@ -9099,1 +9096,2 @@\n-  emit_int8((unsigned char)0x3F);\n+  int opcode = is_signed ? 0x3F : 0x3E;\n+  emit_int8((unsigned char)opcode);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":24,"deletions":26,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1708,1 +1708,0 @@\n-  void evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate of, int vector_len);\n@@ -2449,1 +2448,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2451,1 +2450,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2455,1 +2454,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2457,1 +2456,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2461,1 +2460,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2463,1 +2462,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2467,1 +2466,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n@@ -2469,1 +2468,1 @@\n-               int comparison, int vector_len);\n+               int comparison, bool is_signed, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2117,1 +2117,1 @@\n-      evpcmpb(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpb(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2120,1 +2120,1 @@\n-      evpcmpw(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpw(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2124,1 +2124,1 @@\n-      evpcmpd(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpd(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2128,1 +2128,1 @@\n-      evpcmpq(kdmask, ksmask, src1, adr, comparison, vector_len, scratch);\n+      evpcmpq(kdmask, ksmask, src1, adr, comparison, \/*signed*\/ true, vector_len, scratch);\n@@ -2136,0 +2136,84 @@\n+void C2_MacroAssembler::vpcmpu(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison,\n+                            int vlen_in_bytes, XMMRegister vtmp1, XMMRegister vtmp2, Register scratch) {\n+  int vlen_enc = vector_length_encoding(vlen_in_bytes*2);\n+  switch (typ) {\n+  case T_BYTE:\n+    vpmovzxbw(vtmp1, src1, vlen_enc);\n+    vpmovzxbw(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_short_to_byte_mask()), vlen_enc, scratch);\n+    vpackuswb(dst, dst, dst, vlen_enc);\n+    break;\n+  case T_SHORT:\n+    vpmovzxwd(vtmp1, src1, vlen_enc);\n+    vpmovzxwd(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n+    vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_int_to_short_mask()), vlen_enc, scratch);\n+    vpackusdw(dst, dst, dst, vlen_enc);\n+    break;\n+  case T_INT:\n+    vpmovzxdq(vtmp1, src1, vlen_enc);\n+    vpmovzxdq(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n+    vpermilps(dst, dst, 8, vlen_enc);\n+    break;\n+  default:\n+    assert(false, \"Should not reach here\");\n+  }\n+  if (vlen_in_bytes == 16) {\n+    vpermpd(dst, dst, 0x8, vlen_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vpcmpu32(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n+                              XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3, Register scratch) {\n+  int vlen_enc = vector_length_encoding(vlen_in_bytes);\n+  switch (typ) {\n+  case T_BYTE:\n+    vpmovzxbw(vtmp1, src1, vlen_enc);\n+    vpmovzxbw(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_short_to_byte_mask()), vlen_enc, scratch);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxbw(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxbw(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::W, vlen_enc, scratch);\n+    vpand(vtmp3, vtmp3, ExternalAddress(StubRoutines::x86::vector_short_to_byte_mask()), vlen_enc, scratch);\n+    vpackuswb(dst, dst, vtmp3, vlen_enc);\n+    vpermpd(dst, dst, 0xd8, vlen_enc);\n+    break;\n+  case T_SHORT:\n+    vpmovzxwd(vtmp1, src1, vlen_enc);\n+    vpmovzxwd(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::D, vlen_enc, scratch);\n+    vpand(dst, dst, ExternalAddress(StubRoutines::x86::vector_int_to_short_mask()), vlen_enc, scratch);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxwd(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxwd(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::D,  vlen_enc, scratch);\n+    vpand(vtmp3, vtmp3, ExternalAddress(StubRoutines::x86::vector_int_to_short_mask()), vlen_enc, scratch);\n+    vpackusdw(dst, dst, vtmp3, vlen_enc);\n+    vpermpd(dst, dst, 0xd8, vlen_enc);\n+    break;\n+  case T_INT:\n+    vpmovzxdq(vtmp1, src1, vlen_enc);\n+    vpmovzxdq(vtmp2, src2, vlen_enc);\n+    vpcmpCCW(dst, vtmp1, vtmp2, comparison, Assembler::Q, vlen_enc, scratch);\n+    vpermilps(dst, dst, 8, vlen_enc);\n+    vpermpd(dst, dst, 8, vlen_enc);\n+    vextracti128(vtmp1, src1, 1);\n+    vextracti128(vtmp2, src2, 1);\n+    vpmovzxdq(vtmp1, vtmp1, vlen_enc);\n+    vpmovzxdq(vtmp2, vtmp2, vlen_enc);\n+    vpcmpCCW(vtmp3, vtmp1, vtmp2, comparison, Assembler::Q,  vlen_enc, scratch);\n+    vpermilps(vtmp3, vtmp3, 8, vlen_enc);\n+    vpermpd(vtmp3, vtmp3, 0x80, vlen_enc);\n+    vpblendd(dst, dst, vtmp3, 0xf0, vlen_enc);\n+    break;\n+  default:\n+    assert(false, \"Should not reach here\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":88,"deletions":4,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -143,0 +143,6 @@\n+  \/\/ vector compare\n+  void vpcmpu(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n+              XMMRegister vtmp1, XMMRegister vtmp2, Register scratch);\n+  void vpcmpu32(BasicType typ, XMMRegister dst, XMMRegister src1, XMMRegister src2, ComparisonPredicate comparison, int vlen_in_bytes,\n+                XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3, Register scratch);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3145,1 +3145,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3147,1 +3147,1 @@\n-    Assembler::evpcmpd(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpd(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3150,1 +3150,1 @@\n-    Assembler::evpcmpd(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpd(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3155,1 +3155,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3157,1 +3157,1 @@\n-    Assembler::evpcmpq(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpq(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3160,1 +3160,1 @@\n-    Assembler::evpcmpq(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpq(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3165,1 +3165,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3167,1 +3167,1 @@\n-    Assembler::evpcmpb(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpb(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3170,1 +3170,1 @@\n-    Assembler::evpcmpb(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpb(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -3175,1 +3175,1 @@\n-                             int comparison, int vector_len, Register scratch_reg) {\n+                             int comparison, bool is_signed, int vector_len, Register scratch_reg) {\n@@ -3177,1 +3177,1 @@\n-    Assembler::evpcmpw(kdst, mask, nds, as_Address(src), comparison, vector_len);\n+    Assembler::evpcmpw(kdst, mask, nds, as_Address(src), comparison, is_signed, vector_len);\n@@ -3180,1 +3180,1 @@\n-    Assembler::evpcmpw(kdst, mask, nds, Address(scratch_reg, 0), comparison, vector_len);\n+    Assembler::evpcmpw(kdst, mask, nds, Address(scratch_reg, 0), comparison, is_signed, vector_len);\n@@ -7860,1 +7860,1 @@\n-    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    evpcmpw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, \/*signed*\/ false, Assembler::AVX_512bit);\n@@ -7910,1 +7910,1 @@\n-    evpcmpuw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);\n+    evpcmpw(mask1, mask2, tmp1Reg, tmp2Reg, Assembler::le, \/*signed*\/ false, Assembler::AVX_512bit);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1288,1 +1288,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpd(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpd(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1290,1 +1290,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1292,1 +1292,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpq(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpq(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1294,1 +1294,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1296,1 +1296,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpb(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpb(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1298,1 +1298,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n@@ -1300,1 +1300,1 @@\n-               int comparison, int vector_len) { Assembler::evpcmpw(kdst, mask, nds, src, comparison, vector_len); }\n+               int comparison, bool is_signed, int vector_len) { Assembler::evpcmpw(kdst, mask, nds, src, comparison, is_signed, vector_len); }\n@@ -1302,1 +1302,1 @@\n-               int comparison, int vector_len, Register scratch_reg);\n+               int comparison, bool is_signed, int vector_len, Register scratch_reg);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1277,0 +1277,4 @@\n+static inline bool is_unsigned_booltest_pred(int bt) {\n+  return  ((bt & BoolTest::unsigned_compare) == BoolTest::unsigned_compare);\n+}\n+\n@@ -1881,0 +1885,16 @@\n+bool Matcher::supports_unsigned_vector_comparison(int vlen, BasicType bt) {\n+  if ((UseAVX > 2) && (VM_Version::supports_avx512vl() || vlen == 64))\n+    return true;\n+  else {\n+    \/\/ instruction set supports only signed comparison\n+    \/\/ so need to zero extend to higher integral type and perform comparison\n+    \/\/ cannot cast long to higher integral type\n+    \/\/ and on avx1 cannot cast 128 bit integral vectors to higher size\n+\n+    if ((bt != T_LONG)  &&\n+        ((UseAVX >= 2) || (vlen <= 8)))\n+      return true;\n+  }\n+  return false;\n+}\n+\n@@ -2180,6 +2200,16 @@\n-    case BoolTest::eq: return Assembler::eq;\n-    case BoolTest::ne: return Assembler::neq;\n-    case BoolTest::le: return Assembler::le;\n-    case BoolTest::ge: return Assembler::nlt;\n-    case BoolTest::lt: return Assembler::lt;\n-    case BoolTest::gt: return Assembler::nle;\n+    case BoolTest::eq:\n+      return Assembler::eq;\n+    case BoolTest::ne:\n+      return Assembler::neq;\n+    case BoolTest::le:\n+    case BoolTest::ule:\n+      return Assembler::le;\n+    case BoolTest::ge:\n+    case BoolTest::uge:\n+      return Assembler::nlt;\n+    case BoolTest::lt:\n+    case BoolTest::ult:\n+      return Assembler::lt;\n+    case BoolTest::gt:\n+    case BoolTest::ugt:\n+      return Assembler::nle;\n@@ -6869,1 +6899,3 @@\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+  predicate((UseAVX <= 2 || !VM_Version::supports_avx512vl()) && \n+            !is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n@@ -6884,2 +6916,5 @@\n-instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n-  predicate(vector_length_in_bytes(n->in(1)->in(1)) == 64 && \/\/ src1\n+instruct vcmpu(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, rRegP scratch) %{\n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) && \n+            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) >=  8 && \/\/ src1\n+            vector_length_in_bytes(n->in(1)->in(1)) <= 16 && \/\/ src1\n@@ -6888,0 +6923,36 @@\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP scratch);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    Assembler::ComparisonPredicate cmp = booltest_pred_to_comparison_pred($cond$$constant);\n+    BasicType bt = vector_element_basic_type(this, $src1);\n+    __ vpcmpu(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n+              $vtmp2$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcmpu32(legVec dst, legVec src1, legVec src2, immI8 cond, legVec vtmp1, legVec vtmp2, legVec vtmp3, rRegP scratch) %{\n+  predicate((UseAVX == 2 || !VM_Version::supports_avx512vl()) && \n+            is_unsigned_booltest_pred(n->in(2)->get_int()) &&\n+            vector_length_in_bytes(n->in(1)->in(1)) == 32 && \/\/ src1\n+            is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n+  effect(TEMP dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP scratch);\n+  format %{ \"vector_compareu $dst,$src1,$src2,$cond\\t! using $scratch as TEMP\" %}\n+  ins_encode %{\n+    int vlen = vector_length_in_bytes(this, $src1);\n+    Assembler::ComparisonPredicate cmp = booltest_pred_to_comparison_pred($cond$$constant);\n+    BasicType bt = vector_element_basic_type(this, $src1);\n+    __ vpcmpu32(bt, $dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen, $vtmp1$$XMMRegister,\n+                $vtmp2$$XMMRegister, $vtmp3$$XMMRegister, $scratch$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct evcmp(vec dst, vec src1, vec src2, immI8 cond, rRegP scratch, kReg ktmp) %{\n+  predicate(UseAVX > 2 && \n+            (VM_Version::supports_avx512vl() ||  \n+             vector_length_in_bytes(n->in(1)->in(1)) == 64) && \/\/ src1\n+             is_integral_type(vector_element_basic_type(n->in(1)->in(1)))); \/\/ src1\n+  match(Set dst (VectorMaskCmp (Binary src1 src2) cond));\n@@ -6893,1 +6964,1 @@\n-    int vlen_enc = Assembler::AVX_512bit;\n+    int vlen_enc = vector_length_encoding(this, $src1);\n@@ -6895,0 +6966,1 @@\n+    bool is_unsigned = is_unsigned_booltest_pred($cond$$constant);\n@@ -6901,1 +6973,1 @@\n-        __ evpcmpb($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpb($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6906,1 +6978,1 @@\n-        __ evpcmpw($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpw($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6911,1 +6983,1 @@\n-        __ evpcmpd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpd($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6913,0 +6985,1 @@\n+\n@@ -6916,1 +6989,1 @@\n-        __ evpcmpq($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, vlen_enc);\n+        __ evpcmpq($ktmp$$KRegister, mask, $src1$$XMMRegister, $src2$$XMMRegister, cmp, !is_unsigned, vlen_enc);\n@@ -6920,1 +6993,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":87,"deletions":15,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -356,0 +356,3 @@\n+  \/\/ Does the CPU supports vector unsigned comparison instructions for given vector length and type?\n+  static bool supports_unsigned_vector_comparison(int vlen, BasicType bt);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+\/\/ For vector compares, additionally, the 4th bit indicates if the compare is unsigned\n@@ -308,1 +309,5 @@\n-  enum mask { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1, overflow = 2, no_overflow = 6, never = 8, illegal = 9 };\n+  enum mask { eq = 0, ne = 4, le = 5, ge = 7, lt = 3, gt = 1, overflow = 2, no_overflow = 6, never = 8, illegal = 9,\n+              \/\/ The following values are used with vector compares\n+              \/\/ A BoolTest value should not be constructed for such values\n+              unsigned_compare = 16,\n+              ule = unsigned_compare | le, uge = unsigned_compare | ge, ult = unsigned_compare | lt, ugt = unsigned_compare | gt };\n@@ -310,1 +315,1 @@\n-  BoolTest( mask btm ) : _test(btm) {}\n+  BoolTest( mask btm ) : _test(btm) { assert((btm & unsigned_compare) == 0, \"unsupported\");}\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1201,0 +1201,10 @@\n+  if ((cond->get_con() & BoolTest::unsigned_compare) != 0) {\n+    if (!Matcher::supports_unsigned_vector_comparison(num_elem, elem_bt)) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** not supported: unsigned comparison op=comp\/%d vlen=%d etype=%s ismask=usestore\",\n+                      cond->get_con() & (BoolTest::unsigned_compare - 1), num_elem, type2name(elem_bt));\n+      }\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -32,3 +31,0 @@\n-import java.nio.Buffer;\n-import java.nio.ByteBuffer;\n-import java.util.Objects;\n@@ -92,9 +88,19 @@\n-    \/\/ enum BoolTest\n-    public static final int BT_eq = 0;\n-    public static final int BT_ne = 4;\n-    public static final int BT_le = 5;\n-    public static final int BT_ge = 7;\n-    public static final int BT_lt = 3;\n-    public static final int BT_gt = 1;\n-    public static final int BT_overflow = 2;\n-    public static final int BT_no_overflow = 6;\n+    \/\/ See src\/hotspot\/share\/opto\/subnode.hpp\n+    \/\/     struct BoolTest, and enclosed enum mask\n+    public static final int BT_eq = 0;  \/\/ 0000\n+    public static final int BT_ne = 4;  \/\/ 0100\n+    public static final int BT_le = 5;  \/\/ 0101\n+    public static final int BT_ge = 7;  \/\/ 0111\n+    public static final int BT_lt = 3;  \/\/ 0011\n+    public static final int BT_gt = 1;  \/\/ 0001\n+    public static final int BT_overflow = 2;     \/\/ 0010\n+    public static final int BT_no_overflow = 6;  \/\/ 0110\n+    \/\/ never = 8    1000\n+    \/\/ illegal = 9  1001\n+    \/\/ Unsigned comparisons apply to BT_le, BT_ge, BT_lt, BT_gt for integral types\n+    public static final int BT_unsigned_compare = 0b10000;\n+    public static final int BT_ule = BT_le | BT_unsigned_compare;\n+    public static final int BT_uge = BT_ge | BT_unsigned_compare;\n+    public static final int BT_ult = BT_lt | BT_unsigned_compare;\n+    public static final int BT_ugt = BT_gt | BT_unsigned_compare;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, byte a, byte b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1770,11 +1756,14 @@\n-    private static\n-    boolean compareWithOp(int cond, byte a, byte b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, byte a, byte b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Byte.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Byte.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Byte.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Byte.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, double a, double b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1683,11 +1669,10 @@\n-    private static\n-    boolean compareWithOp(int cond, double a, double b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, double a, double b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            default -> throw new AssertionError();\n+        };\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, float a, float b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1695,11 +1681,10 @@\n-    private static\n-    boolean compareWithOp(int cond, float a, float b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, float a, float b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            default -> throw new AssertionError();\n+        };\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, int a, int b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1769,11 +1755,14 @@\n-    private static\n-    boolean compareWithOp(int cond, int a, int b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, int a, int b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Integer.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Integer.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Integer.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Integer.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, long a, long b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1687,11 +1673,14 @@\n-    private static\n-    boolean compareWithOp(int cond, long a, long b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, long a, long b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Long.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Long.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Long.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Long.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -382,14 +382,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, short a, short b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -1770,11 +1756,14 @@\n-    private static\n-    boolean compareWithOp(int cond, short a, short b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, short a, short b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+            case BT_ult -> Short.compareUnsigned(a, b) < 0;\n+            case BT_ule -> Short.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> Short.compareUnsigned(a, b) > 0;\n+            case BT_uge -> Short.compareUnsigned(a, b) >= 0;\n+            default -> throw new AssertionError();\n+        };\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -568,1 +568,8 @@\n-    \/\/ FIXME: add unsigned comparisons\n+    \/** Unsigned compare {@code a<b}.  Integral only. *\/\n+    public static final Comparison UNSIGNED_LT = compare(\"UNSIGNED_LT\", \"<\",  VectorSupport.BT_ult, VO_NOFP);\n+    \/** Unsigned compare {@code a<=b}.  Integral only. *\/\n+    public static final Comparison UNSIGNED_LE = compare(\"UNSIGNED_LE\", \"<=\", VectorSupport.BT_ule, VO_NOFP);\n+    \/** Unsigned compare {@code a>b}.  Integral only. *\/\n+    public static final Comparison UNSIGNED_GT = compare(\"UNSIGNED_GT\", \">\",  VectorSupport.BT_ugt, VO_NOFP);\n+    \/** Unsigned compare {@code a>=b}.  Integral only. *\/\n+    public static final Comparison UNSIGNED_GE = compare(\"UNSIGNED_GE\", \">=\", VectorSupport.BT_uge, VO_NOFP);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -386,14 +386,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    static boolean doBinTest(int cond, $type$ a, $type$ b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a < b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a > b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError(Integer.toHexString(cond));\n-    }\n-\n@@ -2033,11 +2019,16 @@\n-    private static\n-    boolean compareWithOp(int cond, $type$ a, $type$ b) {\n-        switch (cond) {\n-        case BT_eq:  return a == b;\n-        case BT_ne:  return a != b;\n-        case BT_lt:  return a <  b;\n-        case BT_le:  return a <= b;\n-        case BT_gt:  return a >  b;\n-        case BT_ge:  return a >= b;\n-        }\n-        throw new AssertionError();\n+    private static boolean compareWithOp(int cond, $type$ a, $type$ b) {\n+        return switch (cond) {\n+            case BT_eq -> a == b;\n+            case BT_ne -> a != b;\n+            case BT_lt -> a < b;\n+            case BT_le -> a <= b;\n+            case BT_gt -> a > b;\n+            case BT_ge -> a >= b;\n+#if[!FP]\n+            case BT_ult -> $Boxtype$.compareUnsigned(a, b) < 0;\n+            case BT_ule -> $Boxtype$.compareUnsigned(a, b) <= 0;\n+            case BT_ugt -> $Boxtype$.compareUnsigned(a, b) > 0;\n+            case BT_uge -> $Boxtype$.compareUnsigned(a, b) >= 0;\n+#end[!FP]\n+            default -> throw new AssertionError();\n+        };\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":16,"deletions":25,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1046,0 +1046,4 @@\n+            withToString(\"byte[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1169,0 +1173,40 @@\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3341,1 +3385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3361,1 +3405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3384,1 +3428,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3404,1 +3448,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3427,1 +3471,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3447,1 +3491,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3467,1 +3511,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3490,1 +3534,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3510,1 +3554,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3533,1 +3577,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3553,1 +3597,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3576,1 +3620,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3596,1 +3640,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3619,1 +3663,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LTByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LTByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GTByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GTByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3626,0 +3763,95 @@\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LEByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LEByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GEByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GEByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1046,0 +1046,4 @@\n+            withToString(\"byte[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1169,0 +1173,40 @@\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3341,1 +3385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3361,1 +3405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3384,1 +3428,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3404,1 +3448,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3427,1 +3471,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3447,1 +3491,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3467,1 +3511,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3490,1 +3534,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3510,1 +3554,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3533,1 +3577,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3553,1 +3597,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3576,1 +3620,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3596,1 +3640,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3619,1 +3663,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LTByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LTByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GTByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GTByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3626,0 +3763,95 @@\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LEByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LEByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GEByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GEByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1046,0 +1046,4 @@\n+            withToString(\"byte[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1169,0 +1173,40 @@\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3341,1 +3385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3361,1 +3405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3384,1 +3428,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3404,1 +3448,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3427,1 +3471,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3447,1 +3491,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3467,1 +3511,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3490,1 +3534,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3510,1 +3554,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3533,1 +3577,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3553,1 +3597,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3576,1 +3620,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3596,1 +3640,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3619,1 +3663,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LTByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LTByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GTByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GTByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3626,0 +3763,95 @@\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LEByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LEByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GEByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GEByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1046,0 +1046,4 @@\n+            withToString(\"byte[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1169,0 +1173,40 @@\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3341,1 +3385,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3361,1 +3405,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3384,1 +3428,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3404,1 +3448,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3427,1 +3471,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3447,1 +3491,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3467,1 +3511,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3490,1 +3534,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3510,1 +3554,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3533,1 +3577,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3553,1 +3597,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3576,1 +3620,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3596,1 +3640,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3619,1 +3663,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LTByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LTByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GTByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GTByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3626,0 +3763,95 @@\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LEByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LEByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GEByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GEByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1051,0 +1051,4 @@\n+            withToString(\"byte[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1174,0 +1178,40 @@\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3346,1 +3390,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3366,1 +3410,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3389,1 +3433,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3409,1 +3453,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3432,1 +3476,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3452,1 +3496,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3472,1 +3516,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3495,1 +3539,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3515,1 +3559,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3538,1 +3582,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3558,1 +3602,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3581,1 +3625,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3601,1 +3645,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3624,1 +3668,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LTByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LTByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GTByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GTByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3631,0 +3768,95 @@\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_LEByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_LEByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpProvider\")\n+    static void UNSIGNED_GEByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"byteCompareOpMaskProvider\")\n+    static void UNSIGNED_GEByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                VectorMask<Byte> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1178,0 +1178,4 @@\n+            withToString(\"double[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1290,0 +1294,25 @@\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2658,1 +2687,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2678,1 +2707,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2701,1 +2730,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2721,1 +2750,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2744,1 +2773,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2764,1 +2793,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2784,1 +2813,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2807,1 +2836,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2827,1 +2856,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2850,1 +2879,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2870,1 +2899,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2893,1 +2922,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2913,1 +2942,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2936,1 +2965,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2943,0 +2972,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1178,0 +1178,4 @@\n+            withToString(\"double[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1290,0 +1294,25 @@\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2658,1 +2687,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2678,1 +2707,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2701,1 +2730,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2721,1 +2750,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2744,1 +2773,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2764,1 +2793,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2784,1 +2813,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2807,1 +2836,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2827,1 +2856,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2850,1 +2879,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2870,1 +2899,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2893,1 +2922,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2913,1 +2942,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2936,1 +2965,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2943,0 +2972,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1178,0 +1178,4 @@\n+            withToString(\"double[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1290,0 +1294,25 @@\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2658,1 +2687,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2678,1 +2707,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2701,1 +2730,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2721,1 +2750,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2744,1 +2773,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2764,1 +2793,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2784,1 +2813,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2807,1 +2836,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2827,1 +2856,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2850,1 +2879,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2870,1 +2899,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2893,1 +2922,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2913,1 +2942,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2936,1 +2965,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2943,0 +2972,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1178,0 +1178,4 @@\n+            withToString(\"double[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1290,0 +1294,25 @@\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2658,1 +2687,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2678,1 +2707,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2701,1 +2730,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2721,1 +2750,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2744,1 +2773,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2764,1 +2793,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2784,1 +2813,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2807,1 +2836,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2827,1 +2856,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2850,1 +2879,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2870,1 +2899,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2893,1 +2922,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2913,1 +2942,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2936,1 +2965,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2943,0 +2972,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1183,0 +1183,4 @@\n+            withToString(\"double[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (double)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1295,0 +1299,25 @@\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2663,1 +2692,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2683,1 +2712,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2706,1 +2735,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2726,1 +2755,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2749,1 +2778,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2769,1 +2798,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2789,1 +2818,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2812,1 +2841,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2832,1 +2861,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2855,1 +2884,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2875,1 +2904,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2898,1 +2927,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2918,1 +2947,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2941,1 +2970,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2948,0 +2977,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1188,0 +1188,4 @@\n+            withToString(\"float[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1300,0 +1304,25 @@\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2668,1 +2697,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2688,1 +2717,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2711,1 +2740,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2731,1 +2760,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2754,1 +2783,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2774,1 +2803,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2794,1 +2823,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2817,1 +2846,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2837,1 +2866,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2860,1 +2889,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2880,1 +2909,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2903,1 +2932,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2923,1 +2952,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2946,1 +2975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2953,0 +2982,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1188,0 +1188,4 @@\n+            withToString(\"float[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1300,0 +1304,25 @@\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2668,1 +2697,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2688,1 +2717,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2711,1 +2740,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2731,1 +2760,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2754,1 +2783,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2774,1 +2803,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2794,1 +2823,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2817,1 +2846,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2837,1 +2866,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2860,1 +2889,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2880,1 +2909,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2903,1 +2932,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2923,1 +2952,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2946,1 +2975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2953,0 +2982,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1188,0 +1188,4 @@\n+            withToString(\"float[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1300,0 +1304,25 @@\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2668,1 +2697,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2688,1 +2717,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2711,1 +2740,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2731,1 +2760,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2754,1 +2783,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2774,1 +2803,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2794,1 +2823,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2817,1 +2846,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2837,1 +2866,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2860,1 +2889,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2880,1 +2909,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2903,1 +2932,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2923,1 +2952,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2946,1 +2975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2953,0 +2982,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1188,0 +1188,4 @@\n+            withToString(\"float[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1300,0 +1304,25 @@\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2668,1 +2697,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2688,1 +2717,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2711,1 +2740,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2731,1 +2760,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2754,1 +2783,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2774,1 +2803,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2794,1 +2823,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2817,1 +2846,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2837,1 +2866,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2860,1 +2889,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2880,1 +2909,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2903,1 +2932,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2923,1 +2952,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2946,1 +2975,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2953,0 +2982,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1193,0 +1193,4 @@\n+            withToString(\"float[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (float)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1305,0 +1309,25 @@\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n@@ -2673,1 +2702,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2693,1 +2722,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -2716,1 +2745,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -2736,1 +2765,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -2759,1 +2788,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -2779,1 +2808,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2799,1 +2828,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -2822,1 +2851,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -2842,1 +2871,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -2865,1 +2894,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -2885,1 +2914,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -2908,1 +2937,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -2928,1 +2957,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -2951,1 +2980,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n@@ -2958,0 +2987,8 @@\n+\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1006,0 +1006,4 @@\n+            withToString(\"int[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1129,0 +1133,40 @@\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3306,1 +3350,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3326,1 +3370,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3349,1 +3393,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3369,1 +3413,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3392,1 +3436,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3412,1 +3456,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3432,1 +3476,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3455,1 +3499,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3475,1 +3519,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3498,1 +3542,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3518,1 +3562,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3541,1 +3585,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3561,1 +3605,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3584,1 +3628,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LTInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LTInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GTInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GTInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3591,0 +3728,95 @@\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LEInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LEInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GEInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GEInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1006,0 +1006,4 @@\n+            withToString(\"int[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1129,0 +1133,40 @@\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3306,1 +3350,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3326,1 +3370,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3349,1 +3393,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3369,1 +3413,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3392,1 +3436,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3412,1 +3456,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3432,1 +3476,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3455,1 +3499,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3475,1 +3519,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3498,1 +3542,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3518,1 +3562,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3541,1 +3585,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3561,1 +3605,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3584,1 +3628,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LTInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LTInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GTInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GTInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3591,0 +3728,95 @@\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LEInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LEInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GEInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GEInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1006,0 +1006,4 @@\n+            withToString(\"int[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1129,0 +1133,40 @@\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3306,1 +3350,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3326,1 +3370,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3349,1 +3393,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3369,1 +3413,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3392,1 +3436,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3412,1 +3456,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3432,1 +3476,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3455,1 +3499,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3475,1 +3519,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3498,1 +3542,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3518,1 +3562,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3541,1 +3585,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3561,1 +3605,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3584,1 +3628,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LTInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LTInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GTInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GTInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3591,0 +3728,95 @@\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LEInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LEInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GEInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GEInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1006,0 +1006,4 @@\n+            withToString(\"int[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1129,0 +1133,40 @@\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3306,1 +3350,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3326,1 +3370,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3349,1 +3393,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3369,1 +3413,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3392,1 +3436,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3412,1 +3456,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3432,1 +3476,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3455,1 +3499,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3475,1 +3519,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3498,1 +3542,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3518,1 +3562,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3541,1 +3585,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3561,1 +3605,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3584,1 +3628,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LTInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LTInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GTInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GTInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3591,0 +3728,95 @@\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LEInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LEInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GEInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GEInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1011,0 +1011,4 @@\n+            withToString(\"int[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1134,0 +1138,40 @@\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3311,1 +3355,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3331,1 +3375,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3354,1 +3398,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3374,1 +3418,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3397,1 +3441,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3417,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3437,1 +3481,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3460,1 +3504,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3480,1 +3524,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3503,1 +3547,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3523,1 +3567,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3546,1 +3590,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3566,1 +3610,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3589,1 +3633,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LTIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LTIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GTIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GTIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3596,0 +3733,95 @@\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_LEIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_LEIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpProvider\")\n+    static void UNSIGNED_GEIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"intCompareOpMaskProvider\")\n+    static void UNSIGNED_GEIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                VectorMask<Integer> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1032,0 +1032,4 @@\n+            withToString(\"long[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1151,0 +1155,40 @@\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3328,1 +3372,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3348,1 +3392,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3371,1 +3415,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3391,1 +3435,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3414,1 +3458,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3434,1 +3478,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3454,1 +3498,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3477,1 +3521,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3497,1 +3541,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3520,1 +3564,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3540,1 +3584,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3563,1 +3607,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3583,1 +3627,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3606,1 +3650,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LTLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LTLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GTLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GTLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3613,0 +3750,95 @@\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LELong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LELong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GELong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GELong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1032,0 +1032,4 @@\n+            withToString(\"long[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1151,0 +1155,40 @@\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3328,1 +3372,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3348,1 +3392,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3371,1 +3415,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3391,1 +3435,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3414,1 +3458,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3434,1 +3478,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3454,1 +3498,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3477,1 +3521,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3497,1 +3541,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3520,1 +3564,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3540,1 +3584,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3563,1 +3607,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3583,1 +3627,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3606,1 +3650,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LTLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LTLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GTLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GTLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3613,0 +3750,95 @@\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LELong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LELong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GELong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GELong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1032,0 +1032,4 @@\n+            withToString(\"long[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1151,0 +1155,40 @@\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3328,1 +3372,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3348,1 +3392,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3371,1 +3415,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3391,1 +3435,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3414,1 +3458,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3434,1 +3478,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3454,1 +3498,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3477,1 +3521,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3497,1 +3541,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3520,1 +3564,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3540,1 +3584,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3563,1 +3607,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3583,1 +3627,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3606,1 +3650,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LTLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LTLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GTLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GTLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3613,0 +3750,95 @@\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LELong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LELong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GELong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GELong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1032,0 +1032,4 @@\n+            withToString(\"long[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1151,0 +1155,40 @@\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3328,1 +3372,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3348,1 +3392,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3371,1 +3415,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3391,1 +3435,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3414,1 +3458,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3434,1 +3478,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3454,1 +3498,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3477,1 +3521,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3497,1 +3541,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3520,1 +3564,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3540,1 +3584,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3563,1 +3607,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3583,1 +3627,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3606,1 +3650,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LTLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LTLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GTLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GTLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3613,0 +3750,95 @@\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LELong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LELong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GELong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GELong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1037,0 +1037,4 @@\n+            withToString(\"long[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1156,0 +1160,40 @@\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3333,1 +3377,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3353,1 +3397,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3376,1 +3420,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3396,1 +3440,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3419,1 +3463,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3439,1 +3483,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3459,1 +3503,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3482,1 +3526,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3502,1 +3546,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3525,1 +3569,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3545,1 +3589,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3568,1 +3612,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3588,1 +3632,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3611,1 +3655,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LTLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LTLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GTLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GTLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3618,0 +3755,95 @@\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_LELongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_LELongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpProvider\")\n+    static void UNSIGNED_GELongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"longCompareOpMaskProvider\")\n+    static void UNSIGNED_GELongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                VectorMask<Long> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1036,0 +1036,4 @@\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1159,0 +1163,40 @@\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3331,1 +3375,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3351,1 +3395,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3374,1 +3418,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3394,1 +3438,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3417,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3437,1 +3481,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3457,1 +3501,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3480,1 +3524,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3500,1 +3544,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3523,1 +3567,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3543,1 +3587,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3566,1 +3610,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3586,1 +3630,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3609,1 +3653,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LTShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LTShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GTShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GTShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3616,0 +3753,95 @@\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LEShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LEShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GEShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GEShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1036,0 +1036,4 @@\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1159,0 +1163,40 @@\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3331,1 +3375,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3351,1 +3395,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3374,1 +3418,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3394,1 +3438,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3417,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3437,1 +3481,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3457,1 +3501,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3480,1 +3524,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3500,1 +3544,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3523,1 +3567,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3543,1 +3587,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3566,1 +3610,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3586,1 +3630,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3609,1 +3653,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LTShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LTShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GTShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GTShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3616,0 +3753,95 @@\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LEShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LEShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GEShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GEShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1036,0 +1036,4 @@\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1159,0 +1163,40 @@\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3331,1 +3375,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3351,1 +3395,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3374,1 +3418,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3394,1 +3438,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3417,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3437,1 +3481,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3457,1 +3501,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3480,1 +3524,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3500,1 +3544,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3523,1 +3567,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3543,1 +3587,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3566,1 +3610,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3586,1 +3630,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3609,1 +3653,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LTShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LTShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GTShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GTShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3616,0 +3753,95 @@\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LEShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LEShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GEShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GEShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1036,0 +1036,4 @@\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1159,0 +1163,40 @@\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3331,1 +3375,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3351,1 +3395,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3374,1 +3418,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3394,1 +3438,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3417,1 +3461,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3437,1 +3481,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3457,1 +3501,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3480,1 +3524,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3500,1 +3544,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3523,1 +3567,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3543,1 +3587,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3566,1 +3610,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3586,1 +3630,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3609,1 +3653,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LTShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LTShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GTShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GTShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3616,0 +3753,95 @@\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LEShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LEShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GEShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GEShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1041,0 +1041,4 @@\n+            withToString(\"short[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1164,0 +1168,40 @@\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n@@ -3336,1 +3380,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3356,1 +3400,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] < b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), lt(a[i + j], b[i + j]));\n@@ -3379,1 +3423,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] < b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && lt(a[i + j], b[i + j]));\n@@ -3399,1 +3443,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] > b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), gt(a[i + j], b[i + j]));\n@@ -3422,1 +3466,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] > b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && gt(a[i + j], b[i + j]));\n@@ -3442,1 +3486,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3462,1 +3506,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] == b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), eq(a[i + j], b[i + j]));\n@@ -3485,1 +3529,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] == b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && eq(a[i + j], b[i + j]));\n@@ -3505,1 +3549,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] != b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), neq(a[i + j], b[i + j]));\n@@ -3528,1 +3572,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] != b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && neq(a[i + j], b[i + j]));\n@@ -3548,1 +3592,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] <= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), le(a[i + j], b[i + j]));\n@@ -3571,1 +3615,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] <= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && le(a[i + j], b[i + j]));\n@@ -3591,1 +3635,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] >= b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), ge(a[i + j], b[i + j]));\n@@ -3614,1 +3658,94 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] >= b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LTShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LTShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ult(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GTShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ugt(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GTShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GT, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ugt(a[i + j], b[i + j]));\n@@ -3621,0 +3758,95 @@\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_LEShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_LEShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_LE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && ule(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpProvider\")\n+    static void UNSIGNED_GEShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n+    @Test(dataProvider = \"shortCompareOpMaskProvider\")\n+    static void UNSIGNED_GEShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                VectorMask<Short> mv = av.compare(VectorOperators.UNSIGNED_GE, bv, vmask);\n+\n+                \/\/ Check results as part of computation.\n+                for (int j = 0; j < SPECIES.length(); j++) {\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && uge(a[i + j], b[i + j]));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":246,"deletions":14,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Byte128Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Byte256Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Byte512Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Byte64Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -84,0 +84,39 @@\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n@@ -990,1 +1029,1 @@\n-                r &= (as[i] < bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1005,1 +1044,1 @@\n-                r &= (as[i] > bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1020,1 +1059,1 @@\n-                r &= (as[i] == bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1035,1 +1074,1 @@\n-                r &= (as[i] != bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1050,1 +1089,1 @@\n-                r &= (as[i] <= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1065,1 +1104,17 @@\n-                r &= (as[i] >= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1072,0 +1127,52 @@\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/ByteScalar.java","additions":113,"deletions":6,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -727,0 +727,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Double128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -727,0 +727,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Double256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -727,0 +727,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Double512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -727,0 +727,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Double64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -727,0 +727,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,0 +84,24 @@\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n@@ -566,1 +590,1 @@\n-                r &= (as[i] < bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -581,1 +605,1 @@\n-                r &= (as[i] > bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -596,1 +620,1 @@\n-                r &= (as[i] == bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -611,1 +635,1 @@\n-                r &= (as[i] != bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -626,1 +650,1 @@\n-                r &= (as[i] <= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -641,1 +665,1 @@\n-                r &= (as[i] >= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -648,0 +672,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/DoubleScalar.java","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -727,0 +727,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Float128Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -727,0 +727,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Float256Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -727,0 +727,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Float512Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -727,0 +727,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Float64Vector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -727,0 +727,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,0 +84,24 @@\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n@@ -566,1 +590,1 @@\n-                r &= (as[i] < bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -581,1 +605,1 @@\n-                r &= (as[i] > bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -596,1 +620,1 @@\n-                r &= (as[i] == bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -611,1 +635,1 @@\n-                r &= (as[i] != bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -626,1 +650,1 @@\n-                r &= (as[i] <= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -641,1 +665,1 @@\n-                r &= (as[i] >= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -648,0 +672,4 @@\n+\n+\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/FloatScalar.java","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Int128Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Int256Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Int512Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Int64Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/IntMaxVector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -84,0 +84,39 @@\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n@@ -990,1 +1029,1 @@\n-                r &= (as[i] < bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1005,1 +1044,1 @@\n-                r &= (as[i] > bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1020,1 +1059,1 @@\n-                r &= (as[i] == bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1035,1 +1074,1 @@\n-                r &= (as[i] != bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1050,1 +1089,1 @@\n-                r &= (as[i] <= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1065,1 +1104,17 @@\n-                r &= (as[i] >= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1072,0 +1127,52 @@\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/IntScalar.java","additions":113,"deletions":6,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Long128Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Long256Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Long512Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Long64Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/LongMaxVector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -84,0 +84,39 @@\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n@@ -990,1 +1029,1 @@\n-                r &= (as[i] < bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1005,1 +1044,1 @@\n-                r &= (as[i] > bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1020,1 +1059,1 @@\n-                r &= (as[i] == bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1035,1 +1074,1 @@\n-                r &= (as[i] != bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1050,1 +1089,1 @@\n-                r &= (as[i] <= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1065,1 +1104,17 @@\n-                r &= (as[i] >= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1072,0 +1127,52 @@\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/LongScalar.java","additions":113,"deletions":6,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Short128Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Short256Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Short512Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/Short64Vector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -1197,0 +1197,88 @@\n+\n+    @Benchmark\n+    public Object UNSIGNED_LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public Object UNSIGNED_GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UNSIGNED_GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -84,0 +84,39 @@\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n@@ -990,1 +1029,1 @@\n-                r &= (as[i] < bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1005,1 +1044,1 @@\n-                r &= (as[i] > bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1020,1 +1059,1 @@\n-                r &= (as[i] == bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1035,1 +1074,1 @@\n-                r &= (as[i] != bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1050,1 +1089,1 @@\n-                r &= (as[i] <= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1065,1 +1104,17 @@\n-                r &= (as[i] >= bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n@@ -1072,0 +1127,52 @@\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_LE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void UNSIGNED_GE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/ShortScalar.java","additions":113,"deletions":6,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -484,6 +484,13 @@\n-gen_compare_op \"LT+lt\" \"<\"\n-gen_compare_op \"GT\" \">\"\n-gen_compare_op \"EQ+eq\" \"==\"\n-gen_compare_op \"NE\" \"!=\"\n-gen_compare_op \"LE\" \"<=\"\n-gen_compare_op \"GE\" \">=\"\n+gen_compare_op \"LT+lt\" \"lt\"\n+gen_compare_op \"GT\" \"gt\"\n+gen_compare_op \"EQ+eq\" \"eq\"\n+gen_compare_op \"NE\" \"neq\"\n+gen_compare_op \"LE\" \"le\"\n+gen_compare_op \"GE\" \"ge\"\n+\n+gen_compare_op \"UNSIGNED_LT\" \"ult\" \"BITWISE\"\n+gen_compare_op \"UNSIGNED_GT\" \"ugt\" \"BITWISE\"\n+gen_compare_op \"UNSIGNED_LE\" \"ule\" \"BITWISE\"\n+gen_compare_op \"UNSIGNED_GE\" \"uge\" \"BITWISE\"\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-                r &= (as[i] [[TEST_OP]] bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+                r &= [[TEST_OP]](as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Compare.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,0 +84,41 @@\n+    static boolean eq($type$ a, $type$ b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq($type$ a, $type$ b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt($type$ a, $type$ b) {\n+        return a < b;\n+    }\n+\n+    static boolean le($type$ a, $type$ b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt($type$ a, $type$ b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge($type$ a, $type$ b) {\n+        return a >= b;\n+    }\n+\n+#if[!FP]\n+    static boolean ult($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) >= 0;\n+    }\n+#end[!FP]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-header.template","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && (a[i + j] [[TEST_OP]] b[i + j]));\n+                    Assert.assertEquals(mv.laneIsSet(j), mask[j] && [[TEST_OP]](a[i + j], b[i + j]));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Compare-Masked.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-                    Assert.assertEquals(mv.laneIsSet(j), a[i + j] [[TEST_OP]] b[i + j]);\n+                    Assert.assertEquals(mv.laneIsSet(j), [[TEST_OP]](a[i + j], b[i + j]));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Compare.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1255,0 +1255,4 @@\n+            withToString(\"$type$[i - length \/ 2]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(i - (s * BUFFER_REPS \/ 2)));\n+            }),\n@@ -1401,0 +1405,42 @@\n+    static boolean eq($type$ a, $type$ b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq($type$ a, $type$ b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt($type$ a, $type$ b) {\n+        return a < b;\n+    }\n+\n+    static boolean le($type$ a, $type$ b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt($type$ a, $type$ b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge($type$ a, $type$ b) {\n+        return a >= b;\n+    }\n+\n+#if[!FP]\n+    static boolean ult($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) >= 0;\n+    }\n+#end[!FP]\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"}]}