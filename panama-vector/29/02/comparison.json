{"files":[{"patch":"@@ -235,1 +235,0 @@\n-      case Op_VectorReinterpret:\n@@ -343,0 +342,15 @@\n+\/\/ vector reinterpret\n+\n+instruct reinterpret(vReg dst) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() ==\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \" # reinterpret $dst\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n@@ -344,0 +358,18 @@\n+instruct reinterpretResize(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() !=\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+  match(Set dst (VectorReinterpret src));\n+  ins_cost(SVE_COST);\n+  format %{ \" # reinterpret $dst,$src\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,0 +32,9 @@\n+dnl\n+define(`TYPE2DATATYPE',\n+`ifelse($1, `B', `BYTE',\n+        $1, `S', `SHORT',\n+        $1, `I', `INT',\n+        $1, `L', `LONG',\n+        $1, `F', `FLOAT',\n+        $1, `D', `DOUBLE',\n+        `error($1)')')dnl\n@@ -222,1 +231,0 @@\n-      case Op_VectorReinterpret:\n@@ -338,0 +346,39 @@\n+\/\/ vector reinterpret\n+dnl\n+define(`REINTERPRET', `\n+instruct reinterpret`'(vReg dst) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= $1 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= $1 &&\n+            n->as_Vector()->length_in_bytes() ==\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \" # reinterpret $dst\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}')dnl\n+REINTERPRET(16)\n+dnl\n+define(`REINTERPRET_X', `\n+instruct reinterpretResize`'(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= $1 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= $1 &&\n+            n->as_Vector()->length_in_bytes() !=\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+  match(Set dst (VectorReinterpret src));\n+  ins_cost(SVE_COST);\n+  format %{ \" # reinterpret $dst,$src\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_orr(as_FloatRegister($dst$$reg),\n+             as_FloatRegister($src$$reg),\n+             as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl           $1\n+REINTERPRET_X(16)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1836,1 +1836,1 @@\n-      int num_elem_for_resize = MAX2(num_elem_to, Matcher::min_vector_size(elem_bt_to));\n+      int num_elem_for_resize = MAX2(num_elem_to, Matcher::min_vector_size(elem_bt_from));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}