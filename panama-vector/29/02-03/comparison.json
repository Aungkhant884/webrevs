{"files":[{"patch":"@@ -116,0 +116,12 @@\n+  static inline uint vector_length_in_bytes(const Node* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n+  static inline uint vector_length_in_bytes(const MachNode* use, MachOper* opnd) {\n+    uint def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n@@ -346,1 +358,0 @@\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n@@ -348,1 +359,1 @@\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n@@ -358,1 +369,1 @@\n-instruct reinterpretResize(vReg dst, vReg src) %{\n+instruct reinterpretExpand(vReg dst, vReg src, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr) %{\n@@ -361,2 +372,2 @@\n-            n->as_Vector()->length_in_bytes() !=\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+            n->as_Vector()->length_in_bytes() >\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src < dst\n@@ -364,2 +375,3 @@\n-  ins_cost(SVE_COST);\n-  format %{ \" # reinterpret $dst,$src\" %}\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \" # reinterpretExpand $dst,$src\\t\" %}\n@@ -369,3 +381,6 @@\n-      __ sve_orr(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ B, 0, 1);\n+      __ sve_dup(as_FloatRegister($tmp2$$reg), __ B, vector_length_in_bytes(this, $src));\n+      __ sve_cmpgt(as_PRegister($pTmp$$reg), __ B, ptrue,\n+                   as_FloatRegister($tmp2$$reg), as_FloatRegister($tmp1$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n@@ -376,0 +391,24 @@\n+\n+instruct reinterpretShrink(vReg dst, vReg src, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() <\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src > dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \" # reinterpretShrink $dst,$src\\t\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ B, 0, 1);\n+      __ sve_dup(as_FloatRegister($tmp2$$reg), __ B, vector_length_in_bytes(this));\n+      __ sve_cmpgt(as_PRegister($pTmp$$reg), __ B, ptrue,\n+                   as_FloatRegister($tmp2$$reg), as_FloatRegister($tmp1$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":49,"deletions":10,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -112,0 +112,12 @@\n+  static inline uint vector_length_in_bytes(const Node* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n+  static inline uint vector_length_in_bytes(const MachNode* use, MachOper* opnd) {\n+    uint def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n@@ -351,1 +363,0 @@\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= $1 &&\n@@ -353,1 +364,1 @@\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n@@ -363,7 +374,6 @@\n-dnl\n-define(`REINTERPRET_X', `\n-instruct reinterpretResize`'(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= $1 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= $1 &&\n-            n->as_Vector()->length_in_bytes() !=\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+\n+instruct reinterpretExpand(vReg dst, vReg src, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() >\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src < dst\n@@ -371,2 +381,3 @@\n-  ins_cost(SVE_COST);\n-  format %{ \" # reinterpret $dst,$src\" %}\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \" # reinterpretExpand $dst,$src\\t\" %}\n@@ -376,3 +387,6 @@\n-      __ sve_orr(as_FloatRegister($dst$$reg),\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ B, 0, 1);\n+      __ sve_dup(as_FloatRegister($tmp2$$reg), __ B, vector_length_in_bytes(this, $src));\n+      __ sve_cmpgt(as_PRegister($pTmp$$reg), __ B, ptrue,\n+                   as_FloatRegister($tmp2$$reg), as_FloatRegister($tmp1$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n@@ -382,3 +396,24 @@\n-%}')dnl\n-dnl           $1\n-REINTERPRET_X(16)\n+%}\n+\n+instruct reinterpretShrink(vReg dst, vReg src, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() <\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src > dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \" # reinterpretShrink $dst,$src\\t\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ B, 0, 1);\n+      __ sve_dup(as_FloatRegister($tmp2$$reg), __ B, vector_length_in_bytes(this));\n+      __ sve_cmpgt(as_PRegister($pTmp$$reg), __ B, ptrue,\n+                   as_FloatRegister($tmp2$$reg), as_FloatRegister($tmp1$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":52,"deletions":17,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -3351,0 +3351,13 @@\n+\/\/ SVE INDEX (immediates)\n+#define INSN(NAME)                                                      \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T,                        \\\n+            int16_t imm1, int16_t imm2) {                               \\\n+    starti;                                                             \\\n+    f(0b00000100, 31, 24), f(0b1, 21), f(0b010000, 15, 10);             \\\n+    f(T, 23, 22), rf(Zd, 0);                                            \\\n+    f(imm2, 20, 16), f(imm1, 9, 5);                                     \\\n+  }\n+\n+  INSN(sve_index);\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}