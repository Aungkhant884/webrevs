{"files":[{"patch":"@@ -116,0 +116,12 @@\n+  static inline uint vector_length_in_bytes(const Node* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n+  static inline uint vector_length_in_bytes(const MachNode* use, MachOper* opnd) {\n+    uint def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n@@ -235,1 +247,0 @@\n-      case Op_VectorReinterpret:\n@@ -343,0 +354,60 @@\n+\/\/ vector reinterpret\n+\n+instruct reinterpret(vReg dst) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() ==\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \" # reinterpret $dst\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct reinterpretExpand(vReg dst, vReg src, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() >\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src < dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \" # reinterpretExpand $dst,$src\\t\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ B, 0, 1);\n+      __ sve_dup(as_FloatRegister($tmp2$$reg), __ B, vector_length_in_bytes(this, $src));\n+      __ sve_cmpgt(as_PRegister($pTmp$$reg), __ B, ptrue,\n+                   as_FloatRegister($tmp2$$reg), as_FloatRegister($tmp1$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretShrink(vReg dst, vReg src, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() <\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src > dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \" # reinterpretShrink $dst,$src\\t\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ B, 0, 1);\n+      __ sve_dup(as_FloatRegister($tmp2$$reg), __ B, vector_length_in_bytes(this));\n+      __ sve_cmpgt(as_PRegister($pTmp$$reg), __ B, ptrue,\n+                   as_FloatRegister($tmp2$$reg), as_FloatRegister($tmp1$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -32,0 +32,9 @@\n+dnl\n+define(`TYPE2DATATYPE',\n+`ifelse($1, `B', `BYTE',\n+        $1, `S', `SHORT',\n+        $1, `I', `INT',\n+        $1, `L', `LONG',\n+        $1, `F', `FLOAT',\n+        $1, `D', `DOUBLE',\n+        `error($1)')')dnl\n@@ -103,0 +112,12 @@\n+  static inline uint vector_length_in_bytes(const Node* n) {\n+    const TypeVect* vt = n->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n+  static inline uint vector_length_in_bytes(const MachNode* use, MachOper* opnd) {\n+    uint def_idx = use->operand_index(opnd);\n+    Node* def = use->in(def_idx);\n+    const TypeVect* vt = def->bottom_type()->is_vect();\n+    return vt->length_in_bytes();\n+  }\n+\n@@ -222,1 +243,0 @@\n-      case Op_VectorReinterpret:\n@@ -338,0 +358,62 @@\n+\/\/ vector reinterpret\n+dnl\n+define(`REINTERPRET', `\n+instruct reinterpret`'(vReg dst) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= $1 &&\n+            n->as_Vector()->length_in_bytes() ==\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src == dst\n+  match(Set dst (VectorReinterpret dst));\n+  ins_cost(0);\n+  format %{ \" # reinterpret $dst\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}')dnl\n+REINTERPRET(16)\n+\n+instruct reinterpretExpand(vReg dst, vReg src, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() >\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src < dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \" # reinterpretExpand $dst,$src\\t\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ B, 0, 1);\n+      __ sve_dup(as_FloatRegister($tmp2$$reg), __ B, vector_length_in_bytes(this, $src));\n+      __ sve_cmpgt(as_PRegister($pTmp$$reg), __ B, ptrue,\n+                   as_FloatRegister($tmp2$$reg), as_FloatRegister($tmp1$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretShrink(vReg dst, vReg src, vReg tmp1, vReg tmp2, pRegGov pTmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->as_Vector()->length_in_bytes() >= 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() >= 16 &&\n+            n->as_Vector()->length_in_bytes() <\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes());  \/\/ src > dst\n+  match(Set dst (VectorReinterpret src));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP pTmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \" # reinterpretShrink $dst,$src\\t\" %}\n+  ins_encode %{\n+    \/\/ If register is the same, then move is not needed.\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ B, 0, 1);\n+      __ sve_dup(as_FloatRegister($tmp2$$reg), __ B, vector_length_in_bytes(this));\n+      __ sve_cmpgt(as_PRegister($pTmp$$reg), __ B, ptrue,\n+                   as_FloatRegister($tmp2$$reg), as_FloatRegister($tmp1$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ B,\n+                 as_PRegister($pTmp$$reg), as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":83,"deletions":1,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -3351,0 +3351,13 @@\n+\/\/ SVE INDEX (immediates)\n+#define INSN(NAME)                                                      \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T,                        \\\n+            int16_t imm1, int16_t imm2) {                               \\\n+    starti;                                                             \\\n+    f(0b00000100, 31, 24), f(0b1, 21), f(0b010000, 15, 10);             \\\n+    f(T, 23, 22), rf(Zd, 0);                                            \\\n+    f(imm2, 20, 16), f(imm1, 9, 5);                                     \\\n+  }\n+\n+  INSN(sve_index);\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1836,1 +1836,1 @@\n-      int num_elem_for_resize = MAX2(num_elem_to, Matcher::min_vector_size(elem_bt_to));\n+      int num_elem_for_resize = MAX2(num_elem_to, Matcher::min_vector_size(elem_bt_from));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}