{"files":[{"patch":"@@ -711,0 +711,32 @@\n+            case VECTOR_OP_SIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a))));\n+            case VECTOR_OP_COS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a))));\n+            case VECTOR_OP_TAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ASIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ACOS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ATAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a))));\n+            case VECTOR_OP_EXP: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG10: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a))));\n+            case VECTOR_OP_SQRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+            case VECTOR_OP_CBRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));\n+            case VECTOR_OP_SINH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_COSH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_TANH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_EXPM1: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG1P: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a))));\n@@ -797,0 +829,2 @@\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n@@ -801,0 +835,6 @@\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/HalffloatVector.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -824,0 +824,33 @@\n+#else[!short]\n+            case VECTOR_OP_SIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a))));\n+            case VECTOR_OP_COS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a))));\n+            case VECTOR_OP_TAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ASIN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ACOS: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a))));\n+            case VECTOR_OP_ATAN: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a))));\n+            case VECTOR_OP_EXP: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG10: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a))));\n+            case VECTOR_OP_SQRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+            case VECTOR_OP_CBRT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a))));\n+            case VECTOR_OP_SINH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_COSH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_TANH: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a))));\n+            case VECTOR_OP_EXPM1: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a))));\n+            case VECTOR_OP_LOG1P: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a))));\n@@ -963,0 +996,2 @@\n+            case VECTOR_OP_DIV: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n@@ -1015,0 +1050,7 @@\n+#else[!short]\n+            case VECTOR_OP_ATAN2: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            case VECTOR_OP_POW: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n+            case VECTOR_OP_HYPOT: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, b) -> Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -703,1 +703,76 @@\n-    \/\/ TODO: Fix and Enable isWithin1Ulp\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n@@ -1524,0 +1599,41 @@\n+    static short DIV(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat128VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat128VectorTests::DIV);\n+    }\n+\n@@ -1784,0 +1900,531 @@\n+    static short SQRT(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat128VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat128VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::SIN, Halffloat128VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::EXP, Halffloat128VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG1P, Halffloat128VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG, Halffloat128VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::LOG10, Halffloat128VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::EXPM1, Halffloat128VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::COS, Halffloat128VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::TAN, Halffloat128VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::SINH, Halffloat128VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::COSH, Halffloat128VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::TANH, Halffloat128VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ASIN, Halffloat128VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ACOS, Halffloat128VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::ATAN, Halffloat128VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat128VectorTests::CBRT, Halffloat128VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::HYPOT, Halffloat128VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::POW, Halffloat128VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::pow, Halffloat128VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::ATAN2, Halffloat128VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::POW, Halffloat128VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat128VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat128VectorTests::pow, Halffloat128VectorTests::strictpow);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat128VectorTests.java","additions":648,"deletions":1,"binary":false,"changes":649,"status":"modified"},{"patch":"@@ -703,1 +703,76 @@\n-    \/\/ TODO: Fix and Enable isWithin1Ulp\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n@@ -1524,0 +1599,41 @@\n+    static short DIV(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat256VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat256VectorTests::DIV);\n+    }\n+\n@@ -1784,0 +1900,531 @@\n+    static short SQRT(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat256VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat256VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::SIN, Halffloat256VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::EXP, Halffloat256VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG1P, Halffloat256VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG, Halffloat256VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::LOG10, Halffloat256VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::EXPM1, Halffloat256VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::COS, Halffloat256VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::TAN, Halffloat256VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::SINH, Halffloat256VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::COSH, Halffloat256VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::TANH, Halffloat256VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ASIN, Halffloat256VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ACOS, Halffloat256VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::ATAN, Halffloat256VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat256VectorTests::CBRT, Halffloat256VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::HYPOT, Halffloat256VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::POW, Halffloat256VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::pow, Halffloat256VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::ATAN2, Halffloat256VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::POW, Halffloat256VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat256VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat256VectorTests::pow, Halffloat256VectorTests::strictpow);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat256VectorTests.java","additions":648,"deletions":1,"binary":false,"changes":649,"status":"modified"},{"patch":"@@ -703,1 +703,76 @@\n-    \/\/ TODO: Fix and Enable isWithin1Ulp\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n@@ -1524,0 +1599,41 @@\n+    static short DIV(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat512VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat512VectorTests::DIV);\n+    }\n+\n@@ -1784,0 +1900,531 @@\n+    static short SQRT(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat512VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat512VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::SIN, Halffloat512VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::EXP, Halffloat512VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG1P, Halffloat512VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG, Halffloat512VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::LOG10, Halffloat512VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::EXPM1, Halffloat512VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::COS, Halffloat512VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::TAN, Halffloat512VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::SINH, Halffloat512VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::COSH, Halffloat512VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::TANH, Halffloat512VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ASIN, Halffloat512VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ACOS, Halffloat512VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::ATAN, Halffloat512VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat512VectorTests::CBRT, Halffloat512VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::HYPOT, Halffloat512VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::POW, Halffloat512VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::pow, Halffloat512VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::ATAN2, Halffloat512VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::POW, Halffloat512VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat512VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat512VectorTests::pow, Halffloat512VectorTests::strictpow);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat512VectorTests.java","additions":648,"deletions":1,"binary":false,"changes":649,"status":"modified"},{"patch":"@@ -703,1 +703,76 @@\n-    \/\/ TODO: Fix and Enable isWithin1Ulp\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n@@ -1524,0 +1599,41 @@\n+    static short DIV(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Halffloat64VectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloat64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Halffloat64VectorTests::DIV);\n+    }\n+\n@@ -1784,0 +1900,531 @@\n+    static short SQRT(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Halffloat64VectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloat64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Halffloat64VectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::SIN, Halffloat64VectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::EXP, Halffloat64VectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG1P, Halffloat64VectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG, Halffloat64VectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10Halffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::LOG10, Halffloat64VectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1Halffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::EXPM1, Halffloat64VectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::COS, Halffloat64VectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::TAN, Halffloat64VectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::SINH, Halffloat64VectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::COSH, Halffloat64VectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::TANH, Halffloat64VectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ASIN, Halffloat64VectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ACOS, Halffloat64VectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::ATAN, Halffloat64VectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloat64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, Halffloat64VectorTests::CBRT, Halffloat64VectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::HYPOT, Halffloat64VectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::POW, Halffloat64VectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::pow, Halffloat64VectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2Halffloat64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::ATAN2, Halffloat64VectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::POW, Halffloat64VectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloat64VectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, Halffloat64VectorTests::pow, Halffloat64VectorTests::strictpow);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Halffloat64VectorTests.java","additions":648,"deletions":1,"binary":false,"changes":649,"status":"modified"},{"patch":"@@ -708,1 +708,76 @@\n-    \/\/ TODO: Fix and Enable isWithin1Ulp\n+    static boolean isWithin1Ulp(short actual, short expected) {\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, FUnOp mathf, FUnOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i])) == 0, \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i])), \"at index #\" + i + \", input = \" + a[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i]));\n+        }\n+    }\n+\n+    static void assertArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b, FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0 ||\n+                                    isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i], mathf.apply(a[i], b[i])) == 0, \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected = \" + mathf.apply(a[i], b[i]));\n+            Assert.assertTrue(isWithin1Ulp(r[i], strictmathf.apply(a[i], b[i])), \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", actual = \" + r[i] + \", expected (within 1 ulp) = \" + strictmathf.apply(a[i], b[i]));\n+        }\n+    }\n+\n+    static void assertBroadcastArraysEqualsWithinOneUlp(short[] r, short[] a, short[] b,\n+                                                        FBinOp mathf, FBinOp strictmathf) {\n+        int i = 0;\n+        try {\n+            \/\/ Check that result is within 1 ulp of strict math or equivalent to math implementation.\n+            for (; i < a.length; i++) {\n+                Assert.assertTrue(Short.compare(r[i],\n+                                  mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0 ||\n+                                  isWithin1Ulp(r[i],\n+                                  strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])));\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertTrue(Short.compare(r[i],\n+                              mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])) == 0,\n+                              \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                              b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                              \", expected = \" + mathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+            Assert.assertTrue(isWithin1Ulp(r[i],\n+                              strictmathf.apply(a[i], b[(i \/ SPECIES.length()) * SPECIES.length()])),\n+                             \"at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" +\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()] + \", actual = \" + r[i] +\n+                             \", expected (within 1 ulp) = \" + strictmathf.apply(a[i],\n+                             b[(i \/ SPECIES.length()) * SPECIES.length()]));\n+        }\n+    }\n@@ -1529,0 +1604,41 @@\n+    static short DIV(short a, short b) {\n+        return (short)(Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \/ Halffloat.valueOf(b).floatValue())));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void DIVHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, HalffloatMaxVectorTests::DIV);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpMaskProvider\")\n+    static void DIVHalffloatMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, HalffloatMaxVectorTests::DIV);\n+    }\n+\n@@ -1789,0 +1905,531 @@\n+    static short SQRT(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    static short sqrt(short a) {\n+        return (short)(Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a))));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SQRTHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::SQRT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void sqrtHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.sqrt().intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, HalffloatMaxVectorTests::sqrt);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void SQRTMaskedHalffloatMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Halffloat> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, HalffloatMaxVectorTests::SQRT);\n+    }\n+\n+    static short SIN(short a) {\n+        return Halffloat.valueOf((float) Math.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::SIN, HalffloatMaxVectorTests::strictSIN);\n+    }\n+\n+    static short EXP(short a) {\n+        return Halffloat.valueOf((float) Math.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXP(short a) {\n+        return Halffloat.valueOf((float) StrictMath.exp(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::EXP, HalffloatMaxVectorTests::strictEXP);\n+    }\n+\n+    static short LOG1P(short a) {\n+        return Halffloat.valueOf((float) Math.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG1P(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log1p(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG1PHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG1P, HalffloatMaxVectorTests::strictLOG1P);\n+    }\n+\n+    static short LOG(short a) {\n+        return Halffloat.valueOf((float) Math.log(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOGHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG, HalffloatMaxVectorTests::strictLOG);\n+    }\n+\n+    static short LOG10(short a) {\n+        return Halffloat.valueOf((float) Math.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictLOG10(short a) {\n+        return Halffloat.valueOf((float) StrictMath.log10(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LOG10HalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::LOG10, HalffloatMaxVectorTests::strictLOG10);\n+    }\n+\n+    static short EXPM1(short a) {\n+        return Halffloat.valueOf((float) Math.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictEXPM1(short a) {\n+        return Halffloat.valueOf((float) StrictMath.expm1(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void EXPM1HalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::EXPM1, HalffloatMaxVectorTests::strictEXPM1);\n+    }\n+\n+    static short COS(short a) {\n+        return Halffloat.valueOf((float) Math.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::COS, HalffloatMaxVectorTests::strictCOS);\n+    }\n+\n+    static short TAN(short a) {\n+        return Halffloat.valueOf((float) Math.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::TAN, HalffloatMaxVectorTests::strictTAN);\n+    }\n+\n+    static short SINH(short a) {\n+        return Halffloat.valueOf((float) Math.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictSINH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.sinh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void SINHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::SINH, HalffloatMaxVectorTests::strictSINH);\n+    }\n+\n+    static short COSH(short a) {\n+        return Halffloat.valueOf((float) Math.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCOSH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cosh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void COSHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::COSH, HalffloatMaxVectorTests::strictCOSH);\n+    }\n+\n+    static short TANH(short a) {\n+        return Halffloat.valueOf((float) Math.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictTANH(short a) {\n+        return Halffloat.valueOf((float) StrictMath.tanh(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TANHHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::TANH, HalffloatMaxVectorTests::strictTANH);\n+    }\n+\n+    static short ASIN(short a) {\n+        return Halffloat.valueOf((float) Math.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictASIN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.asin(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ASINHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ASIN, HalffloatMaxVectorTests::strictASIN);\n+    }\n+\n+    static short ACOS(short a) {\n+        return Halffloat.valueOf((float) Math.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictACOS(short a) {\n+        return Halffloat.valueOf((float) StrictMath.acos(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ACOSHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ACOS, HalffloatMaxVectorTests::strictACOS);\n+    }\n+\n+    static short ATAN(short a) {\n+        return Halffloat.valueOf((float) Math.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictATAN(short a) {\n+        return Halffloat.valueOf((float) StrictMath.atan(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void ATANHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::ATAN, HalffloatMaxVectorTests::strictATAN);\n+    }\n+\n+    static short CBRT(short a) {\n+        return Halffloat.valueOf((float) Math.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    static short strictCBRT(short a) {\n+        return Halffloat.valueOf((float) StrictMath.cbrt(Float.float16ToFloat(a)));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void CBRTHalffloatMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, HalffloatMaxVectorTests::CBRT, HalffloatMaxVectorTests::strictCBRT);\n+    }\n+\n+    static short HYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictHYPOT(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void HYPOTHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::HYPOT, HalffloatMaxVectorTests::strictHYPOT);\n+    }\n+\n+    static short POW(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictPOW(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::POW, HalffloatMaxVectorTests::strictPOW);\n+    }\n+\n+    static short pow(short a, short b) {\n+        return Halffloat.valueOf((float) Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictpow(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.pow(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.pow(bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::pow, HalffloatMaxVectorTests::strictpow);\n+    }\n+\n+    static short ATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    static short strictATAN2(short a, short b) {\n+        return Halffloat.valueOf((float) StrictMath.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b)));\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void ATAN2HalffloatMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+                HalffloatVector bv = HalffloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::ATAN2, HalffloatMaxVectorTests::strictATAN2);\n+    }\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void POWHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.lanewise(VectorOperators.POW, b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::POW, HalffloatMaxVectorTests::strictPOW);\n+    }\n+\n+\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void powHalffloatMaxVectorTestsBroadcastSmokeTest(IntFunction<short[]> fa, IntFunction<short[]> fb) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            HalffloatVector av = HalffloatVector.fromArray(SPECIES, a, i);\n+            av.pow(b[i]).intoArray(r, i);\n+        }\n+\n+        assertBroadcastArraysEqualsWithinOneUlp(r, a, b, HalffloatMaxVectorTests::pow, HalffloatMaxVectorTests::strictpow);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/HalffloatMaxVectorTests.java","additions":648,"deletions":1,"binary":false,"changes":649,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+unary_math_hf_template=\"Unary-op-hf-math\"\n@@ -67,0 +68,1 @@\n+binary_math_hf_template=\"Binary-op-hf-math\"\n@@ -68,0 +70,1 @@\n+binary_math_hf_broadcast_template=\"Binary-Broadcast-op-hf-math\"\n@@ -586,0 +589,1 @@\n+  gen_binary_alu_op \"DIV\" \"Halffloat.valueOf((Halffloat.valueOf(a).floatValue() \\\/ Halffloat.valueOf(b).floatValue()))\" \"Halffloat\"\n@@ -591,0 +595,20 @@\n+  gen_unary_alu_op \"SQRT+sqrt\" \"Halffloat.valueOf((float) Math.sqrt(Float.float16ToFloat(a)))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"SIN\" \"Math.sin(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"EXP\" \"Math.exp(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"LOG1P\" \"Math.log1p(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"LOG\" \"Math.log(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"LOG10\" \"Math.log10(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"EXPM1\" \"Math.expm1(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"COS\" \"Math.cos(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"TAN\" \"Math.tan(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"SINH\" \"Math.sinh(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"COSH\" \"Math.cosh(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"TANH\" \"Math.tanh(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"ASIN\" \"Math.asin(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"ACOS\" \"Math.acos(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"ATAN\" \"Math.atan(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $unary_math_hf_template \"CBRT\" \"Math.cbrt(Float.float16ToFloat(a))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_hf_template \"HYPOT\" \"Math.hypot(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_hf_template \"POW+pow\" \"Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_hf_template \"ATAN2\" \"Math.atan2(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n+  gen_op_tmpl $binary_math_broadcast_template \"POW+pow\" \"Math.pow(Float.float16ToFloat(a), Float.float16ToFloat(b))\" \"Halffloat\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-op-hf-math.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Binary-op-math.template","status":"copied"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Unary-op-hf-math.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-Unary-op-math.template","status":"copied"},{"patch":"@@ -0,0 +1,14 @@\n+\n+    static $type$ [[TEST]]($type$ a, $type$ b) {\n+        return Halffloat.valueOf((float) [[TEST_OP]]);\n+    }\n+\n+    static $type$ strict[[TEST]]($type$ a, $type$ b) {\n+        return Halffloat.valueOf((float) Strict[[TEST_OP]]);\n+    }\n+\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb) {\n+[[KERNEL]]\n+        assertArraysEqualsWithinOneUlp(r, a, b, $vectorteststype$::[[TEST]], $vectorteststype$::strict[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-op-hf-math.template","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+\n+    static $type$ [[TEST]]($type$ a) {\n+        return Halffloat.valueOf((float) [[TEST_OP]]);\n+    }\n+\n+    static $type$ strict[[TEST]]($type$ a) {\n+        return Halffloat.valueOf((float) Strict[[TEST_OP]]);\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpProvider\")\n+    static void [[TEST]]$vectorteststype$(IntFunction<$type$[]> fa) {\n+[[KERNEL]]\n+        assertArraysEqualsWithinOneUlp(r, a, $vectorteststype$::[[TEST]], $vectorteststype$::strict[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Unary-op-hf-math.template","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -745,1 +745,0 @@\n-#if[!Halffloat]\n@@ -747,0 +746,20 @@\n+#if[Halffloat]\n+        float act = Float.float16ToFloat(actual);\n+        float exp = Float.float16ToFloat(expected);\n+        if (Float.isNaN(exp) && !Float.isNaN(act)) {\n+            return false;\n+        } else if (!Float.isNaN(exp) && Float.isNaN(act)) {\n+             return false;\n+        }\n+\n+        float low = Math.nextDown(exp);\n+        float high = Math.nextUp(exp);\n+\n+        if (Float.compare(low, exp) > 0) {\n+            return false;\n+        }\n+\n+        if (Float.compare(high, exp) < 0) {\n+            return false;\n+        }\n+#else[Halffloat]\n@@ -763,0 +782,1 @@\n+#end[Halffloat]\n@@ -820,3 +840,0 @@\n-#else[!Halffloat]\n-    \/\/ TODO: Fix and Enable isWithin1Ulp\n-#end[!Halffloat]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"}]}