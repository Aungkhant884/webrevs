{"files":[{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package benchmark.bigdata;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class BooleanArrayCheck {\n+\n+  @Param(\"1024\")\n+  int ARRAY_LENGTH;\n+\n+  static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_PREFERRED;\n+\n+  private boolean[] bitsArray;\n+\n+  @Setup\n+  public void init() {\n+    System.out.println(\"SPECIES's length: \" + SPECIES.length());\n+\n+    bitsArray = new boolean[ARRAY_LENGTH];\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      bitsArray[i] = true;\n+    }\n+  }\n+\n+  @Benchmark\n+  public boolean filterAll_vec() {\n+    int filterPos = 0;\n+\n+    for (; filterPos < ARRAY_LENGTH; filterPos += SPECIES.length()) {\n+      VectorMask<Byte> mask = VectorMask.fromArray(SPECIES, bitsArray, filterPos);\n+      if (!mask.allTrue()) {\n+        return false;\n+      }\n+    }\n+\n+    for (filterPos -= SPECIES.length(); filterPos < ARRAY_LENGTH; filterPos++) {\n+      if (!bitsArray[filterPos]) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Benchmark\n+  public boolean filterAll() {\n+    int filterPos = 0;\n+\n+    for (; filterPos < ARRAY_LENGTH; filterPos++) {\n+      if (!bitsArray[filterPos]) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+}\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/bigdata\/BooleanArrayCheck.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package benchmark.bigdata;\n+\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ValueRangeCheckAndCastL2I {\n+\n+  @Param(\"1024\")\n+  int ARRAY_LENGTH;\n+\n+  private long min = Integer.MIN_VALUE;\n+  private long max = Integer.MAX_VALUE;\n+\n+  private static final VectorSpecies<Long> LONG_SPECIES =\n+    LongVector.SPECIES_PREFERRED;\n+  private static final VectorSpecies<Integer> INT_SPECIES =\n+    VectorSpecies.of(int.class, VectorShape.forBitSize(LONG_SPECIES.vectorBitSize() \/ 2));\n+\n+  private int[] intResult;\n+  private long[] longArray;\n+\n+  @Setup\n+  public void init() {\n+    System.out.println(\"LONG_SPECIES's length: \" + LONG_SPECIES.length());\n+    System.out.println(\"INT_SPECIES's length: \" + INT_SPECIES.length());\n+    System.out.println(\"Min is: \" + min + \". Max is: \" + max);\n+\n+    longArray = new long[ARRAY_LENGTH];\n+    intResult = new int[ARRAY_LENGTH];\n+\n+    Random rand = new Random();\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      intResult[i] = 0;\n+      longArray[i] = rand.nextInt(Integer.MAX_VALUE);\n+    }\n+  }\n+\n+  @Benchmark\n+  public boolean castL2I() {\n+    for (int i = 0; i < longArray.length; i++) {\n+      if (longArray[i] >= min && longArray[i] <= max) {\n+        intResult[i] = (int)(longArray[i]);\n+      } else {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Benchmark\n+  public boolean castL2I_vec() {\n+    for (int i = 0; i < longArray.length; i += LONG_SPECIES.length()) {\n+      LongVector av = LongVector.fromArray(LONG_SPECIES, longArray, i);\n+      if (av.compare(VectorOperators.GE, min).allTrue() && av.compare(VectorOperators.LE, max).allTrue()) {\n+        ((IntVector) av.castShape(INT_SPECIES, 0)).intoArray(intResult, i);\n+      } else {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+}\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/bigdata\/ValueRangeCheckAndCastL2I.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,585 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package benchmark.bigdata;\n+\n+import jdk.incubator.vector.*;\n+import java.util.Base64;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorDistance {\n+\n+    static final VectorSpecies<Float> SPECIES_FLOAT_128 = FloatVector.SPECIES_128;\n+    static final VectorSpecies<Float> SPECIES_FLOAT_256 = FloatVector.SPECIES_256;\n+    static final VectorSpecies<Float> SPECIES_FLOAT_MAX = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_128 = DoubleVector.SPECIES_128;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_256 = DoubleVector.SPECIES_256;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_MAX = DoubleVector.SPECIES_MAX;\n+\n+\n+    static long num = 0;\n+    private static String x1 = \"L5GSwXhHpEH05mNBHnmcQMTw3EBnagFCW1DGQHe\/nUFO1B1BlJOpwCBJ9j\" +\n+                \"+RkY1BzqKeQSglN0Gy7krB5CSfQFzxB8Djn5nB2KNFwKcSRMGYzRQ7qMGWQZ0FF0FTceDAIKjxv\/zhdkHFZMHB6hU4QZbo2cCAryRB+7OOQCxbfEHRtBlBxPG6P0BYSD+Pgz9BqzOLv\/nVO8C9x5\/BQOY\/wTTIx0GfW1BBGv2lQQwdDcGCqBfB12t\/QKUBoEEejIXBPN9kQWsFbEGsGcnBkqJkwKhLgr\/IQZxAelAWQfcYpcFQv0HBeiGCQWExhEDrKAnBpAwBQV4bVcFpGNjAyDsNQVOc+0CSc4nBgG\/ZQQGRccEXts9BKhYzQNK5+MAlU0DBzPGWwPGRCcEZC5\/ADxOcv7lUkEBomM5BuqKiwV2MU8HNGHDBSB84QZRSyMB8RZlBVFdZQXSVgcBTQQBCdWa\/QBQ0qkGILUW\/6NA9QQnkmsG+5PPBj0UowT6nYD9cwpjAS\/w5wTbX2UH8Gb5AR\/HUQMTNAMJ9MN9AgHoqPbbUyUFbe47BBHANQWZJBsGBuPlBy94EQADeXsG5eOtBnA+yQCRka8EMcGLBjuoRwb4k7sAasB5Bmk\/UwaI1akErp6xBq5G5wNo1E8KHa7tB3IiKQTCffcHphK1BTgJzwVY3JEEip\/VAlmgXQSeKCsLEABs\/n1\/xwL5u58CgQY49ahUWQoAJjj1hhqBASXrrQb6nM0H2fY+\/thtbQAQobMAohvXAxM3xv7xyqD+MvpDBrlDiQfBvPcGA8X5AQE4SwXhGx7+uLA1AxY8xu2mVjEE7KlFBArveQFNMtUD3N7DB12BbQcyH4cFhSw3Bu5VWQeTW0z9o03TBxtMlQctp\/8E\/lLVAGUtTwZsGJMKv\/R5A1HKVQV6RhsC1Ji5AcXLFQJd6f0HbB+e+ZDi8wV9tQ0FwCN\/B+A89v2DrU0Bcpc5BglTeQH5dT0HePS9Al4XPwdA6YEFlueXAbWKSQSBWzkBy2RnCt9Yawl9b77+xgxBC9eCqQd8f0kFoBG9BVxrkQZh2QkHNW\/zBEQiawLJEocDhutTA8zEYwbIvEUIO1T9BmlOTwIhbNEDhrtlAVk9BQARQaj89NQNC6usGwDfQrkBSJrlAON7FQQ8FqsEEc\/TAY3zeQYsqUEHV8QPBHJoYQQdn5kGyCiJBlDMYQBBNoUFrxbw\/NlmPP3B24j6ChIdBXk2bwdxdDMFQw1rA4hybQXTchr8d9wvBuCbLQSMKmMBH4RpBQIXePa5DT8IjgvtBgAetQZgGgMEprc1BAOeSPJ5XpEEMa0NBgX4uwX7XIsG2Ie0688iqQSpJPsCAy9LBAGHkPw==\";\n+    private static String x2 = \"5R3ZwGPrxEFMKyNBLFSeQdYav0BQtDFCur7WQAgRYEGHFYC\/MKZtvkiFUT+RNXfBVsGBP2KWSUCmAUTBIf+EQG57kMCtXo7BV1DuwLd98r+YzRQ7qKXNwBMSPUFNQffBPrxeQYw1t7\/7JjFAKNaXP+cMSEG6GI5BuEx0wUANDMEvDqdAT9YEworQTEEiVBZBiMejQP7t67+iRwzB3HadQB1be0Ei5g5BMt+cQXvYTUHwZsLAuoy3QfrR6EFrIiHB5X8Dwc8XbUH8Yr8\/AvGEwa5GkUH3F5tAP8YJQTiDyz+gKsRAFl\/rwDxJuUAPyyxBvg2gQU6bjMEPEa7Bz6wYQpQy7MDF5LvB8HP+QCJdicHQDjpC6RpWQcGeY8FMK6vBoeUjQcPYmUG2QmRBBI0nwScESsGMAcxBvRmawRL2A8IByKNAgTQBQuxdDEGq8JBBHJWmQSBDfz8sLe9BE3gFwTdCPkHEaMxBhX8Xwe7BCcE\/783Bt6EHwdpbpkHc5L\/BCPzRwUdIQUEd\/k3AoGNcQQwNmMEyuKRBtnWlwdCBAUI5Y5DBwOZYvdI+MsEu\/ixBnpMrwRtYt8FECytC6JjEQW3RHcBtfn3B+sgQQcyQKcEI5ytByvw2wPZdaUH+aqLAQFQ+QPi4REBF\/9lBCvJNQTdlEcIAMbzBtD+hwZWufsAEjus\/YRyjwR1YuMHj0ZhBa4w+QORAhMEq9qdB\/L8JQrjhyUAJBeBAKqoIQUnAq0GsLFdBkfrvQHc1zMHH6THBeggSwaJIOsAawwBBDDWqPwrAlkBYDqe\/maUcQabhwsFF2VBBxY8xu5aMQUFDkHVBKhRRwHhgWsEA5jXBlh9NQVMaT0CWlhTAroaFQRyciUHQlp7BF4trQa8unsE4TfI+9XLJQDNpLcIXLZdAuX2MwShiTsFcQh5BrHMqQVI1+UBWe4fBAzi0wfe11UFAIjq9Y1iAQDxrTsEY6plB\/JiXQfjFwkHkYGRBVNOhwCMxtEFbqZTA378WQeA\/Sb+FrSXCqlYywtb5SsDcqlZBk1EtQZ\/RREHZIxG\/kcv8QekDIkHPsDXCBL4VQHN8CMGtNvvAC3YwweUuAkKkJCnANEtVQG9z\/0DrwyTBQ9hnwWX3kMEdLB1CvIlKwQ0IO0HK1ErBvdRQQVpjMMCJDI\/Bb4X8QYVipEGpG2nBeLGUvmBlBT7ISgRB4iGAQUunkkFDFLm\/HNaqPzKTVkCITJG\/XzlYwbj0XcGD60PBbpLwQbvrs8Az8RXB4ubxQXh\/HEDtXLU\/kONrwVBs4MGc2X1BJaHkQd0ByEAKXLJBTq7JwPPkJUGJIIRBlh57wX3FjcC2Ie060Qc6Qal5xcCfqQrCl7edQQ==\";\n+    static float[] queryVectorFloat = parseBase64ToVector(x1);\n+    static float[] inputVectorFloat = parseBase64ToVector(x2);\n+    static double[] queryVectorDouble;\n+    static double[] inputVectorDouble;\n+\n+    static float normQueryVectorFloat;\n+    static double normQueryVectorDouble;\n+\n+    public static float[] parseArray(byte[] input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        float[] floatArr = new float[input.length \/ 4];\n+        for (int i = 0; i < floatArr.length; i++) {\n+            int l;\n+            l = input[i << 2];\n+            l &= 0xff;\n+            l |= ((long) input[(i << 2) + 1] << 8);\n+            l &= 0xffff;\n+            l |= ((long) input[(i << 2) + 2] << 16);\n+            l &= 0xffffff;\n+            l |= ((long) input[(i << 2) + 3] << 24);\n+            floatArr[i] = Float.intBitsToFloat(l);\n+        }\n+        return floatArr;\n+    }\n+\n+    public static float[] parseBase64ToVector(String vectorBase64) {\n+        return parseArray(Base64.getDecoder().decode(vectorBase64));\n+    }\n+\n+    @Setup\n+    public static void init() {\n+        queryVectorDouble = new double[queryVectorFloat.length];\n+        inputVectorDouble = new double[inputVectorFloat.length];\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            queryVectorDouble[i] = (double)(queryVectorFloat[i]);\n+        }\n+        for (int i = 0; i < inputVectorFloat.length; i++) {\n+            inputVectorDouble[i] = (double)(inputVectorFloat[i]);\n+        }\n+        float xSquare = 0;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            xSquare += (float)(queryVectorFloat[i] * queryVectorFloat[i]);\n+        }\n+        normQueryVectorFloat = xSquare;\n+        normQueryVectorDouble = (double)xSquare;\n+    }\n+\n+    @Benchmark\n+    public static float cosinesimilOptimizedScalarFloat() {\n+        float dotProduct = 0.0f;\n+        float normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        if (normalizedProduct == 0) {\n+            return Float.MIN_VALUE;\n+        }\n+        return (float) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public static float cosinesimilOptimizedVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_128);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_128);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public static float cosinesimilOptimizedVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_256);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_256);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public static float cosinesimilOptimizedVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_MAX);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public static float cosinesimilScalarFloat() {\n+        float dotProduct = 0.0f;\n+        float normQueryVectorFloat = 0.0f;\n+        float normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        if (normalizedProduct == 0) {\n+            return Float.MIN_VALUE;\n+        }\n+        return (float) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_128);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_128);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_256);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_256);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public static double cosinesimilOptimizedScalarDouble() {\n+        double dotProduct = 0.0;\n+        double normInputVector = 0.0;\n+        for (int i = 0; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return dotProduct \/ (Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public static double cosinesimilOptimizedVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public static double cosinesimilOptimizedVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public static double cosinesimilOptimizedVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public static double cosinesimilScalarDouble() {\n+        double dotProduct = 0.0f;\n+        double normQueryVectorDouble = 0.0f;\n+        double normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    \/\/ l2Squared is used to compute Euclidean distance\n+    @Benchmark\n+    public float l2SquaredVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public float l2SquaredVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public float l2SquaredVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public static float l2SquaredScalar() {\n+        float squaredDistance = 0;\n+        for (int i = 0; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            squaredDistance += diff * diff;\n+        }\n+        return squaredDistance;\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/benchmark\/src\/main\/java\/benchmark\/bigdata\/VectorDistance.java","additions":585,"deletions":0,"binary":false,"changes":585,"status":"added"}]}